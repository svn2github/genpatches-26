diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/Documentation/networking/README.ipw2100 ipw2100-2.6.4/Documentation/networking/README.ipw2100
--- linux-2.6.4/Documentation/networking/README.ipw2100	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/Documentation/networking/README.ipw2100	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,116 @@
+Intel PRO/Wireless 2100 802.11b Driver for Linux
+README.ipw2100
+
+March 18, 2004
+
+
+Release 0.34 Current Features
+------------ -----   -----       ----       ---       --         -     
+
+- BSS (infrastructure) only
+- limited wireless extension support 
+- 802.11 fragmentation
+
+
+TODO
+------------ -----   -----       ----       ---       --         -     
+- encryption (WEP)
+- long/short preamble support
+- enhance wireless extension support
+- adhoc
+- continue to add support for addtional SW RF kill switch implementations
+- "shared" authentication
+- transmit power control
+- power states support (ACPI)
+
+
+Command Line Parameters
+------------ -----   -----       ----       ---       --         -     
+
+If the driver is built as a module, the following optional parameters are used
+by entering them on the command line with the modprobe command using this
+syntax:
+
+	modprobe ipw2100 [<option>=<VAL1><,VAL2>...]
+
+For example, to set the interface name for driver, entering:
+
+	modprobe ipw2100 if_name=wlan%d
+
+results in the ipw2100 driver defaulting to the wlan prefix, with the system
+assigning a unique number in place of %d.  The default interface name is eth%d.
+
+
+
+Radio Kill Switch
+------------ -----   -----       ----       ---       --         -     
+Most laptops provide the ability for the user to physically disable the radio.
+Some vendors have implemented this as a physical switch that requires no
+software to turn the radio off and on.  On other laptops, however, the switch
+is controlled through a button being pressed and a software driver then making
+calls to turn the radio off and on.  This is referred to as a "software based
+RF kill switch"
+
+Currently this project provides modules for controlling the software RF kill
+switch on the Averatec 5100P and Packard Bell EasyNote E5.  The code may work
+on other laptops, but these are the only models on which it has been tested.
+
+Simply by loading and unloading the av5100/pbe5 module the radio will be toggled
+on and off.  In addition, you can turn the driver on and off by writing either
+a 1 or 0 to /proc/av5100/radio or /proc/pbe5/radio.  If you automatically load
+the av5100/pbe5 module when your system boots, you may wish to use the radio
+module parameter to control the state of the radio upon loading:
+
+	modprobe av5100 radio=0
+	modprobe pbe5 radio=0
+
+results in the module loading with the radio turned off.  You can then turn the
+radio on by:
+
+	echo 1 > /proc/av5100/radio
+	echo 1 > /proc/pbe5/radio
+
+
+Dynamic Firmware
+------------ -----   -----       ----       ---       --         -     
+As the firmware is licensed under a restricted use license, it can not be 
+included within the kernel sources.  To enable the IPW2100 you will need a 
+firmware image to load into the wireless NIC's processors.
+
+You can obtain these images from <http://ipw2100.sf.net/firmware.php>.
+
+See INSTALL for instructions on installing the firmware.
+
+
+Support
+------------ -----   -----       ----       ---       --         -     
+
+For general information and support, go to:
+	
+    http://ipw2100.sf.net/
+
+License
+------------ -----   -----       ----       ---       --         -     
+
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/Kconfig ipw2100-2.6.4/drivers/net/wireless/Kconfig
--- linux-2.6.4/drivers/net/wireless/Kconfig	Thu Mar 18 12:13:53 2004
+++ ipw2100-2.6.4/drivers/net/wireless/Kconfig	Mon Mar 29 22:08:53 2004
@@ -137,6 +137,146 @@
 comment "Wireless 802.11b ISA/PCI cards support"
 	depends on NET_RADIO && (ISA || PCI || PPC_PMAC || PCMCIA)
 
+config IPW2100
+	tristate "Intel PRO/Wireless 2100 802.11b"
+	depends on NET_RADIO && PCI
+	select FW_LOADER
+	---help---
+          A driver for the Intel PRO/Wireless 2100 802.11b wireless network
+          adapter.
+
+          See <file:Documentation/networking/README.ipw2100> for information on
+          the capabilities currently enabled in this driver and for tips
+          for debugging issues and problems.
+
+	  In order to use this driver, you will need a firmware image for it.
+          You can obtain the firmware from
+	  <http://ipw2100.sf.net/>.  Once you have the firmware image, you 
+	  will need to place it in /etc/firmware.
+
+          You will also very likely need the Wireless Tools in order to
+          configure your card:
+
+          <http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html>.
+ 
+          If you want to compile the driver as a module ( = code which can be
+          inserted in and remvoed from the running kernel whenever you want),
+          say M here and read <file:Documentation/modules.txt>.  The module
+          will be called ipw2100.ko.
+	
+config IPW2100_LEGACY_FW_LOAD
+	bool "Legacy firmware loading (non-hotplug)"
+	depends on IPW2100
+	---help---
+	  As of 0.33 we added the ability to use the hotplug request_firmware
+	  capability of Linux to load the firmware image.  If you do not have
+	  hot plug configured, or have compilation or other errors while trying
+	  to use the new mechanism, you can enable this option to use the
+	  legacy approach (loading the firmware from /etc/firmware/)
+
+	  Saying Y here will result in the kernel module being ~4k larger.
+
+config IPW2100_WEP
+	bool "Development WEP support (may not compile)"
+	depends on IPW2100
+	---help---
+	  We are starting to add support for WEP through the incorporation of
+	  generalized code from the Host AP project.  This portion of code
+	  is under _heavy_ development--it may not compile on your machine.  If
+	  it does, it is likely to crash.
+
+	  Only turn this on if you wish to help in the development of this
+	  feature.
+
+	  Saying Y here may break your build.  When in doubt, say N.
+
+config IPW2100_DEBUG
+	bool "Enable full debugging output"
+	depends on IPW2100
+	---help---
+	  This option will enable debug tracing output for the IPW2100.  
+
+	  This will result in the kernel module being ~60k larger.  You can 
+	  control which debug output is sent to the kernel log by setting the 
+	  value in 
+
+	  /proc/ipw2100/debug_level
+
+	  This entry will only exist if this option is enabled.  For a list of 
+	  values you can assign to debug_level, simply perform:
+
+	  % cat /proc/ipw2100/debug_level
+
+	  To set a value, simply echo an 8-byte hex value to the same file:
+
+	  % echo 00000FFO > /proc/ipw2100/debug_level
+
+	  If you are not trying to debug or develop the IPW2100 driver, you 
+	  most likely want to say N here.
+
+config IPW2100_AVERATEC_5100P
+	tristate "Averatec 5100P RF Kill Switch"
+	depends on IPW2100 && PCI
+	---help---
+          If you have an Averatec 5100P, say M or Y here to build support for
+	  controlling the software based radio kill switch on your laptop.
+
+	  Some laptops are enabled with a RF kill switch that is typically
+          controlled through either a physical switch or through software
+          outside of the IPW2100.  We are looking to add support for as many
+          laptops as possible, as quickly as possible.  If you have a laptop
+          exhibiting the symptoms described in
+          <file:/Documentation/networking/README.ipw2100> then please follow the
+          instructions detailed in that file.
+
+	  Upon loading, this driver will attempt to turn the radio ON.  Upon
+	  exiting, it will turn the radio OFF.  You can also toggle the state
+	  of the radio:
+
+	  % # Turn the radio ON
+	  % echo 1 > /proc/av5100/radio
+	  % # Turn the radio OFF
+	  % echo 0 > /proc/av5100/radio
+
+	  If you want to compile the driver as a module ( = code which can be
+	  inserted in and remvoed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called av5100.ko.
+
+          If unsure of what to do, say N here.
+
+config IPW2100_PACKARDBELL_E5
+	tristate "Packard Bell EasyNote E5 RF Kill Switch"
+	depends on IPW2100 && PCI
+	---help---
+          If you have a Packard Bell EasyNote E5, say M or Y here to build
+	  support for controlling the software based radio kill switch on your
+	  laptop.
+
+	  Some laptops are enabled with a RF kill switch that is typically
+          controlled through either a physical switch or through software
+          outside of the IPW2100.  We are looking to add support for as many
+          laptops as possible, as quickly as possible.  If you have a laptop
+          exhibiting the symptoms described in
+          <file:/Documentation/networking/README.ipw2100> then please follow the
+          instructions detailed in that file.
+
+	  Upon loading, this driver will attempt to turn the radio ON.  Upon
+	  exiting, it will turn the radio OFF.  You can also toggle the state
+	  of the radio:
+
+	  % # Turn the radio ON
+	  % echo 1 > /proc/pbe5/radio
+	  % # Turn the radio OFF
+	  % echo 0 > /proc/pbe5/radio
+
+	  If you want to compile the driver as a module ( = code which can be
+	  inserted in and remvoed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called pbe5.ko.
+
+          If unsure of what to do, say N here.
+
 config AIRO
 	tristate "Cisco/Aironet 34X/35X/4500/4800 ISA and PCI cards"
 	depends on NET_RADIO && (ISA || PCI)
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/Makefile ipw2100-2.6.4/drivers/net/wireless/Makefile
--- linux-2.6.4/drivers/net/wireless/Makefile	Thu Mar 18 12:13:53 2004
+++ ipw2100-2.6.4/drivers/net/wireless/Makefile	Mon Mar 29 22:08:53 2004
@@ -1,6 +1,7 @@
 #
 # Makefile for the Linux Wireless network device drivers.
 #
+obj-$(CONFIG_IPW2100) += ipw2100/
 
 obj-$(CONFIG_STRIP) += strip.o
 obj-$(CONFIG_ARLAN) += arlan.o 
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/CHANGES ipw2100-2.6.4/drivers/net/wireless/ipw2100/CHANGES
--- linux-2.6.4/drivers/net/wireless/ipw2100/CHANGES	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/CHANGES	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,173 @@
+
+Mar 29 2004 Changes in 0.40-pre...
+NOTE:  
+  A lot of folks on IRC wanted a code drop now that I have WEP limping 
+  along.  The changes in this version have not been extensively tested.
+  So, if you upgrade to 0.40 you may see a regression in features or 
+  stability--even with WEP disabled.
+
+  To use the WEP, you must install hostap-drivers-0.1.3 (you will need
+  the hostap and hostap_crypt_wep modules)
+
+* Added IPWINFO gathering script (thanks to Jordi Martinez)
+* Added full WEP authentication (HW) and Tx/Rx (SW) built on Host AP's WEP
+  alorigthm.  This is UNSTABLE.  You can play with it by configuring 
+  CONFIG_IPW2100_WEP=y.
+* Added ieee80211.c and ieee80211_wx.c as generic implementations of more 
+  ieee80211 frame handling.  These are based on code from the Host AP project.
+* Added rate/bitrate, channel/frequency support for iwlist (thanks to Pedro
+  Ramalhais)
+* Switched ieee80211_cryto_ops to hostap_crypto_ops and added a copy of 
+  Host AP v0.1.3's hostap_crypt.h to ensure that we are using the same 
+  structures as hostap.
+* Fixed AP scanning to use Probe Response frames vs. Beacon frames for 
+  collecting APs from a scan
+* Added code such that if commands fail to be sent, a firmware restart is 
+  scheduled.
+* Switched firmware init to use schedule_timeout vs. udelay
+* There is s a memory write flush test in place to see if C2->C3 transition 
+  problems can be improved (search for !!!!TEST!!!! in ipw2100_main.c)
+* Packets are only processed if the interface is up
+* Some overly verbose Tx/Rx debug log messages were removed
+* Fixed ISR incorrectly outputting the INTA value to the debug log
+* Tx queue is flushed when interface is closed
+* Added kernel compilation check to only use ethtool_ops if kernel > 2.4.23 
+  (let me know if there is a better way to check for this)
+* Added ieee80211_init to initialize the ieee80211_device struct
+* Firmware load now tied to modprobe/rmmmod vs. ifup/ifdown.  This hasn't been
+  thoroughly tested.
+* Added addition compiler check on wake_up_interruptible_sync to help building
+  on 2.4.22 (thanks to Giuseppe Della Ricca)
+
+Known Issues in 0.40-pre... 
+!-The WEP code is unstable.  
+!-If WEP is enabled (CONFIG_IPW2100_WEP=y), it will eventually crash.
+!-Occassionally, packets start failing decryption.
+!-If the firmware restarts, it does not re configure the WEP keys correctly,
+  so while you may re-associate with the WEP AP, you won't have keys 
+  configured to actually exchange WEP packets.
+!-ieee80211 packet stats are not reported through the /proc/net/wireless (just
+  haven't switched that code over)
+!-WEP Tx is a quick-fix to get the code working.  It will be restructured into
+  a generic 802.11 mechanism.
+!-Firmware restarts are still occuring too frequently.
+ 
+
+Mar 26 2004 Changes in 0.39...
+* Added 'make clean' and error message cleanup (thanks to Luca Capello)
+* Fixed suspend/resume support C3 issue (thanks to Moled on IRC)
+* Moved timer kill to ipw2100_down from the exit routine to stop timers when
+  the interface goes down--otherwise the firmware hang check might kick in.
+* More Makefile cleanups (thanks to Michael Rickmann)
+* Attempted fix for using the external Makefile in a kernel configured for 
+  building ipw2100 internally (in the case when ipw2100 has been added via
+  menuconfig).
+* Modified range settings for quality and level, also switched RSSI to DBM back
+  to the original -98.  Otherwise if you have a strong signal, the value goes
+  positive and the wireless tools switch to displaying as a ratio vs. dBm.
+* Added /proc/net/ipw2100/[if_name]/internals to display some internal 
+  variables to help track issues.
+* Added connection check to quality return for iwconfig (thanks to Pedro 
+  Corte-Real)
+
+Mar 24 2004 Changes in 0.38...
+* Added SW RF Kill switch support for Packard Bell EasyNote E5 (thanks to 
+  Pedro Ramalhais)
+* Fixed RSSI to DBM constant from 98 to 90
+* Added patch for quality metrics in /proc/net/wireless (thanks to Martin 
+  Schrodt)
+* Refactored the start/stop code into ipw2100_up / down, and hooked the code 
+  into the suspend/resume code.
+* Added a 2s heartbeat timer to the firmware; if the RTC stalls then a reset
+  is performed.
+* Fixed ISR code to use a tasklet instead of scheduled work (fixes 
+  'hw_command_send timed out' during firmware restart)
+* Added 'firmware resets' and 'firmware hangs' counters to 
+  /proc/net/ipw2100/[if_name]/stats
+
+Mar 22 2004 Changes in 0.37...
+* Fixed /proc/net/ipw2100 cleanup on exit (thanks to Giuseppe)
+* Added initial eth_tool support for link detection (thanks to Martin Schrodt)
+* Began code changes for WEP support (leveraging Host AP projec)
+* Fixed firmware version # reporting in /proc/ipw2100/[if_name]/version with i
+  CONFIG_IPW2100_LEGACY_FW_LOAD
+* Changed to unified build Makefile for all release versions
+* Switched ISR code to a scheduled work item
+* Upgraded patchset to 2.6.4
+
+Mar 19 2004 Changes in 0.36...
+* Fixed pci_free_consistent bug in ipw2100_msg_free (thanks to Damien 
+  Bergamini).  Defect # 918004.
+* Added dumping of status structure if payload size reported to be greater than
+  allowable 802_11 payload size.
+* Added firmware restart on bogus payload size; temporary work around until we i
+  root cause the data corruption.
+* Added printk() to output which firmware loading method is being used
+* Added printk() to ipw2100_tx_timeout to track firmware stalls
+* Several changes to the Makefile for supporting external and internal building
+
+Mar 18 2004 Changes in 0.35...
+* Added wireless extension get range support
+* Added /proc/net/ipw2100/[if_name]/{ordinals,hw,registers,pci} for dumping 
+  various pieces of data.
+* Code cleanup in a couple spots
+* Removed max transit unit (MTU) check in isr_rx (should fix MTU conflict some 
+  users are seeing)
+* Modified code path so that if wake_up_sync is not defined, we define
+  wake_up_interruptible_sync to wake_up_interruptible so that the 
+  __wake_up_sync patch is no longer needed.
+* Added initial start for suspend/resume (thanks to Len Brown).
+
+Mar 17 2004 Changes in 0.34...
+* ACPI C3 conflict resolved. If you have applied the C3 patch to 
+  drivers/acpi/processor.c, you can now reverse that patch and turn C3 back on. * Added HW register and PCI configuration data dump entries to 
+  proc/net/ipw2100/[if_name]/{hw,pci} 
+* Updated Makefile in the -full version (will migrate to the -2.4 and -2.6 
+  patch versions soon) 
+
+Mar 16 2004 Changes in 0.33...
+* Added hotplug firmware loading support (thanks to Luc Saillard). If you need 
+  to continue using the old style, you can turn it on via kernel configuration
+  options. It defaults to the new mechanism. See INSTALL for information. 
+* Added interface name module parameter (if_name) (thanks to Stanley Wang, 
+  Boris Hu, and Cyril Jaquier for all submitting roughly the same patch) 
+* Added port IO debug output for tracing IO to the actual hardware 
+  (IPW2100_DEBUG_IO) 
+* Moved proc info into /proc/net/ipw2100 from /proc/ipw2100 
+* Added support for /proc/net/wireless (thanks to Luc Saillard). 
+* Added external makefile (thanks to Peter Johanson). This Makefile was 
+  modified slightly to target .../wireless/ipw2100 vs. .../wireless (thanks to 
+  Luca Capello). 
+
+Mar 12 2004 Changes in 0.32...
+* Added support for toggling RF switch. If you have a HW based RF switch you 
+  can now toggle it ON/OFF and the driver will resync. 
+* Added IPW2100_DEBUG_RF_KILL to monitor RF transitions in debug log 
+* Fixed module fault on iwconfig ethX nick (thanks Radu Graeb) 
+
+Mar 12 2004 Changes in 0.31
+* Hardware reset now supported 
+* Support for hardware reset in response to fatal_interrupt 
+* proc oops fixed (thanks to Radu Greab) 
+* Fixed problem with dev->mem_end being set incorrectly 
+* Fixed oops with accesing some iwconfig query commands while the driver is 
+  uninitialized. 
+
+Mar 11 2004 Changes in 0.30...
+* Updated INSTALL with externa build steps (thanks Andrea) 
+* Added IPW2100_DEBUG_FRAG for fragmentation tracing 
+* Fixed oops if module unloaded before interface initialized/up 
+* Fixed oops if attempt to load corrupt firmware 
+* Fixed oops if iwlist scan used before interface initialized/up 
+* Moved printk() device info to after the device is registered (so you don't 
+  see eth%d in the kernel log) 
+* Began cleaning up the open/close logic so that it can reset the firmware 
+  correctly on critical errors. 
+* Incorporated several recommended code fixes by Jeff Garzik (still have quite 
+  a few to incorporate) 
+
+Mar 10 2004 Changes in 0.29
+* Initial release 
+* BSS support 
+* Fragmentation 
+* Some wireless extension support 
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/INSTALL ipw2100-2.6.4/drivers/net/wireless/ipw2100/INSTALL
--- linux-2.6.4/drivers/net/wireless/ipw2100/INSTALL	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/INSTALL	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,182 @@
+Intel PRO/Wireless 2100 802.11b Linux Driver
+Copyright (C) 2004, Intel Corporation
+For additional information, contact James Ketrenos <jketreno@linux.intel.com>
+
+COMPILER REQUIREMENTS
+---------   ------     ----       ---    --       --       -          -
+
+You need to be using GCC v 3.0 or higher in order to build the ipw2100 project.
+Using older versions will result in several compilation errors.
+
+
+INSTALLING THE BITS
+------------ -----   -----       ----       ---       --         -     
+
+There are two ways to build the module, either via a patch to your kernel, or
+as a stand alone module.  For the first, read on, for the later skip to 
+BUILDING EXTERNAL
+
+To install the driver download the package appropriate for your kernel (2.4 or 
+2.6).  Once you have that, simply change to the root of your kernel and
+apply the patch:
+
+% export K=2.4.24
+% export V=0.17
+% tar xzfO ~/ipw2100-$K-$V.tgz ipw2100-$K-$V-patch | patch -p1
+
+NOTE:  If you are upgrading to a new version, first remove the old one by 
+reversing the previous patch.  For example:
+
+% export V=0.16
+% tar xzfO ~/ipw2100-$K-$V.tgz ipw2100-$K-$V-patch | patch -p1 -R
+
+You can then apply the new patch.  
+
+The patch should proceed without errors.  Once you have applied the patch, you
+can configure and build the kernel:
+
+
+CONFIGURING THE KERNEL
+------------ -----   -----       ----       ---       --         -     
+
+# Configure the kernel
+% make menuconfig
+
+# Enable Intel PRO/Wireless 2100 under Network Devices => Wireless
+#
+# NOTE:  You must have EXPERIMENTAL turned on to see the Intel PRO/Wireless
+#        option.  You can set this in Code Maturity Setting Options.
+#
+# ALSO NOTE:  
+#        You only need the av5100 module if you have an Averatec laptop.
+#        You only need the pbe5 module if you have a Packard Bell EasyNote E5 laptop.
+#
+
+BUILDING THE MODULE
+------------ -----   -----       ----       ---       --         -     
+
+# Build the kernel module
+
+% make modules modules_install
+
+If you built as a module and didn't change any other kernel options, you are 
+ready to go.  Proceed to LOADING THE DRIVER
+
+
+BUILDING EXTERNAL
+----------- -----   ----   ----      ---       --       -             -
+
+The -full driver package now contains a Makefile that can be used for building
+the driver outside of the kernel tree.  To build it for the currently running
+kernel, sipmly type:
+
+# make && make install
+
+To build it for a different kernel than the running one, use the KSRC 
+parameter:
+
+# make KSRC=/path/to/kernel/ && make install
+
+Thanks to Peter Johanson for the original Makefile, and several others on the
+ipw2100-devel mailing list for helping to enhance it.
+
+Now proceed to LOADING THE DRIVER
+
+
+LOADING THE FIRMWARE
+------------ -----   -----       ----       ---       --         -     
+
+Before you can load the driver, you need the firmware image.  You can find
+instructions for obtaining the firmware by going to 
+http://ipw2100.sf.net/firmware.php.
+
+Once you have the firmware, uncompress the archive (it may be a .zip which 
+in turn contains a .tgz that you need to uncompress).  You should find a file
+named ipw2100-1.0.fw.  
+
+LOADING FIRMWARE VIA HOTPLUG... (new 0.33)
+------- ----    --    -      -        -
+As of v0.33, the IPW2100 supports loading of firmware via the Linux firmware 
+hotplug capability.  In order to use this, you must enable CONFIG_FW_LOADER in
+your kernel configuration.  In 2.6.x this option is enabled via: 
+
+	Device Drivers -> 
+		Generic Driver Options -> 
+			Hotplug firmware loading support
+
+In 2.4.x, it can be found here:
+	Library Routines ->
+		Hotplug firmware loading support
+
+In addition, you will need the Linux hotplug scripts dated later than 
+2003_10_07 (if you do not have /etc/hotplug/firmware.agent then you need to 
+upgrade).  
+
+You will also need to have sysfs mounted.  You can do this by adding an entry
+to /etc/fstab similar to this:
+
+none            /sys            sysfs   defaults                0       0
+
+If the directory /sys does not already exist, you will need to create it:
+
+# mkdir /sys
+
+You can then mount the sysfs partition via:
+
+# mount -a
+
+You can obtain the latest hotplug scripts via the following link:
+
+http://sourceforge.net/project/showfiles.php?group_id=17679
+
+Once set up, you can copy ipw2100-1.0.fw into /usr/lib/hotplug/firmware/ (you 
+may need to create that directory).  When the driver requests the firmware, 
+the hotplug agent will then push the firmware image to it.
+
+LOADING THE LEGACY WAY... 
+------- ----    --    -      -        -
+If, for some reason, you do not wish to use the hotplug system, IPW2100 still 
+provides a direct mechanism for loading the firmware.  To use this, simply 
+configure your kernel to use the CONFIG_IPW2100_LEGACY_FW_LOAD option. 
+
+You can then place a copy of ipw2100-1.0.fw into /etc/firmware.  The driver will
+then load the firmware directly from the file system.
+
+
+LOADING THE DRIVER
+------------ -----   -----       ----       ---       --         -     
+
+First, create a file in /etc/sysconfig/network-scripts/ called ifcfg-eth1 
+(or eth2, etc. as appropriate).  Place the following within it:
+
+DEVICE=eth1
+ONBOOT=yes
+BOOTPROTO=dhcp
+TYPE=Wireless
+
+% modprobe ipw2100
+% ifup eth1
+
+If you have DHCP configured on your network, and you have a wireless access
+point nearby, you should be up and running.
+
+You can check and see if your interface is up by running 
+
+% ifconfig eth1
+
+To test the connection, you can ping a machine using the wireless interface:
+
+% ping www.intel.com -I eth1
+
+If you want to use the wireless interface for all traffic, set up the default
+gateway to go through it.  I usually perform the following:
+
+# Disable eth0 completely
+% ifdown eth0
+
+# Configure the routing table to go through the wireless NIC
+% route add default gw 192.168.1.1 eth1
+
+If you had brought down eth0 before you load the ipw2100 module, the system
+should set up your routes for you.
+
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/Makefile ipw2100-2.6.4/drivers/net/wireless/ipw2100/Makefile
--- linux-2.6.4/drivers/net/wireless/ipw2100/Makefile	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/Makefile	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,185 @@
+#
+# Makefile for the Linux Wireless network device drivers.
+# 
+# Original makefile by Peter Johanson
+#
+# NOTE: This make file can serve as both an external Makefile (launched
+#       directly by the user), or as the sub-dir Makefile used by the kernel
+# 	build system.
+
+
+
+
+# If CONFIG_IPW2100 isn't set, we'll assume the user has never configured
+# their kernel to include this module and set up some defaults.
+#
+# NOTE: If you have previously added IPW2100 to your kernel and configured it 
+#       for inclusion, these settings will be overridden by your kernel
+#       configuration.
+
+ifndef CONFIG_IPW2100
+EXTERNAL_BUILD=y
+CONFIG_IPW2100=m
+CONFIG_IPW2100_AVERATEC_5100P=m
+CONFIG_IPW2100_PACKARDBELL_E5=m
+CONFIG_IPW2100_DEBUG=y
+
+# If you are building externally and you want to use the legacy firmware,
+# then uncomment the following line:
+# CONFIG_IPW2100_LEGACY_FW_LOAD=y
+
+# If you are building externally and want to play with the WEP code being
+# addeded, then uncomment the following line:
+# CONFIG_IPW2100_WEP=y
+endif
+
+list-m :=
+list-$(CONFIG_IPW2100) += ipw2100
+list-$(CONFIG_IPW2100_AVERATEC_5100P) += av5100
+list-$(CONFIG_IPW2100_PACKARDBELL_E5) += pbe5
+
+obj-$(CONFIG_IPW2100) += ipw2100.o
+obj-$(CONFIG_IPW2100_AVERATEC_5100P) += av5100.o
+obj-$(CONFIG_IPW2100_PACKARDBELL_E5) += pbe5.o
+ipw2100-objs := \
+        ipw2100_main.o \
+        ipw2100_fw.o \
+        ipw2100_wx.o \
+        ipw2100_frag.o 
+
+ifeq ($(CONFIG_IPW2100_WEP),y)
+ipw2100-objs += ieee80211_rx.o ieee80211.o ieee80211_wx.o
+endif
+
+#
+# Begin dual Makefile mode here.  First we provide support for when we
+# are being invoked by the kernel build system
+#
+ifneq ($(KERNELRELEASE),)
+
+#
+# If you receive a compile message about multiple definitions of
+# CONFIG_IPW2100_DEBUG or CONFIG_IPW2100_LEGACY_FW_LOAD, then you have
+# likely previously included the IPW2100 into the full kernel build, and 
+# these definitions are now being set up by the kernel build system.  
+#
+# To correct this, remove any CONFIG_IPW2100_* lines from $(KSRC)/.config
+#
+ifeq ($(EXTERNAL_BUILD),y)
+ifdef CONFIG_IPW2100_DEBUG	
+EXTRA_CFLAGS += -DCONFIG_IPW2100_DEBUG=$(CONFIG_IPW2100_DEBUG)
+endif	
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+EXTRA_CFLAGS += -DCONFIG_IPW2100_LEGACY_FW_LOAD=$(CONFIG_IPW2100_LEGACY_FW_LOAD)
+endif
+ifdef CONFIG_IPW2100_WEP
+EXTRA_CFLAGS += -DCONFIG_IPW2100_WEP=$(CONFIG_IPW2100_WEP)
+endif
+endif
+
+ifneq ($(PATCHLEVEL),6) # If we are not on a 2.6, then do 2.4 specific things
+
+O_TARGET := ipw.o
+
+include $(TOPDIR)/Rules.make
+
+ipw2100.o: $(ipw2100-objs)
+	$(LD) -r -o $@ $(ipw2100-objs)
+
+endif # End if 2.4 specific settings
+
+else 
+# Here we begin the portion that is executed if the user invoked this Makefile
+# directly.
+
+# KSRC should be set to the path to your sources
+# modules are installed into KMISC
+KVER  := $(shell uname -r)
+KSRC := /lib/modules/$(KVER)/build
+KMISC := /lib/modules/$(KVER)/kernel/drivers/net/wireless/ipw2100/
+
+# KSRC_OUTPUT should be overridden if you are using a 2.6 kernel that
+# has it's output sent elsewhere via KBUILD_OUTPUT= or O=
+KSRC_OUTPUT := $(KSRC)
+
+# If we find Rules.make, we can assume we're using the old 2.4 style building
+OLDMAKE=$(wildcard $(KSRC)/Rules.make)
+PWD=$(shell pwd)
+
+VERFILE := $(KSRC_OUTPUT)/include/linux/version.h
+KERNELRELEASE := $(shell \
+	if [ -r $(VERFILE) ]; then \
+		(cat $(VERFILE); echo UTS_RELEASE) | \
+		$(CC) -I$(KSRC_OUTPUT) $(CFLAGS) -E - | \
+		tail -n 1 | \
+		xargs echo; \
+        else \
+		uname -r; \
+	fi)
+
+MODPATH := $(DESTDIR)/lib/modules/$(KERNELRELEASE)
+
+all: modules
+
+clean:
+	rm -f *.mod.c *.mod *.o *.ko .*.cmd
+	rm -rf $(PWD)/tmp
+
+ifeq ($(OLDMAKE),)
+
+TMP=$(PWD)/tmp
+MODVERDIR=$(TMP)/.tmp_versions
+
+modules:
+ifdef ($(KSRC_OUTPUT)/.tmp_versions)
+	mkdir -p $(MODVERDIR)
+	-cp $(KSRC_OUTPUT)/.tmp_versions/*.mod $(MODVERDIR)
+endif
+ifeq ($(KSRC),$(KSRC_OUTPUT)) # We're not outputting elsewhere
+ifdef ($(KSRC)/.tmp_versions)
+	-cp $(KSRC)/.tmp_versions/*.mod $(MODVERDIR)
+endif
+	make -C $(KSRC) SUBDIRS=$(PWD) MODVERDIR=$(PWD) modules
+else # We've got a kernel with seperate output, copy the config, and use O=
+	mkdir -p $(TMP)
+	cp $(KSRC_OUTPUT)/.config $(TMP)
+	make -C $(KSRC) SUBDIRS=$(PWD) MODVERDIR=$(PWD) O=$(PWD)/tmp modules
+endif
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .ko,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	@echo "Don't forget to copy firmware to /etc/firmware/."
+else
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ and have the "
+	@echo "hotplug tools in place."
+endif
+	@echo "See INSTALL for more information."
+
+
+else # We're on 2.4, and things are slightly different
+
+modules:
+	make -C $(KSRC) SUBDIRS=$(PWD) BUILD_DIR=$(PWD) modules
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .o,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	@echo "Don't forget to copy firmware to /etc/firmware/."
+else
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ "
+	@echo "and have the hotplug tools in place."
+endif
+	@echo "See INSTALL for more information."
+
+endif
+
+uninstall:
+	rm -rf $(KMISC)
+	/sbin/depmod -a
+
+endif
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/av5100.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/av5100.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/av5100.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/av5100.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,164 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include "ipwversion.h"
+
+
+#define DRV_NAME		"av5100"
+#define DRV_VERSION		"0." IPW2100_VERSION
+#define DRV_DESCRIPTION		"SW RF kill switch for Averatec 5100P"
+#define DRV_COPYRIGHT		"Copyright(c) 2003-2004 Intel Corporation"
+
+static int radio = 1;
+MODULE_PARM(radio, "i");
+
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR(DRV_COPYRIGHT);
+MODULE_LICENSE("GPL");
+
+#define AV5100_RADIO_ON (0xe0)
+#define AV5100_RADIO_OFF (0xe1)
+
+static int av5100_radio = AV5100_RADIO_OFF;
+
+static void av5100_set_radio(int state)
+{
+	printk(KERN_INFO DRV_NAME ": Radio being turned %s\n",
+	       (state  == AV5100_RADIO_ON) ? "ON" : "OFF");
+	outl(0x80020800, 0xcf8);
+	outb(0x6f, 0x0072);
+	outl(0x1800ffff, 0x1184); 
+	outb(state, 0x00b2);
+	av5100_radio = state;
+}
+
+
+/*
+ * proc stuff
+ */
+static struct proc_dir_entry *dir_base = NULL;
+
+static int proc_set_radio(struct file *file, const char *buffer, 
+			  unsigned long count, void *data)
+{
+	av5100_set_radio(buffer[0] == '0' ? AV5100_RADIO_OFF : AV5100_RADIO_ON);
+	
+	return count;
+}
+
+static int proc_get_radio(char *page, char **start, off_t offset,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	
+	len += snprintf(page, count, DRV_NAME ": %d\n", 
+			av5100_radio == AV5100_RADIO_OFF ? 0 : 1);
+	
+	*eof = 1;
+	return len;
+}
+
+
+static void av5100_proc_cleanup(void)
+{
+	if (dir_base) {
+		remove_proc_entry("radio", dir_base);
+		remove_proc_entry(DRV_NAME, &proc_root);
+		dir_base = NULL;
+	}
+}
+
+
+static int av5100_proc_init(void)
+{
+	struct proc_dir_entry *ent;
+	int err = 0;
+
+	dir_base = create_proc_entry(DRV_NAME, S_IFDIR, &proc_root);
+	if (dir_base == NULL) {
+		printk(KERN_ERR DRV_NAME ": Unable to initialise /proc/" 
+		       DRV_NAME "\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+
+	ent = create_proc_entry("radio", S_IFREG | S_IRUGO | S_IWUSR, 
+				dir_base);
+	if (ent) {
+		ent->read_proc = proc_get_radio;
+		ent->write_proc = proc_set_radio;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/" DRV_NAME "/radio\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	return 0;
+
+ fail:
+	av5100_proc_cleanup();
+	return err;
+}
+
+/*
+ * module stuff
+ */
+static int __init av5100_init(void)
+{
+	av5100_proc_init();
+
+	av5100_set_radio((radio == 1) ? AV5100_RADIO_ON : AV5100_RADIO_OFF);
+	
+	return 0;
+}
+
+static void __exit av5100_exit(void)
+{
+	av5100_set_radio(AV5100_RADIO_OFF);
+
+	av5100_proc_cleanup();
+}
+
+module_init(av5100_init);
+module_exit(av5100_exit);
+
+/*
+         1         2         3         4         5         6         7
+12345678901234567890123456789012345678901234567890123456789012345678901234567890
+*/
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,39 @@
+#ifndef PRISM2_CRYPT_H
+#define PRISM2_CRYPT_H
+
+struct hostap_crypto_ops {
+	char *name;
+
+	/* init new crypto context (e.g., allocate private data space,
+	 * select IV, etc.); returns NULL on failure or pointer to allocated
+	 * private data on success */
+	void * (*init)(void);
+
+	/* deinitialize crypto context and free allocated private data */
+	void (*deinit)(void *priv);
+
+	/* encrypt/decrypt return < 0 on error or number of bytes written
+	 * to out_buf; len is number of bytes in in_buf */
+	int (*encrypt)(u8 *buf, int len, void *priv);
+	int (*decrypt)(u8 *buf, int len, void *priv);
+
+	int (*set_key)(int idx, void *key, int len, void *priv);
+	int (*get_key)(int idx, void *key, int len, void *priv);
+
+	int (*set_key_idx)(int idx, void *priv);
+	int (*get_key_idx)(void *priv);
+
+	/* maximum number of bytes added by encryption; encrypt buf is
+	 * allocated with extra_prefix_len bytes, copy of in_buf, and
+	 * extra_postfix_len; encrypt need not use all this space, but
+	 * the result must start at the beginning of the buffer and correct
+	 * length must be returned */
+	int extra_prefix_len, extra_postfix_len;
+};
+
+
+int hostap_register_crypto_ops(struct hostap_crypto_ops *ops);
+int hostap_unregister_crypto_ops(struct hostap_crypto_ops *ops);
+struct hostap_crypto_ops * hostap_get_crypto_ops(const char *name);
+
+#endif /* PRISM2_CRYPT_H */
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,190 @@
+/*******************************************************************************
+  
+  Copyright(c) 2004 Intel Corporation. All rights reserved.
+
+  Portions of this file are based on the WEP enablement code provided by the
+  Host AP project hostap-drivers v0.1.3
+  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+  <jkmaline@cc.hut.fi>
+  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <asm/uaccess.h>
+
+#include "ieee80211.h"
+
+int ieee80211_set_encryption(struct ieee80211_device *ieee)
+{
+	int len, idx;
+	char keybuf[WEP_KEY_LEN + 1];
+	enum { NONE, WEP, OTHER } encrypt_type;
+
+	if (ieee->crypt == NULL || ieee->crypt->ops == NULL)
+		encrypt_type = NONE;
+	else if (strcmp(ieee->crypt->ops->name, "WEP") == 0)
+		encrypt_type = WEP;
+	else
+		encrypt_type = OTHER;
+
+	if (ieee->func->set_unencrypted_filter) {
+		if (ieee->open_wep || encrypt_type == NONE ||
+		    (ieee->ieee_802_1x && ieee->host_decrypt))
+			ieee->func->set_unencrypted_filter(ieee, 0);
+		else
+			ieee->func->set_unencrypted_filter(ieee, 1);
+	}
+
+	if (encrypt_type != WEP) {
+		if (ieee->func->set_wep_authentication)
+			ieee->func->set_wep_authentication(ieee, 0);
+		return 0;
+	}
+
+	/* For now, we have set it to only support host based encryption
+	 * and decryption.  Since it is not uncommon to have host based WEP
+	 * for general communication, but the authentication process occur
+	 * via the hardware, we must tell the HW which WEP key is being used.
+	 */
+
+	if (!ieee->func->set_key ||
+	    !ieee->func->set_key_idx ||
+	    !ieee->func->set_wep_authentication)
+		return 0;
+
+#ifdef NOTYET
+	/* 104-bit support seems to require that all the keys are set to the
+	 * same keylen */
+	keylen = 6; /* first 5 octets */
+
+#endif
+	idx = ieee->crypt->ops->get_key_idx(ieee->crypt->priv);
+	len = ieee->crypt->ops->get_key(idx, keybuf, sizeof(keybuf),
+					ieee->crypt->priv);
+	
+#ifdef NOTYET
+	if (idx >= 0 && idx < WEP_KEYS && len > 5)
+		keylen = WEP_KEY_LEN + 1; /* first 13 octets */
+
+	for (i = 0; i < WEP_KEYS; i++) {
+		memset(keybuf, 0, sizeof(keybuf));
+		(void) ieee->crypt->ops->get_key(i, keybuf, sizeof(keybuf),
+						  ieee->crypt->priv);
+	}
+#endif
+
+	ieee->func->set_key(ieee, idx, keybuf, len);
+//	ieee->func->set_key_idx(ieee, idx);
+	ieee->func->set_wep_authentication(ieee, 1);
+
+	return 0;
+}
+
+static void ieee80211_crypt_deinit_entries(struct ieee80211_device *ieee, 
+					   int force)
+{
+	struct list_head *ptr, *n;
+	struct ieee80211_crypt_data *entry;
+
+	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
+	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
+		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
+
+		if (atomic_read(&entry->refcnt) != 0 && !force)
+			continue;
+
+		list_del(ptr);
+
+		if (entry->ops)
+			entry->ops->deinit(entry->priv);
+		kfree(entry);
+	}
+}
+
+
+static void ieee80211_crypt_deinit_handler(unsigned long data)
+{
+	struct ieee80211_device *ieee = (struct ieee80211_device *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+	ieee80211_crypt_deinit_entries(ieee, 0);
+	if (!list_empty(&ieee->crypt_deinit_list)) {
+		printk(KERN_DEBUG "%s: entries remaining in delayed crypt "
+		       "deletion list\n", ieee->dev->name);
+		ieee->crypt_deinit_timer.expires = jiffies + HZ;
+		add_timer(&ieee->crypt_deinit_timer);
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+
+}
+
+void ieee80211_init(struct ieee80211_device *ieee, struct net_device *dev,
+		    void *priv)
+{
+	memset(ieee, 0, sizeof(*ieee));
+	ieee->dev = dev;
+	ieee->priv = priv;
+
+	/* Default to enabling full open WEP with host based encrypt/decrypt */
+	ieee->open_wep = 1;
+	ieee->host_encrypt = 1;
+	ieee->host_decrypt = 1;
+	
+	INIT_LIST_HEAD(&ieee->crypt_deinit_list);
+	init_timer(&ieee->crypt_deinit_timer);
+	ieee->crypt_deinit_timer.data = (unsigned long)ieee;
+	ieee->crypt_deinit_timer.function = ieee80211_crypt_deinit_handler;
+
+	spin_lock_init(&ieee->lock);
+}
+
+void ieee80211_deinit(struct ieee80211_device *ieee)
+{
+	ieee80211_crypt_deinit_entries(ieee, 1);
+	if (ieee->crypt && ieee->crypt->ops) {
+		ieee->crypt->ops->deinit(ieee->crypt->priv);
+		kfree(ieee->crypt);
+		ieee->crypt = NULL;
+	}
+}
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,335 @@
+/*
+ * Original code based on Host AP (software wireless LAN access point) driver 
+ * for Intersil Prism2/2.5/3.
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * Adaption to a generic IEEE 802.11 stack by James Ketrenos 
+ * <jketreno@linux.intel.com>
+ *
+ * Copyright (c) 2004, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. See README and COPYING for
+ * more details.
+ */
+#ifndef IEEE80211_H
+#define IEEE80211_H
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+
+#ifndef WIRELESS_SPY
+#define WIRELESS_SPY		// enable iwspy support
+#endif
+#include <net/iw_handler.h>	// new driver API
+
+#define BIT(x) (1 << (x))
+
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+/* IEEE 802.11 defines */
+
+#define WLAN_FC_PVER (BIT(1) | BIT(0))
+#define WLAN_FC_TODS BIT(8)
+#define WLAN_FC_FROMDS BIT(9)
+#define WLAN_FC_MOREFRAG BIT(10)
+#define WLAN_FC_RETRY BIT(11)
+#define WLAN_FC_PWRMGT BIT(12)
+#define WLAN_FC_MOREDATA BIT(13)
+#define WLAN_FC_ISWEP BIT(14)
+#define WLAN_FC_ORDER BIT(15)
+
+#define WLAN_FC_GET_TYPE(fc) (((fc) & (BIT(3) | BIT(2))) >> 2)
+#define WLAN_FC_GET_STYPE(fc) \
+	(((fc) & (BIT(7) | BIT(6) | BIT(5) | BIT(4))) >> 4)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & (BIT(3) | BIT(2) | BIT(1) | BIT(0)))
+#define WLAN_GET_SEQ_SEQ(seq) \
+	(((seq) & (~(BIT(3) | BIT(2) | BIT(1) | BIT(0)))) >> 4)
+
+#define WLAN_FC_TYPE_MGMT 0
+#define WLAN_FC_TYPE_CTRL 1
+#define WLAN_FC_TYPE_DATA 2
+
+/* management */
+#define WLAN_FC_STYPE_ASSOC_REQ 0
+#define WLAN_FC_STYPE_ASSOC_RESP 1
+#define WLAN_FC_STYPE_REASSOC_REQ 2
+#define WLAN_FC_STYPE_REASSOC_RESP 3
+#define WLAN_FC_STYPE_PROBE_REQ 4
+#define WLAN_FC_STYPE_PROBE_RESP 5
+#define WLAN_FC_STYPE_BEACON 8
+#define WLAN_FC_STYPE_ATIM 9
+#define WLAN_FC_STYPE_DISASSOC 10
+#define WLAN_FC_STYPE_AUTH 11
+#define WLAN_FC_STYPE_DEAUTH 12
+
+/* control */
+#define WLAN_FC_STYPE_PSPOLL 10
+#define WLAN_FC_STYPE_RTS 11
+#define WLAN_FC_STYPE_CTS 12
+#define WLAN_FC_STYPE_ACK 13
+#define WLAN_FC_STYPE_CFEND 14
+#define WLAN_FC_STYPE_CFENDACK 15
+
+/* data */
+#define WLAN_FC_STYPE_DATA 0
+#define WLAN_FC_STYPE_DATA_CFACK 1
+#define WLAN_FC_STYPE_DATA_CFPOLL 2
+#define WLAN_FC_STYPE_DATA_CFACKPOLL 3
+#define WLAN_FC_STYPE_NULLFUNC 4
+#define WLAN_FC_STYPE_CFACK 5
+#define WLAN_FC_STYPE_CFPOLL 6
+#define WLAN_FC_STYPE_CFACKPOLL 7
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_ESS BIT(0)
+#define WLAN_CAPABILITY_IBSS BIT(1)
+#define WLAN_CAPABILITY_CF_POLLABLE BIT(2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST BIT(3)
+#define WLAN_CAPABILITY_PRIVACY BIT(4)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+struct ieee80211_hdr {
+	u16 frame_control;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+	u8 addr4[6];
+} __attribute__ ((packed));
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	u32 mac_time;
+	u8 signal;
+	u8 noise;
+	u16 rate; /* in 100 kbps */
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	unsigned long first_frag_time;
+	unsigned int seq;
+	unsigned int last_frag;
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	unsigned int tx_unicast_frames;
+	unsigned int tx_multicast_frames;
+	unsigned int tx_fragments;
+	unsigned int tx_unicast_octets;
+	unsigned int tx_multicast_octets;
+	unsigned int tx_deferred_transmissions;
+	unsigned int tx_single_retry_frames;
+	unsigned int tx_multiple_retry_frames;
+	unsigned int tx_retry_limit_exceeded;
+	unsigned int tx_discards;
+	unsigned int rx_unicast_frames;
+	unsigned int rx_multicast_frames;
+	unsigned int rx_fragments;
+	unsigned int rx_unicast_octets;
+	unsigned int rx_multicast_octets;
+	unsigned int rx_fcs_errors;
+	unsigned int rx_discards_no_buffer;
+	unsigned int tx_discards_wrong_sa;
+	unsigned int rx_discards_wep_undecryptable;
+	unsigned int rx_message_in_msg_fragments;
+	unsigned int rx_message_in_bad_msg_fragments;
+};
+
+#include "ieee80211_crypt.h"
+
+struct ieee80211_device;
+
+struct ieee80211_helper_functions {
+	void (*set_key)(struct ieee80211_device *ieee, int idx, char *key, 
+		     int len);
+	void (*set_key_idx)(struct ieee80211_device *ieee, int idx);
+	void (*set_wep_authentication)(struct ieee80211_device *ieee, 
+				       int enable);
+
+	/* these functions are defined in hardware model specific files
+	 * (hostap_{cs,plx,pci}.c */
+	int (*card_present)(struct ieee80211_device *ieee);
+	void (*cor_sreset)(struct ieee80211_device *ieee);
+	int (*dev_open)(struct ieee80211_device *ieee);
+	int (*dev_close)(struct ieee80211_device *ieee);
+	void (*genesis_reset)(struct ieee80211_device *ieee, int hcr);
+
+	
+	/* Turn on unencrypted packet filtering at the HW level */
+	void (*set_unencrypted_filter)(struct ieee80211_device *ieee, int flag);
+
+	/* the following functions are from hostap_hw.c, but they may have some
+	 * hardware model specific code */
+
+	int (*hw_enable)(struct net_device *dev, int initial);
+	int (*hw_config)(struct net_device *dev, int initial);
+	void (*hw_reset)(struct net_device *dev);
+	void (*hw_shutdown)(struct net_device *dev, int no_disable);
+	int (*reset_port)(struct net_device *dev);
+	int (*tx)(struct sk_buff *skb, struct net_device *dev);
+	void (*schedule_reset)(struct ieee80211_device *ieee);
+	int (*tx_80211)(struct sk_buff *skb, struct net_device *dev);
+};
+
+struct ieee80211_device {
+	struct net_device *dev;
+
+	/* Bookkeeping structures */
+	struct net_device_stats stats;
+	struct ieee80211_stats ieee_stats;
+	void *priv;
+
+	int iw_mode; /* operating mode (IW_MODE_*) */
+
+	spinlock_t lock;
+
+	/* WEP and other encryption related settings at the device level */
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+	int open_wep; /* Set to 1 to allow unencrypted frames */
+
+	int reset_on_keychange; /* Set to 1 if the HW needs to be reset on
+				 * WEP key changes */
+
+	/* If the host performs {en,de}cryption, then set to 1 */
+	int host_encrypt;
+	int host_decrypt;
+
+	int ieee_802_1x; /* is IEEE 802.1X used */
+
+	struct list_head crypt_deinit_list;
+	struct ieee80211_crypt_data *crypt;
+	struct timer_list crypt_deinit_timer;
+
+	int bcrx_sta_key; /* use individual keys to override default keys even
+			   * with RX of broad/multicast frames */
+
+	/* Fragmentation structures */
+	struct ieee80211_frag_entry frag_cache[IEEE80211_FRAG_CACHE_LEN];
+	unsigned int frag_next_idx;
+
+
+	/* Callback vtable */
+	struct ieee80211_helper_functions *func;
+
+};
+
+
+extern inline int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case WLAN_FC_TYPE_DATA:
+		if ((fc & WLAN_FC_FROMDS) && (fc & WLAN_FC_TODS))
+			hdrlen = 30; /* Addr4 */
+		break;
+	case WLAN_FC_TYPE_CTRL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case WLAN_FC_STYPE_CTS:
+		case WLAN_FC_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+
+	return hdrlen;
+}
+
+/* ieee80211.c */
+extern void ieee80211_init(struct ieee80211_device *ieee, 
+			   struct net_device *dev,
+			   void *priv);
+extern void ieee80211_deinit(struct ieee80211_device *ieee);
+extern int ieee80211_set_encryption(struct ieee80211_device *ieee);
+
+
+/* ieee80211_rx.c */
+extern int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+			struct ieee80211_rx_stats *rx_stats);
+
+/* iee80211_wx.c */
+extern int ieee80211_wx_set_encode(struct ieee80211_device *ieee, 
+				   struct iw_request_info *info, 
+				   union iwreq_data *wrqu, char *key);
+extern int ieee80211_wx_get_encode(struct ieee80211_device *ieee, 
+				   struct iw_request_info *info, 
+				   union iwreq_data *wrqu, char *key);
+
+#endif /* IEEE80211_H */
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211_crypt.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211_crypt.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211_crypt.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211_crypt.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,35 @@
+/*
+ * Original code based on Host AP (software wireless LAN access point) driver 
+ * for Intersil Prism2/2.5/3.
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * Adaption to a generic IEEE 802.11 stack by James Ketrenos 
+ * <jketreno@linux.intel.com>
+ *
+ * Copyright (c) 2004, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. See README and COPYING for
+ * more details.
+ */
+
+/*
+ * This file defines the interface to the ieee80211 crypto module.  
+ */
+#ifndef IEEE80211_CRYPT_H
+#define IEEE80211_CRYPT_H
+
+#include "hostap/hostap_crypt.h"
+
+struct ieee80211_crypt_data {
+	struct list_head list; /* delayed deletion list */
+	struct hostap_crypto_ops *ops;
+	void *priv;
+	atomic_t refcnt;
+};
+
+#endif
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211_rx.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211_rx.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211_rx.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211_rx.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,681 @@
+/*
+ * Original code based Host AP (software wireless LAN access point) driver 
+ * for Intersil Prism2/2.5/3 - hostap.o module, common routines
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright (c) 2004, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. See README and COPYING for
+ * more details.
+ */
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <asm/uaccess.h>
+
+#include "ieee80211.h"
+
+/* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static unsigned char rfc1042_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static unsigned char bridge_tunnel_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+/* No encapsulation header if EtherType < 0x600 (=length) */
+
+
+/* Called by ieee80211_rx_frame_decrypt */
+static inline int ieee80211_is_eapol_frame(struct ieee80211_device *ieee,
+					   struct ieee80211_hdr *hdr, u8 *buf,
+					   int len)
+{
+	struct net_device *dev = ieee->dev;
+	u16 fc, ethertype;
+
+	fc = le16_to_cpu(hdr->frame_control);
+
+	/* check that the frame is unicast frame to us */
+	if ((fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_TODS &&
+	    memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&
+	    memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {
+		/* ToDS frame with own addr BSSID and DA */
+	} else if ((fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_FROMDS &&
+		   memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {
+		/* FromDS frame with own addr as DA */
+	} else
+		return 0;
+
+	if (len < 8)
+		return 0;
+
+	/* check for port access entity Ethernet type */
+	ethertype = (buf[6] << 8) | buf[7];
+	if (ethertype == ETH_P_PAE)
+		return 1;
+
+	return 0;
+}
+
+#define STR_12c "%02X%02X%02X%02X-%02X%02X%02X%02X-%02X%02X%02X%02X"
+#define VAR_12c(x) ((u8*)x)[0],((u8*)x)[1],((u8*)x)[2],((u8*)x)[3],\
+ ((u8*)x)[4],((u8*)x)[5],((u8*)x)[6],((u8*)x)[7], \
+ ((u8*)x)[8],((u8*)x)[9],((u8*)x)[10],((u8*)x)[11] 
+
+/* Called only as a tasklet (software IRQ), by ieee80211_rx */
+static inline int
+ieee80211_rx_frame_decrypt(struct ieee80211_device* ieee, int iswep, 
+			   struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_crypt_data *crypt;
+	void *sta = NULL;
+	int ret = 0, olen, len, hdrlen;
+	char *payload;
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	hdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_control));
+
+	len = skb->len - hdrlen;
+	payload = ((char *) (hdr)) + hdrlen;
+	crypt = ieee->crypt;
+	sta = NULL;
+
+#ifdef NOT_YET
+	/* Use station specific key to override default keys if the receiver
+	 * address is a unicast address ("individual RA"). If bcrx_sta_key
+	 * parameter is set, station specific key is used even with
+	 * broad/multicast targets (this is against IEEE 802.11, but makes it
+	 * easier to use different keys with stations that do not support WEP
+	 * key mapping). */
+	if (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)
+		(void) hostap_handle_sta_crypto(local, hdr, &crypt, &sta);
+#endif
+
+	/* allow NULL decrypt to indicate an station specific override for
+	 * default encryption */
+	if (crypt && (crypt->ops == NULL || crypt->ops->decrypt == NULL))
+		crypt = NULL;
+
+	if (!crypt && iswep) {
+		printk(KERN_DEBUG "%s: WEP decryption failed (not set) (SA="
+		       MACSTR ")\n", ieee->dev->name, MAC2STR(hdr->addr2));
+		ieee->ieee_stats.rx_discards_wep_undecryptable++;
+		ret = -1;
+		goto done;
+	}
+
+	if (!crypt)
+		goto done;
+
+	if (!iswep && !ieee->open_wep) {
+		if (ieee->ieee_802_1x &&
+		    ieee80211_is_eapol_frame(ieee, hdr, payload, len)) {
+			/* pass unencrypted EAPOL frames even if encryption is
+			 * configured */
+			printk(KERN_DEBUG "%s: RX: IEEE 802.1X - passing "
+			       "unencrypted EAPOL frame\n", ieee->dev->name);
+			goto done;
+		}
+		printk(KERN_DEBUG "%s: encryption configured, but RX frame "
+		       "not encrypted (SA=" MACSTR ")\n",
+		       ieee->dev->name, MAC2STR(hdr->addr2));
+		ret = -1;
+		goto done;
+	}
+
+	/* decrypt WEP part of the frame: IV (4 bytes), encrypted
+	 * payload (including SNAP header), ICV (4 bytes) */
+	atomic_inc(&crypt->refcnt);
+
+/*	printk(KERN_INFO "%s: Before decrypt: " STR_12c "\n",
+	ieee->dev->name, VAR_12c(payload)); */
+	olen = crypt->ops->decrypt(payload, len, crypt->priv);
+/*	printk(KERN_INFO "%s: After decrypt : " STR_12c "\n",
+	ieee->dev->name, VAR_12c(payload));*/
+	atomic_dec(&crypt->refcnt);
+	if (olen < 0) {
+		printk(KERN_DEBUG "%s: WEP decryption failed (SA=" MACSTR
+		       ") len = %d\n", ieee->dev->name, MAC2STR(hdr->addr2),
+		       len);
+		ieee->ieee_stats.rx_discards_wep_undecryptable++;
+		ret = -1;
+		goto done;
+	}
+
+	skb_trim(skb, skb->len - (len - olen));
+
+ done:
+#ifdef NOT_YET
+	if (sta)
+		hostap_handle_sta_release(sta);
+#endif
+
+	return ret;
+}
+
+/* ieee80211_rx_frame_mgtmt
+ *
+ * Responsible for handling management control frames
+ * 
+ * Called by ieee80211_rx */
+static inline int
+ieee80211_rx_frame_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb,
+			struct ieee80211_rx_stats *rx_stats, u16 type,
+			u16 stype)
+{
+	if (ieee->iw_mode == IW_MODE_MASTER) {
+		printk(KERN_DEBUG "%s: Master mode not yet suppported.\n",
+		       ieee->dev->name);
+#ifdef NOT_YET
+		hostap_update_sta_ps(ieee, (struct hostap_ieee80211_hdr *)
+				     skb->data);
+#endif
+	}
+
+#ifdef NOT_YET
+	if (ieee->hostapd && type == WLAN_FC_TYPE_MGMT) {
+		if (stype == WLAN_FC_STYPE_BEACON &&
+		    ieee->iw_mode == IW_MODE_MASTER) {
+			struct sk_buff *skb2;
+			/* Process beacon frames also in kernel driver to
+			 * update STA(AP) table statistics */
+			skb2 = skb_clone(skb, GFP_ATOMIC);
+			if (skb2)
+				hostap_rx(skb2->dev, skb2, rx_stats);
+		}
+
+		/* send management frames to the user space daemon for
+		 * processing */
+		ieee->apdevstats.rx_packets++;
+		ieee->apdevstats.rx_bytes += skb->len;
+		prism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);
+		return 0;
+	}
+#endif
+
+#ifdef NOT_YET
+	if (ieee->iw_mode == IW_MODE_MASTER) {
+		if (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {
+			printk(KERN_DEBUG "%s: unknown management frame "
+			       "(type=0x%02x, stype=0x%02x) dropped\n",
+			       skb->dev->name, type, stype);
+			return -1;
+		}
+
+		hostap_rx(skb->dev, skb, rx_stats);
+		return 0;
+	} 
+#endif
+	printk(KERN_DEBUG "%s: hostap_rx_frame_mgmt: management frame "
+	       "received in non-Host AP mode\n", skb->dev->name);
+	return -1;
+}
+
+/* Called only as a tasklet (software IRQ) */
+static struct ieee80211_frag_entry *
+ieee80211_frag_cache_find(struct ieee80211_device *ieee, unsigned int seq,
+			  unsigned int frag, u8 *src, u8 *dst)
+{
+	struct ieee80211_frag_entry *entry;
+	int i;
+
+	for (i = 0; i < IEEE80211_FRAG_CACHE_LEN; i++) {
+		entry = &ieee->frag_cache[i];
+		if (entry->skb != NULL &&
+		    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {
+			printk(KERN_DEBUG "%s: expiring fragment cache entry "
+			       "seq=%u last_frag=%u\n",
+			       ieee->dev->name, entry->seq, entry->last_frag);
+			dev_kfree_skb(entry->skb);
+			entry->skb = NULL;
+		}
+
+		if (entry->skb != NULL && entry->seq == seq &&
+		    (entry->last_frag + 1 == frag || frag == -1) &&
+		    memcmp(entry->src_addr, src, ETH_ALEN) == 0 &&
+		    memcmp(entry->dst_addr, dst, ETH_ALEN) == 0)
+			return entry;
+	}
+
+	return NULL;
+}
+
+/* Called only as a tasklet (software IRQ) */
+static struct sk_buff *
+ieee80211_frag_cache_get(struct ieee80211_device *ieee, 
+			 struct ieee80211_hdr *hdr)
+{
+	struct sk_buff *skb = NULL;
+	u16 sc;
+	unsigned int frag, seq;
+	struct ieee80211_frag_entry *entry;
+	
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	frag = WLAN_GET_SEQ_FRAG(sc);
+	seq = WLAN_GET_SEQ_SEQ(sc);
+
+	if (frag == 0) {
+		/* Reserve enough space to fit maximum frame length */
+		skb = dev_alloc_skb(ieee->dev->mtu +
+				    sizeof(struct ieee80211_hdr) +
+				    8 /* LLC */ +
+				    2 /* alignment */ +
+				    8 /* WEP */ + ETH_ALEN /* WDS */);
+		if (skb == NULL)
+			return NULL;
+
+		entry = &ieee->frag_cache[ieee->frag_next_idx];
+		ieee->frag_next_idx++;
+		if (ieee->frag_next_idx >= IEEE80211_FRAG_CACHE_LEN)
+			ieee->frag_next_idx = 0;
+
+		if (entry->skb != NULL)
+			dev_kfree_skb(entry->skb);
+
+		entry->first_frag_time = jiffies;
+		entry->seq = seq;
+		entry->last_frag = frag;
+		entry->skb = skb;
+		memcpy(entry->src_addr, hdr->addr2, ETH_ALEN);
+		memcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);
+	} else {
+		/* received a fragment of a frame for which the head fragment
+		 * should have already been received */
+		entry = ieee80211_frag_cache_find(ieee, seq, frag, hdr->addr2,
+						  hdr->addr1);
+		if (entry != NULL) {
+			entry->last_frag = frag;
+			skb = entry->skb;
+		}
+	}
+
+	return skb;
+}
+
+
+/* Called only as a tasklet (software IRQ) */
+static int ieee80211_frag_cache_invalidate(struct ieee80211_device *ieee,
+					   struct ieee80211_hdr *hdr)
+{
+	u16 sc;
+	unsigned int seq;
+	struct ieee80211_frag_entry *entry;
+
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	seq = WLAN_GET_SEQ_SEQ(sc);
+
+	entry = ieee80211_frag_cache_find(ieee, seq, -1, hdr->addr2, 
+					  hdr->addr1);
+
+	if (entry == NULL) {
+		printk(KERN_DEBUG "%s: could not invalidate fragment cache "
+		       "entry (seq=%u)\n",
+		       ieee->dev->name, seq);
+		return -1;
+	}
+
+	entry->skb = NULL;
+	return 0;
+}
+ 
+
+/* All received frames are sent to this function. @skb contains the frame in
+ * IEEE 802.11 format, i.e., in the format it was sent over air.
+ * This function is called only as a tasklet (software IRQ). */
+int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+		 struct ieee80211_rx_stats *rx_stats)
+{
+	struct net_device *dev = ieee->dev;
+	struct ieee80211_hdr *hdr;
+	size_t hdrlen;
+	u16 fc, type, stype, sc;
+	struct net_device *wds = NULL;
+	struct net_device_stats *stats;
+	unsigned int frag;
+	u8 *payload;
+	struct sk_buff *skb2 = NULL;
+	u16 ethertype;
+#ifdef NOT_YET
+	int frame_authorized = 0;
+	int from_assoc_ap = 0;
+#endif
+	u8 dst[ETH_ALEN];
+	u8 src[ETH_ALEN];
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	stats = &ieee->stats;
+
+	if (skb->len < 10) {
+		printk(KERN_INFO "%s: SKB length < 10\n",
+		       dev->name);
+		goto rx_dropped;
+	}
+
+	fc = le16_to_cpu(hdr->frame_control);
+	type = WLAN_FC_GET_TYPE(fc);
+	stype = WLAN_FC_GET_STYPE(fc);
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	frag = WLAN_GET_SEQ_FRAG(sc);
+	hdrlen = ieee80211_get_hdrlen(fc);
+
+#ifdef NOT_YET
+
+#if WIRELESS_EXT > 15
+	/* Put this code here so that we avoid duplicating it in all
+	 * Rx paths. - Jean II */
+#ifdef IW_WIRELESS_SPY		/* defined in iw_handler.h */
+	/* If spy monitoring on */
+	if (iface->spy_data.spy_number > 0) {
+		struct iw_quality wstats;
+		wstats.level = rx_stats->signal;
+		wstats.noise = rx_stats->noise;
+		wstats.updated = 6;	/* No qual value */
+		/* Update spy records */
+		wireless_spy_update(dev, hdr->addr2, &wstats);
+	}
+#endif /* IW_WIRELESS_SPY */
+#endif /* WIRELESS_EXT > 15 */
+
+	if (ieee->iw_mode == IW_MODE_MONITOR) {
+		monitor_rx(dev, skb, rx_stats);
+		return 1;
+	}
+
+#endif
+
+	if (type != WLAN_FC_TYPE_DATA) {
+		if (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&
+		    fc & WLAN_FC_ISWEP && ieee->host_decrypt &&
+		    ieee80211_rx_frame_decrypt(ieee, fc & WLAN_FC_ISWEP, 
+					       skb)) {
+			printk(KERN_DEBUG "%s: failed to decrypt mgmt::auth "
+			       "from " MACSTR "\n", dev->name,
+			       MAC2STR(hdr->addr2));
+			/* TODO: could inform hostapd about this so that it
+			 * could send auth failure report */
+			goto rx_dropped;
+		}
+
+		if (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))
+			goto rx_dropped;
+		else
+			goto rx_exit;
+	}
+
+	/* Data frame - extract src/dst addresses */
+	if (skb->len < IEEE80211_DATA_HDR3_LEN)
+		goto rx_dropped;
+
+	switch (fc & (WLAN_FC_FROMDS | WLAN_FC_TODS)) {
+	case WLAN_FC_FROMDS:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr3, ETH_ALEN);
+		break;
+	case WLAN_FC_TODS:
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		break;
+	case WLAN_FC_FROMDS | WLAN_FC_TODS:
+		if (skb->len < IEEE80211_DATA_HDR4_LEN)
+			goto rx_dropped;
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr4, ETH_ALEN);
+		break;
+	case 0:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		break;
+	}
+
+#ifdef NOT_YET
+	if (hostap_rx_frame_wds(ieee, hdr, fc, &wds))
+		goto rx_dropped;
+	if (wds) {
+		skb->dev = dev = wds;
+		stats = hostap_get_stats(dev);
+	}
+
+	if (ieee->iw_mode == IW_MODE_MASTER && !wds &&
+	    (fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_FROMDS &&
+	    ieee->stadev &&
+	    memcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {
+		/* Frame from BSSID of the AP for which we are a client */
+		skb->dev = dev = ieee->stadev;
+		stats = hostap_get_stats(dev);
+		from_assoc_ap = 1;
+	}
+#endif
+
+	dev->last_rx = jiffies;
+
+#ifdef NOT_YET
+	if ((ieee->iw_mode == IW_MODE_MASTER ||
+	     ieee->iw_mode == IW_MODE_REPEAT) &&
+	    !from_assoc_ap) {
+		switch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,
+					     wds != NULL)) {
+		case AP_RX_CONTINUE_NOT_AUTHORIZED:
+			frame_authorized = 0;
+			break;
+		case AP_RX_CONTINUE:
+			frame_authorized = 1;
+			break;
+		case AP_RX_DROP:
+			goto rx_dropped;
+		case AP_RX_EXIT:
+			goto rx_exit;
+		}
+	} else if (ieee->iw_mode == IW_MODE_REPEAT ||
+		   ieee->wds_type & HOSTAP_WDS_AP_CLIENT)
+		hostap_update_rx_stats(ieee->ap, hdr, rx_stats);
+#endif
+
+	/* Nullfunc frames may have PS-bit set, so they must be passed to
+	 * hostap_handle_sta_rx() before being dropped here. */
+	if (stype != WLAN_FC_STYPE_DATA &&
+	    stype != WLAN_FC_STYPE_DATA_CFACK &&
+	    stype != WLAN_FC_STYPE_DATA_CFPOLL &&
+	    stype != WLAN_FC_STYPE_DATA_CFACKPOLL) {
+		if (stype != WLAN_FC_STYPE_NULLFUNC)
+			printk(KERN_DEBUG "%s: RX: dropped data frame "
+			       "with no data (type=0x%02x, subtype=0x%02x)\n",
+			       dev->name, type, stype);
+		goto rx_dropped;
+	}
+
+	/* skb: hdr + (possibly fragmented, possibly encrypted) payload */
+
+	if (ieee->host_decrypt &&
+	    ieee80211_rx_frame_decrypt(ieee, fc & WLAN_FC_ISWEP, skb)) 
+		goto rx_dropped;
+
+	/* skb: hdr + (possibly fragmented) plaintext payload */
+
+	if (/*ieee->host_decrypt && (fc & WLAN_FC_ISWEP) &&*/
+	    (frag != 0 || (fc & WLAN_FC_MOREFRAG))) {
+		int flen;
+		struct sk_buff *frag_skb = 
+			ieee80211_frag_cache_get(ieee, hdr);
+		if (!frag_skb) {
+			printk(KERN_DEBUG "%s: Rx cannot get skb from "
+			       "fragment cache (morefrag=%d seq=%u frag=%u)\n",
+			       dev->name, (fc & WLAN_FC_MOREFRAG) != 0,
+			       WLAN_GET_SEQ_SEQ(sc), frag);
+			goto rx_dropped;
+		}
+
+		flen = skb->len;
+		if (frag != 0)
+			flen -= hdrlen;
+
+		if (frag_skb->tail + flen > frag_skb->end) {
+			printk(KERN_WARNING "%s: host decrypted and "
+			       "reassembled frame did not fit skb\n",
+			       dev->name);
+			ieee80211_frag_cache_invalidate(ieee, hdr);
+			goto rx_dropped;
+		}
+
+		if (frag == 0) {
+			/* copy first fragment (including full headers) into
+			 * beginning of the fragment cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data, flen);
+		} else {
+			/* append frame payload to the end of the fragment
+			 * cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
+			       flen);
+		}
+		dev_kfree_skb(skb);
+		skb = NULL;
+
+		if (fc & WLAN_FC_MOREFRAG) {
+			/* more fragments expected - leave the skb in fragment
+			 * cache for now; it will be delivered to upper layers
+			 * after all fragments have been received */
+			goto rx_exit;
+		}
+
+		/* this was the last fragment and the frame will be
+		 * delivered, so remove skb from fragment cache */
+		skb = frag_skb;
+		hdr = (struct ieee80211_hdr *) skb->data;
+		ieee80211_frag_cache_invalidate(ieee, hdr);
+	}
+
+	/* skb: hdr + (possible reassembled) full plaintext payload */
+
+	payload = skb->data + hdrlen;
+	ethertype = (payload[6] << 8) | payload[7];
+
+#ifdef NOT_YET
+	/* If IEEE 802.1X is used, check whether the port is authorized to send
+	 * the received frame. */
+	if (ieee->ieee_802_1x && ieee->iw_mode == IW_MODE_MASTER) {
+		if (ethertype == ETH_P_PAE) {
+			printk(KERN_DEBUG "%s: RX: IEEE 802.1X frame\n",
+			       dev->name);
+			if (ieee->hostapd && ieee->apdev) {
+				/* Send IEEE 802.1X frames to the user
+				 * space daemon for processing */
+				prism2_rx_80211(ieee->apdev, skb, rx_stats,
+						PRISM2_RX_MGMT);
+				ieee->apdevstats.rx_packets++;
+				ieee->apdevstats.rx_bytes += skb->len;
+				goto rx_exit;
+			}
+		} else if (!frame_authorized) {
+			printk(KERN_DEBUG "%s: dropped frame from "
+			       "unauthorized port (IEEE 802.1X): "
+			       "ethertype=0x%04x\n",
+			       dev->name, ethertype);
+			goto rx_dropped;
+		}
+	}
+#endif
+
+	/* convert hdr + possible LLC headers into Ethernet header */
+	if (skb->len - hdrlen >= 8 &&
+	    ((memcmp(payload, rfc1042_header, 6) == 0 &&
+	      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+	     memcmp(payload, bridge_tunnel_header, 6) == 0)) {
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and
+		 * replace EtherType */
+		skb_pull(skb, hdrlen + 6);
+		memcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);
+		memcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);
+	} else {
+		u16 len;
+		/* Leave Ethernet header part of hdr and full payload */
+		skb_pull(skb, hdrlen);
+		len = htons(skb->len);
+		memcpy(skb_push(skb, 2), &len, 2);
+		memcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);
+		memcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);
+	}
+
+	if (wds && ((fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_TODS) &&
+	    skb->len >= ETH_HLEN + ETH_ALEN) {
+		/* Non-standard frame: get addr4 from its bogus location after
+		 * the payload */
+		memcpy(skb->data + ETH_ALEN,
+		       skb->data + skb->len - ETH_ALEN, ETH_ALEN);
+		skb_trim(skb, skb->len - ETH_ALEN);
+	}
+
+	stats->rx_packets++;
+	stats->rx_bytes += skb->len;
+
+#ifdef NOT_YET
+	if (ieee->iw_mode == IW_MODE_MASTER && !wds &&
+	    ieee->ap->bridge_packets) {
+		if (dst[0] & 0x01) {
+			/* copy multicast frame both to the higher layers and
+			 * to the wireless media */
+			ieee->ap->bridged_multicast++;
+			skb2 = skb_clone(skb, GFP_ATOMIC);
+			if (skb2 == NULL)
+				printk(KERN_DEBUG "%s: skb_clone failed for "
+				       "multicast frame\n", dev->name);
+		} else if (hostap_is_sta_assoc(ieee->ap, dst)) {
+			/* send frame directly to the associated STA using
+			 * wireless media and not passing to higher layers */
+			ieee->ap->bridged_unicast++;
+			skb2 = skb;
+			skb = NULL;
+		}
+	}
+#endif
+
+	if (skb2 != NULL) {
+		/* send to wireless media */
+		skb2->protocol = __constant_htons(ETH_P_802_3);
+		skb2->mac.raw = skb2->nh.raw = skb2->data;
+		/* skb2->nh.raw = skb2->data + ETH_HLEN; */
+		skb2->dev = dev;
+		dev_queue_xmit(skb2);
+	}
+
+	if (skb) {
+		skb->protocol = eth_type_trans(skb, dev);
+		memset(skb->cb, 0, sizeof(skb->cb));
+		skb->dev = dev;
+		netif_rx(skb);
+	}
+
+ rx_exit:
+	return 1;
+
+ rx_dropped:
+	/* dev_kfree_skb(skb); */
+
+	stats->rx_dropped++;
+
+	/* Returning 0 indicates to caller that we have not handled the SKB--
+	 * so it is still allocated and can be used again by underlying
+	 * hardware as a DMA target */
+	return 0;
+}
+
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211_wx.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211_wx.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/ieee80211_wx.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ieee80211_wx.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,215 @@
+/*******************************************************************************
+  
+  Copyright(c) 2004 Intel Corporation. All rights reserved.
+
+  Portions of this file are based on the WEP enablement code provided by the
+  Host AP project hostap-drivers v0.1.3
+  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+  <jkmaline@cc.hut.fi>
+  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#include <linux/wireless.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/kmod.h> /* request_module */
+#endif
+
+#include "ieee80211.h"
+
+static void ieee80211_crypt_delayed_deinit(struct ieee80211_device *ieee,
+					   struct ieee80211_crypt_data **crypt)
+{
+	struct ieee80211_crypt_data *tmp;
+	unsigned long flags;
+
+	if (*crypt == NULL)
+		return;
+	
+	tmp = *crypt;
+	*crypt = NULL;
+
+	/* must not run ops->deinit() while there may be pending encrypt or
+	 * decrypt operations. Use a list of delayed deinits to avoid needing
+	 * locking. */
+
+	spin_lock_irqsave(&ieee->lock, flags);
+	list_add(&tmp->list, &ieee->crypt_deinit_list);
+	if (!timer_pending(&ieee->crypt_deinit_timer)) {
+		ieee->crypt_deinit_timer.expires = jiffies + HZ;
+		add_timer(&ieee->crypt_deinit_timer);
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+}
+
+
+int ieee80211_wx_set_encode(struct ieee80211_device *ieee,
+			   struct iw_request_info *info, 
+			   union iwreq_data *wrqu, char *key)
+{
+	struct net_device *dev = ieee->dev;
+	struct iw_point *erq = &(wrqu->encoding);
+	int first = 0;
+	int i;
+
+	if (erq->flags & IW_ENCODE_DISABLED) {
+		ieee80211_crypt_delayed_deinit(ieee, &ieee->crypt);
+		goto done;
+	}
+	
+	if (ieee->crypt != NULL && ieee->crypt->ops != NULL &&
+	    strcmp(ieee->crypt->ops->name, "WEP") != 0) {
+		/* changing to use WEP; deinit previously used algorithm */
+		ieee80211_crypt_delayed_deinit(ieee, &ieee->crypt);
+	}
+	
+	if (ieee->crypt == NULL) {
+		struct ieee80211_crypt_data *new_crypt;
+		
+		/* take WEP into use */
+		new_crypt = (struct ieee80211_crypt_data *)
+			kmalloc(sizeof(struct ieee80211_crypt_data), 
+				GFP_KERNEL);
+		if (new_crypt == NULL)
+			return -ENOMEM;
+		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
+		new_crypt->ops = hostap_get_crypto_ops("WEP");
+		if (!new_crypt->ops) {
+			request_module("hostap_crypt_wep");
+			new_crypt->ops = hostap_get_crypto_ops("WEP");
+		}
+		if (new_crypt->ops)
+			new_crypt->priv = new_crypt->ops->init();
+		if (!new_crypt->ops || !new_crypt->priv) {
+			kfree(new_crypt);
+			new_crypt = NULL;
+
+			printk(KERN_WARNING "%s: could not initialize WEP: "
+			       "load module hostap_crypt_wep.o\n",
+			       dev->name);
+			return -EOPNOTSUPP;
+		}
+		first = 1;
+		ieee->crypt = new_crypt;
+	}
+
+	i = erq->flags & IW_ENCODE_INDEX;
+	if (i < 1 || i > 4)
+		i = ieee->crypt->ops->get_key_idx(ieee->crypt->priv);
+	else
+		i--;
+	if (i < 0 || i >= WEP_KEYS)
+		return -EINVAL;
+
+	if (erq->length > 0) {
+		int len = erq->length <= 5 ? 5 : 13;
+		printk(KERN_INFO "%s: Setting key %d to %c%c%c%c%c\n",
+		       ieee->dev->name, i, key[0], key[1], key[2], key[3],
+		       key[4]);
+		if (len > erq->length)
+			memset(key + erq->length, 0, len - erq->length);
+		ieee->crypt->ops->set_key(i, key, len, ieee->crypt->priv);
+		if (first) {
+			printk(KERN_INFO "%s: Setting index to %d\n",
+			       ieee->dev->name, i);
+			ieee->crypt->ops->set_key_idx(i, ieee->crypt->priv);
+		}
+	} else {
+		if (ieee->crypt->ops->set_key_idx(i, ieee->crypt->priv) < 0)
+			return -EINVAL; /* keyidx not valid */
+	}
+
+ done:
+	ieee->open_wep = erq->flags & IW_ENCODE_OPEN;
+
+	if (ieee80211_set_encryption(ieee)) {
+		printk(KERN_DEBUG "%s: set_encryption failed\n", dev->name);
+		return -EINVAL;
+	}
+
+	/* Do not reset port if card is in Managed mode since resetting will
+	 * generate new IEEE 802.11 authentication which may end up in looping
+	 * with IEEE 802.1X.  If your hardware requires a reset after WEP
+	 * configuration (for example... Prism2), implement the reset_port in 
+	 * the callbacks structures used to initialize the 802.11 stack. */
+	if (ieee->reset_on_keychange &&
+	    ieee->iw_mode != IW_MODE_INFRA && 
+	    ieee->func->reset_port &&
+	    ieee->func->reset_port(dev)) {
+		printk(KERN_DEBUG "%s: reset_port failed\n", dev->name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
+			   struct iw_request_info *info, 
+			   union iwreq_data *wrqu, char *key)
+{
+	struct iw_point *erq = &(wrqu->encoding);
+	int i, len;
+
+	if (ieee->crypt == NULL || ieee->crypt->ops == NULL) {
+		erq->length = 0;
+		erq->flags = IW_ENCODE_DISABLED;
+		return 0;
+	}
+
+	if (strcmp(ieee->crypt->ops->name, "WEP") != 0) {
+		/* only WEP is supported with wireless extensions, so just
+		 * report that encryption is used */
+		erq->length = 0;
+		erq->flags = IW_ENCODE_ENABLED;
+		return 0;
+	}
+
+	i = erq->flags & IW_ENCODE_INDEX;
+	if (i < 1 || i > 4)
+		i = ieee->crypt->ops->get_key_idx(ieee->crypt->priv);
+	else
+		i--;
+	if (i < 0 || i >= WEP_KEYS)
+		return -EINVAL;
+
+	erq->flags = i + 1;
+
+	len = ieee->crypt->ops->get_key(i, key, WEP_KEY_LEN,
+					ieee->crypt->priv);
+	erq->length = (len >= 0 ? len : 0);
+
+	printk(KERN_INFO "%s: Key %d %08X%08X len %d\n", 
+	       ieee->dev->name, i, ((u32*)key)[0], ((u32*)key)[1], len);
+
+	if (ieee->host_encrypt)
+		erq->flags |= IW_ENCODE_ENABLED;
+	else
+		erq->flags |= IW_ENCODE_DISABLED;
+	if (ieee->open_wep)
+		erq->flags |= IW_ENCODE_OPEN;
+	else
+		erq->flags |= IW_ENCODE_RESTRICTED;
+
+	return 0;
+}
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,1226 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_H
+#define _IPW2100_H
+
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+#include <linux/socket.h>
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+#include <linux/version.h>
+
+#ifdef CONFIG_IPW2100_WEP
+#include "ieee80211.h"
+#endif /* CONFIG_IPW2100_WEP */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define work_struct tq_struct
+#define schedule_work schedule_task
+#define INIT_WORK INIT_TQUEUE
+#endif
+
+struct ipw2100_priv;
+struct ipw2100_hw_packet;
+
+#include "ipw2100_frag.h"
+
+
+#ifdef CONFIG_IPW2100_DEBUG
+#define IPW2100_DEBUG(level, fmt, args...) \
+do { if (ipw2100_debug_level & level) \
+  printk(KERN_DEBUG "ipw2100: %c %s " fmt, \
+         in_interrupt() ? 'I' : 'U', __FUNCTION__, ## args); } while (0) 
+extern unsigned long ipw2100_debug_level;
+#else
+#define IPW2100_DEBUG(level, fmt, args...) do {} while (0);
+#endif /* CONFIG_IPW2100_DEBUG */
+
+#define IPW2100_DL_UNINIT    0x80000000
+#define IPW2100_DL_NONE      0x00000000
+#define IPW2100_DL_ALL       0x7FFFFFFF
+
+/*
+ * To use the debug system;
+ *
+ * If you are defining a new debug classification, simply add it to the #define
+ * list here in the form of:
+ *
+ * #define IPW2100_DL_xxxx VALUE
+ * 
+ * shifting value to the left one bit from the previous entry.  xxxx should be
+ * the name of the classification (for example, WEP)
+ *
+ * You then need to either add a IPW2100_xxxx_DEBUG() macro definition for your
+ * classification, or use IPW2100_DEBUG(IPW2100_DL_xxxx, ...) whenever you want
+ * to send output to that classification.
+ *
+ * To add your debug level to the list of levels seen when you perform
+ *
+ * % cat /proc/ipw2100/debug_level
+ *
+ * you simply need to add your entry to the ipw2100_debug_levels array.
+ *
+ * If you do not see debug_level in /proc/ipw2100 then you do not have 
+ * CONFIG_IPW2100_DEBUG defined in your kernel configuration
+ *
+ */
+
+#define IPW2100_DL_ERROR         0x00000001
+#define IPW2100_DL_WARNING       0x00000002
+#define IPW2100_DL_INFO          0x00000004
+#define IPW2100_DL_WIRELESS_EXT  0x00000008
+#define IPW2100_DL_ISR           0x00000010
+#define IPW2100_DL_SCAN          0x00000020
+#define IPW2100_DL_STATUS        0x00000040
+#define IPW2100_DL_TRACE         0x00000080
+#define IPW2100_DL_RX            0x00000100
+#define IPW2100_DL_TX            0x00000200
+#define IPW2100_DL_MANAGE        0x00000400
+#define IPW2100_DL_WEP           0x00000800
+#define IPW2100_DL_FW_COMMAND    0x00001000
+#define IPW2100_DL_FRAG          0x00002000
+#define IPW2100_DL_FW            0x00004000
+#define IPW2100_DL_RF_KILL       0x00008000
+#define IPW2100_DL_IO		 0x00010000
+
+#ifdef CONFIG_IPW2100_DEBUG 
+#ifdef IPW2100_MAIN
+struct ipw2100_dl {
+	const char *name;
+	unsigned long value;
+};
+#define IPW2100_DL(v) { .name = #v, .value = v }
+
+const struct ipw2100_dl ipw2100_debug_levels[] = {
+	IPW2100_DL(IPW2100_DL_ERROR),
+	IPW2100_DL(IPW2100_DL_WARNING),
+	IPW2100_DL(IPW2100_DL_INFO),
+	IPW2100_DL(IPW2100_DL_WIRELESS_EXT),
+	IPW2100_DL(IPW2100_DL_ISR),
+	IPW2100_DL(IPW2100_DL_SCAN),
+	IPW2100_DL(IPW2100_DL_STATUS),
+	IPW2100_DL(IPW2100_DL_TRACE),
+	IPW2100_DL(IPW2100_DL_RX),
+	IPW2100_DL(IPW2100_DL_TX),
+	IPW2100_DL(IPW2100_DL_MANAGE),
+	IPW2100_DL(IPW2100_DL_WEP),
+	IPW2100_DL(IPW2100_DL_FW_COMMAND),
+	IPW2100_DL(IPW2100_DL_FRAG),
+	IPW2100_DL(IPW2100_DL_FW),
+	IPW2100_DL(IPW2100_DL_RF_KILL),
+	IPW2100_DL(IPW2100_DL_IO),
+};
+#endif
+#endif
+
+#define IPW2100_DEBUG_ERROR(f, a...)   IPW2100_DEBUG(IPW2100_DL_ERROR, f, ## a)
+#define IPW2100_DEBUG_WARNING(f, a...) IPW2100_DEBUG(IPW2100_DL_WARNING, f, ## a)
+#define IPW2100_DEBUG_INFO(f, a...)    IPW2100_DEBUG(IPW2100_DL_INFO, f, ## a)
+
+
+#define IPW2100_DEBUG_WX(f, a...)     IPW2100_DEBUG(IPW2100_DL_WIRELESS_EXT, f, ## a)
+#define IPW2100_DEBUG_SCAN(f, a...)   IPW2100_DEBUG(IPW2100_DL_SCAN, f, ## a)
+#define IPW2100_DEBUG_STATUS(f, a...) IPW2100_DEBUG(IPW2100_DL_STATUS, f, ## a)
+#define IPW2100_DEBUG_TRACE(f, a...)  IPW2100_DEBUG(IPW2100_DL_TRACE, f, ## a)
+#define IPW2100_DEBUG_RX(f, a...)     IPW2100_DEBUG(IPW2100_DL_RX, f, ## a)
+#define IPW2100_DEBUG_TX(f, a...)     IPW2100_DEBUG(IPW2100_DL_TX, f, ## a)
+#define IPW2100_DEBUG_ISR(f, a...)    IPW2100_DEBUG(IPW2100_DL_ISR, f, ## a)
+#define IPW2100_DEBUG_MANAGEMENT(f, a...) IPW2100_DEBUG(IPW2100_DL_MANAGE, f, ## a)
+#define IPW2100_DEBUG_WEP(f, a...)    IPW2100_DEBUG(IPW2100_DL_WEP, f, ## a)
+#define IPW2100_DEBUG_FW_COMMAND(f, a...) IPW2100_DEBUG(IPW2100_DL_FW_COMMAND, f, ## a)
+#define IPW2100_DEBUG_FRAG(f, a...) IPW2100_DEBUG(IPW2100_DL_FRAG, f, ## a)
+#define IPW2100_DEBUG_FW(f, a...) IPW2100_DEBUG(IPW2100_DL_FW, f, ## a)
+#define IPW2100_DEBUG_RF_KILL(f, a...) IPW2100_DEBUG(IPW2100_DL_RF_KILL, f, ## a)
+#define IPW2100_DEBUG_IO(f, a...) IPW2100_DEBUG(IPW2100_DL_IO, f, ## a)
+
+
+#define VERIFY(f) \
+{ \
+  int status = 0; \
+  status = f; \
+  if(status) \
+     return status; \
+}
+
+enum {
+	STATE_DISABLED = 1,
+	STATE_ENABLED = 0
+};
+
+struct ssid_context {
+	char ssid[IW_ESSID_MAX_SIZE + 1];
+	unsigned char bssid[ETH_ALEN];
+	int port_type;
+	int channel;
+
+};
+
+extern const char *port_type_str[];
+extern const char *band_str[];
+
+#define NUMBER_OF_BD_PER_COMMAND_PACKET		1
+#define NUMBER_OF_BD_PER_DATA_PACKET		2
+
+#define NUMBER_OF_OVERHEAD_BDS_PER_PACKETR	2
+#define NUMBER_OF_BDS_TO_LEAVE_FOR_COMMANDS	1
+
+#define REQUIRED_SPACE_IN_RING_FOR_COMMAND_PACKET \
+    (IPW_BD_QUEUE_W_R_MIN_SPARE + NUMBER_OF_BD_PER_COMMAND_PACKET)
+
+struct bd_status {
+	union {
+		struct { u8 nlf:1, txType:2, intEnabled:1, reserved:4; };
+		u8 field;
+	};
+} __attribute__ ((packed));
+
+#define	IPW_BUFDESC_LAST_FRAG 0
+
+struct ipw2100_bd {
+	u32 host_addr;
+	u32 buf_length;
+	struct bd_status status;
+        /* number of fragments for frame (should be set only for 
+	 * 1st TBD) */
+	u8 num_fragments;	
+	u8 reserved[6];
+} __attribute__ ((packed));
+
+#define IPW_BD_QUEUE_LENGTH(n) (1<<n)
+#define IPW_BD_ALIGNMENT(L)    (L*sizeof(struct ipw2100_bd))
+
+#define IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT	0x01
+#define IPW_BD_STATUS_TX_FRAME_COMMAND		0x02
+#define IPW_BD_STATUS_TX_FRAME_802_11	        0x04
+#define IPW_BD_STATUS_TX_INTERRUPT_ENABLE	        0x08
+#define IPW_BD_STATUS_TX_FRAME_802_3              0x00
+
+struct ipw2100_bd_queue {
+	/* driver (virtual) pointer to queue */
+	struct ipw2100_bd *drv;
+
+	/* firmware (physical) pointer to queue */
+	dma_addr_t nic;
+
+	/* Length of phy memory allocated for BDs */
+	u32 size;
+
+	/* Number of BDs in queue (and in array) */
+	u32 entries;
+
+	/* Number of available BDs (invalid for NIC BDs) */
+	u32 available;
+
+	/* Offset of oldest used BD in array (next one to 
+	 * check for completion) */
+	u32 oldest;
+
+	/* Offset of next available (unused) BD */
+	u32 next;
+};
+
+#define STATUS_TYPE_MASK	0x0000000f
+#define COMMAND_STATUS_VAL	0
+#define STATUS_CHANGE_VAL	1
+#define P80211_DATA_VAL 	2
+#define P8023_DATA_VAL		3
+#define HOST_NOTIFICATION_VAL	4
+
+#define IPW2100_RSSI_TO_DBM (-98)
+
+struct ipw2100_status {
+	u32 frame_size;
+	u16 status_fields;
+	u8 flags;
+#define IPW_STATUS_FLAG_DECRYPTED	(1)
+#define IPW_STATUS_FLAG_WEP_ENCRYPTED	(1<<1)
+	u8 rssi;
+} __attribute__ ((packed));
+
+struct ipw2100_status_queue {
+	/* driver (virtual) pointer to queue */
+	struct ipw2100_status *drv;
+
+	/* firmware (physical) pointer to queue */
+	dma_addr_t nic;
+
+	/* Length of phy memory allocated for BDs */
+	u32 size;
+};
+
+enum {
+	BSS = 1,
+	IBSS,
+	MONITOR
+};
+
+/**
+ * @struct _tx_cmd - HWCommand
+ * @brief H/W command structure.
+ */
+#define HOST_COMMAND_PARAMS_REG_LEN				100
+#define CMD_STATUS_PARAMS_REG_LEN 			3
+
+struct ipw2100_cmd_header {
+	u32 host_command_reg;
+	u32 host_command_reg1;
+	u32 sequence;
+	u32 host_command_len_reg;
+	u32 host_command_params_reg[HOST_COMMAND_PARAMS_REG_LEN];
+	u32 cmd_status_reg;
+	u32 cmd_status_params_reg[CMD_STATUS_PARAMS_REG_LEN];
+	u32 rxq_base_ptr;
+	u32 rxq_next_ptr;
+	u32 rxq_host_ptr;
+	u32 txq_base_ptr;
+	u32 txq_next_ptr;
+	u32 txq_host_ptr;
+	u32 tx_status_reg;
+	u32 reserved;
+	u32 status_change_reg;
+	u32 reserved1[3];
+	u32 *ordinal1_ptr;
+	u32 *ordinal2_ptr;
+} __attribute__ ((packed));
+
+struct ipw2100_data_header {
+	u32 host_command_reg;	
+	u32 host_command_reg1;
+	u8 encrypted;	// BOOLEAN in win! TRUE if frame is enc by driver
+	u8 needs_encryption;	// BOOLEAN in win! TRUE if frma need to be enc in NIC
+	u8 wep_index;		// 0 no key, 1-4 key index, 0xff immediate key
+	u8 key_size;	// 0 no imm key, 0x5 64bit encr, 0xd 128bit encr, 0x10 128bit encr and 128bit IV
+	u8 key[16];
+	u8 reserved[10];	// f/w reserved
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+	u16 fragment_size;
+} __attribute__ ((packed));
+
+// Host command data structure
+struct host_command {
+	u32 host_command;		// COMMAND ID
+	u32 host_command1;		// COMMAND ID
+	u32 host_command_sequence;	// UNIQUE COMMAND NUMBER (ID)
+	u32 host_command_length;	// LENGTH
+	u32 host_command_parameters[HOST_COMMAND_PARAMS_REG_LEN];	// COMMAND PARAMETERS
+} __attribute__ ((packed));
+
+
+typedef enum {
+	POWER_ON_RESET,
+	EXIT_POWER_DOWN_RESET,
+	SW_RESET,
+	EEPROM_RW,
+	SW_RE_INIT
+} ipw2100_reset_event;
+
+enum {
+	COMMAND = 0xCAFE,
+	DATA,
+	RX
+};
+
+struct ipw2100_hw_packet {
+	int type;
+	int index;
+	union {
+		struct { /* COMMAND */
+			struct ipw2100_cmd_header* cmd;
+			dma_addr_t cmd_phys;
+		};
+		struct { /* DATA */
+			struct ipw2100_data_header* data;
+			dma_addr_t data_phys;
+			dma_addr_t skb_phys;
+		};
+
+		struct { /* RX */
+			struct ipw2100_rx_packet *rxp;
+			dma_addr_t dma_addr;
+		};
+	};
+	struct sk_buff *skb;
+	int jiffy_start;
+
+	struct list_head list;
+};
+
+#define DEFAULT_RTS_THRESHOLD     2304U
+#define DEFAULT_BEACON_INTERVAL   100U
+#define	DEFAULT_SHORT_RETRY_LIMIT 7U
+#define	DEFAULT_LONG_RETRY_LIMIT  4U
+
+struct ipw2100_ordinals {
+	u32 table1_addr;
+	u32 table2_addr;
+	u32 table1_size;
+	u32 table2_size;
+};
+
+/* Host Notification header */
+struct ipw2100_notification {
+	u32 hnhdr_subtype;	/* type of host notification */
+	u32 hnhdr_size;		/* size in bytes of data 
+				   or number of entries, if table.
+				   Does NOT include header */
+} __attribute__ ((packed));
+
+
+/* SWEEP TABLE ENTRIES NUBMER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+#define MAX_RATES_LENGTH                  ((u8)8)
+#define MAX_BEACON_COUNT                  128
+
+#define SSID_LENGTH                       ((u8)32)
+#define CRC_LENGTH                 4U
+
+#define SSID_CAPABILITY_BSS        0x0001  // Communicating in BSS Mode (Bit 0)
+#define SSID_CAPABILITY_IBSS       0x0002  // Communicating in IBSS Mode (Bit 1)
+#define SSID_CAPABILITY_POWER      0x0004  // Supports PS Mode (Bit 3)
+#define SSID_CAPABILITY_ENCRYPT    0x0010  // Requires Encryption (Bit 4)
+#define PREAMBLE_CAPABILITY_SHORT  0x0020  // Uses Short Preamble (Bit 5)
+
+#define SSID_11B_RATE_1MB          0x0001
+#define SSID_11B_RATE_2MB          0x0002
+#define SSID_11B_RATE_5MB          0x0004
+#define SSID_11B_RATE_11MB         0x0008
+#define SSID_11B_RATE_22MB         0x0010
+
+#ifndef CONFIG_IPW2100_WEP
+/* Structure used by de-fragmantation*/
+#define MAX_DEFRAG_RX        5
+
+struct defrag_info {
+	u32 seq_num;
+	u16 num_of_frags;
+	u16 free_space;
+	struct sk_buff *skb;
+	struct timer_list defrag_timer;
+	struct ipw2100_priv *priv;
+	u8 valid;
+	struct list_head list;
+};
+#endif
+
+struct ipw2100_beacon;
+
+#define MAX_KEY_SIZE	16
+#define	MAX_KEYS	8
+
+#define IPW2100_WEP_DROP_CLEAR (1<<1)
+#define IPW2100_WEP_ENABLE     (1)
+
+#define NONE_CIPHER   0x00000001
+#define WEP40_CIPHER  0x00000002
+#define WEP104_CIPHER 0x00000020
+#define	AUTH_OPEN     1
+#define	AUTH_SHARED   2
+
+struct ipw2100_priv {
+#ifdef CONFIG_IPW2100_WEP
+	struct ieee80211_device ieee;
+#endif /* CONFIG_IPW2100_WEP */
+	int reset_pending; /* 1 if a reset has been scheduled or is running */
+	int open;
+	int stopped;
+	int disabled;
+	int phy_off;
+	int connected;
+	int been_powered; /* 1 if HW has been powered */
+	int fatal_error;
+	int rf_kill;
+	int eeprom_version;
+	int firmware_version;
+	int irq_enabled; /* 1 when IRQ on 0 when off */
+	unsigned long hw_features;
+	int resets;
+	int hangs;
+	u32 last_rtc;
+
+	struct timer_list hang_check_timer;
+	int stop_hang_check; /* Set 1 when shutting down to kill timer */
+	struct timer_list rf_switch_timer;
+	int stop_rf_check; /* Set 1 when shutting down to kill timer */
+ 
+	/* WEP data */
+	int authentication; /* AUTH_{OPEN,SHARED} */
+	int key_on;
+	int key_open;
+	int key_size[MAX_KEYS];
+	char key_table[MAX_KEYS][MAX_KEY_SIZE];
+	int key_current;
+
+	int message_sending;
+	int messages_sent;
+	
+
+	int short_retry_limit;
+	int long_retry_limit;
+
+	int rts_threshold;
+	u32 frag_threshold;
+	u8 frag_enabled;
+	int in_isr;
+
+	int tx_power;
+	u32 beacon_interval;
+	int port_type;
+
+	char nick[IW_ESSID_MAX_SIZE + 1];
+
+	struct ssid_context *ctx;
+	struct ssid_context active_ctx;
+	struct ssid_context backup_ctx;
+
+	struct ipw2100_status_queue status_queue;
+
+	struct ipw2100_bd_queue rx_queue;
+	struct ipw2100_bd_queue tx_queue;
+	struct ipw2100_hw_packet *rx_buffers;
+
+	struct list_head beacon_free_list;
+	struct list_head beacon_list;
+	struct ipw2100_beacon *beacons;
+
+	struct list_head fw_pend_list;
+
+	struct list_head msg_free_list;
+	struct list_head msg_pend_list;
+	struct ipw2100_hw_packet *msg_buffers;
+
+	struct list_head tx_free_list;
+	struct list_head tx_pend_list;
+	struct ipw2100_hw_packet *tx_buffers;
+
+	struct ipw2100_ordinals ordinals;
+
+	struct pci_dev *pdev;
+
+	struct proc_dir_entry *dir_dev;
+
+	struct net_device *ndev;
+	struct net_device_stats stats;
+	struct iw_statistics wstats;
+
+	struct tasklet_struct irq_tasklet;
+
+	struct work_struct reset_work;
+	struct work_struct tx_work;
+	
+#ifndef CONFIG_IPW2100_WEP
+	struct defrag_info *defrag_pool;
+	struct list_head defrag_list;
+	struct list_head defrag_free_list;
+	u32 num_of_defrag_rx;	
+	unsigned long defrag_timeout;
+#endif
+
+	u32 interrupts;
+	int tx_interrupts;
+	int rx_interrupts;
+	
+
+	u32 proc_cardmemaddr;
+
+	spinlock_t low_lock;
+
+	wait_queue_head_t wait_command_queue;
+#ifdef CONFIG_PM
+	u32 pm_state[16];
+#endif
+};
+
+/*********************************************************
+ * Host Command -> From Driver to FW
+ *********************************************************/
+
+/**
+ * Host command identifiers
+ */
+#define HOST_COMPLETE           2
+#define SYSTEM_CONFIG           6
+#define SSID                    8
+#define MANDATORY_BSSID         9
+#define AUTHENTICATION_TYPE    10
+#define ADAPTER_ADDRESS        11
+#define PORT_TYPE              12
+#define INTERNATIONAL_MODE     13
+#define CHANNEL                14
+#define RTS_THRESHOLD          15
+#define FRAG_THRESHOLD         16
+#define POWER_MODE             17
+#define TX_RATES               18
+#define BASIC_TX_RATES         19
+#define WEP_KEY_INFO           20
+#define WEP_KEY_INDEX          25
+#define WEP_FLAGS              26
+#define ADD_MULTICAST          27
+#define CLEAR_ALL_MULTICAST    28
+#define BEACON_INTERVAL        29
+#define ATIM_WINDOW            30
+#define CLEAR_STATISTICS       31
+#define SEND		       33
+#define TX_POWER_INDEX         36
+#define BROADCAST_SCAN         43
+#define CARD_DISABLE           44
+#define PREFERRED_BSSID        45
+#define SET_SCAN_OPTIONS       46
+#define SCAN_DWELL_TIME        47
+#define SWEEP_TABLE            48
+#define AP_OR_STATION_TABLE    49
+#define GROUP_ORDINALS         50
+#define SHORT_RETRY_LIMIT      51
+#define LONG_RETRY_LIMIT       52
+
+#define HOST_PRE_POWER_DOWN    58
+#define CARD_DISABLE_PHY_OFF   61
+#define MSDU_TX_RATES          62
+
+
+// Rogue AP Detection 
+#define SET_STATION_STAT_BITS      64
+#define CLEAR_STATIONS_STAT_BITS   65
+#define LEAP_ROGUE_MODE            66	//TODO tbw replaced by CFG_LEAP_ROGUE_AP
+#define SET_SECURITY_INFORMATION   67
+#define DISASSOCIATION_BSSID	   68
+#define SET_WPA_ASS_IE             69
+
+
+
+// system configuration bit mask:
+//#define CFG_ANTENNA_SETTING           0x03
+//#define CFG_ANTENNA_A                 0x01
+//#define CFG_ANTENNA_B                 0x02
+#define CFG_PROMISCUOUS         0x00004
+//#define CFG_TX_STATUS_ENABLE    0x00008
+#define CFG_PREAMBLE_LEN        0x00010
+#define CFG_IBSS_AUTO_START     0x00020
+//#define CFG_KERBEROS_ENABLE     0x00040
+#define CFG_LOOPBACK            0x00100
+//#define CFG_WNMP_PING_PASS      0x00200
+//#define CFG_DEBUG_ENABLE        0x00400
+#define CFG_ANSWER_BCSSID_PROBE 0x00800
+//#define CFG_BT_PRIORITY         0x01000
+#define CFG_BT_SIDEBAND_SIGNAL	0x02000
+#define CFG_802_1x_ENABLE       0x04000
+#define CFG_BSS_MASK		0x08000
+#define CFG_IBSS_MASK		0x10000
+//#define CFG_DYNAMIC_CW          0x10000 
+
+
+
+#define IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND			0x200
+#define IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND  	IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0D80
+
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x00)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x04)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x08)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0c)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x10)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x14)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x18)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x1c)
+#define IPW_MEM_HOST_SHARED_RX_BD_BASE                  (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x40)
+#define IPW_MEM_HOST_SHARED_RX_STATUS_BASE              (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x44)
+#define IPW_MEM_HOST_SHARED_RX_BD_SIZE                  (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x48)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x80)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x84)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x88)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x8c)
+#define IPW_MEM_HOST_SHARED_RX_READ_INDEX               (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0xa0)
+
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_BD_BASE(QueueNum) \
+    (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + (QueueNum<<3))
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_BD_SIZE(QueueNum) \
+    (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0004+(QueueNum<<3))
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(QueueNum) \
+    (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0080+(QueueNum<<2))
+
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x00)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x04)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x08)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x0c)
+#define IPW_MEM_HOST_SHARED_RX_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x20)
+#define IPW_MEM_HOST_SHARED_SLAVE_MODE_INT_REGISTER \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x78)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(QueueNum) \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + (QueueNum<<2))
+
+#define IPW_MEM_HOST_SHARED_ORDINALS_TABLE_1   (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x180)
+#define IPW_MEM_HOST_SHARED_ORDINALS_TABLE_2   (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x184)
+
+#define IPW2100_INTA_TX_TRANSFER               (0x00000001)	// Bit 0 (LSB)
+#define IPW2100_INTA_RX_TRANSFER               (0x00000002)	// Bit 1
+#define IPW2100_INTA_TX_COMPLETE	       (0x00000004)	// Bit 2
+#define IPW2100_INTA_EVENT_INTERRUPT           (0x00000008)     // Bit 3 
+#define IPW2100_INTA_STATUS_CHANGE             (0x00000010)	// Bit 4
+#define IPW2100_INTA_BEACON_PERIOD_EXPIRED     (0x00000020)	// Bit 5
+#define IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE  (0x00010000)	// Bit 16
+#define IPW2100_INTA_FW_INIT_DONE              (0x01000000)	// Bit 24
+#define IPW2100_INTA_FW_CALIBRATION_CALC       (0x02000000)	// Bit 25
+#define IPW2100_INTA_FATAL_ERROR               (0x40000000)	// Bit 30
+#define IPW2100_INTA_PARITY_ERROR              (0x80000000)	// Bit 31 (MSB)
+
+#define IPW_AUX_HOST_RESET_REG_PRINCETON_RESET              (0x00000001)	// Bit 0 (LSB)
+#define IPW_AUX_HOST_RESET_REG_FORCE_NMI                    (0x00000002)	// Bit 1
+#define IPW_AUX_HOST_RESET_REG_PCI_HOST_CLUSTER_FATAL_NMI   (0x00000004)	// Bit 2
+#define IPW_AUX_HOST_RESET_REG_CORE_FATAL_NMI               (0x00000008)	// Bit 3
+#define IPW_AUX_HOST_RESET_REG_SW_RESET                     (0x00000080)	// Bit 7
+#define IPW_AUX_HOST_RESET_REG_MASTER_DISABLED              (0x00000100)	// Bit 8
+#define IPW_AUX_HOST_RESET_REG_STOP_MASTER                  (0x00000200)	// Bit 9
+
+#define IPW_AUX_HOST_GP_CNTRL_BIT_CLOCK_READY           (0x00000001)	// Bit 0 (LSB)
+#define IPW_AUX_HOST_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY   (0x00000002)	// Bit 1
+#define IPW_AUX_HOST_GP_CNTRL_BIT_INIT_DONE             (0x00000004)	// Bit 2
+#define IPW_AUX_HOST_GP_CNTRL_BITS_SYS_CONFIG           (0x000007c0)	// Bits 6-10
+#define IPW_AUX_HOST_GP_CNTRL_BIT_BUS_TYPE              (0x00000200)	// Bit 9
+#define IPW_AUX_HOST_GP_CNTRL_BIT_BAR0_BLOCK_SIZE       (0x00000400)	// Bit 10
+#define IPW_AUX_HOST_GP_CNTRL_BIT_USB_MODE              (0x20000000)	// Bit 29
+#define IPW_AUX_HOST_GP_CNTRL_BIT_HOST_FORCES_SYS_CLK   (0x40000000)	// Bit 30
+#define IPW_AUX_HOST_GP_CNTRL_BIT_FW_FORCES_SYS_CLK     (0x80000000)	// Bit 31 (MSB)
+
+#define IPW_BIT_GPIO_GPIO1_MASK         0x0000000C
+#define IPW_BIT_GPIO_GPIO3_MASK         0x000000C0
+#define IPW_BIT_GPIO_GPIO1_ENABLE       0x00000008
+#define IPW_BIT_GPIO_RF_KILL            0x00010000
+
+#define IPW_BIT_GPIO_LED_OFF            0x00002000	// Bit 13 = 1
+
+#define IPW_REG_DOMAIN_0_OFFSET 	0x0000
+#define IPW_REG_DOMAIN_1_OFFSET 	IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND
+
+#define IPW_REG_INTA			IPW_REG_DOMAIN_0_OFFSET + 0x0008
+#define IPW_REG_INTA_MASK		IPW_REG_DOMAIN_0_OFFSET + 0x000C
+#define IPW_REG_INDIRECT_ACCESS_ADDRESS	IPW_REG_DOMAIN_0_OFFSET + 0x0010
+#define IPW_REG_INDIRECT_ACCESS_DATA	IPW_REG_DOMAIN_0_OFFSET + 0x0014
+#define IPW_REG_AUTOINCREMENT_ADDRESS	IPW_REG_DOMAIN_0_OFFSET + 0x0018
+#define IPW_REG_AUTOINCREMENT_DATA	IPW_REG_DOMAIN_0_OFFSET + 0x001C
+#define IPW_REG_RESET_REG		IPW_REG_DOMAIN_0_OFFSET + 0x0020
+#define IPW_REG_GP_CNTRL		IPW_REG_DOMAIN_0_OFFSET + 0x0024
+#define IPW_REG_GPIO			IPW_REG_DOMAIN_0_OFFSET + 0x0030
+#define IPW_REG_FW_TYPE                 IPW_REG_DOMAIN_1_OFFSET + 0x0188
+#define IPW_REG_FW_VERSION 		IPW_REG_DOMAIN_1_OFFSET + 0x018C
+#define IPW_REG_FW_COMPATABILITY_VERSION IPW_REG_DOMAIN_1_OFFSET + 0x0190
+
+#define IPW_REG_INDIRECT_ADDR_MASK	0x00FFFFFC
+
+#define IPW_INTERRUPT_MASK		0xC1010013
+
+#define IPW2100_CONTROL_REG             0x220000
+#define IPW2100_CONTROL_PHY_OFF         0x8
+
+#define IPW2100_COMMAND			0x00300004
+#define IPW2100_COMMAND_PHY_ON		0x0
+#define IPW2100_COMMAND_PHY_OFF		0x1
+
+/* in DEBUG_AREA, values of memory always 0xd55555d5 */
+#define IPW_REG_DOA_DEBUG_AREA_START    IPW_REG_DOMAIN_0_OFFSET + 0x0090
+#define IPW_REG_DOA_DEBUG_AREA_END      IPW_REG_DOMAIN_0_OFFSET + 0x00FF
+#define IPW_DATA_DOA_DEBUG_VALUE        0xd55555d5
+
+#define IPW_INTERNAL_REGISTER_HALT_AND_RESET	0x003000e0
+
+#define IPW_WAIT_CLOCK_STABILIZATION_DELAY	    50	// micro seconds
+#define IPW_WAIT_RESET_ARC_COMPLETE_DELAY	    10	// micro seconds
+#define IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY 10	// micro seconds
+
+// BD ring queue read/write difference
+#define IPW_BD_QUEUE_W_R_MIN_SPARE 2	
+
+#define IPW_CACHE_LINE_LENGTH_DEFAULT		    0x80
+
+#define IPW_CARD_DISABLE_COMPLETE_WAIT		    100	// 100 milli
+#define IPW_CARD_DISABLE_PHY_OFF_COMPLETE_WAIT	    100	// 100 milli
+#define IPW_PREPARE_POWER_DOWN_COMPLETE_WAIT	    100	// 100 milli
+
+
+#define MANAGMENT_802_11_PACKET_TYPE		     0
+#define CONTROL_802_11_PACKET_TYPE		     1
+#define DATA_802_11_PACKET_TYPE			     2
+
+#define ASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE   1
+#define REASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE 3
+#define PROBE_RESPONSE_802_11_PACKET_SUBTYPE         5
+#define BEACON_802_11_PACKET_SUBTYPE		     8
+
+#define IPW_HEADER_802_11_SIZE			\
+        sizeof(struct ipw2100_802_11_header)
+#define IPW_MAX_802_11_PAYLOAD_LENGTH		2312
+#define IPW_MAX_ACCEPTABLE_TX_FRAME_LENGTH	1536
+#define IPW_MIN_ACCEPTABLE_RX_FRAME_LENGTH	60
+#define IPW_MAX_ACCEPTABLE_RX_FRAME_LENGTH \
+	(IPW_MAX_ACCEPTABLE_TX_FRAME_LENGTH + IPW_HEADER_802_11_SIZE - \
+        sizeof(struct ethhdr))
+
+#define IPW_RX_NIC_BUFFER_LENGTH \
+        (IPW_MAX_802_11_PAYLOAD_LENGTH + IPW_HEADER_802_11_SIZE)
+
+#define IPW_802_11_PAYLOAD_OFFSET \
+        (sizeof(struct ipw2100_802_11_header) + \
+         sizeof(struct ieee_802_11_snap_header))
+
+struct ipw2100_802_11_header {
+	union {
+		struct {
+			u8 version:2, type:2, sub_type:4;
+		};
+		u8 ctrl1;
+	};
+	union {
+		struct {
+			u8 to_ds:1, from_ds:1, flags:1, retry:1,
+			    power_mgt:1, more_data:1, wep:1, order:1;
+		};
+		u8 ctrl2;
+	};
+	u16 duration;
+	u8 address1[ETH_ALEN];
+	u8 address2[ETH_ALEN];
+	u8 address3[ETH_ALEN];
+	u16 seq_ctrl;
+} __attribute__ ((packed));
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+
+struct ipw2100_802_11_info_element_hdr {
+	u8 id;
+	u8 len;
+} __attribute__ ((packed));
+
+struct ipw2100_802_11_info_element {
+	u8 id;
+	u8 len;
+	u8 data[1];
+} __attribute__ ((packed));
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+struct ipw2100_802_11_authentication {
+	struct ipw2100_802_11_header header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	struct ipw2100_802_11_info_element info_element;
+} __attribute__ ((packed));
+
+
+struct ipw2100_802_11_probe_response {
+	struct ipw2100_802_11_header header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ipw2100_802_11_info_element info_element;
+} __attribute__ ((packed));
+
+struct ipw2100_beacon {
+	u8 bssid[ETH_ALEN];
+	u8 ssid[SSID_LENGTH];
+	u8 ssid_len;
+/*	u8 beacon[IPW_MAX_802_11_PAYLOAD_LENGTH];
+	u32 beacon_len;
+	u8 response[IPW_MAX_802_11_PAYLOAD_LENGTH];
+	u32 response_len;*/
+	s8 rssi;
+	u16 capability;
+	u8 channel;
+	u8 rates[MAX_RATES_LENGTH];
+	u8 rates_len;
+	struct list_head list;
+};
+
+struct ipw2100_rx_packet {
+	union {
+		unsigned char payload[IPW_RX_NIC_BUFFER_LENGTH];
+		struct ipw2100_802_11_header header;
+		u32 status;
+		struct ipw2100_notification notification;
+		struct ipw2100_cmd_header command;
+	};
+} __attribute__ ((packed));
+
+// Bit 0-7 are for 802.11b tx rates - .  Bit 5-7 are reserved  
+#define TX_RATE_1_MBIT              0x0001
+#define TX_RATE_2_MBIT              0x0002
+#define TX_RATE_5_5_MBIT            0x0004
+#define TX_RATE_11_MBIT             0x0008
+#define TX_RATE_MASK                0x000F
+
+#define IPW_POWER_MODE_CAM           0	//(always on)
+#define IPW_POWER_INDEX_1            1
+#define IPW_POWER_INDEX_2            2
+#define IPW_POWER_INDEX_3            3
+#define IPW_POWER_INDEX_4            4
+#define IPW_POWER_INDEX_5            5
+#define IPW_POWER_AUTOMATIC          6
+
+#define FW_SCAN_DONOT_ASSOCIATE     0x0001 // Dont Attempt to Associate after Scan
+#define FW_SCAN_PASSIVE             0x0008 // Force PASSSIVE Scan
+
+#define REG_MIN_CHANNEL             0
+#define REG_MAX_CHANNEL             14
+
+#define REG_CHANNEL_MASK            0x00003FFF
+
+#define DIVERSITY_EITHER            0	// Use both antennas
+#define DIVERSITY_ANTENNA_A         1	// Use antenna A
+#define DIVERSITY_ANTENNA_B         2	// Use antenna B
+
+
+#define HOST_COMMAND_WAIT 0
+#define HOST_COMMAND_NO_WAIT 1
+
+#define LOCK_NONE 0
+#define LOCK_DRIVER 1
+#define LOCK_FW 2
+
+#define STATUS_INIT_COMPLETE		0x0001
+#define STATUS_COUNTRY_FOUND		0x0002
+#define STATUS_ASSOCIATED		0x0004
+#define STATUS_ASSN_LOST		0x0008
+#define STATUS_ASSN_CHANGED 		0x0010
+#define STATUS_SCAN_COMPLETE		0x0020
+#define STATUS_ENTERED_PSP		0x0040
+#define STATUS_WAKEN_FROM_PSP		0x0080
+#define STATUS_RF_KILL_SWITCH		0x0100
+#define STATUS_CARD_DISABLE_COMPLETE	0x0200
+#define STATUS_PREP_PWR_DOWN_COMPLETE	0x0400
+#define STATUS_SCANNING 		0x0800	// STATUS_FW_SCAN_KEEP_ALIVE
+
+#define TYPE_SWEEP_ORD                  0x000D
+#define TYPE_IBSS_STTN_ORD              0x000E
+#define TYPE_BSS_AP_ORD                 0x000F
+#define TYPE_RAW_BEACON_ENTRY           0x0010
+#define TYPE_CALIBRATION_DATA           0x0011
+#define TYPE_ROGUE_AP_DATA              0x0012
+#define TYPE_ASSOCIATION_REQUEST	0x0013
+#define TYPE_REASSOCIATION_REQUEST	0x0014
+
+
+#define HW_FEATURE_RFKILL (0x0001)
+#define RF_KILLSWITCH_OFF (1)
+#define RF_KILLSWITCH_ON  (0)
+
+#define IPW_COMMAND_POOL_SIZE        40
+
+#define IPW_START_ORD_TAB_1			1
+#define IPW_START_ORD_TAB_2			1000
+
+#define IPW_ORD_TAB_1_ENTRY_SIZE		sizeof(u32)
+
+#define IS_ORDINAL_TABLE_ONE(mgr,id) \
+    ((id >= IPW_START_ORD_TAB_1) && (id < mgr->table1_size))
+#define IS_ORDINAL_TABLE_TWO(mgr,id) \
+    ((id >= IPW_START_ORD_TAB_2) && (id < (mgr->table2_size + IPW_START_ORD_TAB_2)))
+
+#define BSS_ID_LENGTH               6
+
+// Fixed size data: Ordinal Table 1
+typedef enum _ORDINAL_TABLE_1 {	// NS - means Not Supported by FW
+// Transmit statistics
+	IPW_ORD_STAT_TX_HOST_REQUESTS = 1,// # of requested Host Tx's (MSDU)
+	IPW_ORD_STAT_TX_HOST_COMPLETE,	// # of successful Host Tx's (MSDU)
+	IPW_ORD_STAT_TX_DIR_DATA,	// # of successful Directed Tx's (MSDU)
+
+	IPW_ORD_STAT_TX_DIR_DATA1 = 4,	// # of successful Directed Tx's (MSDU) @ 1MB
+	IPW_ORD_STAT_TX_DIR_DATA2,	// # of successful Directed Tx's (MSDU) @ 2MB
+	IPW_ORD_STAT_TX_DIR_DATA5_5,	// # of successful Directed Tx's (MSDU) @ 5_5MB
+	IPW_ORD_STAT_TX_DIR_DATA11,	// # of successful Directed Tx's (MSDU) @ 11MB
+	IPW_ORD_STAT_TX_DIR_DATA22,	// # of successful Directed Tx's (MSDU) @ 22MB
+
+	IPW_ORD_STAT_TX_NODIR_DATA1 = 13,// # of successful Non_Directed Tx's (MSDU) @ 1MB
+	IPW_ORD_STAT_TX_NODIR_DATA2,	// # of successful Non_Directed Tx's (MSDU) @ 2MB
+	IPW_ORD_STAT_TX_NODIR_DATA5_5,	// # of successful Non_Directed Tx's (MSDU) @ 5.5MB
+	IPW_ORD_STAT_TX_NODIR_DATA11,	// # of successful Non_Directed Tx's (MSDU) @ 11MB
+
+	IPW_ORD_STAT_NULL_DATA = 21,	// # of successful NULL data Tx's
+	IPW_ORD_STAT_TX_RTS,	        // # of successful Tx RTS
+	IPW_ORD_STAT_TX_CTS,	        // # of successful Tx CTS            
+	IPW_ORD_STAT_TX_ACK,	        // # of successful Tx ACK
+	IPW_ORD_STAT_TX_ASSN,	        // # of successful Association Tx's               
+	IPW_ORD_STAT_TX_ASSN_RESP,	// # of successful Association response Tx's   
+	IPW_ORD_STAT_TX_REASSN,	        // # of successful Reassociation Tx's           
+	IPW_ORD_STAT_TX_REASSN_RESP,	// # of successful Reassociation response Tx's                
+	IPW_ORD_STAT_TX_PROBE,	        // # of probes successfully transmitted 
+	IPW_ORD_STAT_TX_PROBE_RESP,	// # of probe responses successfully transmitted                
+	IPW_ORD_STAT_TX_BEACON,	        // # of tx beacon             
+	IPW_ORD_STAT_TX_ATIM,	        // # of Tx ATIM            
+	IPW_ORD_STAT_TX_DISASSN,	// # of successful Disassociation TX           
+	IPW_ORD_STAT_TX_AUTH,	        // # of successful Authentication Tx                 
+	IPW_ORD_STAT_TX_DEAUTH,	        // # of successful Deauthentication TX                
+
+	IPW_ORD_STAT_TX_TOTAL_BYTES = 41,// Total successful Tx data bytes
+	IPW_ORD_STAT_TX_RETRIES,         // # of Tx retries
+	IPW_ORD_STAT_TX_RETRY1,          // # of Tx retries at 1MBPS
+	IPW_ORD_STAT_TX_RETRY2,          // # of Tx retries at 2MBPS
+	IPW_ORD_STAT_TX_RETRY5_5,	 // # of Tx retries at 5.5MBPS
+	IPW_ORD_STAT_TX_RETRY11,	 // # of Tx retries at 11MBPS
+
+	IPW_ORD_STAT_TX_FAILURES = 51,	// # of Tx Failures
+	IPW_ORD_STAT_TX_ABORT_AT_HOP,	//NS // # of Tx's aborted at hop time
+	IPW_ORD_STAT_TX_MAX_TRIES_IN_HOP,// # of times max tries in a hop failed
+	IPW_ORD_STAT_TX_ABORT_LATE_DMA,	//NS // # of times tx aborted due to late dma setup
+	IPW_ORD_STAT_TX_ABORT_STX,	//NS // # of times backoff aborted
+	IPW_ORD_STAT_TX_DISASSN_FAIL,	// # of times disassociation failed
+	IPW_ORD_STAT_TX_ERR_CTS,         // # of missed/bad CTS frames
+	IPW_ORD_STAT_TX_BPDU,	        //NS // # of spanning tree BPDUs sent
+	IPW_ORD_STAT_TX_ERR_ACK,	// # of tx err due to acks
+
+	// Receive statistics
+	IPW_ORD_STAT_RX_HOST = 61,	// # of packets passed to host
+	IPW_ORD_STAT_RX_DIR_DATA,	// # of directed packets                
+	IPW_ORD_STAT_RX_DIR_DATA1,	// # of directed packets at 1MB            
+	IPW_ORD_STAT_RX_DIR_DATA2,	// # of directed packets at 2MB           
+	IPW_ORD_STAT_RX_DIR_DATA5_5,	// # of directed packets at 5.5MB            
+	IPW_ORD_STAT_RX_DIR_DATA11,	// # of directed packets at 11MB            
+	IPW_ORD_STAT_RX_DIR_DATA22,	// # of directed packets at 22MB            
+
+	IPW_ORD_STAT_RX_NODIR_DATA = 71,// # of nondirected packets        
+	IPW_ORD_STAT_RX_NODIR_DATA1,	// # of nondirected packets at 1MB            
+	IPW_ORD_STAT_RX_NODIR_DATA2,	// # of nondirected packets at 2MB           
+	IPW_ORD_STAT_RX_NODIR_DATA5_5,	// # of nondirected packets at 5.5MB            
+	IPW_ORD_STAT_RX_NODIR_DATA11,	// # of nondirected packets at 11MB            
+
+	IPW_ORD_STAT_RX_NULL_DATA = 80,	// # of null data rx's            
+	IPW_ORD_STAT_RX_POLL,	//NS // # of poll rx                    
+	IPW_ORD_STAT_RX_RTS,	// # of Rx RTS                
+	IPW_ORD_STAT_RX_CTS,	// # of Rx CTS                
+	IPW_ORD_STAT_RX_ACK,	// # of Rx ACK                
+	IPW_ORD_STAT_RX_CFEND,	// # of Rx CF End                
+	IPW_ORD_STAT_RX_CFEND_ACK,	// # of Rx CF End + CF Ack             
+	IPW_ORD_STAT_RX_ASSN,	// # of Association Rx's                    
+	IPW_ORD_STAT_RX_ASSN_RESP,	// # of Association response Rx's            
+	IPW_ORD_STAT_RX_REASSN,	// # of Reassociation Rx's            
+	IPW_ORD_STAT_RX_REASSN_RESP,	// # of Reassociation response Rx's            
+	IPW_ORD_STAT_RX_PROBE,	// # of probe Rx's                
+	IPW_ORD_STAT_RX_PROBE_RESP,	// # of probe response Rx's            
+	IPW_ORD_STAT_RX_BEACON,	// # of Rx beacon            
+	IPW_ORD_STAT_RX_ATIM,	// # of Rx ATIM                    
+	IPW_ORD_STAT_RX_DISASSN,	// # of disassociation Rx            
+	IPW_ORD_STAT_RX_AUTH,	// # of authentication Rx                    
+	IPW_ORD_STAT_RX_DEAUTH,	// # of deauthentication Rx            
+
+	IPW_ORD_STAT_RX_TOTAL_BYTES = 101,// Total rx data bytes received
+	IPW_ORD_STAT_RX_ERR_CRC,	 // # of packets with Rx CRC error
+	IPW_ORD_STAT_RX_ERR_CRC1,	 // # of Rx CRC errors at 1MB
+	IPW_ORD_STAT_RX_ERR_CRC2,	 // # of Rx CRC errors at 2MB
+	IPW_ORD_STAT_RX_ERR_CRC5_5,	 // # of Rx CRC errors at 5.5MB
+	IPW_ORD_STAT_RX_ERR_CRC11,	 // # of Rx CRC errors at 11MB
+
+	IPW_ORD_STAT_RX_DUPLICATE1 = 112, // # of duplicate rx packets at 1MB
+	IPW_ORD_STAT_RX_DUPLICATE2,	 // # of duplicate rx packets at 2MB
+	IPW_ORD_STAT_RX_DUPLICATE5_5,	 // # of duplicate rx packets at 5.5MB
+	IPW_ORD_STAT_RX_DUPLICATE11,	 // # of duplicate rx packets at 11MB
+	IPW_ORD_STAT_RX_DUPLICATE = 119, // # of duplicate rx packets            
+
+	IPW_ORD_PERS_DB_LOCK = 120,	// # locking fw permanent  db
+	IPW_ORD_PERS_DB_SIZE,	// # size of fw permanent  db           
+	IPW_ORD_PERS_DB_ADDR,	// # address of fw permanent  db           
+	IPW_ORD_STAT_RX_INVALID_PROTOCOL,	// # of rx frames with invalid protocol        
+	IPW_ORD_SYS_BOOT_TIME,	// # Boot time 
+	IPW_ORD_STAT_RX_NO_BUFFER,	// # of rx frames rejected due to no buffer 
+	IPW_ORD_STAT_RX_ABORT_LATE_DMA,	//NS // # of rx frames rejected due to dma setup too late    
+	IPW_ORD_STAT_RX_ABORT_AT_HOP,	//NS // # of rx frames aborted due to hop            
+	IPW_ORD_STAT_RX_MISSING_FRAG,	// # of rx frames dropped due to missing fragment            
+	IPW_ORD_STAT_RX_ORPHAN_FRAG,	// # of rx frames dropped due to non-sequential fragment        
+	IPW_ORD_STAT_RX_ORPHAN_FRAME,	// # of rx frames dropped due to unmatched 1st frame            
+	IPW_ORD_STAT_RX_FRAG_AGEOUT,	// # of rx frames dropped due to uncompleted frame        
+	IPW_ORD_STAT_RX_BAD_SSID,	//NS // Bad SSID (unused)            
+	IPW_ORD_STAT_RX_ICV_ERRORS,	// # of ICV errors during decryption        
+
+// PSP Statistics
+	IPW_ORD_STAT_PSP_SUSPENSION = 137,// # of times adapter suspended        
+	IPW_ORD_STAT_PSP_BCN_TIMEOUT,	// # of beacon timeout           
+	IPW_ORD_STAT_PSP_POLL_TIMEOUT,	// # of poll response timeouts       
+	IPW_ORD_STAT_PSP_NONDIR_TIMEOUT,// # of timeouts waiting for last broadcast/muticast pkt
+	IPW_ORD_STAT_PSP_RX_DTIMS,	// # of PSP DTIMs received
+	IPW_ORD_STAT_PSP_RX_TIMS,	// # of PSP TIMs received
+	IPW_ORD_STAT_PSP_STATION_ID,	// PSP Station ID
+
+// Association and roaming
+	IPW_ORD_LAST_ASSN_TIME = 147,	// RTC time of last association               
+	IPW_ORD_STAT_PERCENT_MISSED_BCNS,// current calculation of % missed beacons       
+	IPW_ORD_STAT_PERCENT_RETRIES,	// current calculation of % missed tx retries            
+	IPW_ORD_ASSOCIATED_AP_PTR,	// If associated, this is ptr to the associated
+	// AP table entry. set to 0 if not associated
+	IPW_ORD_AVAILABLE_AP_CNT,	// # of AP's decsribed in the AP table
+	IPW_ORD_AP_LIST_PTR,	// Ptr to list of available APs
+	IPW_ORD_STAT_AP_ASSNS,	// # of associations       
+	IPW_ORD_STAT_ASSN_FAIL,	// # of association failures       
+	IPW_ORD_STAT_ASSN_RESP_FAIL,	// # of failuresdue to response fail       
+	IPW_ORD_STAT_FULL_SCANS,	// # of full scans
+
+	IPW_ORD_CARD_DISABLED,	// # Card Disabled 
+	IPW_ORD_STAT_ROAM_INHIBIT,	// # of times roaming was inhibited due to ongoing activity       
+	IPW_FILLER_40,
+	IPW_ORD_RSSI_AT_ASSN = 160,	// RSSI of associated AP at time of association           
+	IPW_ORD_STAT_ASSN_CAUSE1,	// # of reassociations due to no tx from AP in last N
+	// hops or no probe responses in last 3 minutes           
+	IPW_ORD_STAT_ASSN_CAUSE2,	// # of reassociations due to poor tx/rx quality            
+	IPW_ORD_STAT_ASSN_CAUSE3,	// # of reassociations due to tx/rx quality with excessive 
+	// load at the AP        
+	IPW_ORD_STAT_ASSN_CAUSE4,	// # of reassociations due to AP RSSI level fell below
+	// eligible group             
+	IPW_ORD_STAT_ASSN_CAUSE5,	// # of reassociations due to load leveling            
+	IPW_ORD_STAT_ASSN_CAUSE6,	//NS // # of reassociations due to dropped by Ap            
+	IPW_FILLER_41,
+	IPW_FILLER_42,
+	IPW_FILLER_43,
+	IPW_ORD_STAT_AUTH_FAIL,	// # of times authentication failed        
+	IPW_ORD_STAT_AUTH_RESP_FAIL,	// # of times authentication response failed       
+	IPW_ORD_STATION_TABLE_CNT,	// # of entries in association table        
+
+// Other statistics
+	IPW_ORD_RSSI_AVG_CURR = 173,	// Current avg RSSI
+	IPW_ORD_STEST_RESULTS_CURR,	//NS // Current self test results word       
+	IPW_ORD_STEST_RESULTS_CUM,	//NS // Cummulative self test results word       
+	IPW_ORD_SELF_TEST_STATUS,	//NS //        
+	IPW_ORD_POWER_MGMT_MODE,	// Power mode - 0=CAM, 1=PSP       
+	IPW_ORD_POWER_MGMT_INDEX,	//NS //            
+	IPW_ORD_COUNTRY_CODE,	// IEEE country code as recv'd from beacon
+	IPW_ORD_COUNTRY_CHANNELS,	// channels suported by country           
+// IPW_ORD_COUNTRY_CHANNELS:
+// For 11b the lower 2-byte are used for channels from 1-14 
+//   and the higher 2-byte are not used.
+	IPW_ORD_RESET_CNT,	// # of adapter resets (warm)       
+	IPW_ORD_BEACON_INTERVAL,	// Beacon interval       
+
+	IPW_ORD_PRINCETON_VERSION = 184,	//NS // Princeton Version       
+	IPW_ORD_ANTENNA_DIVERSITY,	// TRUE if antenna diversity is disabled       
+	IPW_ORD_CCA_RSSI,	//NS // CCA RSSI value (factory programmed)           
+	IPW_ORD_STAT_EEPROM_UPDATE,	//NS // # of times config EEPROM updated       
+	IPW_ORD_DTIM_PERIOD,	// # of beacon intervals between DTIMs       
+	IPW_ORD_OUR_FREQ,	// current radio freq lower digits - channel ID
+
+	IPW_ORD_RTC_TIME = 190,	// current RTC time           
+	IPW_ORD_PORT_TYPE,	// operating mode       
+	IPW_ORD_CURRENT_TX_RATE,	// current tx rate
+	IPW_ORD_SUPPORTED_RATES,	// Bitmap of supported tx rates       
+	IPW_ORD_ATIM_WINDOW,	// current ATIM Window
+	IPW_ORD_BASIC_RATES,	// bitmap of basic tx rates       
+	IPW_ORD_NIC_HIGHEST_RATE,	// bitmap of basic tx rates       
+	IPW_ORD_AP_HIGHEST_RATE,	// bitmap of basic tx rates       
+	IPW_ORD_CAPABILITIES,	// Management frame capability field           
+	IPW_ORD_AUTH_TYPE,	// Type of authentication       
+	IPW_ORD_RADIO_TYPE,	// Adapter card platform type       
+	IPW_ORD_RTS_THRESHOLD = 201,	// Min length of packet after which RTS handshaking is used       
+	IPW_ORD_INT_MODE,	// International mode           
+	IPW_ORD_FRAGMENTATION_THRESHOLD,	// protocol frag threshold       
+	IPW_ORD_EEPROM_SRAM_DB_BLOCK_START_ADDRESS,	// EEPROM offset in SRAM
+	IPW_ORD_EEPROM_SRAM_DB_BLOCK_SIZE,	// EEPROM size in SRAM
+	IPW_ORD_EEPROM_SKU_CAPABILITY,	// EEPROM SKU Capability    206 =  
+	IPW_ORD_EEPROM_IBSS_11B_CHANNELS,	// EEPROM IBSS 11b channel set       
+
+	IPW_ORD_MAC_VERSION = 209,	// MAC Version       
+	IPW_ORD_MAC_REVISION,	// MAC Revision       
+	IPW_ORD_RADIO_VERSION,	// Radio Version       
+	IPW_ORD_NIC_MANF_DATE_TIME,	// MANF Date/Time STAMP
+	IPW_ORD_UCODE_VERSION,	// Ucode Version       
+	IPW_ORD_HW_RF_SWITCH_STATE = 214,	// HW RF Kill Switch State       
+} ORDINALTABLE1;
+//ENDOF TABLE1
+
+// ordinal table 2
+// Variable length data:
+#define IPW_FIRST_VARIABLE_LENGTH_ORDINAL   1001
+
+typedef enum _ORDINAL_TABLE_2 {	// NS - means Not Supported by FW
+	IPW_ORD_STAT_BASE = 1000,	// contains number of variable ORDs
+	IPW_ORD_STAT_ADAPTER_MAC = 1001,	// 6 bytes: our adapter MAC address  
+	IPW_ORD_STAT_PREFERRED_BSSID = 1002,	// 6 bytes: BSSID of the preferred AP
+	IPW_ORD_STAT_MANDATORY_BSSID = 1003,	// 6 bytes: BSSID of the mandatory AP
+	IPW_FILL_1,		//NS // 
+	IPW_ORD_STAT_COUNTRY_TEXT = 1005,	// 36 bytes: Country name text, First two bytes are Country code
+	IPW_ORD_STAT_ASSN_SSID = 1006,	// 32 bytes: ESSID String
+	IPW_ORD_STATION_TABLE = 1007,	// ? bytes: Station/AP table (via Direct SSID Scans)
+	IPW_ORD_STAT_SWEEP_TABLE = 1008,	// ? bytes: Sweep/Host Table table (via Broadcast Scans)
+	IPW_ORD_STAT_ROAM_LOG = 1009,	// ? bytes: Roaming log
+	IPW_ORD_STAT_RATE_LOG = 1010,	//NS // 0 bytes: Rate log
+	IPW_ORD_STAT_FIFO = 1011,	//NS // 0 bytes: Fifo buffer data structures
+	IPW_ORD_STAT_FW_VER_NUM = 1012,	// 14 bytes: fw version ID string as in (a.bb.ccc; "0.08.011")
+	IPW_ORD_STAT_FW_DATE = 1013,	// 14 bytes: fw date string (mmm dd yyyy; "Mar 13 2002")
+	IPW_ORD_STAT_ASSN_AP_BSSID = 1014,	// 6 bytes: MAC address of associated AP
+	IPW_ORD_STAT_DEBUG = 1015,	//NS // ? bytes:
+	IPW_ORD_STAT_NIC_BPA_NUM = 1016,	// 11 bytes: NIC BPA number in ASCII
+	IPW_ORD_STAT_UCODE_DATE = 1017,	// 5 bytes: uCode date
+	IPW_ORD_SECURITY_NGOTIATION_RESULT = 1018,
+} ORDINALTABLE2;		// NS - means Not Supported by FW
+
+#define IPW_LAST_VARIABLE_LENGTH_ORDINAL   1018
+
+extern int ipw2100_get_ordinal(struct ipw2100_priv *, u32, void *, u32 *);
+extern int ipw2100_set_channel(struct ipw2100_priv *, u32, int);
+extern int ipw2100_set_port_type(struct ipw2100_priv *, u32, int);
+extern int ipw2100_set_mandatory_bssid(struct ipw2100_priv *, u8 *, int);
+extern int ipw2100_set_essid(struct ipw2100_priv *, char *, int);
+extern int ipw2100_set_rts_threshold(struct ipw2100_priv *, u32);
+extern int ipw2100_set_fragmentation_threshold(struct ipw2100_priv *, u32, int);
+extern int ipw2100_set_short_retry(struct ipw2100_priv *, u32);
+extern int ipw2100_set_long_retry(struct ipw2100_priv *, u32);
+extern int ipw2100_start_scan(struct ipw2100_priv *priv);
+
+#endif	/* _IPW2100_H */
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,297 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+#include <linux/802_11.h>
+#include "ipw2100.h"
+#include "ipw2100_frag.h"
+
+/* Get the msdu: real payload size. */ 
+inline u32 ipw2100_msdu_frag_threshold(struct ipw2100_priv *priv)
+{
+        return priv->frag_threshold - (ETH_ALEN + CRC_LENGTH);
+}
+
+
+#ifndef CONFIG_IPW2100_WEP
+static void defrag_timeout(unsigned long arg)
+{
+	struct defrag_info *info = (struct defrag_info *)arg;
+	
+	IPW2100_DEBUG_FRAG("Fragmentation timer freeing packet sequence.\n");
+	
+	if (info->skb) {
+		/* Pull this from the live fragment list */
+		list_del(&info->list);
+
+		dev_kfree_skb_irq(info->skb);
+		info->skb = NULL;
+		info->priv->num_of_defrag_rx--;
+		info->free_space = 0;
+
+		/* Add back to the free fragment list */
+		list_add_tail(&info->list, &info->priv->defrag_free_list);
+		
+	}
+}
+
+static struct defrag_info *defrag_alloc_slot(struct ipw2100_priv *priv)
+{
+	struct defrag_info *info;
+
+	if (list_empty(&priv->defrag_free_list))
+		return NULL;
+
+	info = list_entry(priv->defrag_free_list.next, struct defrag_info, list);
+
+	/* Pull from the free fragment list */
+	list_del(priv->defrag_free_list.next);
+
+	/* Add to the live fragment list */
+	list_add_tail(&info->list, &priv->defrag_list);
+	
+	priv->num_of_defrag_rx++;
+
+	return info;
+}
+
+
+static struct defrag_info *defrag_match_info(
+	struct ipw2100_priv *priv, struct ipw2100_802_11_header *hdr, 
+	u32 seq_num, u32 frag_num)
+{
+	struct list_head *element;
+	struct defrag_info *info = NULL;
+
+	for (element = priv->defrag_list.next;
+	     element != &priv->defrag_list;
+	     element = element->next) {
+		info = list_entry(element, struct defrag_info, list);
+		if ((info->seq_num == seq_num) && 
+		    (!memcmp(info->skb->data, hdr->address1, ETH_ALEN)) &&
+		    (!memcmp(info->skb->data + ETH_ALEN, 
+			    hdr->address3, ETH_ALEN)) && 
+		    (info->num_of_frags == frag_num))
+			return info;
+	}
+
+	return NULL;
+}
+
+static void defrag_first(struct ipw2100_priv *priv, struct ipw2100_hw_packet *packet, u32 frame_size, u32 seq_num)
+{
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+	struct defrag_info *info = NULL;
+		
+	IPW2100_DEBUG_FRAG("First fragment, seq_num: %X\n", seq_num);
+	
+	info = defrag_alloc_slot(priv);
+
+	if (info==NULL) {
+		IPW2100_DEBUG_FRAG("No valid slot found for fragmented "
+				 "packet, dropped\n");
+		priv->wstats.discard.fragment++;	
+		dev_kfree_skb_irq(packet->skb);
+		return;
+	}
+	
+	info->skb = packet->skb;
+	
+	skb_put(info->skb, frame_size - IPW_802_11_PAYLOAD_OFFSET);
+	
+	memcpy(skb_push(info->skb, ETH_ALEN), &hdr->address3, ETH_ALEN);
+	memcpy(skb_push(info->skb, ETH_ALEN), &hdr->address1, ETH_ALEN);
+	
+	info->seq_num = seq_num;
+	info->num_of_frags = 1;
+	info->free_space = info->skb->end - info->skb->head;
+	
+	init_timer(&info->defrag_timer);
+	info->defrag_timer.expires = jiffies + priv->defrag_timeout;
+	info->defrag_timer.data = (unsigned long)info;
+	info->defrag_timer.function = defrag_timeout;
+	add_timer(&info->defrag_timer);
+} 
+
+
+static struct sk_buff *defrag_cont(struct ipw2100_priv *priv, 
+				   struct ipw2100_hw_packet *packet, 
+				   u32 frame_size, u32 seq_num, u32 frag_num)
+{
+	struct defrag_info *info = NULL;
+    	u32 length;	
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+	struct sk_buff *skb = NULL;
+	
+	IPW2100_DEBUG_FRAG("Non-first fragment, seq_num: %X frag_num: %X\n",
+			   seq_num, frag_num);
+
+	length = frame_size - IPW_802_11_PAYLOAD_OFFSET + 
+			sizeof(struct ieee_802_11_snap_header);
+
+	info = defrag_match_info(priv, hdr, seq_num, frag_num);
+	
+	if (info != NULL) {
+		IPW2100_DEBUG_FRAG("Found matched defrag_info\n");
+
+		if (info->free_space < length) {
+			printk(KERN_WARNING "ipw2100"
+			       ": AP sending fragment overrun.  Dropping "
+			       "%d frames.\n", info->num_of_frags);
+			priv->wstats.discard.fragment++;	
+
+			/* For consistent cleanup, we just force a timeout
+			 * expiration */
+			del_timer_sync(&info->defrag_timer);
+			defrag_timeout((unsigned long)info);
+
+		} else {
+
+			info->num_of_frags++;
+			mod_timer(&info->defrag_timer, 
+				  jiffies + priv->defrag_timeout);
+			
+			skb_push(packet->skb, 
+				 sizeof(struct ieee_802_11_snap_header));
+			memcpy(skb_put(info->skb, length), packet->skb->data, 
+			       length);
+		
+			if ((*hdr).flags == 0) {
+				
+				IPW2100_DEBUG_FRAG("Last fragment received\n");
+				
+				del_timer_sync(&info->defrag_timer);
+				
+				
+				/* Pull this from the live fragment list */
+				list_del(&info->list);
+
+				skb = info->skb;
+				info->skb = NULL;
+				priv->num_of_defrag_rx--;
+				info->free_space = 0;
+
+				/* Add back to the free fragment list */
+				list_add_tail(&info->list, 
+					      &info->priv->defrag_free_list);
+			}
+		}
+	} else {
+		IPW2100_DEBUG_FRAG("Cannot match this fragment, dropped!\n");
+		priv->wstats.discard.fragment++;	
+	}
+
+	dev_kfree_skb_irq(packet->skb);
+
+	return skb;
+} 
+
+struct sk_buff *ipw2100_defrag_rx(struct ipw2100_priv *priv, 
+				  struct ipw2100_hw_packet *packet, 
+				  u32 frame_size)
+{
+	struct sk_buff *skb = NULL;
+
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+
+	u32 seq_num = SEQUENCE_NUMBER(hdr);
+	u32 frag_num = FRAGMENT_NUMBER(hdr);
+
+	if (frag_num == 0)
+		defrag_first(priv, packet, frame_size, seq_num);
+	else 
+		skb = defrag_cont(priv, packet, frame_size, seq_num, frag_num);
+
+	return skb;
+} 
+
+
+int ipw2100_defrag_alloc(struct ipw2100_priv *priv)
+{
+	priv->defrag_pool = (struct defrag_info *)kmalloc(
+		MAX_DEFRAG_RX * sizeof(struct defrag_info), 
+		GFP_KERNEL);
+	if (!priv->defrag_pool)
+		return -ENOMEM;
+
+	memset(priv->defrag_pool, 0, MAX_DEFRAG_RX * 
+	       sizeof(struct defrag_info));
+
+	return 0;
+}
+
+void ipw2100_defrag_free(struct ipw2100_priv *priv)
+{
+	struct defrag_info *info;
+	struct list_head *element;
+
+	if (!priv->defrag_pool)
+		return;
+
+	for (element = priv->defrag_list.next;
+	     element != &priv->defrag_list;
+	     element = element->next) {
+		info = list_entry(element, struct defrag_info, list);
+		if (info->skb) {
+			del_timer_sync(&info->defrag_timer);
+			dev_kfree_skb(info->skb);
+			info->skb = NULL;
+		}
+		priv->num_of_defrag_rx--;
+		if (priv->num_of_defrag_rx < 0) {
+			IPW2100_DEBUG_FRAG("Bad Rx count!\n");
+			break;
+		}
+	}
+
+	kfree(priv->defrag_pool);
+	priv->defrag_pool = NULL;
+}
+
+void ipw2100_defrag_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	INIT_LIST_HEAD(&priv->defrag_free_list);
+	INIT_LIST_HEAD(&priv->defrag_list);
+
+	priv->num_of_defrag_rx = 0;
+	priv->defrag_timeout = DEFAULT_DEFRAG_TIMEOUT;
+		
+	for(i = 0; i < MAX_DEFRAG_RX; i++) {
+		priv->defrag_pool[i].priv = priv;
+
+		/* Free any stale SKBs */
+		if (priv->defrag_pool[i].skb) {
+			dev_kfree_skb(priv->defrag_pool[i].skb);
+			priv->defrag_pool[i].skb = NULL;
+		}
+
+		list_add_tail(&priv->defrag_pool[i].list, 
+			      &priv->defrag_free_list);
+	}
+}
+#endif
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_frag.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,77 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_FRAG_H
+#define _IPW2100_FRAG_H
+
+#define DEFAULT_FRAG_THRESHOLD 2342U
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2342U
+
+
+#ifndef CONFIG_IPW2100_WEP
+
+#define IS_ESS(priv)     (priv->port_type == BSS)
+#define IS_IBSS(priv)    (priv->port_type == IBSS)
+
+enum {
+        WSE_UNICAST,
+        WSE_MULTICAST,
+        WSE_BROADCAST
+};
+
+#define ETH_IS_BROADCAST(addr)  (addr[0] == 0xff && addr[1] == 0xff     \
+                                 && addr[2] == 0xff && addr[3] == 0xff  \
+                                 && addr[4] == 0xff && addr[5] == 0xff)
+
+#define ETH_IS_MULTICAST(addr)  (addr[0] & 0x01)
+
+#define FRAGMENT_NUMBER_FIELD_MASK				0x000F
+#define SEQUENCE_NUMBER_FIELD_MASK				0xFFF0
+#define SEQUENCE_NUMBER_FIELD_SHIFT				4
+
+#define FRAGMENT_NUMBER(header) ((header->seq_ctrl & \
+        FRAGMENT_NUMBER_FIELD_MASK))
+#define SEQUENCE_NUMBER(header) ((header->seq_ctrl & \
+        SEQUENCE_NUMBER_FIELD_MASK)>>SEQUENCE_NUMBER_FIELD_SHIFT)
+
+#define IS_FRAGMENT(header) (((*header).flags == 1) || \
+                            (FRAGMENT_NUMBER(header) > 0))
+
+#define MAX_DEFRAG_TIMEOUT	0xFFFFFFFF	
+#define MIN_DEFRAG_TIMEOUT	0x1
+#define DEFAULT_DEFRAG_TIMEOUT	0x200
+struct sk_buff *ipw2100_defrag_rx(struct ipw2100_priv *priv, 
+				  struct ipw2100_hw_packet *packet, 
+				  u32 frame_size);
+int ipw2100_defrag_alloc(struct ipw2100_priv *);
+void ipw2100_defrag_free(struct ipw2100_priv *);
+void ipw2100_defrag_initialize(struct ipw2100_priv *priv);
+#endif
+
+u32 ipw2100_msdu_frag_threshold(struct ipw2100_priv *);
+
+#endif
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,656 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+/*******************************************************************************
+
+  Changes
+
+  0.33 Luc Saillard
+       Added support for using firmware hotplug vs. a custom binary loader.
+
+  Portions of ipw2100_mod_firmware_load, ipw2100_do_mod_firmware_load, and 
+  ipw2100_fw_load are loosely based on drivers/sound/sound_firmware.c 
+  available in the 2.4.25 kernel sources, and are copyright (c) Alan Cox
+
+*******************************************************************************/
+
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#ifndef CONFIG_IPW2100_LEGACY_FW_LOAD
+#include <linux/firmware.h>
+#endif
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#define __KERNEL_SYSCALLS__
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/unistd.h>
+
+#include "ipw2100.h"
+#include "ipw2100_hw.h"
+#include "ipw2100_fw.h"
+
+#define IPW2100_FW_VERSION 1
+
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+/* Module paramter for path to the firmware*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+static char firmware[255] = {[0 ... 254] = 0};
+MODULE_PARM(firmware, "1-254s");
+
+#else /* LINUX_VERSION_CODE < 2.6.0 */
+
+#include <linux/moduleparam.h>
+static char *firmware = NULL;
+module_param(firmware, charp, 0);
+
+#endif /* LINUX_VERSION_CODE < 2.6.0 */
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+
+/*
+
+BINARY FIRMWARE HEADER FORMAT
+
+offset      length   desc
+0           4        version
+4           4        fw_len
+8           4        uc_len
+C           fw_len   firmware data
+12 + fw_len uc_len   microcode data
+
+*/
+
+struct ipw2100_fw_header {
+	int version;
+	unsigned int fw_size;
+	unsigned int uc_size;
+} __attribute__ ((packed));
+
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+/*
+ * 
+ * The following was originally based on the mod_firmware_load in
+ * drivers/sound/sound_firmware.c.  Primary changes revolved around 
+ * making it work for firmware images > 128k and to support having
+ * both a firmware and microcode image in the file loaded.
+ *
+ */
+static void ipw2100_fw_free(struct ipw2100_fw *fw)
+{
+	struct ipw2100_fw_chunk *c;
+	struct list_head *e;
+
+	while (!list_empty(&fw->fw.chunk_list)) {
+		e = fw->fw.chunk_list.next;
+		c = list_entry(e, struct ipw2100_fw_chunk, list);
+		list_del(e);
+		vfree(c->buf);
+		vfree(c);
+	}
+
+	while (!list_empty(&fw->uc.chunk_list)) {
+		e = fw->uc.chunk_list.next;
+		c = list_entry(e, struct ipw2100_fw_chunk, list);
+		list_del(e);
+		vfree(c->buf);
+		vfree(c);
+	}
+}
+
+
+static int ipw2100_fw_load(int fd, struct ipw2100_fw_chunk_set *cs, long size)
+{
+	struct ipw2100_fw_chunk *c;
+	int i = 0;
+	
+	/* Break firmware image into chunks of 128k */
+	cs->size = size;
+	cs->chunks = cs->size >> 17;
+	
+	if (cs->size & 0x1FFFF)
+		cs->chunks++;
+	
+	IPW2100_DEBUG_FW("Loading %ld bytes from %u chunks\n",
+			 cs->size, cs->chunks);
+	
+	/* Load the chunks */
+	while (size > 0) {
+		i++;
+		
+		c = (struct ipw2100_fw_chunk *)vmalloc(
+			sizeof(struct ipw2100_fw_chunk));
+		if (c == NULL) {
+			printk(KERN_INFO "Out of memory loading firmware "
+			       "chunk %d.\n", i);
+			goto fail;
+		}
+		c->pos = 0;
+		
+		if (size >= 0x20000)
+			c->len = 0x20000;
+		else
+			c->len = size;
+		
+		c->buf = (unsigned char *)vmalloc(c->len);
+		if (c->buf == NULL) {
+			printk(KERN_INFO "Out of memory loading firmware "
+			       "chunk %d.\n", i);
+			goto fail;
+			
+		}
+		if (read(fd, c->buf, c->len) != c->len) {
+			printk(KERN_INFO "Failed to read chunk firmware "
+			       "chunk %d.\n", i);
+			goto fail;
+		}
+		
+		list_add_tail(&c->list, &cs->chunk_list);
+		
+		IPW2100_DEBUG_FW("Chunk %d loaded: %lu bytes\n",
+				 i, c->len);
+		size -= c->len;
+	}
+	
+	return 0;
+	
+ fail:
+	return 1;
+}
+
+static int errno;
+static int ipw2100_do_mod_firmware_load(const char *fn, struct ipw2100_fw *fw)
+{
+	int fd;
+	long l;
+	struct ipw2100_fw_header h;
+
+	/* Make sure the lists are init'd so that error paths can safely walk
+        * them to free potentially allocated storage */
+	INIT_LIST_HEAD(&fw->fw.chunk_list);
+	INIT_LIST_HEAD(&fw->uc.chunk_list);
+	
+	fd = open(fn, 0, 0);
+	if (fd == -1) {
+		printk(KERN_INFO "Unable to load '%s'.\n", fn);
+		return 1;
+	}
+	l = lseek(fd, 0L, 2);
+	lseek(fd, 0L, 0);
+	
+	IPW2100_DEBUG_FW("Loading %ld bytes for firmware '%s'\n", l, fn);
+	
+	if (read(fd, (char *)&h, sizeof(h)) != sizeof(h)) {
+		printk(KERN_INFO "Failed to read '%s'.\n", fn);
+		goto fail;
+	}
+	
+	if (h.version != IPW2100_FW_VERSION) {
+		printk(KERN_WARNING "Firmware image not compatible "
+		       "(detected version id of %u). "
+		       "See Documentation/networking/README.ipw2100\n",
+		       h.version);
+		goto fail;
+	}
+	
+	fw->version = h.version;
+
+	if (ipw2100_fw_load(fd, &fw->fw, h.fw_size))
+		goto fail;
+
+	if (ipw2100_fw_load(fd, &fw->uc, h.uc_size))
+		goto fail;
+
+	close(fd);
+	return 0;
+
+ fail:
+	ipw2100_fw_free(fw);
+	close(fd);
+	return 1;
+}
+
+
+static int ipw2100_mod_firmware_load(const char *fn, struct ipw2100_fw *fw)
+{
+	int r;
+	mm_segment_t fs = get_fs();
+	set_fs(get_ds());
+	r = ipw2100_do_mod_firmware_load(fn, fw);
+	set_fs(fs);
+	return r;
+}
+
+static inline struct list_head *ipw2100_fw_read(
+	struct list_head *e, struct ipw2100_fw_chunk_set *cs,
+	unsigned char *data, size_t len)
+{
+	struct ipw2100_fw_chunk *c = list_entry(e, struct ipw2100_fw_chunk, 
+						list);
+	unsigned int avail = c->len - c->pos;
+	if (avail <= len) {
+		struct ipw2100_fw_chunk *tmp;
+
+		memcpy(data, c->buf + c->pos, avail);
+		list_del(e);
+
+		IPW2100_DEBUG_INFO("advancing to next chunk...\n");
+
+		e = cs->chunk_list.next;
+		tmp = list_entry(e, struct ipw2100_fw_chunk, list);
+
+		if (avail != len) {
+			memcpy(data + avail, 
+			       tmp->buf + tmp->pos, 
+			       len - avail);
+			tmp->pos += len - avail;
+		}
+
+		vfree(c->buf);
+		vfree(c);
+
+		return e;
+	} 
+
+	memcpy(data, c->buf + c->pos, len);
+	c->pos += len;
+
+	return e;
+}
+
+static inline struct list_head *ipw2100_fw_readw(
+	struct list_head *e, struct ipw2100_fw_chunk_set *cs, 
+	unsigned short *data)
+{
+	return ipw2100_fw_read(e, cs, (unsigned char *)data, sizeof(*data));
+}
+
+static inline struct list_head *ipw2100_fw_readl(
+	struct list_head *e, struct ipw2100_fw_chunk_set *cs,
+	unsigned int *data)
+{
+	return ipw2100_fw_read(e, cs, (unsigned char *)data, sizeof(*data));
+}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+static int ipw2100_mod_firmware_load(struct ipw2100_fw *fw)
+{
+	struct ipw2100_fw_header *h = 
+		(struct ipw2100_fw_header *)fw->fw_entry->data;
+
+	if (h->version != IPW2100_FW_VERSION) {
+		printk(KERN_WARNING "Firmware image not compatible "
+		       "(detected version id of %u). "
+		       "See Documentation/networking/README.ipw2100\n",
+		       h->version);
+		return 1;
+	}
+
+	fw->version = h->version;
+	fw->fw.data = fw->fw_entry->data + sizeof(struct ipw2100_fw_header);
+	fw->fw.size = h->fw_size;
+	fw->uc.data = fw->fw.data + h->fw_size;
+	fw->uc.size = h->uc_size;
+
+	return 0;
+}
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+
+int ipw2100_get_firmware(struct ipw2100_priv *priv, struct ipw2100_fw *fw)
+{
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	char *fw_name;
+	int err = 0;
+
+	printk(KERN_DEBUG "%s: Using legacy firmware load.\n",
+	       priv->ndev->name);
+
+	if (!firmware || firmware[0] == '\0') 
+		fw_name = "/etc/firmware/ipw2100-1.0.fw";
+	else 
+		fw_name = firmware;
+
+	err = ipw2100_mod_firmware_load(fw_name, fw);
+	if (err) {
+		printk(KERN_ERR "%s: Firmware not available. "
+		       "See Documentation/networking/README.ipw2100\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+	int rc;
+
+	printk(KERN_DEBUG "%s: Using hotplug firmware load.\n",
+	       priv->ndev->name);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	rc = request_firmware(&fw->fw_entry, "ipw2100-1.0.fw",
+			      pci_name(priv->pdev));
+#else
+	rc = request_firmware(&fw->fw_entry, "ipw2100-1.0.fw",
+			      &priv->pdev->dev);
+#endif /* LINUX_VERSION_CODE */
+
+	if (rc < 0) {
+		printk(KERN_ERR
+		       "%s: Firmware not available or load failed\n",
+		       priv->ndev->name);
+		return rc;
+	}
+	IPW2100_DEBUG_INFO("firmware data %p size %d", fw->fw_entry->data,
+			   fw->fw_entry->size);
+
+	ipw2100_mod_firmware_load(fw);
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	return 0;
+}
+
+void ipw2100_release_firmware(struct ipw2100_priv *priv,
+			      struct ipw2100_fw *fw)
+{
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+	ipw2100_fw_free(fw);
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	if (fw->fw_entry)
+		release_firmware(fw->fw_entry);
+	fw->fw_entry = NULL;
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+}
+
+
+int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max)
+{
+	char ver[MAX_FW_VERSION_LEN];
+	u32 len = MAX_FW_VERSION_LEN;
+	u32 tmp;
+	int i;
+	/* firmware version is an ascii string (max len of 14) */
+	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_FW_VER_NUM,
+				ver, &len)) 
+		return -EIO;
+	tmp = max;
+	if (len >= max)
+		len = max - 1;
+	for (i = 0; i < len; i++)
+		buf[i] = ver[i];
+	buf[i] = '\0';
+	return tmp;
+}
+
+int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max)
+{
+	u32 ver;
+	u32 len = sizeof(ver);
+	/* microcode version is a 32 bit integer */
+	if (ipw2100_get_ordinal(priv, IPW_ORD_UCODE_VERSION,
+				&ver, &len))
+		return -EIO;
+	return snprintf(buf, max, "%08X", ver);
+}
+
+/* 
+ * On exit, the firmware will have been freed from the fw list 
+ */
+int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)
+{
+	/* firmware is constructed of N contiguous entries, each entry is
+	 * structured as:
+	 * 
+	 * offset    sie         desc
+	 * 0         4           address to write to
+	 * 4         2           length of data run
+         * 6         length      data
+	 */
+	unsigned int addr;
+	unsigned short len;
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	unsigned char data[32];
+	
+	struct ipw2100_fw_chunk_set *cs = &fw->fw;
+	struct list_head *e = cs->chunk_list.next;
+
+	while (cs->size > 0) {
+		e = ipw2100_fw_readl(e, cs, &addr);
+		cs->size -= sizeof(addr);
+
+		e = ipw2100_fw_readw(e, cs, &len);
+		cs->size -= sizeof(len);
+
+		if (len > 32) {
+			printk(KERN_ERR 
+			       "Invalid firmware run-length of %d bytes\n",
+			       len);
+			return -EINVAL;
+		}
+
+		e = ipw2100_fw_read(e, cs, data, len);
+		cs->size -= len;
+
+		write_nic_memory(priv->ndev, addr, len, data);
+	}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	const unsigned char *firmware_data = fw->fw.data;
+	unsigned int firmware_data_left = fw->fw.size;
+
+	while (firmware_data_left > 0) {
+	   	addr = *(u32 *)(firmware_data);
+		firmware_data      += 4;
+		firmware_data_left -= 4;
+
+	   	len = *(u16 *)(firmware_data);
+		firmware_data      += 2;
+		firmware_data_left -= 2;
+
+		if (len > 32) {
+			printk(KERN_ERR
+			       "Invalid firmware run-length of %d bytes\n",
+			       len);
+			return -EINVAL;
+		}
+
+		write_nic_memory(priv->ndev, addr, len, firmware_data);
+		firmware_data      += len;
+		firmware_data_left -= len;
+	}
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	return 0;
+}
+
+struct symbol_alive_response {
+	u8 cmd_id;
+	u8 seq_num;
+	u8 ucode_rev;
+	u8 eeprom_valid;
+	u16 valid_flags;
+	u8 IEEE_addr[6];
+	u16 flags;
+	u16 pcb_rev;
+	u16 clock_settle_time;	// 1us LSB
+	u16 powerup_settle_time;	// 1us LSB
+	u16 hop_settle_time;	// 1us LSB
+	u8 date[3];		// month, day, year
+	u8 time[2];		// hours, minutes
+	u8 ucode_valid;
+};
+
+int ipw2100_ucode_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)
+{
+	struct net_device *dev = priv->ndev;
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+	struct ipw2100_fw_chunk_set *cs = &fw->uc;
+	struct list_head *e = cs->chunk_list.next;
+	unsigned short uc_data;
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	const unsigned char *microcode_data = fw->uc.data;
+	unsigned int microcode_data_left = fw->uc.size;
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	struct symbol_alive_response response;
+	int i, j;
+	u8 data;
+
+	/* Symbol control */
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x703);
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x707);
+
+	/* HW config */
+	write_nic_byte(dev, 0x210014, 0x72);	/* fifo width =16 */
+	write_nic_byte(dev, 0x210014, 0x72);	/* fifo width =16 */
+
+	/* EN_CS_ACCESS bit to reset control store pointer */
+	write_nic_byte(dev, 0x210000, 0x40);
+	write_nic_byte(dev, 0x210000, 0x0);
+	write_nic_byte(dev, 0x210000, 0x40);
+
+	/* copy microcode from buffer into Symbol */
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+	while (cs->size > 0) {
+
+		e = ipw2100_fw_readw(e, cs, &uc_data);
+		cs->size -= sizeof(uc_data);
+		write_nic_byte(dev, 0x210010, uc_data & 0xFF);
+		write_nic_byte(dev, 0x210010, (uc_data >> 8) & 0xFF);
+
+	}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	while (microcode_data_left > 0) {
+
+		write_nic_byte(dev, 0x210010, *microcode_data++);
+		write_nic_byte(dev, 0x210010, *microcode_data++);
+		microcode_data_left -= 2;
+
+	}
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	/* EN_CS_ACCESS bit to reset the control store pointer */
+	write_nic_byte(dev, 0x210000, 0x0);
+
+	/* Enable System (Reg 0)
+	 * first enable causes a garbage in RX FIFO */
+	write_nic_byte(dev, 0x210000, 0x0);
+	write_nic_byte(dev, 0x210000, 0x80);
+
+	/* Reset External Baseband Reg */
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x703);
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x707);
+
+	/* HW Config (Reg 5) */
+	write_nic_byte(dev, 0x210014, 0x72);	// fifo width =16
+	write_nic_byte(dev, 0x210014, 0x72);	// fifo width =16
+
+	/* Enable System (Reg 0)
+	 * second enable should be OK 
+	 */
+	write_nic_byte(dev, 0x210000, 0x0);	// clear enable system
+	write_nic_byte(dev, 0x210000, 0x80);	// set enable system
+
+	/* check Symbol is enabled - upped this from 5 as it wasn't always
+	 * catching the update */
+	for (i = 0; i < 10; i++) {
+		udelay(10);
+
+		/* check Dino is enabled bit */
+		read_nic_byte(dev, 0x210000, &data);
+		if (data & 0x1)
+			break;
+	}
+
+	if (i == 10) {
+		printk(KERN_ERR "%s: Error initializing Symbol\n",
+		       dev->name);
+		return -EIO;
+	}
+
+	/* Get Symbol alive response */
+	for (i = 0; i < 10; i++) {
+		/* Read alive response structure */
+		for (j = 0; 
+		     j < (sizeof(struct symbol_alive_response) >> 1); 
+		     j++)
+			read_nic_word(dev, 0x210004,
+				      ((u16 *)&response) + j);
+
+		if ((response.cmd_id == 1) &&
+		    (response.ucode_valid == 0x1))
+			break;
+		udelay(10);
+	}
+
+	if (i == 10) {
+		printk(KERN_ERR "%s: No response from Symbol - hw not alive\n",
+		       dev->name);
+		return -EIO;
+	}
+
+	return 0;
+}
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_fw.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,83 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_FW_H
+#define _IPW2100_FW_H
+
+#include <linux/netdevice.h>
+
+#define IPW_HOST_FW_SHARED_AREA0 	0x0002f200
+#define IPW_HOST_FW_SHARED_AREA0_END 	0x0002f510	// 0x310 bytes
+
+#define IPW_HOST_FW_SHARED_AREA1 	0x0002f610
+#define IPW_HOST_FW_SHARED_AREA1_END 	0x0002f630	// 0x20 bytes
+
+#define IPW_HOST_FW_SHARED_AREA2 	0x0002fa00
+#define IPW_HOST_FW_SHARED_AREA2_END 	0x0002fa20	// 0x20 bytes
+
+#define IPW_HOST_FW_SHARED_AREA3 	0x0002fc00
+#define IPW_HOST_FW_SHARED_AREA3_END 	0x0002fc10	// 0x10 bytes
+
+#define IPW_HOST_FW_INTERRUPT_AREA 	0x0002ff80
+#define IPW_HOST_FW_INTERRUPT_AREA_END 	0x00030000	// 0x80 bytes
+
+struct ipw2100_fw_chunk {
+	unsigned char *buf;
+	long len;
+	long pos;
+	struct list_head list;
+};
+
+struct ipw2100_fw_chunk_set {
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	struct list_head chunk_list;
+	unsigned int chunks;
+#else
+   	const void *data;
+#endif
+	unsigned long size;
+};
+
+struct ipw2100_fw {
+	int version;
+	struct ipw2100_fw_chunk_set fw;
+	struct ipw2100_fw_chunk_set uc;
+#ifndef CONFIG_IPW2100_LEGACY_FW_LOAD
+	const struct firmware *fw_entry;
+#endif
+};
+
+int ipw2100_get_firmware(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+void ipw2100_release_firmware(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+int ipw2100_ucode_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+
+#define MAX_FW_VERSION_LEN 14
+
+int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max);
+int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max);
+
+#endif	/* _IPW2100_FW_H */
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_hw.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_hw.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_hw.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_hw.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,205 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_HW_H
+#define _IPW2100_HW_H
+
+#include <linux/netdevice.h>
+#include <asm/io.h>
+
+#include "ipw2100.h"
+
+static inline void read_register(struct net_device *dev, u32 reg, u32 *val) 
+{
+	*val = readl(dev->base_addr + reg);
+	IPW2100_DEBUG_IO("r: 0x%08X => 0x%08X\n", reg, *val);
+}
+
+static inline void write_register(struct net_device *dev, u32 reg, u32 val) 
+{
+	writel(val, dev->base_addr + reg);
+	IPW2100_DEBUG_IO("w: 0x%08X <= 0x%08X\n", reg, val);
+}
+
+static inline void read_register_word(struct net_device *dev, u32 reg, u16 *val)
+{
+	*val = readw(dev->base_addr + reg);
+	IPW2100_DEBUG_IO("r: 0x%08X => %04X\n", reg, *val);
+}
+
+static inline void read_register_byte(struct net_device *dev, u32 reg, u8 *val)
+{
+	*val = readb(dev->base_addr + reg);
+	IPW2100_DEBUG_IO("r: 0x%08X => %02X\n", reg, *val);
+}
+
+static inline void write_register_word(struct net_device *dev, u32 reg, u16 val)
+{
+	writew(val, dev->base_addr + reg);
+	IPW2100_DEBUG_IO("w: 0x%08X <= %04X\n", reg, val);
+}
+
+
+static inline void write_register_byte(struct net_device *dev, u32 reg, u8 val)
+{
+	writeb(val, dev->base_addr + reg);
+	IPW2100_DEBUG_IO("w: 0x%08X =< %02X\n", reg, val);
+}
+
+static inline void read_nic_dword(struct net_device *dev, u32 addr, u32 *val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	read_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_dword(struct net_device *dev, u32 addr, u32 val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void read_nic_word(struct net_device *dev, u32 addr, u16 *val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	read_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_word(struct net_device *dev, u32 addr, u16 val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	write_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void read_nic_byte(struct net_device *dev, u32 addr, u8 *val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	read_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_byte(struct net_device *dev, u32 addr, u8 val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	write_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_auto_inc_address(struct net_device *dev, u32 addr)
+{
+	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+}
+
+static inline void write_nic_dword_auto_inc(struct net_device *dev, u32 val)
+{
+	write_register(dev, IPW_REG_AUTOINCREMENT_DATA, val);
+}
+
+static inline void write_nic_memory(struct net_device *dev, u32 addr, u32 len,
+				    const u8 *buf)
+{
+	u32 aligned_addr;
+	u32 aligned_len;
+	u32 dif_len;
+	u32 i;
+
+	/* read first nibble byte by byte */
+	aligned_addr = addr & (~0x3);
+	dif_len = addr - aligned_addr;
+	if (dif_len) {
+		/* Start reading at aligned_addr + dif_len */
+		write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, 
+			       aligned_addr);
+		for (i = dif_len; i < 4; i++, buf++)
+			write_register_byte(
+				dev, IPW_REG_INDIRECT_ACCESS_DATA + i, 
+				*buf);
+		
+		len -= dif_len;
+		aligned_addr += 4;
+	}
+
+	/* read DWs through autoincrement registers */
+	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,
+		       aligned_addr);
+	aligned_len = len & (~0x3);
+	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)
+		write_register(
+			dev, IPW_REG_AUTOINCREMENT_DATA, *(u32 *)buf);
+	
+	/* copy the last nibble */
+	dif_len = len - aligned_len;
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);
+	for (i = 0; i < dif_len; i++, buf++)
+		write_register_byte(
+			dev, IPW_REG_INDIRECT_ACCESS_DATA + i, *buf);
+}
+
+static inline void read_nic_memory(struct net_device *dev, u32 addr, u32 len,
+				   u8 *buf)
+{
+	u32 aligned_addr;
+	u32 aligned_len;
+	u32 dif_len;
+	u32 i;
+
+	/* read first nibble byte by byte */
+	aligned_addr = addr & (~0x3);
+	dif_len = addr - aligned_addr;
+	if (dif_len) {
+		/* Start reading at aligned_addr + dif_len */
+		write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, 
+			       aligned_addr);
+		for (i = dif_len; i < 4; i++, buf++)
+			read_register_byte(
+				dev, IPW_REG_INDIRECT_ACCESS_DATA + i, buf);
+		
+		len -= dif_len;
+		aligned_addr += 4;
+	}
+
+	/* read DWs through autoincrement registers */
+	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,
+		       aligned_addr);
+	aligned_len = len & (~0x3);
+	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)
+		read_register(dev, IPW_REG_AUTOINCREMENT_DATA,
+			      (u32 *)buf);
+	
+	/* copy the last nibble */
+	dif_len = len - aligned_len;
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       aligned_addr);
+	for (i = 0; i < dif_len; i++, buf++)
+		read_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA +
+				   i, buf);
+}
+
+#endif	/* _IPW2100_HW_H */
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_main.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_main.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_main.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_main.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,6166 @@
+/******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+/*
+
+ Initial driver on which this is based was developed by Janusz Gorycki, 
+ Maciej Urbaniak, and Maciej Sosnowski.
+
+
+Theory of Operation
+
+Tx - Commands and Data
+
+Firmware and host share a circular queue of Transmit Buffer Descriptors (TBDs)
+Each TBD contains a pointer to the physical (dma_addr_t) address of data being
+sent to the firmware as well as the length of the data.
+
+The host writes to the TBD queue at the WRITE index.  The WRITE index points
+to the _next_ packet to be written and is advanced when after the TBD has been
+filled.
+
+The firmware pulls from the TBD queue at the READ index.  The READ index points
+to the currently being read entry, and is advanced once the firmware is
+done with a packet.
+
+When data is sent to the firmware, the first TBD is used to indicate to the
+firmware if a Command or Data is being sent.  If it is Command, all of the 
+command information is contained within the physical address referred to by the
+TBD.  If it is Data, the first TBD indicates the type of data packet, number
+of fragments, etc.  The next TBD then referrs to the actual packet location.
+
+The Tx flow cycle is as follows:
+
+1) ipw2100_tx() is called by kernel with SKB to transmit
+2) Packet is move from the tx_free_list and appended to the transmit pending 
+   list (tx_pend_list)
+3) work is scheduled to move pending packets into the shared circular queue.
+4) when placing packet in the circular queue, the incoming SKB is DMA mapped
+   to a physical address.  That address is entered into a TBD.  Two TBDs are
+   filled out.  The first indicating a data packet, the second referring to the
+   actual payload data.
+5) the packet is removed from tx_pend_list and placed on the end of the 
+   firmware pending list (fw_pend_list)
+6) firmware is notified that the WRITE index has 
+7) Once the firmware has processed the TBD, INTA is triggered.  
+8) For each Tx interrupt received from the firmware, the READ index is checked
+   to see which TBDs are done being processed.
+9) For each TBD that has been processed, the ISR pulls the oldest packet 
+   from the fw_pend_list.  
+10)The packet structure contained in the fw_pend_list is then used
+   to unmap the DMA address and to free the SKB originally passed to the driver
+   from the kernel.
+11)The packet structure is placed onto the tx_free_list
+
+The above steps are the same for commands, only the msg_free_list/msg_pend_list
+are used instead of tx_free_list/tx_pend_list
+
+...
+
+Critical Sections / Locking :
+
+There are two locks utilized.  The first is the low level lock (priv->low_lock)
+that protects the following:
+
+- Access to the Tx/Rx queue lists via priv->low_lock.  The lists are as follows:
+
+  tx_free_list : Holds pre-allocated Tx buffers.
+    TAIL modified in __ipw2100_tx_process()
+    HEAD modified in ipw2100_tx()
+
+  tx_pend_list : Holds used Tx buffers waiting to go into the TBD ring 
+    TAIL modified ipw2100_tx()
+    HEAD modified by X__ipw2100_tx_send_data()
+
+  msg_free_list : Holds pre-allocated Msg (Command) buffers
+    TAIL modified in __ipw2100_tx_process()
+    HEAD modified in ipw2100_hw_seond_command()
+
+  msg_pend_list : Holds used Msg buffers waiting to go into the TBD ring
+    TAIL modified in ipw2100_hw_send_command()
+    HEAD modified in X__ipw2100_tx_send_commands()
+
+  The flow of data on the TX side is as follows:
+
+  MSG_FREE_LIST + COMMAND => MSG_PEND_LIST => TBD => MSG_FREE_LIST
+  TX_FREE_LIST + DATA => TX_PEND_LIST => TBD => TX_FREE_LIST
+
+  The methods that work on the TBD ring are protected via priv->low_lock.
+
+- The internal data state of the device itself
+- Access to the firmware read/write indexes for the BD queues
+  and associated logic
+
+...
+
+TODO
+
+- Deprecate the proc filesystem code (how to cleanly support 2.4 and 2.6 in
+  one driver base?)  ethtool_ops ?
+-   
+
+...
+
+Files:
+  ipw2100_fw.c/h   Defines the interface and implementation for 
+                   loading and unloading the firmware and microcode 
+		   onto the NIC MAC.  The code in these files will be 
+		   rewritten in the coming weeks to use a dynamic 
+		   loading approach.
+
+  ipw2100_hw.h     Inline functions for read/writing to the NIC.
+
+  ipw2100_main.c/h This file - defines modules entry points, ISR, 
+                   wireless extension, etc.
+
+  ipw2100_wx.c/h   Defines wireless extension handlers.	
+
+
+*/
+
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/sched.h>
+#endif
+
+#ifndef IRQ_NONE
+typedef void irqreturn_t;
+#define IRQ_NONE 
+#define IRQ_HANDLED 
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(x) kfree(x)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/* Some 2.4 kernels configured with different schedulers do not have the
+ * __wake_up_sync function.  As such, we need to switch the 
+ * wake_up_interruptible_sync's accordingly */
+#  ifndef wake_up_sync
+/* Some versions don't define wake_up_sync but do define 
+ * wake_up_interruptible_sync.  We can't just check for
+ * the later since sometimes it is defined as an actual function
+ * and not a #define--in these cases, wake_up_sync is not defined */
+#    ifdef wake_up_interruptible_sync
+#      undef wake_up_interruptible_sync
+#    endif
+#  define wake_up_interruptible_sync wake_up_interruptible
+#  endif
+#endif
+
+#define IPW2100_MAIN
+#include "ipw2100.h"
+#include "ipw2100_hw.h"
+#include "ipw2100_fw.h"
+#include "ipw2100_wx.h"
+#include "ipwversion.h"
+
+#define DRV_NAME	"ipw2100"
+#define DRV_VERSION	IPW2100_VERSION
+#define DRV_DESCRIPTION	"Intel(R) PRO/Wireless 2100 Network Driver"
+#define DRV_COPYRIGHT	"Copyright(c) 2003-2004 Intel Corporation"
+
+static int debug = -1;
+
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR(DRV_COPYRIGHT);
+MODULE_LICENSE("GPL");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+MODULE_PARM(debug, "i");
+
+static char if_name[IFNAMSIZ] = {[0 ... IFNAMSIZ - 1] = 0};
+MODULE_PARM(if_name, "1-" __MODULE_STRING(IFNAMSIZ - 1) "s");
+
+#else /* LINUX_VERSION_CODE < 2.6.0 */
+
+#include <linux/moduleparam.h>
+module_param(debug, int, 0);
+static char *if_name = NULL;
+module_param(if_name, charp, 0);
+
+#endif /* LINUX_VERSION_CODE < 2.6.0 */
+
+unsigned long ipw2100_debug_level = IPW2100_DL_UNINIT; /* Unset */
+
+const char *port_type_str[] = { 
+	"managed", "adhoc", "monitor"
+};
+
+#ifdef CONFIG_IPW2100_DEBUG
+const char *command_types[] = {
+	"undefined",
+	"unused", /* HOST_ATTENTION */ 
+	"HOST_COMPLETE",
+	"unused", /* SLEEP */
+	"unused", /* HOST_POWER_DOWN */
+	"unused", 
+	"SYSTEM_CONFIG",
+	"unused", /* SET_IMR */
+	"SSID",
+	"MANDATORY_BSSID",
+	"AUTHENTICATION_TYPE",
+	"ADAPTER_ADDRESS",
+	"PORT_TYPE",
+	"INTERNATIONAL_MODE",
+	"CHANNEL",
+	"RTS_THRESHOLD",
+	"POWER_MODE",
+	"TX_RATES",
+	"BASIC_TX_RATES",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"ADD_MULTICAST",
+	"CLEAR_ALL_MULTICAST",
+	"BEACON_INTERVAL",
+	"ATIM_WINDOW",
+	"CLEAR_STATISTICS",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"TX_POWER_INDEX",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"BROADCAST_SCAN",
+	"CARD_DISABLE",
+	"PREFERRED_BSSID",
+	"SET_SCAN_OPTIONS",
+	"SCAN_DWELL_TIME",
+	"SWEEP_TABLE",
+	"AP_OR_STATION_TABLE",
+	"GROUP_ORDINALS",
+	"SHORT_RETRY_LIMIT",
+	"LONG_RETRY_LIMIT",
+	"unused", /* SAVE_CALIBRATION */
+	"unused", /* RESTORE_CALIBRATION */
+	"undefined",
+	"undefined",
+	"undefined",
+	"HOST_PRE_POWER_DOWN",
+	"unused", /* HOST_INTERRUPT_COALESCING */
+	"undefined",
+	"CARD_DISABLE_PHY_OFF",
+	"MSDU_TX_RATES"
+	"undefined",
+	"undefined",
+	"SET_STATION_STAT_BITS",
+	"CLEAR_STATIONS_STAT_BITS",
+	"LEAP_ROGUE_MODE",
+	"SET_SECURITY_INFORMATION",
+	"DISASSOCIATION_BSSID",
+	"SET_WPA_ASS_IE"
+};
+#endif
+
+
+/* Pre-decl until we get the code solid and then we can clean it up */
+static void X__ipw2100_tx_send_commands(struct ipw2100_priv *priv);
+static void X__ipw2100_tx_send_data(struct ipw2100_priv *priv);
+static int ipw2100_adapter_setup(struct ipw2100_priv *priv);
+
+static void ipw2100_queues_initialize(struct ipw2100_priv *priv);
+static void ipw2100_queues_free(struct ipw2100_priv *priv);
+static int ipw2100_queues_allocate(struct ipw2100_priv *priv);
+
+static int ipw2100_proc_init(void);
+static void ipw2100_proc_cleanup(void);
+static void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv);
+static int ipw2100_proc_dev_init(struct ipw2100_priv *priv);
+
+static inline int ipw2100_hw_is_adapter_in_system(struct net_device *dev)
+{
+	return (dev->base_addr && 
+		(readl(dev->base_addr + IPW_REG_DOA_DEBUG_AREA_START)
+		 == IPW_DATA_DOA_DEBUG_VALUE));
+}
+
+int ipw2100_get_ordinal(struct ipw2100_priv *priv, u32 ord, void *val, 
+			       u32 *len)
+{
+	struct ipw2100_ordinals *ordinals = &priv->ordinals;
+	u32 addr;
+	u32 field_info;
+	u16 field_len;
+	u16 field_count;
+	u32 total_length;
+
+	if (ordinals->table1_addr == 0) {
+		printk(KERN_WARNING DRV_NAME ": attempt to use fw ordinals "
+		       "before they have been loaded.\n");
+		return -EINVAL;
+	}
+
+	if (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {
+		if (*len < IPW_ORD_TAB_1_ENTRY_SIZE) {
+			*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+
+			printk(KERN_WARNING DRV_NAME 
+			       ": ordinal buffer length too small, need %d\n",
+			       IPW_ORD_TAB_1_ENTRY_SIZE);
+
+			return -EINVAL;
+		}
+
+		read_nic_dword(priv->ndev, ordinals->table1_addr + (ord << 2), 
+			       &addr);
+		read_nic_dword(priv->ndev, addr, val);
+
+		*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+		
+		return 0;
+	} 
+	
+	if (IS_ORDINAL_TABLE_TWO(ordinals, ord)) {
+
+		ord -= IPW_START_ORD_TAB_2;
+		
+		/* get the address of statistic */
+		read_nic_dword(priv->ndev, ordinals->table2_addr + (ord << 3), 
+			       &addr);
+		
+		/* get the second DW of statistics ; 
+		 * two 16-bit words - first is length, second is count */
+		read_nic_dword(priv->ndev, 
+			       ordinals->table2_addr + (ord << 3) + sizeof(u32),
+			       &field_info);
+		
+		/* get each entry length */
+		field_len = *((u16 *)&field_info);
+		
+		/* get number of entries */
+		field_count = *(((u16 *)&field_info) + 1);
+		
+		/* abort if no enought memory */
+		total_length = field_len * field_count;
+		if (total_length > *len) {
+			*len = total_length;
+			return -EINVAL;
+		}
+		
+		*len = total_length;
+		if (!total_length)
+			return 0;
+		
+		/* read the ordinal data from the SRAM */
+		read_nic_memory(priv->ndev, addr, total_length, val);
+		
+		return 0;
+	}
+
+	printk(KERN_WARNING DRV_NAME ": ordinal %d neither in table 1 nor "
+	       "in table 2\n", ord);
+
+	return -EINVAL;
+}
+
+static int ipw2100_set_ordinal(struct ipw2100_priv *priv, u32 ord, u32 *val, 
+			       u32 *len)
+{
+	struct ipw2100_ordinals *ordinals = &priv->ordinals;
+	u32 addr;
+
+	if (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {
+		if (*len != IPW_ORD_TAB_1_ENTRY_SIZE) {
+			*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+			IPW2100_DEBUG_INFO("wrong size\n");
+			return -EINVAL;
+		}
+
+		read_nic_dword(priv->ndev, ordinals->table1_addr + (ord << 2), 
+			       &addr);
+
+		write_nic_dword(priv->ndev, addr, *val);
+
+		*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+
+		return 0;
+	} 
+
+	IPW2100_DEBUG_INFO("wrong table\n");
+	if (IS_ORDINAL_TABLE_TWO(ordinals, ord)) 
+		return -EINVAL;
+
+	return -EINVAL;
+}
+
+/*
+ * 1. check if message in progress, ret EBUSY if so
+ * 2. issue command
+ * 3. wait for command to complete; timeout in 3s
+ */
+static int ipw2100_hw_send_command(struct ipw2100_priv *priv,
+				   struct host_command * cmd) 
+{
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	unsigned long flags;
+	int err = 0;
+
+	IPW2100_DEBUG_INFO("enter - '%s' (%d)\n",
+	       command_types[cmd->host_command],
+	       cmd->host_command);
+	
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	if (priv->fatal_error) {
+		IPW2100_DEBUG_INFO("Attempt to send command while hardware "
+				   "in fatal error condition.");
+		err = -EIO;
+		goto fail_unlock;
+	}
+
+	if (priv->stopped) {
+		IPW2100_DEBUG_INFO("Attempt to send command while hardware "
+				   "is not running.");
+		err = -EIO;
+		goto fail_unlock;
+	}
+
+	if (priv->message_sending) {
+		IPW2100_DEBUG_INFO("Attempt to send command while hardware "
+				   "another command is pending.");
+		err = -EBUSY;
+		goto fail_unlock;
+	}
+
+	if (list_empty(&priv->msg_free_list)) {
+		IPW2100_DEBUG_INFO("no available msg buffers\n");
+		goto fail_unlock;
+	}
+
+	priv->message_sending = 1;
+	priv->messages_sent++;
+
+	element = priv->msg_free_list.next;
+
+	packet = list_entry(element, struct ipw2100_hw_packet, list);
+	packet->jiffy_start = jiffies;
+
+	/* initialize the firmware command packet */
+	packet->cmd->host_command_reg = cmd->host_command;
+	packet->cmd->host_command_reg1 = cmd->host_command1;
+	packet->cmd->host_command_len_reg = cmd->host_command_length;
+	packet->cmd->sequence = cmd->host_command_sequence;
+
+	memcpy(packet->cmd->host_command_params_reg,
+	       cmd->host_command_parameters,
+	       sizeof(packet->cmd->host_command_params_reg));
+
+	list_del(element);
+	list_add_tail(element, &priv->msg_pend_list);
+
+	X__ipw2100_tx_send_commands(priv);
+	X__ipw2100_tx_send_data(priv);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	/*
+	 * We must wait for this command to complete before another
+	 * command can be sent...  but if we wait more than 3 seconds
+	 * then there is a problem.
+	 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = interruptible_sleep_on_timeout(&priv->wait_command_queue, 3 * HZ);
+#else
+	err = wait_event_interruptible_timeout(
+		priv->wait_command_queue, !priv->message_sending, 3 * HZ);
+#endif
+	if (err == 0) {
+		printk(KERN_WARNING 
+		       "%s: ipw2100_hw_send_command timed out.\n",
+		       priv->ndev->name);
+		priv->fatal_error = 1;
+		priv->message_sending = 0;
+		return -EIO;
+	}
+
+	if (priv->fatal_error) {
+		printk(KERN_WARNING "%s: firmware fatal error\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+
+	IPW2100_DEBUG_INFO("exit - command %d\n", cmd->host_command);
+
+	return 0;
+
+ fail_unlock:
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	return err;
+}
+
+
+/*
+ * Verify the values and data access of the hardware
+ * No locks needed or used.  No functions called.
+ */
+static int ipw2100_verify(struct ipw2100_priv *priv)
+{
+	u32 data1, data2;
+	u32 address;
+
+	u32 val1 = 0x76543210;
+	u32 val2 = 0xFEDCBA98;
+
+	/* Domain 0 check - all values should be DOA_DEBUG */
+	for (address = IPW_REG_DOA_DEBUG_AREA_START;
+	     address < IPW_REG_DOA_DEBUG_AREA_END;
+	     address += sizeof(u32)) {
+		read_register(priv->ndev, address, &data1);
+		if (data1 != IPW_DATA_DOA_DEBUG_VALUE)
+			return -EIO;
+	}
+
+	/* Domain 1 check - use arbitrary read/write compare  */
+	for (address = 0; address < 5; address++) {
+		/* The memory area is not used now */
+		write_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x32, 
+			       val1);
+		write_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x36, 
+			       val2);
+		read_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x32, 
+			      &data1);
+		read_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x36, 
+			      &data2);
+		if (val1 == data1 && val2 == data2)
+			return 0;
+	}
+
+	return -EIO;
+}
+
+/*
+ * 
+ * Loop until the CARD_DISABLED bit is the same value as the
+ * supplied parameter
+ *
+ * TODO: See if it would be more efficient to do a wait/wake
+ *       cycle and have the completion event trigger the wakeup
+ * 
+ */
+static int ipw2100_wait_for_card_state(struct ipw2100_priv *priv, int disabled)
+{
+	int i;
+	u32 card_disabled;
+	u32 len = sizeof(card_disabled);
+	int err;
+	
+	for (i = 0; i <= IPW_CARD_DISABLE_COMPLETE_WAIT * 1000; i += 50) {
+		err = ipw2100_get_ordinal(priv, IPW_ORD_CARD_DISABLED, 
+					  &card_disabled, &len);
+		if (err) {
+			IPW2100_DEBUG_INFO("query failed.\n");
+			break;
+		}
+
+		/* We'll break out if either the HW state says it is
+		 * in the state we want, or if HOST_COMPLETE command
+		 * finishes */
+		if (card_disabled == disabled ||
+		    priv->disabled == disabled) {
+			priv->disabled = disabled;
+			return 0;
+		}
+
+		udelay(50);
+	}
+
+	if (i >= IPW_CARD_DISABLE_COMPLETE_WAIT * 1000) {
+		IPW2100_DEBUG_INFO("ipw2100_wait_for_card_state to %s state "
+				   "timed out\n", 
+				   disabled ? "DISABLED" : "ENABLED");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+/*********************************************************************
+    Procedure   :   sw_reset_and_clock
+    Purpose     :   Asserts s/w reset, asserts clock initialization 
+                    and waits for clock stabilization
+ ********************************************************************/
+static int sw_reset_and_clock(struct ipw2100_priv *priv)
+{
+	int i;
+	u32 r;
+
+	// assert s/w reset
+	write_register(priv->ndev, IPW_REG_RESET_REG, 
+		       IPW_AUX_HOST_RESET_REG_SW_RESET);
+
+	// wait for clock stabilization
+	for (i = 0; i < 1000; i++) {
+		udelay(IPW_WAIT_RESET_ARC_COMPLETE_DELAY);
+
+		// check clock ready bit
+		read_register(priv->ndev, IPW_REG_RESET_REG, &r);
+		if (r & IPW_AUX_HOST_RESET_REG_PRINCETON_RESET)
+			break;
+	}
+
+	if (i == 1000)
+		return -EIO;	// TODO: better error value
+
+	/* set "initialization complete" bit to move adapter to 
+	 * D0 state */
+	write_register(priv->ndev, IPW_REG_GP_CNTRL,
+		       IPW_AUX_HOST_GP_CNTRL_BIT_INIT_DONE);
+
+	/* wait for clock stabilization */
+	for (i = 0; i < 10000; i++) {
+		udelay(IPW_WAIT_CLOCK_STABILIZATION_DELAY * 4);
+
+		/* check clock ready bit */
+		read_register(priv->ndev, IPW_REG_GP_CNTRL, &r);
+		if (r & IPW_AUX_HOST_GP_CNTRL_BIT_CLOCK_READY)
+			break;
+	}
+
+	if (i == 10000)
+		return -EIO;	/* TODO: better error value */
+
+//#if CONFIG_IPW2100_D0ENABLED
+	/* set D0 standby bit */
+	read_register(priv->ndev, IPW_REG_GP_CNTRL, &r);
+	write_register(priv->ndev, IPW_REG_GP_CNTRL,
+		       r | IPW_AUX_HOST_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);
+//#endif
+
+	return 0;
+}
+
+/*********************************************************************
+    Procedure   :   ipw2100_ipw2100_download_firmware
+    Purpose     :   Initiaze adapter after power on.
+                    The sequence is:
+                    1. assert s/w reset first!
+                    2. awake clocks & wait for clock stabilization
+                    3. hold ARC (don't ask me why...)
+                    4. load Dino ucode and reset/clock init again
+                    5. zero-out shared mem
+                    6. download f/w
+ *******************************************************************/
+static int ipw2100_download_firmware(struct ipw2100_priv *priv)
+{
+	u32 address;
+	int err;
+
+	/* Fetch the firmware and microcode */
+	struct ipw2100_fw fw;
+	
+	if (priv->fatal_error) {
+		printk(KERN_ERR "%s: ipw2100_download_firmware called after "
+		       "fatal error %d.  Interface must be brought down.\n",
+		       priv->ndev->name, priv->fatal_error);
+		return -EINVAL;
+	}
+
+	err = ipw2100_get_firmware(priv, &fw);
+	if (err) {
+		printk(KERN_ERR "%s: ipw2100_get_firmware failed: %d\n",
+		       priv->ndev->name, err);
+		priv->fatal_error = 101;
+		return err;
+	}
+	priv->firmware_version = fw.version;
+
+	/* s/w reset and clock stabilization */
+	err = sw_reset_and_clock(priv);
+	if (err) {
+		printk(KERN_ERR "%s: sw_reset_and_clock failed: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	err = ipw2100_verify(priv);
+	if (err) {
+		printk(KERN_ERR "%s: ipw2100_verify failed: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	/* Hold ARC */
+	write_nic_dword(priv->ndev,
+			IPW_INTERNAL_REGISTER_HALT_AND_RESET,
+			0x80000000);
+
+	/* allow ARC to run */
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+
+	/* load microcode */
+	err = ipw2100_ucode_download(priv, &fw);
+	if (err) {
+		printk(KERN_ERR "%s: Error loading microcode: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	/* release ARC */
+	write_nic_dword(priv->ndev,
+			IPW_INTERNAL_REGISTER_HALT_AND_RESET,
+			0x00000000);
+
+	/* s/w reset and clock stabilization (again!!!) */
+	err = sw_reset_and_clock(priv);
+	if (err) {
+		printk(KERN_ERR "%s: sw_reset_and_clock failed: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	/* load f/w */
+	err = ipw2100_fw_download(priv, &fw);
+	if (err) {
+		printk(KERN_ERR "%s: Error loading firmware: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+	
+	/* free any storage allocated for firmware image */
+	ipw2100_release_firmware(priv, &fw);
+
+	/* zero out Domain 1 area indirectly (Si requirement) */
+	for (address = IPW_HOST_FW_SHARED_AREA0; 
+	     address < IPW_HOST_FW_SHARED_AREA0_END; address += 4) 
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_SHARED_AREA1; 
+	     address < IPW_HOST_FW_SHARED_AREA1_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_SHARED_AREA2; 
+	     address < IPW_HOST_FW_SHARED_AREA2_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_SHARED_AREA3; 
+	     address < IPW_HOST_FW_SHARED_AREA3_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_INTERRUPT_AREA; 
+	     address < IPW_HOST_FW_INTERRUPT_AREA_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+
+	return 0;
+
+ fail:
+	ipw2100_release_firmware(priv, &fw);
+	return err;
+}
+
+static inline void ipw2100_hw_disable_interrupt(struct ipw2100_priv *priv)
+{
+	write_register(priv->ndev, IPW_REG_INTA_MASK, 0x0);
+}
+
+static inline void ipw2100_hw_enable_interrupt(struct ipw2100_priv *priv)
+{
+	write_register(priv->ndev, IPW_REG_INTA_MASK, IPW_INTERRUPT_MASK);
+}
+
+static void ipw2100_initialize_ordinals(struct ipw2100_priv *priv)
+{
+	struct ipw2100_ordinals *ord = &priv->ordinals;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_1,
+		      &ord->table1_addr);
+
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_2,
+		      &ord->table2_addr);
+
+	read_nic_dword(priv->ndev, ord->table1_addr, &ord->table1_size);
+	read_nic_dword(priv->ndev, ord->table2_addr, &ord->table2_size);
+
+	ord->table2_size &= 0x0000FFFF;
+
+	IPW2100_DEBUG_INFO("table 1 size: %d\n", ord->table1_size);
+	IPW2100_DEBUG_INFO("table 2 size: %d\n", ord->table2_size);
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static inline void ipw2100_hw_set_gpio(struct ipw2100_priv *priv)
+{
+	u32 reg = 0;
+	/*
+	 * Set GPIO 3 writable by FW; GPIO 1 writable 
+	 * by driver and enable clock
+	 */
+	reg = (IPW_BIT_GPIO_GPIO3_MASK | IPW_BIT_GPIO_GPIO1_ENABLE |
+	       IPW_BIT_GPIO_LED_OFF);
+	write_register(priv->ndev, IPW_REG_GPIO, reg);
+}
+
+static inline int ipw2100_get_rf_switch(struct ipw2100_priv *priv)
+{
+#define MAX_RF_KILL_CHECKS 5
+#define RF_KILL_CHECK_DELAY 40
+#define RF_KILL_CHECK_THRESHOLD 3
+	
+	unsigned short value = 0;
+	u32 reg = 0;
+	int i;
+	
+	if (!(priv->hw_features & HW_FEATURE_RFKILL)) 
+		return 0;
+
+	for (i = 0; i < MAX_RF_KILL_CHECKS; i++) {
+		udelay(RF_KILL_CHECK_DELAY);
+		read_register(priv->ndev, IPW_REG_GPIO, &reg);
+		value = (value << 1) | ((reg & IPW_BIT_GPIO_RF_KILL) ? 0 : 1);
+	}
+
+	return (value == 0);
+}
+
+static int ipw2100_get_hw_features(struct ipw2100_priv *priv)
+{
+	u32 addr, len;
+	u32 val;
+
+	/* 
+	 * EEPROM_SRAM_DB_START_ADDRESS using ordinal in ordinal table 1
+	 */
+	len = sizeof(addr);
+	if (ipw2100_get_ordinal(
+		    priv, IPW_ORD_EEPROM_SRAM_DB_BLOCK_START_ADDRESS,
+		    &addr, &len)) {
+		printk(KERN_INFO "failed querying ordinals at line %d\n", 
+		       __LINE__);
+		return -EIO;
+	}
+
+	IPW2100_DEBUG_INFO("EEPROM address: %08X\n", addr);
+ 
+	/*
+	 * EEPROM version is the byte at offset 0xfd in firmware
+	 * We read 4 bytes, then shift out the byte we actually want */ 
+	read_nic_dword(priv->ndev, addr + 0xFC, &val);
+	priv->eeprom_version = (val >> 24) & 0xFF;
+	IPW2100_DEBUG_INFO("EEPROM version: %d\n", priv->eeprom_version);
+
+        /*
+	 *  HW RF Kill enable is bit 0 in byte at offset 0x21 in firmware
+	 *
+	 *  notice that the EEPROM bit is reverse polarity, i.e.
+	 *     bit = 0  signifies HW RF kill switch is supported
+	 *     bit = 1  signifies HW RF kill switch is NOT supported
+	 */
+	read_nic_dword(priv->ndev, addr + 0x20, &val);
+	if (!((val >> 24) & 0x01))
+		priv->hw_features |= HW_FEATURE_RFKILL;
+
+	IPW2100_DEBUG_INFO("HW RF Kill: %ssupported.\n",
+			   (priv->hw_features & HW_FEATURE_RFKILL) ?
+			   "" : "not ");
+
+	return 0;
+}
+
+static int ipw2100_beacons_allocate(struct ipw2100_priv *priv)
+{
+	if (priv->beacons)
+		return 0;
+
+	IPW2100_DEBUG_SCAN("Allocating %d beacon slots.\n", 
+			   MAX_BEACON_COUNT);
+
+	priv->beacons = (struct ipw2100_beacon *)kmalloc(
+		MAX_BEACON_COUNT * sizeof(struct ipw2100_beacon),
+		GFP_KERNEL);
+	if (!priv->beacons) {
+		printk(KERN_WARNING DRV_NAME 
+		       ": Out of memory allocating beacons\n");
+		return -ENOMEM;
+	}
+
+	memset(priv->beacons, 0, 
+	       MAX_BEACON_COUNT * sizeof(struct ipw2100_beacon));
+
+	return 0;
+}
+
+static void ipw2100_beacons_free(struct ipw2100_priv *priv)
+{
+	if (!priv->beacons)
+		return;
+	kfree(priv->beacons);
+	priv->beacons = NULL;
+}
+
+static void ipw2100_beacons_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	INIT_LIST_HEAD(&priv->beacon_free_list);
+	INIT_LIST_HEAD(&priv->beacon_list);
+	for (i = 0; i < MAX_BEACON_COUNT; i++) 
+		list_add_tail(&priv->beacons[i].list, &priv->beacon_free_list);
+}
+
+/*
+ * Start firmware execution after power on and intialization
+ * The sequence is:
+ *  1. Release ARC
+ *  2. Wait for f/w initialization completes;
+ */
+static int ipw2100_start_adapter(struct ipw2100_priv *priv)
+{
+#define IPW_WAIT_FW_INIT_COMPLETE_DELAY (40 * HZ / 1000)
+	int i;
+	u32 r;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (!priv->stopped)
+		return 0;
+
+	/*
+	 * Initialize the hw - drive adapter to DO state by setting 
+	 * init_done bit. Wait for clk_ready bit and Download 
+	 * fw & dino ucode
+	 */
+	if (ipw2100_download_firmware(priv)) {
+		printk(KERN_ERR "%s: Failed to power on the adapter.\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+	
+	/* Clear the Tx, Rx and Msg queues and the r/w indexes
+	 * in the firmware RBD and TBD ring queue */
+	ipw2100_queues_initialize(priv);
+	ipw2100_beacons_initialize(priv);
+
+#ifndef CONFIG_IPW2100_WEP
+	ipw2100_defrag_initialize(priv);
+#endif
+		
+	ipw2100_hw_set_gpio(priv);
+
+	/* Release ARC - clear reset bit */
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+
+	/* wait for f/w intialization complete */
+	i = 5000;
+	do {
+  		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(IPW_WAIT_FW_INIT_COMPLETE_DELAY);
+
+		read_register(priv->ndev, IPW_REG_INTA, &r);
+
+		/* check "init done" bit */
+		if (r & IPW2100_INTA_FW_INIT_DONE) {
+			/* reset "init done" bit */
+			write_register(priv->ndev, IPW_REG_INTA,
+				       IPW2100_INTA_FW_INIT_DONE);
+			break;
+		}
+
+		/* check error conditions : we check these after the firmware
+		 * check so that if there is an error, the interrupt handler
+		 * will see it and the adapter will be reset */
+		if (r & 
+		    (IPW2100_INTA_FATAL_ERROR | IPW2100_INTA_PARITY_ERROR)) {
+			/* clear error conditions */
+			write_register(priv->ndev, IPW_REG_INTA,
+				       IPW2100_INTA_FATAL_ERROR |
+				       IPW2100_INTA_PARITY_ERROR);
+		}
+
+
+	} while (i--);
+
+	/* Start firmware hang check timer */
+	if (priv->stop_hang_check) {
+		priv->stop_hang_check = 0;
+		priv->hang_check_timer.expires = jiffies + 2 * HZ;
+		add_timer(&priv->hang_check_timer);
+	}
+	
+	if (!i) {
+		printk(KERN_WARNING "%s: Firmware did not initialized.\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+
+	/* allow firmware to write to GPIO1 & GPIO3 */
+	read_register(priv->ndev, IPW_REG_GPIO, &r);
+
+	r |= (IPW_BIT_GPIO_GPIO1_MASK | IPW_BIT_GPIO_GPIO3_MASK);
+
+	write_register(priv->ndev, IPW_REG_GPIO, r);
+
+	priv->stopped = 0;
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static inline void ipw2100_reset_sw(struct ipw2100_priv *priv)
+{
+	/* Forget whatever we know about any associated SSIDs... */
+	memset(priv->ctx->ssid, 0, sizeof(priv->ctx->ssid));
+	priv->ctx->port_type = BSS;
+	priv->ctx->channel = 1;
+	
+	ipw2100_hw_set_gpio(priv);
+
+	/* SW Reset the adapter */
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+}
+
+/* NOTE: Our interrupt is disabled when this method is called */
+static int ipw2100_power_cycle_adapter(struct ipw2100_priv *priv)
+{
+	u32 reg;
+	int i;
+
+	IPW2100_DEBUG_INFO("Power cycling the hardware.\n");
+
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+
+	ipw2100_hw_set_gpio(priv);
+
+	/* Step 1. Stop Master Assert */
+	write_nic_dword(priv->ndev, IPW_REG_RESET_REG, 
+			IPW_AUX_HOST_RESET_REG_STOP_MASTER);    
+	
+	/* Step 2. Wait for stop Master Assert 
+	 *         (not more then 50us, otherwise ret error */
+	i = 5;
+	do {
+		udelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);
+		read_register(priv->ndev, IPW_REG_RESET_REG, &reg);
+		
+		if (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)
+			break;
+	}  while(i--);
+
+	priv->reset_pending = 0;
+
+	if (!i) {
+		IPW2100_DEBUG_INFO("exit - waited too long for master assert "
+		       "stop\n");
+		return -EIO;
+	}
+
+	write_register(priv->ndev, IPW_REG_RESET_REG, 
+		       IPW_AUX_HOST_RESET_REG_SW_RESET);
+
+	
+	/* Reset any fatal_error conditions */
+	priv->fatal_error = 0;
+
+	/* At this point, the adapter is now stopped and disabled */
+	priv->stopped = 1;
+	priv->disabled = 1;
+
+	return 0;
+}
+
+/*
+ * Send the CARD_DISABLE_PHY_OFF comamnd to the card to disable it
+ *
+ * After disabling, if the card was associated, a STATUS_ASSN_LOST will be sent.
+ *
+ * STATUS_CARD_DISABLE_NOTIFICATION will be sent regardless of
+ * if STATUS_ASSN_LOST is sent.
+ */
+static int ipw2100_hw_phy_off(struct ipw2100_priv *priv)
+{
+
+#define HW_PHY_OFF_LOOP_DELAY (HZ / 5000)
+
+	struct host_command cmd = {
+		.host_command = CARD_DISABLE_PHY_OFF,
+		.host_command_sequence = 0,
+		.host_command_length = 0,
+	};
+	int err, i;
+	u32 val1, val2;
+
+	if (priv->phy_off == 1)
+		return 0;
+
+	IPW2100_DEBUG_FW_COMMAND("CARD_DISABLE_PHY_OFF\n");
+
+	/* Turn off the radio */
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) 
+		return err;
+
+	for (i = 0; i < 2500; i++) {
+		read_nic_dword(priv->ndev, IPW2100_CONTROL_REG, &val1);
+		read_nic_dword(priv->ndev, IPW2100_COMMAND, &val2);
+
+		if ((val1 & IPW2100_CONTROL_PHY_OFF) &&
+		    (val2 & IPW2100_COMMAND_PHY_OFF)) {
+			priv->phy_off = 1;
+			return 0;
+		}
+		
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HW_PHY_OFF_LOOP_DELAY);
+	}
+
+	return -EIO;
+}
+
+
+static int ipw2100_enable_adapter(struct ipw2100_priv *priv)
+{	
+	struct host_command cmd = {
+		.host_command = HOST_COMPLETE,
+		.host_command_sequence = 0,
+		.host_command_length = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("HOST_COMPLETE\n");
+	
+	if (!priv->disabled) 
+		return 0;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) {
+		IPW2100_DEBUG_INFO("Failed to send HOST_COMPLETE command\n");
+		return err;
+	}
+
+	err = ipw2100_wait_for_card_state(priv, STATE_ENABLED);
+	if (err) {
+		printk(KERN_WARNING 
+		       "%s: card not responding to init command.\n",
+		       priv->ndev->name);
+		return err;
+	}
+
+	IPW2100_DEBUG_INFO("TODO: implement scan state machine\n");
+
+	return 0;
+}
+
+static int ipw2100_hw_stop_adapter(struct ipw2100_priv *priv)
+{
+#define HW_POWER_DOWN_DELAY (HZ / 10)
+
+	struct host_command cmd = {
+		.host_command = HOST_PRE_POWER_DOWN,
+		.host_command_sequence = 0,
+		.host_command_length = 0,
+	};
+	int err, i;
+	u32 reg;
+
+	if (priv->stopped)
+		return 0;
+
+	/* We can only shut down the card if the firmware is operational.  So,
+	 * if we haven't reset since a fatal_error, then we can not send the
+	 * shutdown commands. */
+	if (priv->fatal_error) {
+		/* First, make sure the adapter is enabled so that the PHY_OFF 
+		 * command can shut it down */
+		ipw2100_enable_adapter(priv);
+
+		err = ipw2100_hw_phy_off(priv);
+		if (err) 
+			IPW2100_DEBUG_WARNING("Error disabling radio %d\n", err);
+		
+		/*
+		 * If in D0-standby mode going directly to D3 may cause a
+		 * PCI bus violation.  Therefore we must change out of the D0 
+		 * state.
+		 *
+		 * Sending the PREPARE_FOR_POWER_DOWN will restrict the 
+		 * hardware from going into standby mode and will transition 
+		 * out of D0-standy if it is already in that state.
+		 * 
+		 * STATUS_PREPARE_POWER_DOWN_COMPLETE will be sent by the
+		 * driver upon completion.  Once received, the driver can 
+		 * proceed to the D3 state.
+		 *
+		 * Prepare for power down command to fw.  This command would 
+		 * take HW out of D0-standby and prepare it for D3 state.
+		 * 
+		 * Currently FW does not support event notification for this 
+		 * event. Therefore, skip waiting for it.  Just wait a fixed 
+		 * 100ms
+		 */
+		IPW2100_DEBUG_FW_COMMAND("HOST_PRE_POWER_DOWN\n");
+		
+		err = ipw2100_hw_send_command(priv, &cmd);
+		if (err) 
+			printk(KERN_WARNING 
+			       "%s: Power down command failed: Error %d\n",
+			       priv->ndev->name, err);
+		else {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(HW_POWER_DOWN_DELAY);
+		}
+	}
+	
+	priv->disabled = 1;
+
+	/*
+	 * Set GPIO 3 writable by FW; GPIO 1 writable 
+	 * by driver and enable clock
+	 */
+	ipw2100_hw_set_gpio(priv);
+
+	/*
+	 * Power down adapter.  Sequence:
+	 * 1. Stop master assert (RESET_REG[9]=1)
+	 * 2. Wait for stop master (RESET_REG[8]==1)
+	 * 3. S/w reset assert (RESET_REG[7] = 1)
+	 */
+
+	/* Stop master assert */
+	write_register(priv->ndev, IPW_REG_RESET_REG,
+		       IPW_AUX_HOST_RESET_REG_STOP_MASTER);
+
+	/* wait stop master not more than 50 usec. 
+	 * Otherwise return error. */
+	for (i = 5; i > 0; i--) {
+		udelay(10);
+
+		/* Check master stop bit */
+		read_register(priv->ndev, IPW_REG_RESET_REG, &reg);
+
+		if (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)
+			break;
+	}
+
+	if (i == 0) 
+		printk(KERN_WARNING DRV_NAME 
+		       ": %s: Could now power down adapter.\n", 
+		       priv->ndev->name);
+
+	/* assert s/w reset */
+	write_register(priv->ndev, IPW_REG_RESET_REG,
+		       IPW_AUX_HOST_RESET_REG_SW_RESET);
+
+	priv->stopped = 1;
+
+	return 0;
+}
+
+
+static int ipw2100_disable_adapter(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = CARD_DISABLE,
+		.host_command_sequence = 0,
+		.host_command_length = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("CARD_DISABLE\n");
+
+	if (priv->disabled) 
+		return 0;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) {
+		IPW2100_DEBUG_WARNING("exit - failed to send CARD_DISABLE "
+				      "command\n");
+		return err;
+	}
+
+	err = ipw2100_wait_for_card_state(priv, STATE_DISABLED);
+	if (err) {
+		IPW2100_DEBUG_WARNING("exit - card failed to change to "
+				      "DISABLED\n");
+		return err;
+	}
+
+	IPW2100_DEBUG_INFO("TODO: implement scan state machine\n");
+
+
+	return 0;
+}
+
+
+static int ipw2100_up(struct ipw2100_priv *priv)
+{
+	unsigned long flags;
+	int rc = 0;
+	u32 lock;
+	u32 ord_len = sizeof(lock);
+
+	/* If the interrupt is enabled, turn it off... */
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (priv->irq_enabled) {
+		ipw2100_hw_disable_interrupt(priv);
+		priv->irq_enabled = 0;
+	}
+
+	/* Reset any fatal_error conditions */
+	priv->fatal_error = 0;
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	if (priv->been_powered || priv->reset_pending) {
+		/* Power cycle the card ... */
+		if (ipw2100_power_cycle_adapter(priv)) {
+			printk(KERN_WARNING DRV_NAME 
+			       ": Could not cycle adapter.\n");
+			rc = 1;
+			goto exit;
+		}
+	} else 
+		priv->been_powered = 1;
+
+	/* Load the firmeware, start the clocks, etc. */
+	if (ipw2100_start_adapter(priv)) {
+	       	printk(KERN_ERR "%s: Failed to start the firmware.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+	ipw2100_initialize_ordinals(priv);
+	
+	/* Determine capabilities of this particular HW configuration */
+	if (ipw2100_get_hw_features(priv)) {
+		printk(KERN_ERR "%s: Failed to determine HW features.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+	lock = LOCK_NONE;
+	if (ipw2100_set_ordinal(priv, IPW_ORD_PERS_DB_LOCK, &lock, &ord_len)) {
+		printk(KERN_ERR "%s: Failed to clear ordinal lock.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+	/* Turn on the interrupt so that commands can be processed */
+	ipw2100_hw_enable_interrupt(priv);
+	priv->irq_enabled = 1;
+	
+	/* Send all of the commands that must be sent prior to 
+	 * HOST_COMPLETE */
+	if (ipw2100_adapter_setup(priv)) {
+		printk(KERN_ERR "%s: Failed to start the card.\n", 
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+        /* Enable the adapter - sends HOST_COMPLETE */
+	if (ipw2100_enable_adapter(priv)) {
+		printk(KERN_ERR "%s: failed in call to enable adapter.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+
+	/* Start a scan . . . */
+	ipw2100_start_scan(priv);
+
+ exit:
+	return rc;
+}
+
+
+static void ipw2100_down(struct ipw2100_priv *priv)
+{
+	unsigned long flags;
+
+	/* Kill the RF switch timer */
+	if (!priv->stop_rf_check) {
+		priv->stop_rf_check = 1;
+		del_timer_sync(&priv->rf_switch_timer);
+	}
+	
+	/* Kill the firmare hang check timer */
+	if (!priv->stop_hang_check) {
+		priv->stop_hang_check = 1;
+		del_timer_sync(&priv->hang_check_timer);
+	}
+
+	/* Make sure the interrupt is on so that FW commands will be 
+	 * processed correctly */
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (!priv->irq_enabled) {
+		ipw2100_hw_enable_interrupt(priv);
+		priv->irq_enabled = 1;
+	}
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+	
+	if (ipw2100_hw_stop_adapter(priv)) 
+		printk(KERN_ERR "%s: Error stopping adapter.\n", 
+		       priv->ndev->name);
+	
+	/* Do not disable the interrupt until _after_ we disable
+	 * the adaptor.  Otherwise the CARD_DISABLE command will never
+	 * be ack'd by the firmware */
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (priv->irq_enabled) {
+		ipw2100_hw_disable_interrupt(priv);
+		priv->irq_enabled = 0;
+	}
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+}
+
+static void ipw2100_reset_adapter(struct ipw2100_priv *priv)
+{
+	printk(KERN_INFO DRV_NAME ": %s: Restarting adapter.\n", 
+	       priv->ndev->name);
+
+	priv->resets++;
+	priv->connected = 0;
+	
+	/* Force a power cycle even if interface hasn't been opened
+	 * yet */
+	priv->reset_pending = 1;
+	memset(priv->key_table, 0, sizeof(priv->key_table));
+	memset(priv->key_size, 0, sizeof(priv->key_size));
+	priv->key_current = 0;
+	priv->authentication = 0;
+
+	ipw2100_up(priv);
+
+}
+
+
+static void isr_indicate_associated(struct ipw2100_priv *priv, u32 status)
+{
+
+#define MAC_ASSOCIATION_READ_DELAY (HZ)
+	int ret;
+	int len;
+	char essid[IW_ESSID_MAX_SIZE + 1];
+	u32 txrate;
+	u32 chan;
+	char *txratename;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/*
+	 * TBD: BSSID is usually 00:00:00:00:00:00 here and not
+	 *      an actual MAC of the AP. Seems like FW sets this
+	 *      address too late. Read it later and expose through 
+	 *      /proc or schedule a later task to query and update
+	 */
+#if 0
+	len = ETH_ALEN;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, 
+				  &priv->ctx->bssid,  &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+#endif
+
+	memset(essid, 0, IW_ESSID_MAX_SIZE + 1);
+
+	len = IW_ESSID_MAX_SIZE;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID, 
+				  essid, &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+
+	len = sizeof(u32);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, 
+				  &txrate, &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+
+	len = sizeof(u32);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+
+	switch (txrate) {
+	case TX_RATE_1_MBIT:
+		txratename = "1Mbps";
+		break;
+	case TX_RATE_2_MBIT:
+		txratename = "2Mbsp";
+		break;
+	case TX_RATE_5_5_MBIT:
+		txratename = "5.5Mbps";
+		break;
+	case TX_RATE_11_MBIT:
+		txratename = "11Mbps";
+		break;
+	default:
+		txratename = "unknown rate";
+		break;
+	}
+
+	printk(KERN_INFO DRV_NAME 
+	       ": Associated with '%s' at %s, channel %d\n",
+	       essid, txratename, chan);
+
+	/* now we copy read ssid into dev */
+	memcpy(priv->ctx->ssid, essid, IW_ESSID_MAX_SIZE);
+	priv->ctx->channel = chan;
+
+	priv->connected = 1;
+	netif_carrier_on(priv->ndev);
+	netif_wake_queue(priv->ndev);
+}
+
+static void isr_indicate_association_lost(struct ipw2100_priv *priv, u32 status)
+{
+#if 0
+	struct host_command cmd = {
+		.host_command = BROADCAST_SCAN,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+	};
+#endif
+
+	printk(KERN_DEBUG "%s: Association lost.\n", priv->ndev->name);
+
+	IPW2100_DEBUG_INFO("TODO: only scan if scanning enabled and "
+	       "radio is on\n");
+
+	IPW2100_DEBUG_INFO("TODO: Move broadcast_scan initiation to scheduled "
+	       "work\n");
+
+#if 0
+	ipw2100_hw_send_command(priv, &cmd);
+#endif
+
+	priv->connected = 0;
+	netif_carrier_off(priv->ndev);
+	netif_stop_queue(priv->ndev);
+}
+
+static void isr_indicate_rf_kill(struct ipw2100_priv *priv, u32 status)
+{
+	IPW2100_DEBUG_RF_KILL("RF Kill state changed to radio OFF.\n");
+
+	/* RF_KILL is now enabled (else we wouldn't be here) */
+	priv->rf_kill = 1;
+
+	/* If not already running, we now fire up a timer that will poll
+	 * the state of the RF switch on the hardware so we can re-enable
+	 * the firmware if the switch is enabled */
+	if (priv->stop_rf_check) {
+		priv->stop_rf_check = 0;
+		priv->rf_switch_timer.expires = jiffies + HZ;
+		add_timer(&priv->rf_switch_timer);
+	}
+}
+
+static void isr_scan_complete(struct ipw2100_priv *priv, u32 status)
+{
+	IPW2100_DEBUG_SCAN("scan complete\n");
+}
+
+#ifdef CONFIG_IPW2100_DEBUG
+#define IPW2100_HANDLER(v, f) { v, f, # v }
+struct ipw2100_status_indicator {
+	int status;
+	void (*cb)(struct ipw2100_priv *priv, u32 status);
+	char *name;
+};
+#else
+#define IPW2100_HANDLER(v, f) { v, f }
+struct ipw2100_status_indicator {
+	int status;
+	void (*cb)(struct ipw2100_priv *priv, u32 status);
+};
+#endif /* CONFIG_IPW2100_DEBUG */
+
+const struct ipw2100_status_indicator status_handlers[] = {
+	IPW2100_HANDLER(STATUS_INIT_COMPLETE, 0),
+	IPW2100_HANDLER(STATUS_COUNTRY_FOUND, 0),
+	IPW2100_HANDLER(STATUS_ASSOCIATED, isr_indicate_associated),
+	IPW2100_HANDLER(STATUS_ASSN_LOST, isr_indicate_association_lost),
+	IPW2100_HANDLER(STATUS_ASSN_CHANGED, 0),
+	IPW2100_HANDLER(STATUS_SCAN_COMPLETE, isr_scan_complete),
+	IPW2100_HANDLER(STATUS_ENTERED_PSP, 0),
+	IPW2100_HANDLER(STATUS_WAKEN_FROM_PSP, 0),
+	IPW2100_HANDLER(STATUS_RF_KILL_SWITCH, isr_indicate_rf_kill),
+	IPW2100_HANDLER(STATUS_CARD_DISABLE_COMPLETE, 0),
+	IPW2100_HANDLER(STATUS_PREP_PWR_DOWN_COMPLETE, 0),
+	IPW2100_HANDLER(STATUS_SCANNING, 0),
+	IPW2100_HANDLER(-1, 0)
+};
+
+static void isr_status_change(struct ipw2100_priv *priv, int status)
+{
+	int i;
+
+	for (i = 0; status_handlers[i].status != -1; i++) {
+		if (status == status_handlers[i].status) {
+			IPW2100_DEBUG_STATUS("Status change: %s\n", 
+					     status_handlers[i].name);
+			if (status_handlers[i].cb)
+				status_handlers[i].cb(priv, status);
+			priv->wstats.status = status;
+			return;
+		}
+	}
+
+	IPW2100_DEBUG_STATUS("unknown status received: %04x\n", status);
+}
+
+static void isr_indicate_host_notification(struct ipw2100_priv *priv,
+					   struct ipw2100_notification * hdr)
+{
+
+#ifdef CONFIG_IPW2100_DEBUG
+
+	char *notif;
+
+	switch (hdr->hnhdr_subtype) {
+	case TYPE_SWEEP_ORD:
+		notif = "TYPE_SWEEP_ORD";
+		break;
+	case TYPE_IBSS_STTN_ORD:
+		notif = "TYPE_IBSS_STTN_ORD";
+		break;
+	case TYPE_BSS_AP_ORD:
+		notif = "TYPE_BSS_AP_ORD";
+		break;
+	case TYPE_CALIBRATION_DATA:
+		notif = "TYPE_CALIBRATION_DATA";
+		break;
+	case TYPE_RAW_BEACON_ENTRY:
+		notif = "TYPE_RAW_BEACON_ENTRY";
+		break;
+	case TYPE_ROGUE_AP_DATA:
+		notif = "TYPE_ROGUE_AP_DATA";
+		break;
+	case TYPE_ASSOCIATION_REQUEST:
+		notif = "TYPE_ASSOCIATION_REQUEST";
+		break;
+	case TYPE_REASSOCIATION_REQUEST:
+		notif = "TYPE_REASSOCIATION_REQUEST";
+		break;
+	default:
+		notif = "*UNKNOWN*";
+		break;
+	}
+
+	IPW2100_DEBUG_INFO("received %s host notification, size %d\n",
+	     notif, hdr->hnhdr_size);
+#endif
+}
+
+
+
+static void isr_rx_complete_command(
+	struct ipw2100_priv *priv,
+	struct ipw2100_cmd_header *cmd)
+{
+#ifdef CONFIG_IPW2100_DEBUG
+	if (cmd->host_command_reg < sizeof(command_types) / 
+	    sizeof(*command_types)) {
+		IPW2100_DEBUG_RX("Command '%s (%d)' completed\n",
+				 command_types[cmd->host_command_reg],
+				 cmd->host_command_reg);
+	}
+#endif
+	if (cmd->host_command_reg == HOST_COMPLETE) {
+		priv->disabled = 0;
+	}
+	if (cmd->host_command_reg == CARD_DISABLE) {
+		priv->disabled = 1;
+	}
+	if (cmd->host_command_reg == CARD_DISABLE_PHY_OFF) {
+		priv->phy_off = 1;
+	}
+
+	priv->message_sending = 0;
+
+	wake_up_interruptible_sync(&priv->wait_command_queue);
+
+#ifdef CONFIG_IPW2100_DEBUG
+	IPW2100_DEBUG_INFO("received command status:\n");
+	IPW2100_DEBUG_INFO("    CMD    = %d\n", cmd->host_command_reg);
+	IPW2100_DEBUG_INFO("    CMD1   = %08x\n", cmd->host_command_reg1);
+	IPW2100_DEBUG_INFO("    SEQ    = %d\n", cmd->sequence);
+	IPW2100_DEBUG_INFO("    STATUS = %d\n", cmd->cmd_status_reg);
+#endif
+
+}
+
+static  void isr_handle_ctl_packet(
+	struct ipw2100_priv *priv, 
+	struct ipw2100_802_11_header *header,
+	struct ipw2100_status *status)
+{
+	IPW2100_DEBUG_RX("Ignoring control frame.\n");
+}
+
+static inline void isr_beacon_add(
+	struct ipw2100_priv *priv,
+	struct ipw2100_802_11_probe_response *new_beacon,
+	s8 rssi)
+{
+	struct list_head *element;
+	struct ipw2100_beacon *beacon;
+	struct ipw2100_802_11_info_element *info_element;
+
+	element = priv->beacon_free_list.next;
+	
+	beacon = list_entry(element, struct ipw2100_beacon, list);
+	
+	/* Pull out fixed field data */
+	memcpy(beacon->bssid, new_beacon->header.address3, ETH_ALEN);
+	beacon->capability = new_beacon->capability;
+	beacon->rssi = rssi;
+	
+	/* First info element is the SSID */
+	info_element = &new_beacon->info_element;
+	if (info_element->id != MFIE_TYPE_SSID) {
+		printk(KERN_INFO DRV_NAME ": invalid MFIE type for SSID.\n");
+		IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+				   info_element->id);
+		return;
+	}
+	beacon->ssid_len = min(info_element->len, SSID_LENGTH);
+	memcpy(beacon->ssid, info_element->data, beacon->ssid_len);
+
+	/* Second info element is the RATES */
+	info_element = (struct ipw2100_802_11_info_element *)
+		&info_element->data[info_element->len];
+	if (info_element->id != MFIE_TYPE_RATES) {
+		printk(KERN_INFO DRV_NAME ": invalid MFIE type for RATES.\n");
+		IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+				   info_element->id);
+		return;
+	}
+	beacon->rates_len = min(info_element->len, MAX_RATES_LENGTH);
+	memcpy(beacon->rates, info_element->data, beacon->rates_len);
+
+	/* Third info element is either FH or DS, based on BSS capability */
+	info_element = (struct ipw2100_802_11_info_element *)
+		&info_element->data[info_element->len];
+	if (beacon->capability & SSID_CAPABILITY_BSS) {
+		/* BSS - Direct Sequence */
+		if (info_element->id != MFIE_TYPE_DS_SET) {
+			printk(KERN_INFO DRV_NAME 
+			       ": invalid MFIE type for DIRECT SEQUENCE.\n");
+			IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+					   info_element->id);
+			return;
+		}
+		
+		beacon->channel = info_element->data[0];
+	} else if (beacon->capability & SSID_CAPABILITY_IBSS) {
+		/* IBSS - Frequency Hop */
+		if (info_element->id != MFIE_TYPE_FH_SET) {
+			printk(KERN_INFO DRV_NAME 
+			       ": invalid MFIE type for FREQ HOP.\n");
+			IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+					   info_element->id);
+			return;
+		}
+	} else {
+		/* Invalid ESS/IBSS capability! */
+		printk(KERN_INFO DRV_NAME
+		       ": Invalid ESS/IBSS capability (both 0).\n");
+		IPW2100_DEBUG_SCAN("exit - invalid ESS/IBSS capability: %1X\n",
+				   beacon->capability & 0x3);
+		return;
+	}
+
+	/* For now, we ignore the optional CF and IBSS parameter sets */
+
+	list_del(element);
+
+	IPW2100_DEBUG_SCAN("adding '%s' to beacon list.\n", beacon->ssid);
+	
+	list_add_tail(&beacon->list, &priv->beacon_list);
+}
+
+static void isr_process_probe_response(
+	struct ipw2100_priv *priv,
+	struct ipw2100_802_11_probe_response *new_beacon,
+	s8 rssi)
+{
+	struct ipw2100_802_11_info_element *ssid_info;
+	struct list_head *element;
+	struct ipw2100_beacon *beacon;
+	u8 ssid_len;
+
+	IPW2100_DEBUG_MANAGEMENT(
+		"\n"
+		"Time Stamp 1    : %08X\n"
+		"Time Stamp 2    : %08X\n"
+		"Beacon Interval : %04X\n"
+		"Capabilities    : %c%c%c%c%c%c%c000000000\n",
+		new_beacon->time_stamp[0],
+		new_beacon->time_stamp[1],
+		new_beacon->beacon_interval,
+		(new_beacon->capability & 1) ? '1' : '0',
+		(new_beacon->capability & 2) ? '1' : '0',
+		(new_beacon->capability & 4) ? '1' : '0',
+		(new_beacon->capability & 8) ? '1' : '0',
+		(new_beacon->capability & 10) ? '1' : '0',
+		(new_beacon->capability & 20) ? '1' : '0',
+		(new_beacon->capability & 40) ? '1' : '0');
+
+	ssid_info = &new_beacon->info_element;
+	if (ssid_info->id != MFIE_TYPE_SSID) {
+		printk(KERN_INFO DRV_NAME ": invalid MFIE type for SSID.\n");
+		IPW2100_DEBUG_SCAN("exit - invalid MFIE type for SSID: %d\n",
+				   ssid_info->id);
+		return;
+	}
+
+	ssid_len = min(ssid_info->len, SSID_LENGTH);
+
+	IPW2100_DEBUG_SCAN("enter\n");
+
+	for (element = priv->beacon_list.next;
+	     element != &priv->beacon_list;
+	     element = element->next) {
+		beacon = list_entry(element, struct ipw2100_beacon, list);
+		if (!memcmp(beacon->bssid, new_beacon->header.address3, 
+			    ETH_ALEN) &&
+		    !memcmp(beacon->ssid, ssid_info->data, ssid_len))
+			return;
+	}
+
+	if (list_empty(&priv->beacon_free_list)) {
+		IPW2100_DEBUG_SCAN("TODO: Expire oldest beacon to add new.\n");
+		printk(KERN_WARNING DRV_NAME ": Beacon free list is empty.\n");
+	} else 
+		isr_beacon_add(priv, new_beacon, rssi);
+
+	IPW2100_DEBUG_SCAN("exit\n");
+}
+	
+static void isr_handle_mgt_packet(
+	struct ipw2100_priv *priv, 
+	struct ipw2100_802_11_header *header,
+	struct ipw2100_status *status)
+{
+	char *msg = "UNKNOWN";
+	
+	switch (header->sub_type) {
+	case ASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE:
+		msg = "ASSOCIATION RESPONSE";
+		break;
+	case REASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE:
+		msg = "REASSOCIATION RESPONSE";
+		break;
+	case PROBE_RESPONSE_802_11_PACKET_SUBTYPE:
+		msg = "PROBE RESPONSE";
+		IPW2100_DEBUG_SCAN("Probe response\n");
+		isr_process_probe_response(
+			priv, (struct ipw2100_802_11_probe_response *)header,
+			status->rssi);
+		break;
+
+	case BEACON_802_11_PACKET_SUBTYPE:
+		msg = "BEACON";
+		break;
+	default:
+		printk(KERN_DEBUG "%s: Unknown management packet: %d\n",
+		       priv->ndev->name, header->sub_type);
+		break;
+	}
+
+	IPW2100_DEBUG_RX("received %s(%d)\n", msg, header->sub_type);
+}
+
+
+
+#ifdef CONFIG_IPW2100_DEBUG
+const char *frame_types[] = {
+	"COMMAND_STATUS_VAL",
+	"STATUS_CHANGE_VAL",
+	"P80211_DATA_VAL",
+	"P8023_DATA_VAL",
+	"HOST_NOTIFICATION_VAL"
+};
+#endif
+
+
+const char snap_bridge[] = {
+	0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8
+};
+
+const char snap_tunnel[] = {
+	0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00
+};
+
+
+static inline struct ipw2100_hw_packet *ipw2100_alloc_skb(
+	struct ipw2100_priv *priv,
+	struct ipw2100_hw_packet *packet)
+{
+	packet->skb = dev_alloc_skb(sizeof(struct ipw2100_rx_packet));
+	
+	if (!packet->skb)
+		return NULL;
+
+	packet->rxp = (struct ipw2100_rx_packet *)packet->skb->data;
+	packet->dma_addr = pci_map_single(priv->pdev, packet->skb->data,
+					  sizeof(struct ipw2100_rx_packet),
+					  PCI_DMA_FROMDEVICE);
+	/* NOTE: pci_map_single does not return an error code, and 0 is a valid
+	 *       dma_addr */
+	
+#ifndef CONFIG_IPW2100_WEP
+	skb_reserve(packet->skb, IPW_802_11_PAYLOAD_OFFSET);
+#endif /* CONFIG_IPW2100_WEP */
+
+	return packet;
+}
+
+
+/*
+ *
+ * 0) Disconnect the SKB from the firmware (just unmap)
+ * 1) Pack the ETH header into the SKB
+ * 2) Pass the SKB to the network stack
+ *
+ * When packet is provided by the firmware, it contains the following:
+ * 
+ * .  ipw2100_802_11_header
+ * .  ieee_802_11_snap_header
+ * .  payload <= sbk->data was already set to here in ipw2100_alloc_skb
+ *
+ * The size of the constructed ethernet 
+ *
+ */
+static inline int isr_rx(struct ipw2100_priv *priv, int i)
+{
+	struct ipw2100_status *status = &priv->status_queue.drv[i];
+	struct ipw2100_hw_packet *packet = &priv->rx_buffers[i];
+#ifndef CONFIG_IPW2100_WEP
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+	struct sk_buff *skb = NULL;
+#else /* CONFIG_IPW2100_WEP */
+	struct ieee80211_rx_stats stats = {
+		.signal = status->rssi,
+		.noise = IPW2100_RSSI_TO_DBM,
+		.rate = 0,
+		.mac_time = jiffies,
+	};
+#endif /* CONFIG_IPW2100_WEP */
+	unsigned int payload_len;
+	
+	payload_len = status->frame_size - IPW_802_11_PAYLOAD_OFFSET + 
+		ETH_ALEN * 2;
+
+	pci_unmap_single(priv->pdev,
+			 packet->dma_addr,
+			 sizeof(struct ipw2100_rx_packet),
+			 PCI_DMA_FROMDEVICE);
+	
+	if (payload_len > IPW_MAX_802_11_PAYLOAD_LENGTH) {
+		printk(KERN_INFO 
+		       "%s: Packet payload too large (%u) - dropping:\n"
+		       "status packet = \n"
+		       "   bd index      = %d\n"
+		       "   frame_size    = %u\n"
+		       "   status_fields = 0x%04X\n"
+		       "   flags         = 0x%02X\n"
+		       "   rssi          = 0x%02X\n"
+		       "Scheduling firmware restart.\n",
+		       priv->ndev->name, payload_len, i,
+		       status->frame_size, status->status_fields,
+		       status->flags, status->rssi);
+
+		priv->fatal_error = 1;
+		priv->stats.rx_errors++;
+		if (!priv->reset_pending) {
+			priv->reset_pending = 1;
+			schedule_work(&priv->reset_work);
+		}
+		wake_up_interruptible_sync(&priv->wait_command_queue);
+
+		return 0;
+	}
+	
+#ifdef CONFIG_IPW2100_WEP
+	skb_put(packet->skb, status->frame_size);
+	return ieee80211_rx(&priv->ieee, packet->skb, &stats);
+
+#else /* CONFIG_IPW2100_WEP */
+
+#ifdef CONFIG_IPW2100_DEBUG
+	if (status->flags & IPW_STATUS_FLAG_DECRYPTED)
+		IPW2100_DEBUG_WEP("Received decrypted packet.\n");
+	if (status->flags & IPW_STATUS_FLAG_WEP_ENCRYPTED)
+		IPW2100_DEBUG_WEP("Received WEP encrypted packet.\n");
+#endif /* CONFIG_IPW2100_DEBUG */
+	/*
+	 * This is the older legacy code that will go away once we fully
+	 * transition to the new WEP code and generic 802.11 stack.
+	 */
+	if (!IS_FRAGMENT(hdr)) {
+		skb = packet->skb;
+		
+		/*
+		 * Build header (two ethernet addresses)
+		 * NOTE: These are in reverse order (since they are pushed)
+		 */
+		memcpy(skb_push(skb, ETH_ALEN), &hdr->address3, ETH_ALEN);
+		memcpy(skb_push(skb, ETH_ALEN), &hdr->address1, ETH_ALEN);
+		
+		/* Advance SKB buffer to include the data DMA'd by the
+		 * firmware */
+		skb_put(skb, payload_len);
+	} else {
+		IPW2100_DEBUG_RX("fragment Rx: %d bytes\n", status->frame_size);
+		skb = ipw2100_defrag_rx(priv, packet, status->frame_size);
+	}
+	
+	priv->ndev->last_rx = jiffies;
+	
+	/* If this was a fragment, then an SKB may not be finished */
+	if (skb) {
+		skb->dev = priv->ndev;
+		skb->protocol = eth_type_trans(skb, priv->ndev);
+		skb->ip_summed = CHECKSUM_NONE;
+		
+		IPW2100_DEBUG_RX("protocol from eth_type_trans=%04x\n",
+				 skb->protocol);
+		
+		priv->stats.rx_packets++;
+		priv->stats.rx_bytes += skb->len;
+		
+		netif_rx(skb);
+	}
+	
+	return 1;
+	
+#endif /* CONFIG_IPW2100_WEP */
+}
+ 
+/*
+ * ipw2100 interrupts are disabled at this point, and the ISR
+ * is the only code that calls this method.  So, we do not need
+ * to play with any locks.  
+ *
+ * RX Queue works as follows:
+ * 
+ * Read index - firmware places packet in entry identified by the 
+ *              Read index and advances Read index.  In this manner, 
+ *              Read index will always point to the next packet to 
+ *              be filled--but not yet valid.
+ *
+ * Write index - driver fills this entry with an unused RBD entry.
+ *               This entry has not filled by the firmware yet.
+ *
+ * In between the W and R indexes are the RBDs that have been received
+ * but not yet processed.  
+ *
+ * The process of handling packets will start at WRITE + 1 and advance
+ * until it reaches the READ index.  
+ *
+ * The WRITE index is cached in the variable 'priv->rx_queue.next'.
+ *
+ */
+static inline void __ipw2100_rx_process(struct ipw2100_priv *priv)
+{
+	struct ipw2100_bd_queue *rxq = &priv->rx_queue;
+	struct ipw2100_status_queue *sq = &priv->status_queue;
+	struct ipw2100_hw_packet *packet;
+	u16 frame_type;
+	u32 frame_size;
+	u32 r, w, i, s;//, j;
+	int handled;
+	struct ipw2100_rx_packet *u;
+	
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_RX_READ_INDEX, &r);
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, &w);
+	
+	if (r >= rxq->entries) {
+		IPW2100_DEBUG_RX("exit - bad read index\n");
+		return;
+	}
+
+	i = (rxq->next + 1) % rxq->entries;
+	s = i;
+	while (i != r) {
+		/* IPW2100_DEBUG_RX("r = %d : w = %d : processing = %d\n",
+		   r, rxq->next, i); */
+		
+		packet = &priv->rx_buffers[i];
+
+		/* Sync the DMA for the STATUS buffer so CPU is sure to get 
+		 * the correct values */
+		pci_dma_sync_single(
+			priv->pdev, 
+			sq->nic + sizeof(struct ipw2100_status) * i,
+			sizeof(struct ipw2100_status),
+			PCI_DMA_FROMDEVICE);
+
+		/* Sync the DMA for the RX buffer so CPU is sure to get 
+		 * the correct values */
+		pci_dma_sync_single(priv->pdev, packet->dma_addr,
+				    sizeof(struct ipw2100_rx_packet),
+				    PCI_DMA_FROMDEVICE);
+		
+		/* !!!!TEST!!!! This is to see if forcing a HW buffer flush
+		 * can fix the C2->C3 data corruption problem */
+		__asm__ __volatile__ ("lock; addl $0,0(%%esp)": : :"memory");
+
+		u = packet->rxp;
+		frame_type = sq->drv[i].status_fields & STATUS_TYPE_MASK;
+		frame_size = sq->drv[i].frame_size;
+		
+		IPW2100_DEBUG_RX("%s: '%s' frame type received (%d).\n",
+				 priv->ndev->name, frame_types[frame_type],
+				 frame_size);
+
+		handled = 0;
+		switch (frame_type) {
+		case COMMAND_STATUS_VAL:
+			if (frame_size == sizeof(u->command))
+			    isr_rx_complete_command(priv, &u->command);
+			break;
+
+		case STATUS_CHANGE_VAL:
+			if (frame_size == sizeof(u->status))
+				isr_status_change(priv, u->status);
+			break;
+
+		case P80211_DATA_VAL:
+		case P8023_DATA_VAL:
+			if (frame_size < sizeof(u->header))
+				break;
+
+			switch (u->header.type) {
+			case MANAGMENT_802_11_PACKET_TYPE:
+				isr_handle_mgt_packet(priv, &u->header,
+						      &sq->drv[i]);
+				break;
+				
+			case CONTROL_802_11_PACKET_TYPE:
+				isr_handle_ctl_packet(priv, &u->header,
+						      &sq->drv[i]);
+				break;
+				
+			case DATA_802_11_PACKET_TYPE:
+				/* We only process data packets if the interface
+				 * is open */
+				if (!priv->open) {
+					priv->wstats.discard.misc++;
+					IPW2100_DEBUG_RX(
+						"Dropping packet while "
+						"interface is not up.\n");
+					break;
+				}
+
+				handled = isr_rx(priv, i);
+				if (handled) 
+					break;
+				
+                                /* Remap the DMA address */
+				packet->dma_addr = pci_map_single(
+					priv->pdev, 
+					packet->skb->data,
+					sizeof(struct ipw2100_rx_packet),
+					PCI_DMA_FROMDEVICE);
+				
+				/* Update the RDB entry */
+				rxq->drv[i].host_addr = packet->dma_addr;
+				
+				break;
+				
+			default:
+				priv->wstats.discard.misc++;
+				IPW2100_DEBUG_RX("received unknown packet "
+						 "type, dropping...\n");
+				break;
+			}
+			break;
+
+		case HOST_NOTIFICATION_VAL:
+			if (frame_size >= sizeof(u->notification))
+			    isr_indicate_host_notification(priv, 
+							   &u->notification);
+			break;
+
+		default:
+			priv->wstats.discard.misc++;
+			IPW2100_DEBUG_WARNING(
+				"received unknown frame type: %d, "
+				"ignoring...\n", frame_type);
+			break;
+		}
+
+		if (handled) {
+			/* packet was sent; the function that sent it will
+			 * unmap and disconnect from this RDB.  We must 
+			 * allocate a new SKB and attach it. */
+			packet = ipw2100_alloc_skb(priv, packet);
+			if (!packet) {
+				printk(KERN_WARNING 
+				      "Unable to allocate SKB onto RBD ring - "
+				      "disabling adapter.\n");
+				/* TODO: schedule adapter shutdown */
+				IPW2100_DEBUG_INFO("TODO: Shutdown adapter...\n");
+				break;
+			}
+
+			/* Update the RBD to refer to the new region */
+			rxq->drv[i].host_addr = packet->dma_addr;
+		}
+		
+		/* clear status field associated with this RBD */
+		rxq->drv[i].status.field = 0;
+
+		i = (i + 1) % rxq->entries;
+	}
+
+	if (i != s) {
+		/* backtrack one entry, wrapping to end if at 0 */
+		rxq->next = (i ? i : rxq->entries) - 1;
+	
+		write_register(priv->ndev,
+			       IPW_MEM_HOST_SHARED_RX_WRITE_INDEX,
+			       rxq->next);
+	}
+}
+
+
+/*
+ * __ipw2100_tx_process
+ *
+ * This routine will determine whether the next packet on
+ * the fw_pend_list has been processed by the firmware yet.
+ *
+ * If not, then it does nothing and returns.
+ *
+ * If so, then it removes the item from the fw_pend_list, frees
+ * any associated storage, and places the item back on the
+ * free list of its source (either msg_free_list or tx_free_list)
+ *
+ * TX Queue works as follows:
+ * 
+ * Read index - points to the next TBD that the firmware will 
+ *              process.  The firmware will read the data, and once
+ *              done processing, it will advance the Read index.
+ *
+ * Write index - driver fills this entry with an constructed TBD 
+ *               entry.  The Write index is not advanced until the
+ *               packet has been configured.
+ *
+ * In between the W and R indexes are the TBDs that have NOT been 
+ * processed.  Lagging behind the R index are packets that have
+ * been processed but have not been freed by the driver.
+ *
+ * In order to free old storage, an internal index will be maintained
+ * that points to the next packet to be freed.  When all used
+ * packets have been freed, the oldest index will be the same as the
+ * firmware's read index.
+ *
+ * The OLDEST index is cached in the variable 'priv->tx_queue.oldest'
+ *
+ * Because the TBD structure can not contain arbitrary data, the
+ * driver must keep an internal queue of cached allocations such that
+ * it can put that data back into the tx_free_list and msg_free_list
+ * for use by future command and data packets.
+ *
+ */
+static inline int __ipw2100_tx_process(struct ipw2100_priv *priv)
+{
+	struct ipw2100_bd_queue *txq = &priv->tx_queue;
+        struct ipw2100_bd *tbd;
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	int descriptors_used;
+	int e, i;
+	u32 r, w, frag_num = 0;
+
+	if (list_empty(&priv->fw_pend_list)) {
+		return 0;
+	}
+	
+	element = priv->fw_pend_list.next;
+
+	packet = list_entry(element, struct ipw2100_hw_packet, list);
+        tbd = &txq->drv[packet->index];
+
+	/* Determine how many TBD entries must be finished... */
+	switch (packet->type) {
+	case COMMAND:
+		/* COMMAND uses only one slot; don't advance */
+		descriptors_used = 1;
+		e = txq->oldest;
+		break;
+
+	case DATA:
+		/* DATA uses two slots; advance and loop position. */
+		descriptors_used = tbd->num_fragments;
+                frag_num = tbd->num_fragments - 1;
+		e = txq->oldest + frag_num;
+		e %= txq->entries;
+		break;
+
+	default:
+		IPW2100_DEBUG_WARNING("%s: Bad fw_pend_list entry!\n", 
+				   priv->ndev->name);
+		return 0;
+	}
+
+	/* if the last TBD is not done by NIC yet, then packet is
+	 * not ready to be released. 
+	 * 
+	 */
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(0), 
+		      &r);
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0), 
+		      &w);
+	if (w != txq->next) 
+		printk(KERN_WARNING "%s: write index mismatch\n", 
+		       priv->ndev->name);
+
+        /*
+	 * txq->next is the index of the last packet written txq->oldest is 
+	 * the index of the r is the index of the next packet to be read by 
+	 * firmware
+	 */
+
+
+	/* 
+	 * Quick graphic to help you visualize the following
+	 * if / else statement
+	 * 
+	 * ===>|                     s---->|===============
+	 *                               e>|
+	 * | a | b | c | d | e | f | g | h | i | j | k | l 
+	 *       r---->|
+	 *               w
+	 *
+	 * w - updated by driver
+	 * r - updated by firmware
+	 * s - start of oldest BD entry (txq->oldest)
+	 * e - end of oldest BD entry
+	 *
+	 */
+	if (!((r <= w && (e < r || e >= w)) ||
+	      (e < r && e >= w))) { 
+		IPW2100_DEBUG_TX("exit - no processed packets ready to "
+				 "release.\n");
+		return 0;
+	}
+
+	list_del(element);
+
+#ifdef CONFIG_IPW2100_DEBUG
+	{
+		int i;
+		i = (txq->oldest + 1) % txq->entries;
+		IPW2100_DEBUG_TX(
+			"TX%d V=%p P=%p T=%p L=%d\n", i,
+			&txq->drv[i],
+			(void*)txq->nic + i * sizeof(struct ipw2100_bd),
+			(void*)txq->drv[i].host_addr,
+			txq->drv[i].buf_length);
+		
+		if (packet->type == DATA) {
+			i = (i + 1) % txq->entries;
+			
+			IPW2100_DEBUG_TX(
+				"TX%d V=%p P=%p T=%p L=%d\n", i,
+				&txq->drv[i],
+				(void*)txq->nic + i * sizeof(struct ipw2100_bd),
+				(void*)txq->drv[i].host_addr,
+				txq->drv[i].buf_length);
+		}
+	}
+#endif
+ 
+	switch (packet->type) {
+	case DATA:
+		if (txq->drv[txq->oldest].status.txType != 0) 
+			printk(KERN_WARNING "%s: Queue mismatch.  "
+			       "Expecting DATA TBD but pulled "
+			       "something else: ids %d=%d.\n", 
+			       priv->ndev->name, txq->oldest, packet->index);
+		
+		/* DATA packet; we have to free the SKB */
+		if (packet->skb) {
+			priv->stats.tx_packets++;
+			priv->stats.tx_bytes += packet->skb->len;
+                        for (i = 0; i < frag_num; i++) {
+                                tbd = &txq->drv[(packet->index + 1 + i) \
+                                                % txq->entries];
+                                IPW2100_DEBUG_TX(
+					"TX%d P=%08x L=%d\n",
+					(packet->index +1 +i) % txq->entries,
+					tbd->host_addr, tbd->buf_length);
+                                pci_unmap_single(priv->pdev,
+                                                 tbd->host_addr,
+                                                 tbd->buf_length,
+                                                 PCI_DMA_TODEVICE);
+                        }
+
+			dev_kfree_skb_irq(packet->skb);
+			packet->skb = NULL;
+		} else 
+			printk(KERN_WARNING "%s: Bad state.  SKB is NULL!\n",
+			       priv->ndev->name);
+
+		list_add_tail(element, &priv->tx_free_list);
+
+		/* We have a free slot in the Tx queue, so wake up the
+		 * transmit layer if it is stopped. */
+		if (netif_queue_stopped(priv->ndev))
+			netif_wake_queue(priv->ndev);
+		break;
+
+	case COMMAND:
+		if (txq->drv[txq->oldest].status.txType != 1) 
+			printk(KERN_WARNING "%s: Queue mismatch.  "
+			       "Expecting COMMAND TBD but pulled "
+			       "something else: ids %d=%d.\n", 
+			       priv->ndev->name, txq->oldest, packet->index);
+
+#ifdef CONFIG_IPW2100_DEBUG
+		if (packet->cmd->host_command_reg <
+		    sizeof(command_types) / sizeof(*command_types)) 
+			IPW2100_DEBUG_TX(
+				"Command '%s (%d)' processed: %d.\n",
+				command_types[packet->cmd->host_command_reg],
+				packet->cmd->host_command_reg,
+				packet->cmd->cmd_status_reg);
+#endif
+
+		list_add_tail(element, &priv->msg_free_list);
+		break;
+	}
+        
+	/* advance oldest used TBD pointer to start of next entry */
+	txq->oldest = (e + 1) % txq->entries;
+	/* increase available TBDs number */
+	txq->available += descriptors_used;
+
+	IPW2100_DEBUG_TX("packet latency (send to process)  %ld jiffies\n",
+			 jiffies - packet->jiffy_start);
+	
+	return (!list_empty(&priv->fw_pend_list));
+}
+
+
+static inline void __ipw2100_tx_complete(struct ipw2100_priv *priv)
+{
+	int i = 0;
+
+	while (__ipw2100_tx_process(priv) && i < 200) i++;
+
+	if (i == 200) {
+		printk(KERN_WARNING 
+		       "%s: Driver is running slow (%d iters).\n",
+		       priv->ndev->name, i);
+	}
+}
+
+
+static void X__ipw2100_tx_send_commands(struct ipw2100_priv *priv)
+{
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	struct ipw2100_bd_queue *txq = &priv->tx_queue;
+	struct ipw2100_bd *tbd;
+	int next = txq->next;
+
+	while (!list_empty(&priv->msg_pend_list)) {
+		/* if there isn't enough space in TBD queue, then
+		 * don't stuff a new one in. 
+		 * NOTE: 3 are needed as a command will take one,
+		 *       and there is a minimum of 2 that must be
+		 *       maintained between the r and w indexes
+		 */
+		if (txq->available <= 3) {
+			IPW2100_DEBUG_TX("no room in tx_queue\n");
+			break;
+		}
+
+		element = priv->msg_pend_list.next;
+		list_del(element);
+
+		packet = list_entry(element, 
+				    struct ipw2100_hw_packet, list);
+		
+		IPW2100_DEBUG_TX("using TBD at virt=%p, phys=%p\n",
+				 &txq->drv[txq->next],
+				 (void*)(txq->nic + txq->next * 
+					 sizeof(struct ipw2100_bd)));
+
+		packet->index = txq->next;
+
+		tbd = &txq->drv[txq->next];
+
+		/* initialize TBD */
+		tbd->host_addr = packet->cmd_phys;
+		tbd->buf_length = sizeof(struct ipw2100_cmd_header);
+		/* not marking number of fragments causes problems 
+		 * with f/w debug version */
+		tbd->num_fragments = 1;
+		tbd->status.field =
+			IPW_BD_STATUS_TX_FRAME_COMMAND |
+			IPW_BD_STATUS_TX_INTERRUPT_ENABLE;
+
+		/* update TBD queue counters */
+		txq->next++;
+		txq->next %= txq->entries;
+		txq->available--;
+
+		list_add_tail(element, &priv->fw_pend_list);
+	}
+
+	if (txq->next != next) {
+		/* kick off the DMA by notifying firmware the 
+		 * write index has moved; make sure TBD stores are sync'd */
+		wmb();
+		write_register(priv->ndev, 
+			       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0),
+			       txq->next);
+	}
+}
+
+
+/*
+ * X__ipw2100_tx_send_data
+ *
+ */
+static void X__ipw2100_tx_send_data(struct ipw2100_priv *priv)
+{
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	struct ipw2100_bd_queue *txq = &priv->tx_queue;
+	struct ipw2100_bd *tbd;
+	int next = txq->next;
+        u32 frag_num, msdu_frag_threshold, frag_last_size, frag_size;
+        int i = 0;
+
+	while (!list_empty(&priv->tx_pend_list)) {
+		/* if there isn't enough space in TBD queue, then
+		 * don't stuff a new one in. 
+		 * NOTE: 4 are needed as a data will take two,
+		 *       and there is a minimum of 2 that must be
+		 *       maintained between the r and w indexes
+		 */
+		if (txq->available <= 4) {
+			IPW2100_DEBUG_TX("no room in tx_queue\n");
+			break;
+		}
+		
+		element = priv->tx_pend_list.next;
+                packet = list_entry(element, struct ipw2100_hw_packet, list);
+
+		/* Determine final fragment size and number of fragments */
+                msdu_frag_threshold = ipw2100_msdu_frag_threshold(priv);
+                frag_num = packet->skb->len / msdu_frag_threshold;
+                frag_last_size = packet->skb->len % msdu_frag_threshold;
+		if (frag_last_size)
+			frag_num++;
+		else
+			frag_last_size = msdu_frag_threshold;
+
+                if (txq->available <= 3 + frag_num) {
+                        IPW2100_DEBUG_TX("no room in tx_queue for "
+					 "fragments \n");
+                        break;
+                }
+
+		list_del(element);
+
+		tbd = &txq->drv[txq->next];
+
+		packet->index = txq->next;
+
+		tbd->host_addr = packet->data_phys;
+		tbd->buf_length = sizeof(struct ipw2100_data_header);
+		tbd->num_fragments = 1 + frag_num; /* TX header, and data */
+		tbd->status.field =
+			IPW_BD_STATUS_TX_FRAME_802_3 |
+			IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;
+		txq->next++;
+		txq->next %= txq->entries;
+
+		frag_size = msdu_frag_threshold;
+		IPW2100_DEBUG_TX(
+			"data header tbd skb->len:%d TX%d P=%08x L=%d\n", 
+			packet->skb->len, packet->index, tbd->host_addr, 
+			tbd->buf_length);
+#ifdef CONFIG_IPW2100_DEBUG		
+		if (frag_num > 1) 
+			IPW2100_DEBUG_FRAG("fragment Tx: %d frames\n", 
+					   frag_num);
+#endif
+
+                for (i = 0; i < frag_num; i++) {
+		        tbd = &txq->drv[txq->next];
+			txq->next++;
+			txq->next %= txq->entries;
+
+			/* If this is the last fragment, then set the final
+			 * fragmentation size accordingly, and turn on
+			 * interrupt firing */
+			if (i == frag_num - 1) {
+				frag_size = frag_last_size;
+				tbd->status.field = 
+					IPW_BD_STATUS_TX_FRAME_802_3 |
+					IPW_BD_STATUS_TX_INTERRUPT_ENABLE;
+			} else
+				tbd->status.field =
+					IPW_BD_STATUS_TX_FRAME_802_3 |
+					IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;
+			
+			tbd->buf_length = frag_size;
+ 
+                        tbd->host_addr = pci_map_single(
+				priv->pdev, 
+				packet->skb->data + i * msdu_frag_threshold,
+				frag_size, PCI_DMA_TODEVICE);
+			/* NOTE: pci_map_single does not return an error code, 
+			 *       and 0 is a valid dma_addr */
+
+			IPW2100_DEBUG_TX(
+				"data frag tbd TX%d P=%08x L=%d\n", 
+				txq->next == 0 ? txq->entries -1 : 
+				txq->next - 1,
+				tbd->host_addr, tbd->buf_length);
+
+			pci_dma_sync_single(priv->pdev,
+                                            tbd->host_addr,
+                                            tbd->buf_length,
+                                            PCI_DMA_TODEVICE);
+
+                }
+		
+		txq->available -= 1 + frag_num;
+
+		list_add_tail(element, &priv->fw_pend_list);
+	}
+
+	if (txq->next != next) {
+		/* A packet was handed to the hardware, so update the 
+		 * watchdog */
+		priv->ndev->trans_start = jiffies;
+
+		/* kick off the DMA by notifying firmware the 
+		 * write index has moved; make sure TBD stores are sync'd */
+		write_register(priv->ndev, 
+			       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0),
+			       txq->next);
+	}
+        return;
+}
+
+static void ipw2100_irq_tasklet(struct ipw2100_priv *priv)
+{
+	struct net_device *dev = priv->ndev;
+	unsigned long flags;
+	u32 inta, tmp;
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+	ipw2100_hw_disable_interrupt(priv);
+
+	read_register(dev, IPW_REG_INTA, &inta);
+			 
+	IPW2100_DEBUG_ISR("enter - INTA: 0x%08lX\n", 
+			  (unsigned long)inta & IPW_INTERRUPT_MASK);
+
+	priv->in_isr++;
+	priv->interrupts++;
+
+	/* We do not loop and keep polling for more interrupts as this
+	 * is frowned upon and doesn't play nicely with other potentially
+	 * chained IRQs */
+	IPW2100_DEBUG_ISR("INTA: 0x%08lX\n", 
+			  (unsigned long)inta & IPW_INTERRUPT_MASK);
+
+	if (inta & IPW2100_INTA_FATAL_ERROR) {
+		printk(KERN_WARNING DRV_NAME 
+		       ": Fatal interrupt. Scheduling firmware restart.\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_FATAL_ERROR);
+		/* Wake up any sleeping jobs */
+		priv->fatal_error = 1;
+		if (!priv->reset_pending) {
+			priv->reset_pending = 1;
+			schedule_work(&priv->reset_work);
+		}
+		wake_up_interruptible_sync(&priv->wait_command_queue);
+	}
+	
+	if (inta & IPW2100_INTA_PARITY_ERROR) {
+		IPW2100_DEBUG_ERROR("***** PARITY ERROR INTERRUPT !!!! \n");
+		write_register(
+			dev, IPW_REG_INTA, 
+			IPW2100_INTA_PARITY_ERROR);
+	}
+
+	if (inta & IPW2100_INTA_RX_TRANSFER) {
+		IPW2100_DEBUG_ISR("RX interrupt\n");
+
+		priv->rx_interrupts++;
+
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_RX_TRANSFER);
+		
+		__ipw2100_rx_process(priv);
+		__ipw2100_tx_complete(priv);
+	}
+	
+	if (inta & IPW2100_INTA_TX_TRANSFER) {
+		IPW2100_DEBUG_ISR("TX interrupt\n");
+
+		priv->tx_interrupts++;
+		
+		write_register(dev, IPW_REG_INTA,
+			       IPW2100_INTA_TX_TRANSFER);
+		
+		__ipw2100_tx_complete(priv);
+		X__ipw2100_tx_send_commands(priv);
+		X__ipw2100_tx_send_data(priv);
+	}
+	
+	if (inta & IPW2100_INTA_TX_COMPLETE) {
+		IPW2100_DEBUG_ISR("TX complete\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_TX_COMPLETE);
+		
+		__ipw2100_tx_complete(priv);
+	}
+	
+	if (inta & IPW2100_INTA_EVENT_INTERRUPT) {
+		/* ipw2100_handle_event(dev); */
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_EVENT_INTERRUPT);
+	}
+	
+	if (inta & IPW2100_INTA_FW_INIT_DONE) {
+		IPW2100_DEBUG_ISR("FW init done interrupt\n");
+		
+		read_register(dev, IPW_REG_INTA, &tmp);
+		if (tmp & (IPW2100_INTA_FATAL_ERROR |
+			   IPW2100_INTA_PARITY_ERROR)) {
+			write_register(
+				dev, IPW_REG_INTA,
+				IPW2100_INTA_FATAL_ERROR |
+				IPW2100_INTA_PARITY_ERROR);
+		}
+		
+		write_register(dev, IPW_REG_INTA,
+			       IPW2100_INTA_FW_INIT_DONE);
+	}
+	
+	if (inta & IPW2100_INTA_STATUS_CHANGE) {
+		IPW2100_DEBUG_ISR("Status change interrupt\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_STATUS_CHANGE);
+	}
+	
+	if (inta & IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE) {
+		IPW2100_DEBUG_ISR("slave host mode interrupt\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE);
+	}
+	
+	priv->in_isr--;
+	ipw2100_hw_enable_interrupt(priv);
+	priv->irq_enabled = 1;
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	IPW2100_DEBUG_ISR("exit\n");
+}
+
+
+static irqreturn_t ipw2100_interrupt(int irq, void *dev_id, 
+				     struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct ipw2100_priv *priv = dev->priv;
+	u32 inta, inta_mask;
+
+	if (!dev)
+		return IRQ_NONE;
+
+	read_register(dev, IPW_REG_INTA_MASK, &inta_mask);
+	read_register(dev, IPW_REG_INTA, &inta);
+	inta &= IPW_INTERRUPT_MASK;
+
+	if (!(inta & inta_mask)) {
+		/* Shared interrupt */
+		return IRQ_NONE;
+	}
+
+	if (inta == 0xFFFFFFFF) {
+		/* Hardware disappeared */
+		return IRQ_HANDLED;
+	}
+
+	/* We disable the hardware interrupt here just to prevent unneeded
+	 * calls to be made.  We disable this again within the actual
+	 * work tasklet, so if another part of the code re-enables the
+	 * interrupt, that is fine */
+	ipw2100_hw_disable_interrupt(priv);
+
+	tasklet_schedule(&priv->irq_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * ipw2100_tx_prepare
+ *
+ * called by ipw2100_tx
+ * locks must be held prior to calling
+ * ret: 1 failure (skb not stored) 0 success
+ */
+static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
+static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+
+#define STR_12c "%02X%02X%02X%02X-%02X%02X%02X%02X-%02X%02X%02X%02X"
+#define VAR_12c(x) ((u8*)x)[0],((u8*)x)[1],((u8*)x)[2],((u8*)x)[3],\
+ ((u8*)x)[4],((u8*)x)[5],((u8*)x)[6],((u8*)x)[7], \
+ ((u8*)x)[8],((u8*)x)[9],((u8*)x)[10],((u8*)x)[11] 
+
+static void ipw2100_tx_prepare(struct ipw2100_priv *priv, struct sk_buff *skb)
+{
+	struct list_head *element;
+	struct ipw2100_data_header *header;
+	struct ipw2100_hw_packet *packet;
+	struct ieee_802_11_snap_header *snap;
+	u16 *type;
+	u8 *oui;
+#ifdef CONFIG_IPW2100_WEP
+	int olen;
+	struct sk_buff *wep_skb;
+#endif
+
+	element = priv->tx_free_list.next;
+
+	packet = list_entry(element, struct ipw2100_hw_packet, list);
+	header = packet->data;
+
+	header->host_command_reg = SEND;
+	header->host_command_reg1 = 0;
+	header->encrypted = 0;
+	header->needs_encryption = 0;
+	header->fragment_size = 0;
+	memcpy(header->dst_addr, skb->data, ETH_ALEN);
+	memcpy(header->src_addr, skb->data + ETH_ALEN, ETH_ALEN);
+
+	/* An ethhdr is 14 bytes:
+	   struct ethhdr {
+	   unsigned char h_dest[ETH_ALEN];
+	   unsigned char h_source[ETH_ALEN];
+	   unsigned short h_proto;
+	   } 
+
+	   A snap header is 6 bytes:
+	   struct ieee_802_11_snap_header {
+	   u8 dsap;
+	   u8 ssap;
+	   u8 ctrl;
+	   u8 oui[3];
+	   }
+	   
+	   Since we retain the h_proto, this only gives us 6 bytes of extra 
+	   space--not enough to hold the IV and ICV for a wep packet.  So, we
+	   have to re-allocate a new SKB if WEP is enabled.
+	*/
+
+#ifdef CONFIG_IPW2100_WEP
+	/* If we are connected and under shared authentication, then allocate
+	 * and encrypt */
+	if (priv->connected && 
+	    priv->authentication == AUTH_SHARED &&
+	    priv->ieee.crypt &&
+	    priv->ieee.crypt->ops->encrypt) {
+		wep_skb = dev_alloc_skb(
+			skb->len - sizeof(struct ethhdr) + 
+			sizeof(struct ieee_802_11_snap_header) +
+			2 + /* Type field ARP or IP */ +
+			8 /* IV and ICV */);
+		if (wep_skb == NULL) {
+			printk(KERN_WARNING "%s: Could not allocate SKB for "
+			       "WEP encryption.  Dropping packet.\n",
+			       priv->ndev->name);
+			dev_kfree_skb(skb);
+			priv->stats.rx_errors++;
+			return;
+		}
+
+		/* To encrypt, frame format is:
+		 * IV (4 bytes), clear payload (including SNAP header), 
+		 * ICV (4 bytes) */
+
+		/* Put space at the start of wep_skb for the IV */
+		skb_put(wep_skb, 4);
+		
+		/* Set up the SNAP header */
+		/* Pull the incoming SKB data ptr past the ethernet header */
+		skb_pull(skb, sizeof(struct ethhdr) - 2);
+
+		type = (u16 *) skb->data;
+		if (ntohs(*type) == 0x8137 || ntohs(*type) == 0x80f3)
+			oui = P802_1H_OUI;
+		else
+			oui = RFC1042_OUI;
+		
+		/* Put the SNAP into wep_skb */
+		snap = (struct ieee_802_11_snap_header *)skb_put(
+			wep_skb, sizeof(*snap));
+		snap->dsap = 0xaa;
+		snap->ssap = 0xaa;
+		snap->ctrl = 0x03;
+		memcpy(snap->oui, oui, P80211_OUI_LEN);
+
+		/* For now, the Host AP encryption system performs WEP
+		 * encrypt in place--this means we need to copy the non
+		 * encrypted data into the new SKB vs. having Host AP
+		 * transform the encrypted data across buffers */
+
+		/* Copy the h_proto (Type) and unencrypted payload into the 
+		 * wep_skb */
+		memcpy(skb_put(wep_skb, skb->len), skb->data, skb->len);
+		
+		/* Advance wep_skb storage to hold the ICV */
+		skb_put(wep_skb, 4);
+
+		/* We're done with the original SKB... so let it be free... */
+		dev_kfree_skb(skb);
+
+		/* Encrypt the frame */
+/*		printk(KERN_INFO "%s: Before encrypt: " STR_12c "\n",
+		priv->ieee.dev->name, VAR_12c(wep_skb->data));*/
+		atomic_inc(&priv->ieee.crypt->refcnt);
+		olen = priv->ieee.crypt->ops->encrypt(
+			wep_skb->data, wep_skb->len - 8, 
+			priv->ieee.crypt->priv);
+		atomic_dec(&priv->ieee.crypt->refcnt);
+/*		printk(KERN_INFO "%s: After encrypt : " STR_12c "\n",
+		priv->ieee.dev->name, VAR_12c(wep_skb->data));*/
+		if (olen != wep_skb->len) {
+			printk(KERN_INFO "%s: Encryption failed: %d vs. %d.\n",
+			       priv->ndev->name, olen, wep_skb->len);
+			dev_kfree_skb(wep_skb);
+			return;
+		}
+
+		header->encrypted = 1;
+		skb = wep_skb;
+	} else {
+#endif
+		/* Put a SNAP header where the ethernet header used to be 
+		 * and update skb->data pointer - we don't use the original 
+		 * ethernet header anyway
+		 *
+		 * An assumption is that SNAP header is smaller than 
+		 * ethernet header.  Silently drop. */
+		if (skb->len < sizeof(struct ethhdr) - 2) {
+			printk(KERN_WARNING "%s: skb too small for snap "
+			       "header.\n", priv->ndev->name);
+			return;
+		}
+		
+		/* move data pointer forward to the h_proto field 
+		 * (after h_dest and h_source MAC addresses) then back the size 
+		 * of a SNAP header */
+		skb_pull(skb, sizeof(struct ethhdr) - 2);
+		
+		type = (u16 *) skb->data;
+		if (ntohs(*type) == 0x8137 || ntohs(*type) == 0x80f3)
+			oui = P802_1H_OUI;
+		else
+			oui = RFC1042_OUI;
+		
+		skb_push(skb, sizeof(struct ieee_802_11_snap_header));
+		
+		snap = (struct ieee_802_11_snap_header *)skb->data;
+		snap->dsap = 0xaa;
+		snap->ssap = 0xaa;
+		snap->ctrl = 0x03;
+		memcpy(snap->oui, oui, P80211_OUI_LEN);	
+#ifdef CONFIG_IPW2100_WEP	
+	}
+#endif
+	
+	packet->jiffy_start = jiffies;
+	packet->skb = skb;
+	
+	list_del(element);
+	list_add_tail(element, &priv->tx_pend_list);
+	
+	X__ipw2100_tx_send_data(priv);
+}
+
+
+
+
+
+static int ipw2100_msg_allocate(struct ipw2100_priv *priv)
+{
+	int i, j, err = -EINVAL;
+	void *v;
+	dma_addr_t p;
+	     
+	priv->msg_buffers = (struct ipw2100_hw_packet *)kmalloc(
+		IPW_COMMAND_POOL_SIZE * sizeof(struct ipw2100_hw_packet), 
+		GFP_KERNEL);
+	if (!priv->msg_buffers) {
+		printk(KERN_ERR "%s: PCI alloc failed for msg "
+		       "buffers.\n", priv->ndev->name);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {
+		v = pci_alloc_consistent(
+			priv->pdev,
+			sizeof(struct ipw2100_cmd_header), 
+			&p);
+		if (!v) {
+			printk(KERN_ERR 
+			       "%s: PCI alloc failed for msg "
+			       "buffers.\n",
+			       priv->ndev->name);
+			err = -ENOMEM;
+			break;
+		} 
+
+		memset(v, 0, sizeof(struct ipw2100_cmd_header));
+		
+		priv->msg_buffers[i].type = COMMAND;
+		priv->msg_buffers[i].cmd = 
+			(struct ipw2100_cmd_header*)v;
+		priv->msg_buffers[i].cmd_phys = p;
+	}
+
+	if (i == IPW_COMMAND_POOL_SIZE)
+		return 0;
+
+	for (j = 0; j < i; j++) {
+		pci_free_consistent(
+			priv->pdev,
+			sizeof(struct ipw2100_cmd_header), 
+			priv->msg_buffers[j].cmd,
+			priv->msg_buffers[j].cmd_phys);
+	}
+	
+	kfree(priv->msg_buffers);
+	priv->msg_buffers = NULL;
+
+	return err;
+}
+
+static int ipw2100_msg_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	INIT_LIST_HEAD(&priv->msg_free_list);
+	INIT_LIST_HEAD(&priv->msg_pend_list);
+
+	for (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) 
+		list_add_tail(&priv->msg_buffers[i].list, &priv->msg_free_list);
+
+	return 0;
+}
+
+static void ipw2100_msg_free(struct ipw2100_priv *priv)
+{
+	int i;
+
+	if (!priv->msg_buffers) 
+		return;
+
+	for (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {
+		pci_free_consistent(priv->pdev,
+				    sizeof(struct ipw2100_cmd_header),
+				    priv->msg_buffers[i].cmd,
+				    priv->msg_buffers[i].cmd_phys);
+	}
+	
+	kfree(priv->msg_buffers);
+	priv->msg_buffers = NULL;
+}
+
+static struct proc_dir_entry *ipw2100_proc = NULL;
+
+static int proc_get_pci(char *page, char **start,
+		       off_t offset, int count,
+		       int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+	struct pci_dev *pdev = priv->pdev;
+	int i, j, len;
+	u32 val;
+
+	
+	len = 0;
+
+	len += snprintf(page + len, count - len, "PCI Configuration Data\n");
+	
+	for (i = 0; i < 16; i++) {
+		len += snprintf(page + len, count - len, "[%08X] ", i * 16);
+		for (j = 0; j < 16; j += 4) {
+			pci_read_config_dword(pdev, i * 16 + j, &val); 
+			len += snprintf(page + len, count - len, "%08X ", val);
+		}
+		len += snprintf(page + len, count - len, "\n");
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+#define IPW2100_REG(x) { IPW_ ##x, #x }
+const struct {
+	u32 addr;
+	const char *name;
+} hw_data[] = {
+	IPW2100_REG(REG_GP_CNTRL),
+	IPW2100_REG(REG_GPIO),
+	IPW2100_REG(REG_INTA),
+	IPW2100_REG(REG_INTA_MASK),
+	IPW2100_REG(REG_RESET_REG),
+};
+#define IPW2100_NIC(x, s) { x, #x, s }
+const struct {
+	u32 addr;
+	const char *name;
+	size_t size;
+} nic_data[] = {
+	IPW2100_NIC(IPW2100_CONTROL_REG, 2),
+	IPW2100_NIC(0x210014, 1),
+	IPW2100_NIC(0x210000, 1),
+};
+#define IPW2100_ORD(x, d) { IPW_ORD_ ##x, #x, d }
+const struct {
+	u8 index;
+	const char *name;
+	const char *desc;
+} ord_data[] = {
+	IPW2100_ORD(STAT_TX_HOST_REQUESTS, "requested Host Tx's (MSDU)"),
+	IPW2100_ORD(STAT_TX_HOST_COMPLETE, "successful Host Tx's (MSDU)"),
+	IPW2100_ORD(STAT_TX_DIR_DATA,	   "successful Directed Tx's (MSDU)"),
+	IPW2100_ORD(STAT_TX_DIR_DATA1,	   "successful Directed Tx's (MSDU) @ 1MB"),
+	IPW2100_ORD(STAT_TX_DIR_DATA2,	   "successful Directed Tx's (MSDU) @ 2MB"),
+	IPW2100_ORD(STAT_TX_DIR_DATA5_5,   "successful Directed Tx's (MSDU) @ 5_5MB"),
+	IPW2100_ORD(STAT_TX_DIR_DATA11,	   "successful Directed Tx's (MSDU) @ 11MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA1,   "successful Non_Directed Tx's (MSDU) @ 1MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA2,   "successful Non_Directed Tx's (MSDU) @ 2MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA5_5, "successful Non_Directed Tx's (MSDU) @ 5.5MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA11,  "successful Non_Directed Tx's (MSDU) @ 11MB"),
+	IPW2100_ORD(STAT_NULL_DATA,	   "successful NULL data Tx's"),
+	IPW2100_ORD(STAT_TX_RTS,	   "successful Tx RTS"),
+	IPW2100_ORD(STAT_TX_CTS,	   "successful Tx CTS"),         
+	IPW2100_ORD(STAT_TX_ACK,	   "successful Tx ACK"),
+	IPW2100_ORD(STAT_TX_ASSN,	   "successful Association Tx's"),               
+	IPW2100_ORD(STAT_TX_ASSN_RESP,	   "successful Association response Tx's"),   
+	IPW2100_ORD(STAT_TX_REASSN,	   "successful Reassociation Tx's"),           
+	IPW2100_ORD(STAT_TX_REASSN_RESP,   "successful Reassociation response Tx's"),
+	IPW2100_ORD(STAT_TX_PROBE,	   "probes successfully transmitted"), 
+	IPW2100_ORD(STAT_TX_PROBE_RESP,	   "probe responses successfully transmitted"),                
+	IPW2100_ORD(STAT_TX_BEACON,	   "tx beacon"),             
+	IPW2100_ORD(STAT_TX_ATIM,	   "Tx ATIM"),            
+	IPW2100_ORD(STAT_TX_DISASSN,	   "successful Disassociation TX"),           
+	IPW2100_ORD(STAT_TX_AUTH,	   "successful Authentication Tx"),                 
+	IPW2100_ORD(STAT_TX_DEAUTH,	   "successful Deauthentication TX"),                
+	IPW2100_ORD(STAT_TX_TOTAL_BYTES,   "Total successful Tx data bytes"),
+	IPW2100_ORD(STAT_TX_RETRIES,       "Tx retries"),
+	IPW2100_ORD(STAT_TX_RETRY1,        "Tx retries at 1MBPS"),
+	IPW2100_ORD(STAT_TX_RETRY2,        "Tx retries at 2MBPS"),
+	IPW2100_ORD(STAT_TX_RETRY5_5,	   "Tx retries at 5.5MBPS"),
+	IPW2100_ORD(STAT_TX_RETRY11,	   "Tx retries at 11MBPS"),
+	IPW2100_ORD(STAT_TX_FAILURES,	   "Tx Failures"),
+	IPW2100_ORD(STAT_TX_MAX_TRIES_IN_HOP,"times max tries in a hop failed"),
+	IPW2100_ORD(STAT_TX_DISASSN_FAIL,	"times disassociation failed"),
+	IPW2100_ORD(STAT_TX_ERR_CTS,         "missed/bad CTS frames"),
+	IPW2100_ORD(STAT_TX_ERR_ACK,	"tx err due to acks"),
+	IPW2100_ORD(STAT_RX_HOST,	"packets passed to host"),
+	IPW2100_ORD(STAT_RX_DIR_DATA,	"directed packets"),                
+	IPW2100_ORD(STAT_RX_DIR_DATA1,	"directed packets at 1MB"),            
+	IPW2100_ORD(STAT_RX_DIR_DATA2,	"directed packets at 2MB"),           
+	IPW2100_ORD(STAT_RX_DIR_DATA5_5,	"directed packets at 5.5MB"),            
+	IPW2100_ORD(STAT_RX_DIR_DATA11,	"directed packets at 11MB"),            
+	IPW2100_ORD(STAT_RX_NODIR_DATA,"nondirected packets"),        
+	IPW2100_ORD(STAT_RX_NODIR_DATA1,	"nondirected packets at 1MB"),            
+	IPW2100_ORD(STAT_RX_NODIR_DATA2,	"nondirected packets at 2MB"),           
+	IPW2100_ORD(STAT_RX_NODIR_DATA5_5,	"nondirected packets at 5.5MB"),            
+	IPW2100_ORD(STAT_RX_NODIR_DATA11,	"nondirected packets at 11MB"),            
+	IPW2100_ORD(STAT_RX_NULL_DATA,	"null data rx's"),            
+	IPW2100_ORD(STAT_RX_RTS,	"Rx RTS"),                
+	IPW2100_ORD(STAT_RX_CTS,	"Rx CTS"),                
+	IPW2100_ORD(STAT_RX_ACK,	"Rx ACK"),                
+	IPW2100_ORD(STAT_RX_CFEND,	"Rx CF End"),                
+	IPW2100_ORD(STAT_RX_CFEND_ACK,	"Rx CF End + CF Ack"),             
+	IPW2100_ORD(STAT_RX_ASSN,	"Association Rx's"),                    
+	IPW2100_ORD(STAT_RX_ASSN_RESP,	"Association response Rx's"),            
+	IPW2100_ORD(STAT_RX_REASSN,	"Reassociation Rx's"),            
+	IPW2100_ORD(STAT_RX_REASSN_RESP,	"Reassociation response Rx's"),            
+	IPW2100_ORD(STAT_RX_PROBE,	"probe Rx's"),                
+	IPW2100_ORD(STAT_RX_PROBE_RESP,	"probe response Rx's"),            
+	IPW2100_ORD(STAT_RX_BEACON,	"Rx beacon"),            
+	IPW2100_ORD(STAT_RX_ATIM,	"Rx ATIM"),                    
+	IPW2100_ORD(STAT_RX_DISASSN,	"disassociation Rx"),            
+	IPW2100_ORD(STAT_RX_AUTH,	"authentication Rx"),                    
+	IPW2100_ORD(STAT_RX_DEAUTH,	"deauthentication Rx"),            
+	IPW2100_ORD(STAT_RX_TOTAL_BYTES,"Total rx data bytes received"),
+	IPW2100_ORD(STAT_RX_ERR_CRC,	 "packets with Rx CRC error"),
+	IPW2100_ORD(STAT_RX_ERR_CRC1,	 "Rx CRC errors at 1MB"),
+	IPW2100_ORD(STAT_RX_ERR_CRC2,	 "Rx CRC errors at 2MB"),
+	IPW2100_ORD(STAT_RX_ERR_CRC5_5,	 "Rx CRC errors at 5.5MB"),
+	IPW2100_ORD(STAT_RX_ERR_CRC11,	 "Rx CRC errors at 11MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE1, "duplicate rx packets at 1MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE2,	 "duplicate rx packets at 2MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE5_5,	 "duplicate rx packets at 5.5MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE11,	 "duplicate rx packets at 11MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE, "duplicate rx packets"),            
+	IPW2100_ORD(PERS_DB_LOCK,	"locking fw permanent  db"),
+	IPW2100_ORD(PERS_DB_SIZE,	"size of fw permanent  db"),           
+	IPW2100_ORD(PERS_DB_ADDR,	"address of fw permanent  db"),           
+	IPW2100_ORD(STAT_RX_INVALID_PROTOCOL,	"rx frames with invalid protocol"),        
+	IPW2100_ORD(SYS_BOOT_TIME,	"Boot time"),
+	IPW2100_ORD(STAT_RX_NO_BUFFER,	"rx frames rejected due to no buffer"), 
+	IPW2100_ORD(STAT_RX_MISSING_FRAG,	"rx frames dropped due to missing fragment"),            
+	IPW2100_ORD(STAT_RX_ORPHAN_FRAG,	"rx frames dropped due to non-sequential fragment"),        
+	IPW2100_ORD(STAT_RX_ORPHAN_FRAME,	"rx frames dropped due to unmatched 1st frame"),            
+	IPW2100_ORD(STAT_RX_FRAG_AGEOUT,	"rx frames dropped due to uncompleted frame"),        
+	IPW2100_ORD(STAT_RX_ICV_ERRORS,	"ICV errors during decryption"),        
+	IPW2100_ORD(STAT_PSP_SUSPENSION,"times adapter suspended"),        
+	IPW2100_ORD(STAT_PSP_BCN_TIMEOUT,	"beacon timeout"),           
+	IPW2100_ORD(STAT_PSP_POLL_TIMEOUT,	"poll response timeouts"),       
+	IPW2100_ORD(STAT_PSP_NONDIR_TIMEOUT, "timeouts waiting for last {broad,multi}cast pkt"),
+	IPW2100_ORD(STAT_PSP_RX_DTIMS,	"PSP DTIMs received"),
+	IPW2100_ORD(STAT_PSP_RX_TIMS,	"PSP TIMs received"),
+	IPW2100_ORD(STAT_PSP_STATION_ID,"PSP Station ID"),
+	IPW2100_ORD(LAST_ASSN_TIME,	"RTC time of last association"),               
+	IPW2100_ORD(STAT_PERCENT_MISSED_BCNS,"current calculation of % missed beacons"),       
+	IPW2100_ORD(STAT_PERCENT_RETRIES,"current calculation of % missed tx retries"),            
+	IPW2100_ORD(ASSOCIATED_AP_PTR,	"0 if not associated, else pointer to AP table entry"),
+	IPW2100_ORD(AVAILABLE_AP_CNT,	"AP's decsribed in the AP table"),
+	IPW2100_ORD(AP_LIST_PTR,	"Ptr to list of available APs"),
+	IPW2100_ORD(STAT_AP_ASSNS,	"associations"),
+	IPW2100_ORD(STAT_ASSN_FAIL,	"association failures"),       
+	IPW2100_ORD(STAT_ASSN_RESP_FAIL,"failures due to response fail"),       
+	IPW2100_ORD(STAT_FULL_SCANS,	"full scans"),
+	IPW2100_ORD(CARD_DISABLED,	"Card Disabled"),
+	IPW2100_ORD(STAT_ROAM_INHIBIT,	"times roaming was inhibited due to activity"),       
+	IPW2100_ORD(RSSI_AT_ASSN,	"RSSI of associated AP at time of association"),           
+	IPW2100_ORD(STAT_ASSN_CAUSE1,	"reassociation: no probe response or TX on hop"),
+	IPW2100_ORD(STAT_ASSN_CAUSE2,	"reassociation: poor tx/rx quality"),            
+	IPW2100_ORD(STAT_ASSN_CAUSE3,	"reassociation: tx/rx quality (excessive AP load"),
+	IPW2100_ORD(STAT_ASSN_CAUSE4,	"reassociation: AP RSSI level"),
+	IPW2100_ORD(STAT_ASSN_CAUSE5,	"reassociations due to load leveling"),            
+	IPW2100_ORD(STAT_AUTH_FAIL,	"times authentication failed"),        
+	IPW2100_ORD(STAT_AUTH_RESP_FAIL,"times authentication response failed"),       
+	IPW2100_ORD(STATION_TABLE_CNT,	"entries in association table"),        
+	IPW2100_ORD(RSSI_AVG_CURR,	"Current avg RSSI"),
+	IPW2100_ORD(POWER_MGMT_MODE,	"Power mode - 0=CAM, 1=PSP"),       
+	IPW2100_ORD(COUNTRY_CODE,	"IEEE country code as recv'd from beacon"),
+	IPW2100_ORD(COUNTRY_CHANNELS,	"channels suported by country"),           
+	IPW2100_ORD(RESET_CNT,	"adapter resets (warm)"),       
+	IPW2100_ORD(BEACON_INTERVAL,	"Beacon interval"),       
+	IPW2100_ORD(ANTENNA_DIVERSITY,	"TRUE if antenna diversity is disabled"),       
+	IPW2100_ORD(DTIM_PERIOD,	"beacon intervals between DTIMs"),       
+	IPW2100_ORD(OUR_FREQ,	"current radio freq lower digits - channel ID"),
+	IPW2100_ORD(RTC_TIME,	"current RTC time"),           
+	IPW2100_ORD(PORT_TYPE,	"operating mode"),       
+	IPW2100_ORD(CURRENT_TX_RATE,	"current tx rate"),
+	IPW2100_ORD(SUPPORTED_RATES,	"supported tx rates"),       
+	IPW2100_ORD(ATIM_WINDOW,	"current ATIM Window"),
+	IPW2100_ORD(BASIC_RATES,	"basic tx rates"),       
+	IPW2100_ORD(NIC_HIGHEST_RATE,	"NIC highest tx rate"),
+	IPW2100_ORD(AP_HIGHEST_RATE,	"AP highest tx rate"),
+	IPW2100_ORD(CAPABILITIES,	"Management frame capability field"),
+	IPW2100_ORD(AUTH_TYPE,	"Type of authentication"),       
+	IPW2100_ORD(RADIO_TYPE,	"Adapter card platform type"),       
+	IPW2100_ORD(RTS_THRESHOLD,	"Min packet length for RTS handshaking"),       
+	IPW2100_ORD(INT_MODE,	"International mode"),           
+	IPW2100_ORD(FRAGMENTATION_THRESHOLD,	"protocol frag threshold"),       
+	IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_START_ADDRESS,	"EEPROM offset in SRAM"),
+	IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_SIZE,	"EEPROM size in SRAM"),
+	IPW2100_ORD(EEPROM_SKU_CAPABILITY,	"EEPROM SKU Capability"),
+	IPW2100_ORD(EEPROM_IBSS_11B_CHANNELS,	"EEPROM IBSS 11b channel set"),       
+	IPW2100_ORD(MAC_VERSION,	"MAC Version"),       
+	IPW2100_ORD(MAC_REVISION,	"MAC Revision"),       
+	IPW2100_ORD(RADIO_VERSION,	"Radio Version"),       
+	IPW2100_ORD(NIC_MANF_DATE_TIME,	"MANF Date/Time STAMP"),
+	IPW2100_ORD(UCODE_VERSION,	"Ucode Version"),       
+};
+
+
+static int proc_get_registers(char *page, char **start,
+		       off_t offset, int count,
+		       int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	int i;
+	int len = 0;
+	u32 val = 0;
+
+	len += snprintf(page + len, count - len, 
+			"%30s [Address ] : Hex\n", "Register");
+	
+	for (i = 0; 
+	     i < (sizeof(hw_data) / sizeof(*hw_data)); 
+	     i++) {
+		read_register(dev, hw_data[i].addr, &val);
+
+		len += snprintf(page + len, count - len, 
+				"%30s [%08X] : %08X\n",
+				hw_data[i].name, hw_data[i].addr,
+				val);
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+static int proc_get_hw(char *page, char **start,
+		       off_t offset, int count,
+		       int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	int i;
+	int len = 0;
+
+	len += snprintf(page + len, count - len, 
+			"%30s [Address ] : Hex\n", "NIC entry");
+	
+	for (i = 0; 
+	     i < (sizeof(nic_data) / sizeof(*nic_data)); 
+	     i++) {
+		u8 tmp8;
+		u16 tmp16;
+		u32 tmp32;
+		
+		switch (nic_data[i].size) {
+		case 1:
+			read_nic_byte(dev, nic_data[i].addr, &tmp8);
+			len += snprintf(page + len, count - len, 
+					"%30s [%08X] : %02X\n",
+					nic_data[i].name, nic_data[i].addr,
+					tmp8);
+			break;
+		case 2:
+			read_nic_word(dev, nic_data[i].addr, &tmp16);
+			len += snprintf(page + len, count - len, 
+					"%30s [%08X] : %04X\n",
+					nic_data[i].name, nic_data[i].addr,
+					tmp16);
+			break;
+		case 4:
+			read_nic_dword(dev, nic_data[i].addr, &tmp32);
+			len += snprintf(page + len, count - len, 
+					"%30s [%08X] : %08X\n",
+					nic_data[i].name, nic_data[i].addr,
+					tmp32);
+			break;
+		}
+	}
+	*eof = 1;
+	return len;
+}
+
+
+static int proc_get_ordinals(char *page, char **start,
+			     off_t offset, int count,
+			     int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+	u32 val_len;
+	u32 val = 0;
+	static int loop = 0;
+
+	if (offset == 0)
+		loop = 0;
+
+	/* If we've reached EOF or the user is cutting is short, then
+	 * restart the counter and return 0 bytes */
+	if (loop >= (sizeof(ord_data) / sizeof(*ord_data))) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && 
+	       len < 2048 && 
+	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+		
+		val_len = sizeof(u32);
+
+		if (ipw2100_get_ordinal(priv, ord_data[loop].index, &val, 
+					&val_len)) 
+			len += snprintf(page + len, count - len,
+					"[0x%02X] = ERROR    %s\n",
+					ord_data[loop].index,
+					ord_data[loop].desc);
+		else
+			len += snprintf(page + len, count - len,
+					"[0x%02X] = 0x%08X %s\n",
+					ord_data[loop].index, 
+					val, ord_data[loop].desc);
+
+		loop++;
+	}
+	
+	/* see comment in fs/proc/generic.c proc_file_read */
+	if (len) 
+		*start = (char*)len; 
+	else
+		*eof = 1;
+
+	return len;
+}
+
+static int proc_get_version(char *page, char **start,
+			    off_t offset, int count,
+			    int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+	int len = 0;
+	char tmp[MAX_FW_VERSION_LEN];
+
+	len += snprintf(page + len, count - len, 
+			"hardware    : 0x%04X\n", 
+			priv->pdev->subsystem_device);
+
+#ifdef CONFIG_IPW2100_WEP
+	len += snprintf(page + len, count - len, 
+			"driver      : " DRV_VERSION " [WEP]\n");
+#else
+	len += snprintf(page + len, count - len, 
+			"driver      : " DRV_VERSION "\n");
+#endif
+
+	len += snprintf(page + len, count - len,
+			"build date  : " __DATE__ "\n");
+
+	len += snprintf(page + len, count - len,
+			"build time  : " __TIME__ "\n");
+
+	len += snprintf(page + len, count - len,
+			"eeprom      : %d\n", priv->eeprom_version);
+	err = ipw2100_get_ucodeversion(priv, tmp, sizeof(tmp));
+	if (err < 0) 
+		len += snprintf(page + len, count - len,
+				"ucode       : error\n");
+	else 
+		len += snprintf(page + len, count - len,
+				"ucode       : %s\n", tmp);
+	err = ipw2100_get_fwversion(priv, tmp, sizeof(tmp));
+	if (err < 0) 
+		len += snprintf(page + len, count - len,
+				"firmware    : error\n");
+	else 
+		len += snprintf(page + len, count - len,
+				"firmware    : %s\n", tmp);
+
+	len += snprintf(page + len, count - len,
+			"firmware img: %d\n", priv->firmware_version);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_stats(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+
+	len += snprintf(page + len, count - len,
+			"interrupts: %d {tx: %d, rx: %d, other: %d}\n", 
+			priv->interrupts, priv->tx_interrupts,
+			priv->rx_interrupts,
+			priv->interrupts - 
+			(priv->tx_interrupts + priv->rx_interrupts));
+	len += snprintf(page + len, count - len,
+			"firmware resets: %d\n", priv->resets);
+	len += snprintf(page + len, count - len,
+			"firmware hangs: %d\n", priv->hangs);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_internals(char *page, char **start,
+			      off_t offset, int count,
+			      int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+
+#define DUMP_VAR(x,y) \
+        len += snprintf(page + len, count - len, \
+			# x ": %" # y "\n", priv-> x)
+
+	DUMP_VAR(reset_pending, d);
+	DUMP_VAR(stopped, d);
+	DUMP_VAR(disabled, d);
+	DUMP_VAR(phy_off, d);
+	DUMP_VAR(connected, d);
+	DUMP_VAR(been_powered, d);
+	DUMP_VAR(fatal_error, d);
+	DUMP_VAR(rf_kill, d);
+	DUMP_VAR(stop_hang_check, d);
+	DUMP_VAR(stop_rf_check, d);
+	DUMP_VAR(message_sending, d);
+	DUMP_VAR(messages_sent, d);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_bssinfo(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	int ret;
+	int length;
+	char essid[IW_ESSID_MAX_SIZE + 1];
+	u8 bssid[ETH_ALEN];
+	u32 chan = 0;
+
+	memset(essid, 0, sizeof(essid));
+	memset(bssid, 0, sizeof(bssid));
+
+	length = IW_ESSID_MAX_SIZE;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID, essid, &length);
+	if (ret) 
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+
+	length = sizeof(bssid);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,
+				  bssid, &length);
+	if (ret)
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+
+	length = sizeof(u32);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &length);
+	if (ret) 
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+
+	len += snprintf(page + len, count - len, "ESSID: %s\n", essid);
+	len += snprintf(page + len, count - len,
+			"BSSID:   %02x:%02x:%02x:%02x:%02x:%02x\n",
+			bssid[0], bssid[1], bssid[2],
+			bssid[3], bssid[4], bssid[5]);
+	len += snprintf(page + len, count - len, "Channel: %d\n", chan);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_txqueue(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	u32 tbdr_r, tbdr_w;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	read_register(dev, IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(0),
+		      &tbdr_r);
+	read_register(dev, IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0),
+		      &tbdr_w);
+
+	IPW2100_DEBUG_INFO("after register read\n");
+
+	len += snprintf(page, count,
+			"Tx Queue\nnic:\n\tread  index=%d\n\twrite index=%d\n",
+			tbdr_r, tbdr_w);
+	len += snprintf(page + len, count - len,
+			"drv:\n\tread index=%d\n\twrite index=%d\n",
+			priv->tx_queue.oldest,
+			priv->tx_queue.next);
+	*eof = 1;
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return len;
+}
+
+static int proc_get_rxqueue(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	u32 rbdr_r, rbdr_w;
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	read_register(dev, IPW_MEM_HOST_SHARED_RX_READ_INDEX, &rbdr_r);
+	read_register(dev, IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, &rbdr_w);
+
+	IPW2100_DEBUG_INFO("after register read\n");
+
+	len += snprintf(page, count,
+			"Rx Queue\nnic:\n\tread  index=%d\n\twrite index=%d\n",
+			rbdr_r, rbdr_w);
+	len += snprintf(page + len, count - len,
+			"drv:\n\tread  index=NOT USED\n\twrite index=%d\n",
+			priv->rx_queue.next);
+
+	*eof = 1;
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return len;
+}
+
+
+#ifdef CONFIG_IPW2100_DEBUG
+static int proc_get_debug_level(char *page, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+	len += snprintf(page + len, count - len, 
+			"%-25s\tHex        SET Decimal\n",
+			"Description");
+	for (i = 0; i < sizeof(ipw2100_debug_levels) / 
+		     sizeof(struct ipw2100_dl); i++) {
+		len += snprintf(
+			page + len, count - len, "%-25s\t0x%08lX [%c] %lu\n",
+			ipw2100_debug_levels[i].name,
+			ipw2100_debug_levels[i].value,
+			(ipw2100_debug_level & ipw2100_debug_levels[i].value) ?
+			'*' : ' ',
+			ipw2100_debug_levels[i].value);
+	}
+	
+	len += snprintf(page + len, count - len, 
+			"debug_level = 0x%08lX (* = enabled)\n", 
+			ipw2100_debug_level);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_set_debug_level(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	char buf[] = "0x00000000";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+	unsigned long val;
+	char *p = buf;
+	int i;
+
+	if (copy_from_user(buf, buffer, len)) {
+		IPW2100_DEBUG_INFO("can't copy data from userspace\n");
+		return count;	
+	} else
+		buf[len] = 0;
+
+	if (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {
+	  p++;
+ 	  if (p[0] == 'x' || p[0] == 'X')
+	    p++;
+	  val = simple_strtoul(p, &p, 16);
+	} else
+	  val = simple_strtoul(p, &p, 10);
+	if (p == buf) 
+		printk(KERN_INFO DRV_NAME ": %s is not in hex [0x] or "
+		       "decimal form.\n", buf);
+	else {
+		printk(KERN_INFO DRV_NAME ": Debug level set to 0x%08lX\n", 
+		       val);
+		ipw2100_debug_level = val;
+
+		for (i = 0; i < sizeof(ipw2100_debug_levels) / 
+			     sizeof(struct ipw2100_dl); i++) {
+			if ((ipw2100_debug_level & 
+			     ipw2100_debug_levels[i].value) ==
+			    ipw2100_debug_levels[i].value)
+				printk(KERN_INFO DRV_NAME 
+				       ": tracing enabled for %-25s (%08lX).\n",
+				       ipw2100_debug_levels[i].name,
+				       ipw2100_debug_levels[i].value);
+		}
+	}
+
+	return count;
+}
+#endif /* CONFIG_IPW2100_DEBUG */
+
+static int proc_get_fatal_error(char *page, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+
+	len += snprintf(page + len, count - len,
+			"fatal error: %d\n", priv->fatal_error);
+	
+	if (priv->fatal_error)
+		len += snprintf(page + len, count - len,
+				"`echo 0 > fatal_error` to clear\n");
+		
+	*eof = 1;
+	return len;
+}
+
+static int proc_set_fatal_error(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	struct net_device *dev = data;
+	struct ipw2100_priv *priv = dev->priv;
+	priv->fatal_error = 0;
+	return count;
+}
+
+static int proc_get_cardmem(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	u32 d;
+
+	read_nic_dword(dev, priv->proc_cardmemaddr, &d);
+
+	len += snprintf(page, count,
+			"cardmem addr[0x%08x] = 0x%08x (%d)\n",
+			priv->proc_cardmemaddr, d, d);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_set_cardmemaddr(struct file *file, const char
+				*buffer,
+				unsigned long count, void *data)
+{
+	char buff[] = "00000000";
+	unsigned long len =
+	    (sizeof(buff) - 1) > count ? count : sizeof(buff) - 1;
+	u32 val;
+	char *p;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (copy_from_user(buff, buffer, len)) {
+		IPW2100_DEBUG_INFO("can't copy data from userspace\n");
+                /* stupid? yes, but how do I signal an error here? */
+		return count;	
+	} else
+		buff[len] = 0;
+
+	val = simple_strtoul(buff, &p, 16);
+	if (p == buff) {
+		IPW2100_DEBUG_INFO("user supplied invalid address value, *p=%c\n",
+		       *p);
+	} else {
+		struct net_device *dev = (struct net_device *) data;
+		struct ipw2100_priv *priv = dev->priv;
+		
+		IPW2100_DEBUG_INFO("dev=0x%p\n", dev);
+		
+		priv->proc_cardmemaddr = val;
+		IPW2100_DEBUG_INFO("set mem addr = 0x%08x\n", val);
+	}
+	
+	IPW2100_DEBUG_INFO("exit\n");
+	return count;
+}
+
+static int proc_get_state(char *page,
+			  char **start,
+			  off_t offset,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	
+	if (priv->hw_features & HW_FEATURE_RFKILL) 
+		len += snprintf(page, count, "Radio is %s by RF switch\n",
+				ipw2100_get_rf_switch(priv) ? 
+				"disabled" : "enabled");
+	else
+		len += snprintf(page, count, 
+				"Your hardware does not have an RF switch\n");
+	
+	*eof = 1;
+	return len;
+}
+
+
+int ipw2100_proc_dev_init(struct ipw2100_priv *priv)
+{
+	struct proc_dir_entry *e;
+
+	IPW2100_DEBUG_INFO("enter %s\n", priv->ndev->name);
+
+	priv->dir_dev = create_proc_entry(priv->ndev->name, 
+					  S_IFDIR | S_IRUGO | S_IXUGO, 
+					  ipw2100_proc);
+	if (!priv->dir_dev) {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/net/ipw2100/%s\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("hw", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_hw, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/hw\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_registers, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/registers\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("ordinals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_ordinals, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/ordinals\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("pci", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_pci, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/pci\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("version", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_version, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/version\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("stats", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_stats, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/stats\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("internals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_internals, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/internals\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("txqueue", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_txqueue, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/txqueue\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("rxqueue", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_rxqueue, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/rxqueue\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("bssinfo", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_bssinfo, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/bssinfo\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("cardmem", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_cardmem;
+		e->write_proc = proc_set_cardmemaddr;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/cardmem\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("fatal_error", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_fatal_error;
+		e->write_proc = proc_set_fatal_error;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/fatal_error\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("state", S_IFREG | S_IRUGO,
+			      priv->dir_dev, proc_get_state, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/state\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	IPW2100_DEBUG_INFO("exit %s\n", priv->ndev->name);
+
+	return 0;
+
+      fail:
+	ipw2100_proc_dev_cleanup(priv);
+	IPW2100_DEBUG_INFO("exit on fail %s\n", priv->ndev->name);
+
+	return -ENOMEM;
+}
+
+void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv)
+{
+	IPW2100_DEBUG_INFO("enter %s\n", priv->ndev->name);
+
+	if (priv->dir_dev) {
+		remove_proc_entry("stats", priv->dir_dev);
+		remove_proc_entry("internals", priv->dir_dev);
+		remove_proc_entry("txqueue", priv->dir_dev);
+		remove_proc_entry("rxqueue", priv->dir_dev);
+		remove_proc_entry("cardmem", priv->dir_dev);
+		remove_proc_entry("bssinfo", priv->dir_dev);
+		remove_proc_entry("state", priv->dir_dev);
+		remove_proc_entry("version", priv->dir_dev);
+		remove_proc_entry("hw", priv->dir_dev);
+		remove_proc_entry("registers", priv->dir_dev);
+		remove_proc_entry("ordinals", priv->dir_dev);
+		remove_proc_entry("pci", priv->dir_dev);
+		remove_proc_entry("fatal_error", priv->dir_dev);
+		remove_proc_entry(priv->ndev->name, ipw2100_proc);
+		priv->dir_dev = NULL;
+	}
+
+	IPW2100_DEBUG_INFO("exit %s\n", priv->ndev->name);
+}
+
+int ipw2100_proc_init(void)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	ipw2100_proc = create_proc_entry(DRV_NAME, S_IFDIR, proc_net);
+	if (ipw2100_proc == NULL) {
+		printk(KERN_ERR
+		       "Unable to initialise /proc/net/ipw2100.\n");
+		goto fail;
+	}
+
+#ifdef CONFIG_IPW2100_DEBUG
+	{
+		struct proc_dir_entry *e;
+		e = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR, 
+				      ipw2100_proc);
+		if (e) {
+			e->read_proc = proc_get_debug_level;
+			e->write_proc = proc_set_debug_level;
+			e->data = NULL;
+		} else {
+			printk(KERN_ERR
+			       "Unable to initialize "
+			       "/proc/net/ipw2100/debug_level\n");
+			goto fail;
+		}
+	}
+#endif /* CONFIG_IPW2100_DEBUG */
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+
+ fail:
+	ipw2100_proc_cleanup();
+	IPW2100_DEBUG_INFO("exit on fail\n");
+	
+	return -ENOMEM;
+}
+
+void ipw2100_proc_cleanup(void)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (ipw2100_proc) {
+#ifdef CONFIG_IPW2100_DEBUG
+		remove_proc_entry("debug_level", ipw2100_proc);
+#endif
+		remove_proc_entry(DRV_NAME, proc_net);
+		ipw2100_proc = NULL;
+	}
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+
+#define RX_QUEUE_LENGTH 256
+#define TX_QUEUE_LENGTH 256
+#define HW_QUEUE_LENGTH 256
+
+#define TX_PENDED_QUEUE_LENGTH (TX_QUEUE_LENGTH / NUMBER_OF_BD_PER_DATA_PACKET)
+
+
+static int status_queue_allocate(struct ipw2100_priv *priv, int entries)
+{
+	struct ipw2100_status_queue *q = &priv->status_queue;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	q->size = entries * sizeof(struct ipw2100_status);
+	q->drv = (struct ipw2100_status *)pci_alloc_consistent(
+		priv->pdev, q->size, &q->nic);
+	if (!q->drv) {
+		printk(KERN_WARNING 
+		       "Can not allocate status queue.\n");
+		return -ENOMEM;
+	}
+
+	memset(q->drv, 0, q->size);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static void status_queue_free(struct ipw2100_priv *priv)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (priv->status_queue.drv)
+		pci_free_consistent(
+			priv->pdev, priv->status_queue.size, 
+			priv->status_queue.drv, priv->status_queue.nic);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static int bd_queue_allocate(struct ipw2100_priv *priv,
+			     struct ipw2100_bd_queue *q, int entries)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	memset(q, 0, sizeof(struct ipw2100_bd_queue));
+
+	q->entries = entries;
+	q->size = entries * sizeof(struct ipw2100_bd);
+	q->drv = pci_alloc_consistent(priv->pdev, q->size, &q->nic);
+	if (!q->drv) {
+		IPW2100_DEBUG_INFO("can't allocate shared memory for "
+		       "buffer descriptors\n");
+		return -ENOMEM;
+	}
+	memset(q->drv, 0, q->size);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static void bd_queue_free(struct ipw2100_priv *priv,
+			  struct ipw2100_bd_queue *q)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (!q)
+		return;
+
+	if (q->drv)
+		pci_free_consistent(priv->pdev,
+				    q->size, q->drv, q->nic);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static void bd_queue_initialize(
+	struct ipw2100_priv *priv, struct ipw2100_bd_queue * q,
+	u32 base, u32 size, u32 r, u32 w)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	IPW2100_DEBUG_INFO("initializing bd queue at virt=%p, phys=%08x\n", q->drv, q->nic);
+
+	write_register(priv->ndev, base, q->nic);
+	write_register(priv->ndev, size, q->entries);
+	write_register(priv->ndev, r, q->oldest);
+	write_register(priv->ndev, w, q->next);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static int ipw2100_tx_allocate(struct ipw2100_priv *priv)
+{
+	int i, j, err = -EINVAL;
+	void *v;
+	dma_addr_t p;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	err = bd_queue_allocate(priv, &priv->tx_queue, TX_QUEUE_LENGTH);
+	if (err) {
+		printk(KERN_ERR "%s: failed bd_queue_allocate\n",
+		       priv->ndev->name);
+		return err;
+	}
+
+	priv->tx_buffers = (struct ipw2100_hw_packet *)kmalloc(
+		TX_PENDED_QUEUE_LENGTH * sizeof(struct ipw2100_hw_packet), 
+		GFP_KERNEL);
+	if (!priv->tx_buffers) {
+		printk(KERN_ERR "%s: alloc failed form tx buffers.\n",
+		       priv->ndev->name);
+		bd_queue_free(priv, &priv->tx_queue);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {
+		v = pci_alloc_consistent(
+			priv->pdev, sizeof(struct ipw2100_data_header), &p);
+		if (!v) {
+			printk(KERN_ERR "%s: PCI alloc failed for tx "
+			       "buffers.\n", priv->ndev->name);
+			err = -ENOMEM;
+			break;
+		}
+
+		priv->tx_buffers[i].type = DATA;
+		priv->tx_buffers[i].data = (struct ipw2100_data_header*)v;
+		priv->tx_buffers[i].data_phys = p;
+		priv->tx_buffers[i].skb = NULL;
+	}
+	
+	if (i == TX_PENDED_QUEUE_LENGTH)
+		return 0;
+
+	for (j = 0; j < i; j++) {
+		pci_free_consistent(
+			priv->pdev,
+			sizeof(struct ipw2100_data_header), 
+			priv->tx_buffers[j].data,
+			priv->tx_buffers[j].data_phys);
+	}
+	
+	kfree(priv->tx_buffers);
+	priv->tx_buffers = NULL;
+
+	return err;
+}
+
+static void ipw2100_tx_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/*
+	 * reinitialize packet info lists
+	 */
+	INIT_LIST_HEAD(&priv->fw_pend_list);
+
+	/* 
+	 * reinitialize lists
+	 */
+	INIT_LIST_HEAD(&priv->tx_pend_list);
+	INIT_LIST_HEAD(&priv->tx_free_list);
+	for (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {
+		/* We simply drop any SKBs that have been queued for
+		 * transmit */
+		if (priv->tx_buffers[i].skb != NULL) {
+			dev_kfree_skb(priv->tx_buffers[i].skb);
+			priv->tx_buffers[i].skb = NULL;
+		}
+		list_add_tail(&priv->tx_buffers[i].list, &priv->tx_free_list);
+	}
+
+	priv->tx_queue.oldest = 0;
+	priv->tx_queue.available = priv->tx_queue.entries;
+	priv->tx_queue.next = 0;
+	
+	bd_queue_initialize(priv, &priv->tx_queue,
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_BASE(0),
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_SIZE(0),
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(0),
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0));
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+}
+
+static void ipw2100_tx_free(struct ipw2100_priv *priv)
+{
+	int i;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	bd_queue_free(priv, &priv->tx_queue);
+
+	if (!priv->tx_buffers)
+		return;
+
+	for (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {
+		if (priv->tx_buffers[i].skb != NULL) {
+			pci_unmap_single(
+				priv->pdev,
+				priv->tx_buffers[i].skb_phys,
+				priv->tx_buffers[i].skb->len,
+				PCI_DMA_TODEVICE);
+			dev_kfree_skb(priv->tx_buffers[i].skb);
+			priv->tx_buffers[i].skb = NULL;
+		}
+		
+		if (priv->tx_buffers[i].data)
+			pci_free_consistent(
+				priv->pdev,
+				sizeof(struct ipw2100_data_header),
+				priv->tx_buffers[i].data,
+				priv->tx_buffers[i].data_phys);
+	}
+	
+	kfree(priv->tx_buffers);
+	priv->tx_buffers = NULL;
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+
+
+static int ipw2100_rx_allocate(struct ipw2100_priv *priv)
+{
+	int i, j, err = -EINVAL;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	err = bd_queue_allocate(priv, &priv->rx_queue, RX_QUEUE_LENGTH);
+	if (err) {
+		IPW2100_DEBUG_INFO("failed bd_queue_allocate\n");
+		return err;
+	}
+
+	err = status_queue_allocate(priv, RX_QUEUE_LENGTH);
+	if (err) {
+		IPW2100_DEBUG_INFO("failed status_queue_allocate\n");
+		bd_queue_free(priv, &priv->rx_queue);
+		return err;
+	}
+
+	/*
+	 * allocate packets
+	 */
+	priv->rx_buffers = (struct ipw2100_hw_packet *)
+	    kmalloc(RX_QUEUE_LENGTH * sizeof(struct ipw2100_hw_packet), 
+		    GFP_KERNEL);
+	if (!priv->rx_buffers) {
+		IPW2100_DEBUG_INFO("can't allocate rx packet buffer table\n");
+
+		bd_queue_free(priv, &priv->rx_queue);
+
+		status_queue_free(priv);
+
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < RX_QUEUE_LENGTH; i++) {
+		struct ipw2100_hw_packet *packet;
+
+		packet = ipw2100_alloc_skb(priv, &priv->rx_buffers[i]);
+		if (!packet) {
+			err = -ENOMEM;
+			break;
+		}
+
+		/* The BD holds the cache aligned address */
+		priv->rx_queue.drv[i].host_addr = packet->dma_addr;
+		priv->rx_queue.drv[i].buf_length = IPW_RX_NIC_BUFFER_LENGTH;
+		priv->status_queue.drv[i].status_fields = 0;
+	}
+
+	if (i == RX_QUEUE_LENGTH) 
+		return 0;
+
+	for (j = 0; j < i; j++) {
+		pci_unmap_single(priv->pdev, priv->rx_buffers[j].dma_addr,
+				 sizeof(struct ipw2100_rx_packet),
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(priv->rx_buffers[j].skb);
+	}
+	
+	kfree(priv->rx_buffers);
+	priv->rx_buffers = NULL;
+
+	bd_queue_free(priv, &priv->rx_queue);
+
+	status_queue_free(priv);
+
+	return err;
+}
+
+static void ipw2100_rx_initialize(struct ipw2100_priv *priv)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	priv->rx_queue.oldest = 0;
+	priv->rx_queue.available = priv->rx_queue.entries - 1;
+	priv->rx_queue.next = priv->rx_queue.entries - 1;
+
+	bd_queue_initialize(priv, &priv->rx_queue,
+			    IPW_MEM_HOST_SHARED_RX_BD_BASE,
+			    IPW_MEM_HOST_SHARED_RX_BD_SIZE,
+			    IPW_MEM_HOST_SHARED_RX_READ_INDEX,
+			    IPW_MEM_HOST_SHARED_RX_WRITE_INDEX);
+
+	/* set up the status queue */
+	write_register(priv->ndev, IPW_MEM_HOST_SHARED_RX_STATUS_BASE,
+		       priv->status_queue.nic);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static void ipw2100_rx_free(struct ipw2100_priv *priv)
+{
+	int i;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	bd_queue_free(priv, &priv->rx_queue);
+	status_queue_free(priv);
+
+	if (!priv->rx_buffers)
+		return;
+
+	for (i = 0; i < RX_QUEUE_LENGTH; i++) {
+		if (priv->rx_buffers[i].rxp) {
+			pci_unmap_single(priv->pdev, 
+					 priv->rx_buffers[i].dma_addr,
+					 sizeof(struct ipw2100_rx_packet),
+					 PCI_DMA_FROMDEVICE);
+			dev_kfree_skb(priv->rx_buffers[i].skb);
+		}
+	}
+	
+	kfree(priv->rx_buffers);
+	priv->rx_buffers = NULL;
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static int ipw2100_read_mac_address(struct ipw2100_priv *priv)
+{
+	u32 length = ETH_ALEN;
+	u8 mac[ETH_ALEN];
+
+	int err;
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ADAPTER_MAC, 
+				  mac, &length);
+	if (err) {
+		IPW2100_DEBUG_INFO("MAC address read failed\n");
+		return -EIO;
+	}
+	IPW2100_DEBUG_INFO("card MAC is %02X:%02X:%02X:%02X:%02X:%02X\n",
+	       mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	memcpy(priv->ndev->dev_addr, mac, ETH_ALEN);
+
+	return 0;
+}
+
+/********************************************************************
+ *
+ * Firmware Commands
+ *
+ ********************************************************************/
+int ipw2100_start_scan(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = BROADCAST_SCAN,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/* Not clearing here; doing so makes iwlist always return nothing... 
+	 *
+	 * We should modify the table logic to use aging tables vs. clearing 
+	 * the table on each scan start.
+	 */
+	IPW2100_DEBUG_SCAN("starting scan\n");
+	err =  ipw2100_hw_send_command(priv, &cmd);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return err;
+}
+
+int ipw2100_set_mac_address(struct ipw2100_priv *priv, int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = ADAPTER_ADDRESS,
+		.host_command_sequence = 0,
+		.host_command_length = ETH_ALEN
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+	memcpy(cmd.host_command_parameters, priv->ndev->dev_addr, ETH_ALEN);
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return err;
+}
+
+int ipw2100_set_port_type(struct ipw2100_priv *priv, u32 port_type, 
+				 int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = PORT_TYPE,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(u32),
+		.host_command_parameters[0] = port_type
+	};
+	int err;
+
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	/* send cmd to firmware */
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	/* store if successful */
+	if (!err) 
+		priv->ctx->port_type = port_type;
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+
+int ipw2100_set_channel(struct ipw2100_priv *priv, u32 channel, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = CHANNEL,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(channel),
+		.host_command_parameters[0] = channel
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("CHANNEL: %d\n", channel);
+
+	/* If not BSS then we don't support channel selection */
+	if (priv->ctx->port_type != IBSS) 
+		return 0;
+
+	if ((priv->ctx->channel < REG_MIN_CHANNEL) ||
+	    (priv->ctx->channel > REG_MAX_CHANNEL)) 
+		return -EINVAL;
+		
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+	
+		
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) {
+		IPW2100_DEBUG_INFO
+			("Failed to set channel to %d",
+			 channel);
+		return err;
+	}
+	
+	priv->ctx->channel = channel;
+	
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	return 0;
+}
+
+static int ipw2100_system_config(struct ipw2100_priv *priv, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = SYSTEM_CONFIG,
+		.host_command_sequence = 0,
+		.host_command_length = 12,
+	};
+	int err;
+
+	/* Set system configuration */
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	cmd.host_command_parameters[0] = CFG_BSS_MASK;
+
+	/* l1b only */
+	/*cmd.host_command_parameters[0] |= DIVERSITY_ANTENNA_A;*/
+
+	/* long preamble - workaround for a faulty 802.11b radio */
+	cmd.host_command_parameters[0] |= CFG_PREAMBLE_LEN;
+	cmd.host_command_parameters[0] |= CFG_802_1x_ENABLE;
+
+	cmd.host_command_parameters[1] = REG_CHANNEL_MASK;
+
+	cmd.host_command_parameters[2] = 0;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err)
+		return err;
+
+	cmd.host_command = ADD_MULTICAST;
+	cmd.host_command_sequence = 0;
+	cmd.host_command_length = 0;
+
+	ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	return 0;
+}
+
+int ipw2100_set_tx_rates(struct ipw2100_priv *priv, u32 rate, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = BASIC_TX_RATES,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = rate & TX_RATE_MASK
+	};
+	int err;
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	/* Set BASIC TX Rate */
+	ipw2100_hw_send_command(priv, &cmd);
+
+	/* Set TX Rate */
+	cmd.host_command = TX_RATES;
+	ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	return 0;
+}
+
+int ipw2100_set_power_mode(struct ipw2100_priv *priv, 
+			   int power_level)
+{
+	struct host_command cmd = {
+		.host_command = POWER_MODE,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = power_level
+	};
+	int err;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err)
+		return err;
+
+#ifdef CONFIG_IPW2100_TX_POWER
+	if (priv->port_type == IBSS && 
+	    priv->adhoc_power != DFTL_IBSS_TX_POWER) {
+		/* Set beacon interval */
+		cmd.host_command = TX_POWER_INDEX;
+		cmd.host_command_parameters[0] = (u32)priv->adhoc_power;
+
+		err = ipw2100_hw_send_command(priv, &cmd);
+		if (err)
+			return err;
+	}
+#endif
+
+	return 0;
+}
+
+
+int ipw2100_set_rts_threshold(struct ipw2100_priv *priv, u32 threshold)
+{
+	struct host_command cmd = {
+		.host_command = RTS_THRESHOLD,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = threshold
+	};
+	int err;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) 
+		return err;
+
+	priv->rts_threshold = threshold;
+
+	return 0;
+}
+
+int ipw2100_set_fragmentation_threshold(struct ipw2100_priv *priv,
+					u32 threshold, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = FRAG_THRESHOLD,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = 0,
+	};
+	int err;
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	if (threshold == 0) 
+		threshold = DEFAULT_FRAG_THRESHOLD;
+	else {
+		threshold = max(threshold, MIN_FRAG_THRESHOLD);
+		threshold = min(threshold, MAX_FRAG_THRESHOLD);
+	}
+
+	cmd.host_command_parameters[0] = threshold;
+
+	IPW2100_DEBUG_FW_COMMAND("FRAG_THRESHOLD: %u\n", threshold);
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batchmode)
+		ipw2100_enable_adapter(priv);
+
+	if (!err)
+		priv->frag_threshold = threshold;
+
+	return err;
+}
+
+int ipw2100_set_short_retry(struct ipw2100_priv *priv, u32 retry)
+{
+	struct host_command cmd = {
+		.host_command = SHORT_RETRY_LIMIT,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = retry
+	};
+	int err;
+	
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err)
+		return err;
+
+	priv->short_retry_limit = retry;
+
+	return 0;
+}
+
+int ipw2100_set_long_retry(struct ipw2100_priv *priv, u32 retry)
+{
+	struct host_command cmd = {
+		.host_command = LONG_RETRY_LIMIT,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = retry
+	};
+	int err;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) 
+		return err;
+
+	priv->long_retry_limit = retry;
+
+	return 0;
+}
+
+
+int ipw2100_set_mandatory_bssid(struct ipw2100_priv *priv, u8 *bssid, 
+				int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = MANDATORY_BSSID,
+		.host_command_sequence = 0,
+		.host_command_length = (bssid == NULL) ? 0 : ETH_ALEN 
+	};
+	int err;
+
+#ifdef CONFIG_IPW2100_DEBUG
+	if (bssid != NULL)
+		IPW2100_DEBUG_FW_COMMAND(
+			"MANDATORY_BSSID: %02X:%02X:%02X:%02X:%02X:%02X\n",
+			bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], 
+			bssid[5]);
+	else
+		IPW2100_DEBUG_FW_COMMAND("MANDATORY_BSSID: <clear>\n");
+#endif
+	/* if BSSID is empty then we disable mandatory bssid mode */
+	if (bssid != NULL)
+		memcpy((u8 *)cmd.host_command_parameters, bssid, ETH_ALEN);
+	
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	
+	if (!batchmode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+#if 0
+static int ipw2100_disassociate_bssid(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = DISASSOCIATION_BSSID,
+		.host_command_sequence = 0,
+		.host_command_length = ETH_ALEN
+	};
+	int err;
+	int len;
+
+	IPW2100_DEBUG_FW_COMMAND("DISASSOCIATION_BSSID\n");
+
+	len = ETH_ALEN;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, 
+				  &priv->ctx->bssid,  &len);
+	memcpy(cmd.host_command_parameters, priv->ctx->bssid, ETH_ALEN);
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	return err;
+}
+#endif
+		
+int ipw2100_set_essid(struct ipw2100_priv *priv, char *essid, int batchmode)
+{
+	int ssid_length = strnlen(essid, IW_ESSID_MAX_SIZE);
+	struct host_command cmd = {
+		.host_command = SSID,
+		.host_command_sequence = 0,
+		.host_command_length = ssid_length
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("SSID: %s\n", essid);
+	
+	if (memcmp(priv->ctx->ssid, essid, ssid_length) == 0)
+		return 0;
+
+	if (ssid_length) 
+		strncpy((char*)cmd.host_command_parameters, 
+			essid, ssid_length);
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err)
+			return err;
+	}
+
+	ipw2100_start_scan(priv);
+		
+	/* NOTE:  We always send the SSID command even if the provided ESSID is
+	 * the same as what we currently think is set. */
+	
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (!err) {
+		memset(priv->ctx->ssid, 0, IW_ESSID_MAX_SIZE);
+		memcpy(priv->ctx->ssid, essid, ssid_length);
+		
+	}
+
+	if (!batchmode) {
+		if (ipw2100_enable_adapter(priv)) 
+			err = -EIO;
+	}
+
+	return err;
+}
+
+
+struct security_info_params {
+	u32 allowed_ciphers;
+	u16 version;
+	u8 auth_mode;
+	u8 replay_counters_number;
+	u8 unicast_using_group;
+} __attribute__ ((packed));
+
+int ipw2100_set_security_information(struct ipw2100_priv *priv, 
+				     int auth_shared, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = SET_SECURITY_INFORMATION,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(struct security_info_params)
+	};
+	struct security_info_params *security = 
+		(struct security_info_params *)&cmd.host_command_parameters;
+	int err;
+	memset(security, 0, sizeof(*security));
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/* All encryption/decryption is handled in the driver itself and no
+	 * longer in the firmware, so set the firmware to not do anything and
+	 * just provide all packets to the driver 
+	 *
+	 * NOTE: This is the case for everything except AP authentication */
+	security->auth_mode = auth_shared ? AUTH_SHARED : AUTH_OPEN;
+	if (security->auth_mode == AUTH_OPEN) 
+		security->allowed_ciphers = NONE_CIPHER;
+	else if (security->auth_mode == AUTH_SHARED) 
+		security->allowed_ciphers = WEP40_CIPHER | WEP104_CIPHER;
+	security->replay_counters_number = 0;
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err)
+			return err;
+	}
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (!err)
+		priv->authentication = security->auth_mode;
+		
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+	}
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return err;
+}
+
+int ipw2100_set_ibss_beacon_interval(struct ipw2100_priv *priv, 
+				     u32 interval, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = BEACON_INTERVAL,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = interval
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (priv->port_type == IBSS) {
+		if (!batchmode) {
+			err = ipw2100_disable_adapter(priv);
+			if (err)
+				return err;
+		}
+		
+		ipw2100_hw_send_command(priv, &cmd);
+		
+		if (!batchmode) {
+			err = ipw2100_enable_adapter(priv);
+			if (err)
+				return err;
+		}
+	}
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+int ipw2100_set_scan_options(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = SET_SCAN_OPTIONS,
+		.host_command_sequence = 0,
+		.host_command_length = 8,
+		.host_command_parameters[0] = 0,
+		.host_command_parameters[1] = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	IPW2100_DEBUG_SCAN("setting scan options\n");
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return err;
+}
+
+
+void ipw2100_queues_initialize(struct ipw2100_priv *priv)
+{
+	ipw2100_tx_initialize(priv);
+	ipw2100_rx_initialize(priv);
+	ipw2100_msg_initialize(priv);
+}
+
+void ipw2100_queues_free(struct ipw2100_priv *priv)
+{
+	ipw2100_tx_free(priv);
+	ipw2100_rx_free(priv);
+	ipw2100_msg_free(priv);
+}
+
+int ipw2100_queues_allocate(struct ipw2100_priv *priv)
+{
+	int err;
+	err = ipw2100_tx_allocate(priv);
+	if (err)
+		goto fail;
+
+	err = ipw2100_rx_allocate(priv);
+	if (err)
+		goto fail;
+	
+	err = ipw2100_msg_allocate(priv);
+	if (err)
+		goto fail;
+
+	return 0;
+
+ fail:
+	ipw2100_rx_free(priv);
+	ipw2100_msg_free(priv);
+	return -ENOMEM;
+}
+
+static int ipw2100_adapter_setup(struct ipw2100_priv *priv)
+{
+	int err;
+	int batchmode = 1;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	err = ipw2100_disable_adapter(priv);
+	if (err)
+		return err;
+
+	err = ipw2100_read_mac_address(priv);
+	if (err)
+		return -EIO;
+
+	err = ipw2100_set_mac_address(priv, batchmode);
+	if (err)
+		return err;
+	
+	err = ipw2100_set_port_type(priv, BSS, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_channel(priv, priv->ctx->channel, batchmode);
+	if (err)
+		return err;
+
+	err  = ipw2100_system_config(priv, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_tx_rates(priv, 0xFFFFFFFF, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);
+	if (err)
+		return err;
+
+	err = ipw2100_set_rts_threshold(priv, priv->rts_threshold);
+	if (err)
+		return err;
+
+	err = ipw2100_set_mandatory_bssid(priv, NULL, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_essid(priv, priv->ctx->ssid, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_security_information(priv, AUTH_OPEN, batchmode);
+	if (err)
+		return err;
+
+	if (priv->ctx->port_type == IBSS) {
+		err = ipw2100_set_ibss_beacon_interval(
+			priv, priv->beacon_interval, batchmode);
+		if (err)
+			return err;
+	}
+
+	err = ipw2100_set_scan_options(priv);
+	if (err)
+		return err;
+
+	/*
+	 err = ipw2100_set_tx_power_mode(priv, ...);
+	 if (err) 
+	 return err;
+	*/
+	err = ipw2100_set_fragmentation_threshold(
+		priv, priv->frag_threshold, batchmode);
+	if (err) 
+		return err;
+	
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+
+/*************************************************************************
+ * 
+ * EXTERNALLY CALLED METHODS
+ *
+ *************************************************************************/
+
+/* This method is called by the network layer -- not to be confused with
+ * ipw2100_set_mac_address() declared above called by this driver (and this
+ * method as well) to talk to the firmware */
+static int ipw2100_set_address(struct net_device *dev, void *p)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct sockaddr *addr = p;
+	int err;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	err = ipw2100_set_mac_address(priv, 0);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ipw2100_open(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	unsigned long flags;
+
+	IPW2100_DEBUG_INFO("enter\n");
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_INC_USE_COUNT;
+#endif
+
+	/* TODO: We probably shouldn't start the queue until we receive
+	 * an association.  Likewise, for netif_carrier_on() . . .
+	 */
+	netif_start_queue(dev);
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+	priv->open = 1;
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return 0;
+}
+
+static int ipw2100_close(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	unsigned long flags;
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	netif_carrier_off(dev);
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	priv->open = 0;
+	
+	/* Flush the TX queue ... */
+	while (!list_empty(&priv->tx_pend_list)) {
+		element = priv->tx_pend_list.next;
+                packet = list_entry(element, struct ipw2100_hw_packet, list);
+		list_del(element);
+		dev_kfree_skb(packet->skb);
+		packet->skb = NULL;
+		list_add_tail(element, &priv->tx_free_list);
+	}
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+#endif
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static int ipw2100_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	unsigned long flags;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	if (!priv->connected) { 
+		/* TODO: check code to ensure that xmit disabled during
+		 * any call that results in priv->connected == false */
+		IPW2100_DEBUG_INFO("Can not transmit when not connected.\n");
+		priv->stats.tx_carrier_errors++;
+		goto fail_unlock;
+	}
+
+	if (list_empty(&priv->tx_free_list)) {
+		printk(KERN_WARNING "%s: No TX buffers available when awake.\n",
+		       priv->ndev->name);
+		goto fail_unlock;
+	}
+	
+	ipw2100_tx_prepare(priv, skb);
+
+	if (list_empty(&priv->tx_free_list))
+		netif_stop_queue(dev);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return 0;
+
+ fail_unlock:
+	IPW2100_DEBUG_INFO("exit - failed\n");
+	netif_stop_queue(dev);
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+	return 1;
+}
+
+
+/*
+ * TODO:  Fix this function... its just wrong
+ */
+static void ipw2100_tx_timeout(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_TX("enter (connected=%d)\n", priv->connected);
+
+	priv->stats.tx_errors++;
+
+	/* TODO: Make sure we shut off the network interface on 
+	 * disassociation */
+	printk(KERN_INFO "%s: TX timed out.  Scheduling firmware restart.\n",
+	       dev->name);
+	if (!priv->reset_pending) {
+		priv->reset_pending = 1;
+		schedule_work(&priv->reset_work);
+	}
+
+	IPW2100_DEBUG_TX("exit\n");
+}
+
+
+/*
+ * TODO: reimplement it so that it reads statistics
+ *       from the adapter using ordinal tables
+ *       instead of/in addition to collecting them
+ *       in the driver
+ */
+static struct net_device_stats *ipw2100_stats(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv*)dev->priv;
+	return &priv->stats;
+}
+
+static int ipw2100_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu < ETH_ZLEN || new_mtu > ETH_DATA_LEN)
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+
+static int ipw2100_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return -EOPNOTSUPP;
+}
+
+
+static u32 ipw2100_ethtool_get_link(struct net_device *dev)
+{
+    struct ipw2100_priv *priv = (struct ipw2100_priv*)dev->priv;
+    return priv->connected;
+}
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,23)
+static struct ethtool_ops ipw2100_ethtool_ops = {
+    .get_link        = ipw2100_ethtool_get_link,
+};
+#endif
+
+static void ipw2100_hang_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+	unsigned long flags;
+	u32 rtc = 0xa5a5a5a5;
+	u32 len = sizeof(rtc);
+	int restart = 0;
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	if (priv->fatal_error != 0) {
+		/* If fatal_error is set then we need to restart */
+		printk(KERN_INFO "%s: Hardware fatal error detected.\n",
+		       priv->ndev->name);
+
+		restart = 1;
+
+	} else if (ipw2100_get_ordinal(priv, IPW_ORD_RTC_TIME, &rtc, &len) ||
+		   (rtc == priv->last_rtc)) {
+		/* Check if firmware is hung */
+		printk(KERN_INFO "%s: Firmware RTC stalled.\n",
+		       priv->ndev->name);
+
+		restart = 1;
+
+	}
+
+	if (restart) {
+		/* Kill timer */
+		priv->stop_hang_check = 1;
+		
+		priv->hangs++;
+		
+		/* Restart the NIC */
+		if (!priv->reset_pending) {
+			printk(KERN_INFO "%s: Scheduling firmware restart.\n",
+			       priv->ndev->name);
+			
+			priv->reset_pending = 1;
+			schedule_work(&priv->reset_work);
+		} else
+			printk(KERN_INFO 
+			       "%s: Firmware restart already in progress.\n",
+			       priv->ndev->name);
+	} 
+
+	priv->last_rtc = rtc;
+
+	/* Check again in two seconds */
+	if (!priv->stop_hang_check)
+		mod_timer(&priv->hang_check_timer, jiffies + 2 * HZ);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+}
+
+
+static void ipw2100_rf_switch_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (priv->rf_kill != ipw2100_get_rf_switch(priv)) {
+		/* Toggle the switch to match what the HW told us */
+		priv->rf_kill = !priv->rf_kill;
+		
+		printk(KERN_INFO "%s: RF Kill state changed to radio %s.\n",
+		       priv->ndev->name,
+		       priv->rf_kill ? "OFF" : "ON");
+		
+		if (priv->rf_kill) {
+			/* RF switch is ON; firmware will have killed the HW */
+			priv->rf_kill = 0;
+		} else {
+                        /* Kill timer; we don't need to poll for RF going
+			 * off since the firmware will tell us */
+			priv->stop_rf_check = 1;
+			
+			/* Restart the NIC */
+			if (!priv->reset_pending) {
+				printk(KERN_INFO 
+				       "%s: Scheduling firmware restart.\n",
+				       priv->ndev->name);
+				
+				priv->reset_pending = 1;
+				schedule_work(&priv->reset_work);
+			} else
+				printk(KERN_INFO 
+				       "%s: Firmware restart already in progress.\n",
+				       priv->ndev->name);
+		} 
+	} 
+	
+	/* Check again in one second */
+	if (!priv->stop_rf_check)
+		mod_timer(&priv->rf_switch_timer, jiffies + HZ);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+}
+
+static void ipw2100_irq_tasklet(struct ipw2100_priv *priv);
+
+static struct net_device *ipw2100_alloc_device(
+	struct pci_dev *pdev,
+	char *base_addr, 
+	unsigned long mem_start,
+	unsigned long mem_len)
+{
+	struct ipw2100_priv *priv;
+	struct net_device *dev;
+
+	dev = alloc_etherdev(sizeof(struct ipw2100_priv));
+	if (!dev)
+		return NULL;
+
+	dev->type = ARPHRD_ETHER;
+	dev->open = ipw2100_open;
+	dev->stop = ipw2100_close;
+	dev->hard_start_xmit = ipw2100_tx;
+	dev->do_ioctl = ipw2100_ioctl;
+	dev->get_stats = ipw2100_stats;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,23)
+	dev->ethtool_ops = &ipw2100_ethtool_ops;
+#endif
+	dev->change_mtu = ipw2100_change_mtu;
+	dev->tx_timeout = ipw2100_tx_timeout;
+	dev->wireless_handlers = &ipw2100_wx_handler_def;
+	dev->get_wireless_stats = ipw2100_wx_wireless_stats;
+	dev->set_mac_address = ipw2100_set_address;
+	dev->watchdog_timeo = 3*HZ;
+	dev->irq = 0;
+
+	dev->base_addr = (unsigned long)base_addr;
+	dev->mem_start = mem_start;
+	dev->mem_end = dev->mem_start + mem_len - 1;
+	
+	if (!if_name || if_name[0] == '\0')
+                strncpy(dev->name, "eth%d", IFNAMSIZ - 1);
+        else 
+                strncpy(dev->name, if_name, IFNAMSIZ - 1);
+
+	/* NOTE: We don't use the wireless_handlers hook
+	 * in dev as the system will start throwing WX requests
+	 * to us before we're actually initialized and it just
+	 * ends up causing problems.  So, we just handle
+	 * the WX extensions through the ipw2100_ioctl interface */
+
+	priv = (struct ipw2100_priv*)dev->priv;
+	memset(priv, 0, sizeof(struct ipw2100_priv));
+
+	priv->ctx = &priv->active_ctx;
+	priv->pdev = pdev;
+	priv->ndev = dev;
+
+	/* memset() puts everything to 0, so we only have explicitely set
+	 * those values that need to be something else */
+	priv->disabled = 1;
+	priv->stopped = 1;
+
+	priv->ctx->port_type = BSS;
+	priv->ctx->channel = 1;
+
+	priv->beacon_interval = DEFAULT_BEACON_INTERVAL;
+	priv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;
+	priv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;
+	priv->rts_threshold = DEFAULT_RTS_THRESHOLD;
+	priv->frag_threshold = DEFAULT_FRAG_THRESHOLD;
+
+	priv->tx_power = 0;
+
+	strcpy(priv->nick, "ipw2100");
+
+
+	IPW2100_DEBUG_INFO("Port type set to %s\n", 
+			   port_type_str[priv->ctx->port_type]);
+
+	spin_lock_init(&priv->low_lock);
+
+	init_waitqueue_head(&priv->wait_command_queue);
+
+	priv->connected = 0;
+	netif_carrier_off(dev);
+
+#ifndef CONFIG_IPW2100_WEP
+	INIT_LIST_HEAD(&priv->defrag_free_list);
+	INIT_LIST_HEAD(&priv->defrag_list);
+#endif
+		       
+	INIT_LIST_HEAD(&priv->msg_free_list);
+	INIT_LIST_HEAD(&priv->msg_pend_list);
+
+	INIT_LIST_HEAD(&priv->tx_free_list);
+	INIT_LIST_HEAD(&priv->tx_pend_list);
+
+	INIT_LIST_HEAD(&priv->fw_pend_list);
+	
+	INIT_WORK(&priv->reset_work, (void (*)(void *))ipw2100_reset_adapter, 
+		  priv);
+
+	tasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))
+		     ipw2100_irq_tasklet, (unsigned long)priv);
+
+	/* NOTE:  We do not start the timer yet; we only run the timer if the
+	 *        the RF kill switch has been triggered */
+	init_timer(&priv->rf_switch_timer);
+	priv->rf_switch_timer.data = (unsigned long)priv;
+	priv->rf_switch_timer.function = ipw2100_rf_switch_check;
+	priv->stop_rf_check = 1;   /* Timer not running */
+
+	init_timer(&priv->hang_check_timer);
+	priv->hang_check_timer.data = (unsigned long)priv;
+	priv->hang_check_timer.function = ipw2100_hang_check;
+	priv->stop_hang_check = 1; /* Timer not running */
+	return dev;
+}
+
+
+#ifdef CONFIG_IPW2100_WEP
+
+#define IPW_PRIVACY_CAPABLE 0x0008
+
+static int ipw2100_set_wep_flags(struct ipw2100_priv *priv, u32 flags, 
+				 int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = WEP_FLAGS,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = flags,
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("WEP_FLAGS: flags = 0x%08X\n", flags);
+	
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	/* send cmd to firmware */
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+struct ipw2100_wep_key {
+	u8 idx;
+	u8 len;
+	u8 key[13];
+};
+
+static int ipw2100_set_key(struct ipw2100_priv *priv, 
+			   int idx, char *key, int len, int batch_mode)
+{
+	int keylen = len ? (len <= 5 ? 5 : 13) : 0;
+	struct host_command cmd = {
+		.host_command = WEP_KEY_INFO,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(struct ipw2100_wep_key),
+	};
+	struct ipw2100_wep_key *wep_key = (void*)cmd.host_command_parameters;
+	int err;
+	
+	IPW2100_DEBUG_FW_COMMAND("WEP_KEY_INFO: index = %d, len = %d/%d\n", idx,
+				 keylen, len);
+
+	/* NOTE: We don't check cached values in case the firmware was reset
+	 * or some other problem is occuring.  If the user is setting the key,
+	 * then we push the change */
+	
+	wep_key->idx = idx;
+	wep_key->len = keylen;
+
+	if (keylen) {
+		memcpy(wep_key->key, key, len);
+		memset(wep_key->key + len, 0, keylen - len);
+	}
+
+	printk(KERN_INFO "%s: idx: %d, len: %d key: %c%c%c%c%c\n",
+	       priv->ndev->name, wep_key->idx, wep_key->len,
+	       wep_key->key[0], 
+	       wep_key->key[1], 
+	       wep_key->key[2], 
+	       wep_key->key[3], 
+	       wep_key->key[4]);
+
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	err = ipw2100_set_wep_flags(priv, IPW_PRIVACY_CAPABLE, 1);
+	if (!err) {
+		/* send cmd to firmware */
+		err = ipw2100_hw_send_command(priv, &cmd);
+		
+		/* store if successful */
+		if (!err) {
+			memcpy(priv->key_table[idx], key, len);
+			priv->key_size[idx] = len;
+		}
+	}
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+static int ipw2100_set_key_index(struct ipw2100_priv *priv, 
+				 int idx, int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = WEP_KEY_INDEX,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = idx,
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("WEP_KEY_INDEX: index = %d\n", idx);
+	
+	if (idx < 0 || idx > 3)
+		return -EINVAL;
+
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	/* send cmd to firmware */
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	/* store if successful */
+	if (!err) {
+		priv->key_current = idx;
+	}
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+static void shim__set_key(struct ieee80211_device *ieee, int idx, 
+			    char *key, int len)
+{
+	ipw2100_set_key(ieee->priv, idx, key, len, 1);
+}
+
+static void shim__set_key_idx(struct ieee80211_device *ieee, int idx)
+{
+	ipw2100_set_key_index(ieee->priv, idx, 0);
+}
+
+static void shim__set_wep_authentication(struct ieee80211_device *ieee, 
+					 int enable)
+{
+	ipw2100_set_security_information(ieee->priv, 
+					 enable ? AUTH_SHARED : AUTH_OPEN, 0);
+}
+
+static struct ieee80211_helper_functions ipw2100_ieee_callbacks = {
+	.set_key = shim__set_key,
+	.set_key_idx = shim__set_key_idx,
+	.set_wep_authentication = shim__set_wep_authentication,
+	.card_present = NULL,
+	.cor_sreset = NULL,
+	.dev_open = NULL,
+	.dev_close = NULL,
+	.genesis_reset = NULL,
+	.set_unencrypted_filter = NULL,
+	.hw_enable = NULL,
+	.hw_config = NULL,
+	.hw_reset = NULL,
+	.hw_shutdown = NULL,
+	.reset_port = NULL,
+	.tx = NULL,
+	.schedule_reset = NULL,
+	.tx_80211 = NULL
+};
+#endif
+
+#define PCI_DMA_32BIT   0x00000000ffffffffULL
+
+static int ipw2100_pci_init_one(struct pci_dev *pdev, 
+				const struct pci_device_id *ent)
+{
+	unsigned long mem_start, mem_len, mem_flags;
+	char *base_addr = NULL;
+	struct net_device *dev = NULL;
+	struct ipw2100_priv *priv = NULL;
+	int err = 0;
+	int registered = 0;
+	u32 val;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/* set up PCI mappings for device */
+	err = pci_enable_device(pdev);
+	if (err)
+		return err;
+
+	pci_set_master(pdev);
+
+	err = pci_set_dma_mask(pdev, PCI_DMA_32BIT);
+	if (err) {
+		IPW2100_DEBUG_INFO("failed pci_set_dma_mask!\n");
+		pci_disable_device(pdev);
+		return err;
+	}
+
+	pci_set_drvdata(pdev, NULL);
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err) {
+		pci_disable_device(pdev);
+		return err;
+	}
+	
+        /* We disable the RETRY_TIMEOUT register (0x41) to keep 
+	 * PCI Tx retries from interfering with C3 CPU state */
+	pci_read_config_dword(pdev, 0x40, &val); 
+	if ((val & 0x0000ff00) != 0) 
+		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
+
+	mem_start = pci_resource_start(pdev, 0);
+	mem_len = pci_resource_len(pdev, 0);
+	mem_flags = pci_resource_flags(pdev, 0);
+
+	if ((mem_flags & IORESOURCE_MEM) != IORESOURCE_MEM) {
+		IPW2100_DEBUG_INFO("weird - resource type is not memory\n");
+		err = -ENODEV;
+		goto fail;
+	}
+
+	base_addr = ioremap_nocache(mem_start, mem_len);
+	if (!base_addr) {
+		err = -EIO;
+		goto fail;
+	}
+
+	pci_set_power_state(pdev, 0);
+	pci_restore_state(pdev, NULL);
+
+	/* allocate and initialize our net_device */
+	dev = ipw2100_alloc_device(pdev, base_addr, mem_start, mem_len);
+	if (!dev) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	if (!ipw2100_hw_is_adapter_in_system(dev)) {
+		err = -ENODEV;
+		goto fail;
+	}
+
+	pci_set_drvdata(pdev, dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+	SET_NETDEV_DEV(dev, &pdev->dev);
+#endif
+
+	priv = dev->priv;
+
+#ifdef CONFIG_IPW2100_WEP
+	ieee80211_init(&priv->ieee, dev, priv);
+	priv->ieee.func = &ipw2100_ieee_callbacks;
+#endif /* CONFIG_IPW2100_WEP */
+
+	/* begin initializing the hardware */
+	ipw2100_hw_disable_interrupt(priv);
+	priv->irq_enabled = 0;
+
+	/* Allocate and initialize the beacon list */
+	if (ipw2100_beacons_allocate(priv)) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	ipw2100_beacons_initialize(priv);
+
+	/* Allocate and initialize the Tx/Rx queues and lists */
+	if (ipw2100_queues_allocate(priv)) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	ipw2100_queues_initialize(priv);
+
+#ifndef CONFIG_IPW2100_WEP
+	/* Allocate and initialize the defrag buffers */
+	if (ipw2100_defrag_alloc(priv)) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	ipw2100_defrag_initialize(priv);
+#endif
+
+	err = request_irq(pdev->irq,
+			  ipw2100_interrupt, SA_SHIRQ, 
+			  dev->name, dev);
+	if (err) {
+		printk(KERN_ERR
+		       "ipw2100: Error allocating IRQ %d.\n",
+		       pdev->irq);
+		err = -EBUSY;
+		goto fail;
+	}
+	dev->irq = pdev->irq;
+
+	IPW2100_DEBUG_INFO("Attempting to register device...\n");
+
+	err = register_netdev(dev);
+	if (err) {
+		err = -ENODEV;
+		goto fail;
+	}
+	registered = 1;
+
+	SET_MODULE_OWNER(dev);
+
+	printk(KERN_INFO "Detected ipw2100 PCI device at "
+	       "%s, dev: %s, mem: 0x%lX-0x%lX -> %p, irq: %d\n",
+	       pdev->slot_name, dev->name,
+	       dev->mem_start, dev->mem_end, base_addr, pdev->irq);
+
+	/* perform this after register_netdev so that dev->name is
+	 * set */
+	err = ipw2100_proc_dev_init(priv);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Failed to create /proc node\n",
+		       dev->name);
+		err = -EIO;
+		goto fail;
+	}
+
+	/* Bring up the HW */
+	if (ipw2100_up(dev->priv)) {
+		err = -EIO;
+		goto fail;
+	}
+		
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+	
+ fail:
+	if (dev) {
+		if (registered) 
+			unregister_netdev(dev);
+
+		if (dev->irq) {
+			free_irq(dev->irq, dev);
+		}
+
+		/* These are safe to call even if they weren't allocated */
+#ifndef CONFIG_IPW2100_WEP
+		ipw2100_defrag_free(priv);
+#endif
+		ipw2100_beacons_free(priv);
+		ipw2100_queues_free(priv);
+		ipw2100_proc_dev_cleanup(priv);
+
+		free_netdev(dev);
+		pci_set_drvdata(pdev, NULL);
+	}
+
+	if (base_addr) 
+		iounmap((char*)base_addr);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+
+	return err;
+}
+
+static void __devexit ipw2100_pci_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct ipw2100_priv *priv;
+
+	if (dev) {
+		priv = dev->priv;
+
+		/* Unregister the device first - this results in close() 
+		 * being called if the device is open.  If we free storage
+		 * first, then close() will crash. */
+		unregister_netdev(dev);
+
+#ifdef CONFIG_IPW2100_WEP
+		ieee80211_deinit(&priv->ieee);
+#endif /* CONFIG_IPW2100_WEP */
+
+		ipw2100_down(priv);
+
+ 		ipw2100_proc_dev_cleanup(priv);
+
+#ifndef CONFIG_IPW2100_WEP
+		ipw2100_defrag_free(priv);
+#endif
+		ipw2100_beacons_free(priv);
+		ipw2100_queues_free(priv);
+
+		if (dev->irq)
+			free_irq(dev->irq, dev);
+
+		if (dev->base_addr)
+			iounmap((unsigned char *)dev->base_addr);
+
+		free_netdev(dev);
+	}
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+#ifdef CONFIG_PM
+
+static int ipw2100_suspend(struct pci_dev *pdev, u32 state)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct ipw2100_priv *priv = dev->priv;
+	
+	
+	netif_device_detach(dev);
+
+	if (netif_running(dev))
+		ipw2100_down(priv);
+	
+	pci_save_state(pdev, priv->pm_state);
+	pci_disable_device(pdev);       // needed?
+	pci_set_power_state(pdev, state);
+	
+	return 0;
+}
+
+
+static int ipw2100_resume(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct ipw2100_priv *priv = dev->priv;
+	u32 val;
+	
+	pci_set_power_state(pdev, 0);
+	pci_restore_state(pdev, priv->pm_state);
+	
+        /* Suspend/Resume resets the PCI configuration space, so we have to
+	 * re-disable the RETRY_TIMEOUT register (0x41) to keep 
+	 * PCI Tx retries from interfering with C3 CPU state */
+	pci_read_config_dword(pdev, 0x40, &val); 
+	if ((val & 0x0000ff00) != 0) 
+		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
+
+	if (netif_running(dev))
+		ipw2100_up(priv);
+	
+	netif_device_attach(dev);
+	
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+#define IPW2100_DEV_ID(x) { PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, x }
+
+static struct pci_device_id ipw2100_pci_id_table[] __devinitdata = {
+	IPW2100_DEV_ID(0x2520), /* IN 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2521), /* IN 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2524), /* IN 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2525), /* IN 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2526), /* IN 2100A mPCI Gen A3 */
+	IPW2100_DEV_ID(0x2522), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2523), /* IN 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2527), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2528), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2529), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x252B), /* IN 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x252C), /* IN 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x252D), /* IN 2100 mPCI 3A */
+
+	IPW2100_DEV_ID(0x2550), /* IB 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2551), /* IB 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2553), /* IB 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2554), /* IB 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2555), /* IB 2100 mPCI 3B */
+
+	IPW2100_DEV_ID(0x2560), /* DE 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2562), /* DE 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2563), /* DE 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2561), /* DE 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2565), /* DE 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2566), /* DE 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2567), /* DE 2100 mPCI 3A */
+
+	IPW2100_DEV_ID(0x2570), /* GA 2100 mPCI 3B */
+
+	IPW2100_DEV_ID(0x2580), /* TO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2582), /* TO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2583), /* TO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2581), /* TO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2585), /* TO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2586), /* TO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2587), /* TO 2100 mPCI 3B */
+
+	IPW2100_DEV_ID(0x2590), /* SO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2592), /* SO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2591), /* SO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2593), /* SO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2596), /* SO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2598), /* SO 2100 mPCI 3B */
+	
+	IPW2100_DEV_ID(0x25A0), /* HP 2100 mPCI 3B */
+	{0,},
+};
+
+MODULE_DEVICE_TABLE(pci, ipw2100_pci_id_table);
+
+static struct pci_driver ipw2100_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = ipw2100_pci_id_table,
+	.probe = ipw2100_pci_init_one,
+	.remove = __devexit_p(ipw2100_pci_remove_one),
+#ifdef CONFIG_PM
+	.suspend = ipw2100_suspend,
+	.resume = ipw2100_resume,
+#endif
+};
+
+/*
+ * module stuff
+ */
+
+static int __init ipw2100_init(void)
+{
+	int err;
+
+	printk(KERN_INFO DRV_NAME ": %s, %s\n", DRV_DESCRIPTION, DRV_VERSION);
+	printk(KERN_INFO DRV_NAME ": %s\n", DRV_COPYRIGHT);
+
+#ifdef CONFIG_IPW2100_WEP
+	printk(KERN_INFO DRV_NAME ": Compiled with WEP support.\n");
+#endif	       
+
+	/* If debug module parameter declared, set debug_level to that */
+	if (debug != -1) 
+		ipw2100_debug_level = debug;
+	else /* Otherwise, if ipw2100_debug_level has not been initialized, set
+	      * it to NONE */
+		if (ipw2100_debug_level & IPW2100_DL_UNINIT)
+			ipw2100_debug_level = IPW2100_DL_NONE;
+
+	ipw2100_proc_init();
+
+	err = pci_module_init(&ipw2100_pci_driver);
+	if (err)
+		ipw2100_proc_cleanup();
+
+	return err;
+}
+
+static void __exit ipw2100_exit(void)
+{
+	pci_unregister_driver(&ipw2100_pci_driver);
+
+	ipw2100_proc_cleanup();
+}
+
+module_init(ipw2100_init);
+module_exit(ipw2100_exit);
+
+/*
+         1         2         3         4         5         6         7
+12345678901234567890123456789012345678901234567890123456789012345678901234567890
+*/
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,1048 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+
+  Portions of this file are based on the sample_* files provided by Wireless
+  Extensions 0.26 package and copyright (c) 1997-2003 Jean Tourrilhes 
+  <jt@hpl.hp.com>
+
+  Portions of this file are based on the Host AP project, 
+  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+    <jkmaline@cc.hut.fi>
+  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+/*******************************************************************************
+
+  Changes
+
+  0.40 Pedro Ramalhais 
+       Added support for available channel and rates to iwlist.  Code derived
+       from Host AP.
+  0.33 Luc Saillard
+       Added support for wireless stats (/proc/net/wireless)
+
+*******************************************************************************/
+
+/*
+ * This file defines the Wireless Extension handlers.  It does not
+ * define any methods of hardware manipulation and relies on the
+ * functions defined in ipw2100_main to provide the HW interaction.
+ * 
+ * The exception to this is the use of the ipw2100_get_ordinal() 
+ * function used to poll the hardware vs. making unecessary calls.
+ *
+ */
+#include <asm/uaccess.h>
+
+#include "ipw2100.h"
+#include "ipw2100_hw.h"
+#include "ipw2100_wx.h"
+#include "ieee80211.h"
+
+#if WIRELESS_EXT > 12
+
+const long ipw2100_frequencies[] = {  
+	2412, 2417, 2422, 2427, 
+	2432, 2437, 2442, 2447, 
+	2452, 2457, 2462, 2467, 
+	2472, 2484  
+};
+
+#define FREQ_COUNT (sizeof(ipw2100_frequencies) / sizeof(ipw2100_frequencies[0]))
+
+const long ipw2100_rates_11b[] = {
+	1000000,
+	2000000,
+	5500000,
+	11000000
+};
+
+#define RATE_COUNT (sizeof(ipw2100_rates_11b) / sizeof(ipw2100_rates_11b[0]))
+
+static int ipw2100_wx_get_name(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	strcpy(wrqu->name, "IEEE 802.11b");
+	IPW2100_DEBUG_WX("Name: %s\n", wrqu->name);
+	return 0;
+}
+
+
+static int ipw2100_wx_set_freq(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra) 
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_freq *fwrq = &wrqu->freq;
+	
+	/* we only set channel in adhoc mode */
+	if (priv->ctx->port_type != BSS) {
+		/* if setting by freq convert to channel */
+		if (fwrq->e == 1) {
+			if ((fwrq->m >= (int) 2.412e8 &&
+			     fwrq->m <= (int) 2.487e8)) {
+				int f = fwrq->m / 100000;
+				int c = 0;
+				
+				while ((c < REG_MAX_CHANNEL) &&
+				       (f != ipw2100_frequencies[c]))
+					c++;
+				
+				/* hack to fall through */
+				fwrq->e = 0;
+				fwrq->m = c + 1;
+			}
+		}
+
+		if (fwrq->e > 0 || fwrq->m > 1000) 
+			return -EOPNOTSUPP;
+		else /* set the channel */
+			return ipw2100_set_channel(priv, fwrq->m, 0);
+	}
+
+	IPW2100_DEBUG_WX("SET Freq/Channel -> %d \n", priv->ctx->channel);
+	return 0;
+}
+
+
+static int ipw2100_wx_get_freq(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_freq *fwrq = &wrqu->freq;
+	u32 chan;
+	u32 len = sizeof(u32);
+	int err;
+
+	/* feed crap if we are not associated */
+	if (priv->disabled || priv->ctx->ssid[0] == '\0') {
+		fwrq->m = 0;
+		fwrq->e = 0;
+		return 0;
+	}
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &len);
+	if (err) {
+		IPW2100_DEBUG_WX("failed querying ordinals.\n");
+		return err;
+	}
+
+	/* we keep it */
+	priv->ctx->channel = chan;
+
+#ifdef WEXT_USECHANNELS
+	/* return CHANNEL no if requested so */
+	fwrq->m = chan;
+	fwrq->e = 0;
+#else
+	/* otherwise return freq */
+	fwrq->m = ipw2100_frequencies[chan - 1] * 100000;
+	fwrq->e = 1;
+#endif	/* WEXT_USECHANNELS */
+
+	IPW2100_DEBUG_WX("GET Freq/Channel -> %d \n", fwrq->m);
+	return 0;
+}
+
+static int ipw2100_wx_set_mode(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	err = ipw2100_set_port_type(
+		priv, wrqu->mode == IW_MODE_ADHOC ? IBSS : BSS, 0);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET Mode -> %s \n",
+	       port_type_str[priv->ctx->port_type]);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_mode(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	switch (priv->ctx->port_type) {
+	case BSS:
+		wrqu->mode = IW_MODE_INFRA;
+		break;
+	case IBSS:
+		wrqu->mode = IW_MODE_ADHOC;
+		break;
+	default:
+		/*
+		wrqu->mode = IW_MODE_AUTO;
+		*/
+		wrqu->mode = IW_MODE_INFRA;
+	}
+
+	IPW2100_DEBUG_WX("GET Mode -> %s \n",
+	       port_type_str[priv->ctx->port_type]);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_range(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	u16 val;
+	int i;
+
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+	
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;     
+
+	// TODO: Not used in 802.11b?
+//	range->min_nwid;	/* Minimal NWID we are able to set */
+	// TOOD: Not used in 802.11b?
+//	range->max_nwid;	/* Maximal NWID we are able to set */
+
+//	range->old_num_channels;	/* Old Frequency (backward compat - moved lower ) */
+//	range->old_num_frequency;	/* Old Frequency (backward compat - moved lower ) */
+//	range->old_freq[6];		/* Filler to keep "version" at the same offset */
+
+//	range->sensitivity;	/* signal level threshold range */
+	
+	range->max_qual.qual = 100;
+	/* TODO: Find real max RSSI and stick here */
+	range->max_qual.level = 0;
+	range->max_qual.noise = IPW2100_RSSI_TO_DBM;
+	range->max_qual.updated = 7; /* Updated all three */
+
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 20 + IPW2100_RSSI_TO_DBM;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+
+	range->num_bitrates = RATE_COUNT;
+
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
+		range->bitrate[i] = ipw2100_rates_11b[i];
+	}
+	
+//	range->min_rts = 0;	// FIXME: What about min_rts? and max_rts=DEFAULT below?
+	range->max_rts = DEFAULT_RTS_THRESHOLD;
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+//	range->min_pmp;		/* Minimal PM period */
+//	range->max_pmp;		/* Maximal PM period */
+//	range->min_pmt;		/* Minimal PM timeout */
+//	range->max_pmt;		/* Maximal PM timeout */
+//	range->pmp_flags;	/* How to decode max/min PM period */
+//	range->pmt_flags;	/* How to decode max/min PM timeout */
+//	range->pm_capa;		/* What PM options are supported */
+
+//	range->encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+//	range->num_encoding_sizes;			/* Number of entry in the list */
+//	range->max_encoding_tokens;			/* Max number of tokens */
+//	range->encoding_login_index;			/* token index for login token */
+
+//	range->txpower_capa;		/* What options are supported */
+//	range->num_txpower;		/* Number of entries in the list */
+//	range->txpower[IW_MAX_TXPOWER];	/* list, in bps */
+		
+	/* Set the Wireless Extension versions */
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+//	range->retry_capa;	/* What retry options are supported */
+//	range->retry_flags;	/* How to decode max/min retry limit */
+//	range->r_time_flags;	/* How to decode max/min retry life */
+//	range->min_retry;	/* Minimal number of retries */
+//	range->max_retry;	/* Maximal number of retries */
+//	range->min_r_time;	/* Minimal retry lifetime */
+//	range->max_r_time;	/* Maximal retry lifetime */
+											
+        range->num_channels = FREQ_COUNT;
+
+	val = 0;
+	for (i = 0; i < FREQ_COUNT; i++) {
+		// TODO: Include only legal frequencies for some countries
+//		if (local->channel_mask & (1 << i)) {
+			range->freq[val].i = i + 1;
+			range->freq[val].m = ipw2100_frequencies[i] * 100000;
+			range->freq[val].e = 1;
+			val++;
+//		}
+		if (val == IW_MAX_FREQUENCIES)
+		break;
+	}
+	range->num_frequency = val;
+
+	IPW2100_DEBUG_WX("GET Range\n");
+
+	return 0;
+}
+
+static int ipw2100_wx_set_wap(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	static const unsigned char any[] = {
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+	};
+	static const unsigned char off[] = {
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+
+	// sanity checks
+	if (wrqu->ap_addr.sa_family != ARPHRD_ETHER) 
+		return -EINVAL;
+
+	if (!memcmp(any, wrqu->ap_addr.sa_data, ETH_ALEN) ||
+	    !memcmp(off, wrqu->ap_addr.sa_data, ETH_ALEN)) {
+		/* we disable mandatory BSSID association */
+		IPW2100_DEBUG_WX("exit - disable mandatory BSSID\n");
+		return ipw2100_set_mandatory_bssid(priv, NULL, 0);
+	}
+
+	err = ipw2100_set_mandatory_bssid(
+		priv, wrqu->ap_addr.sa_data, 0);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET BSSID -> %02X:%02X:%02X:%02X:%02X:%02X\n",
+	       wrqu->ap_addr.sa_data[0] & 0xff,
+	       wrqu->ap_addr.sa_data[1] & 0xff,
+	       wrqu->ap_addr.sa_data[2] & 0xff,
+	       wrqu->ap_addr.sa_data[3] & 0xff,
+	       wrqu->ap_addr.sa_data[4] & 0xff, 
+	       wrqu->ap_addr.sa_data[5] & 0xff);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_wap(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int len = ETH_ALEN;
+
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+
+	/* Fetch from the hardware */
+	if (priv->disabled ||
+	    ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, 
+				&priv->ctx->bssid,  &len) ||
+	    priv->ctx->ssid[0] == '\0') {
+		memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+		return 0;
+	}
+
+	memcpy(wrqu->ap_addr.sa_data, &priv->ctx->bssid, ETH_ALEN);
+
+	IPW2100_DEBUG_WX("GET BSSID -> %02X:%02X:%02X:%02X:%02X:%02X\n",
+			 (u8)wrqu->ap_addr.sa_data[0],
+			 (u8)wrqu->ap_addr.sa_data[1],
+			 (u8)wrqu->ap_addr.sa_data[2],
+			 (u8)wrqu->ap_addr.sa_data[3],
+			 (u8)wrqu->ap_addr.sa_data[4],
+			 (u8)wrqu->ap_addr.sa_data[5]);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_essid(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+	
+	if (priv->disabled) {
+		IPW2100_DEBUG_WX("Caching ESSID: %s\n", extra);
+		strncpy(priv->ctx->ssid, extra, IW_ESSID_MAX_SIZE);
+		return 0;
+	}
+
+	err = ipw2100_set_essid(priv, extra, 0);
+	if (err) {
+		IPW2100_DEBUG_WX("SET SSID failed\n");
+		return err;
+	}
+
+	IPW2100_DEBUG_WX("exit\n");
+
+	return 0;
+}
+
+static int ipw2100_wx_get_essid(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	wrqu->data.length = strlen(priv->ctx->ssid) + 1;
+	memcpy(extra, priv->ctx->ssid, wrqu->data.length);
+	wrqu->data.flags = 1; /* active */
+
+	IPW2100_DEBUG_WX("GET ESSID -> %s\n", extra);
+	return 0;
+}
+
+static int ipw2100_wx_set_nick(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	if (wrqu->data.length > IW_ESSID_MAX_SIZE)
+		return -E2BIG;
+
+	wrqu->data.length = min((size_t)wrqu->data.length, sizeof(priv->nick));
+	memset(priv->nick, 0, sizeof(priv->nick));
+	memcpy(priv->nick, extra,  wrqu->data.length);
+
+	IPW2100_DEBUG_WX("SET Nickname -> %s \n", priv->nick);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_nick(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	
+	wrqu->data.length = strlen(priv->nick) + 1;
+	memcpy(extra, priv->nick, wrqu->data.length);
+	wrqu->data.flags = 1; /* active */
+	
+	IPW2100_DEBUG_WX("GET Nickname -> %s \n", extra);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_rate(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int val;
+	int len = sizeof(val);
+	int err;
+
+	if (priv->disabled || priv->ctx->ssid[0] == '\0') {
+		wrqu->bitrate.value = 0;
+		return 0;
+	}
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &val, &len);
+	if (err) {
+		IPW2100_DEBUG_WX("failed querying ordinals.\n");
+		return err;
+	}
+
+	switch (val & TX_RATE_MASK) {
+	case TX_RATE_1_MBIT:
+		wrqu->bitrate.value = 1000000;
+		break;
+	case TX_RATE_2_MBIT:
+		wrqu->bitrate.value = 2000000;
+		break;
+	case TX_RATE_5_5_MBIT:
+		wrqu->bitrate.value = 5500000;
+		break;
+	case TX_RATE_11_MBIT:
+		wrqu->bitrate.value = 11000000;
+		break;
+	default:
+		wrqu->bitrate.value = 0;
+	}
+
+	IPW2100_DEBUG_WX("GET Rate -> %d \n", wrqu->bitrate.value);
+	return 0;
+}
+
+static int ipw2100_wx_set_rts(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	if (wrqu->rts.value < 1 || 
+	    wrqu->rts.value > 2304 || 
+	    wrqu->rts.disabled)
+		return -EINVAL;
+
+	err = ipw2100_set_rts_threshold(priv, wrqu->rts.value);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET RTS Threshold -> %d \n", wrqu->rts.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_rts(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int len = sizeof(wrqu->rts.value);
+	int err;
+
+	if (priv->disabled)
+		wrqu->rts.value = priv->rts_threshold;
+	else {
+		err = ipw2100_get_ordinal(priv, IPW_ORD_RTS_THRESHOLD, 
+					  &wrqu->rts.value, &len);
+		if (err) {
+			IPW2100_DEBUG_WX("query ordinal failed.\n");
+			return err;
+		}
+	}
+
+	wrqu->rts.fixed = 1; /* no auto select */
+	wrqu->rts.disabled = 0; /* can't be disabled */
+
+	IPW2100_DEBUG_WX("GET RTS Threshold -> %d \n", wrqu->rts.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_txpow(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	IPW2100_DEBUG_WX("TODO: Power management by wireless extension...\n");
+
+	IPW2100_DEBUG_WX("SET TX Power -> %d \n", wrqu->rts.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_txpow(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	wrqu->power.value = priv->tx_power;
+	wrqu->power.fixed = 1;
+	wrqu->power.flags = IW_TXPOW_DBM;
+	wrqu->power.disabled = 0;
+
+	IPW2100_DEBUG_WX("GET TX Power -> %d \n", wrqu->power.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_frag(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+	    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+		return -EINVAL;
+
+	err = ipw2100_set_fragmentation_threshold(
+		priv, wrqu->frag.value & ~0x1, 0);
+	if (err) 
+		return err;
+
+	IPW2100_DEBUG_WX("SET Frag Threshold -> %d \n", 
+	       wrqu->frag.value & ~0x01);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_frag(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+/*	int len = sizeof(wrqu->frag.value);
+	int err;
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_FRAGMENTATION_THRESHOLD,
+				  &wrqu->frag.value, &len);
+*/
+	wrqu->frag.value = ipw2100_msdu_frag_threshold(priv);
+	wrqu->frag.fixed = 0;	/* no auto select */
+	wrqu->frag.disabled = 
+		(wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
+
+	IPW2100_DEBUG_WX("GET Frag Threshold -> %d \n", wrqu->frag.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_retry(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	if (wrqu->retry.flags & IW_RETRY_LIFETIME || 
+	    wrqu->retry.disabled)
+		return -EINVAL;
+
+	if (!wrqu->retry.flags & IW_RETRY_LIMIT)
+		return 0;
+
+	if (wrqu->retry.flags & IW_RETRY_MIN) {
+		err = ipw2100_set_short_retry(priv, wrqu->retry.value);
+		if (err)
+			return err;
+
+		IPW2100_DEBUG_WX("SET Short Retry Limit -> %d \n",
+		       wrqu->retry.value);
+
+		return 0;
+	} 
+
+	if (wrqu->retry.flags & IW_RETRY_MAX) {
+		err = ipw2100_set_long_retry(priv, wrqu->retry.value);
+		if (err)
+			return err;
+
+		IPW2100_DEBUG_WX("SET Long Retry Limit -> %d \n",
+		       wrqu->retry.value);
+
+		return 0;
+	}
+
+	err = ipw2100_set_short_retry(priv, wrqu->retry.value);
+	if (err)
+		return err;
+	err = ipw2100_set_long_retry(priv, wrqu->retry.value);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET Both Retry Limits -> %d \n", wrqu->retry.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_retry(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	wrqu->retry.disabled = 0; /* can't be disabled */
+
+	if ((wrqu->retry.flags & IW_RETRY_TYPE) == 
+	    IW_RETRY_LIFETIME) 
+		return -EINVAL;
+	
+	if (wrqu->retry.flags & IW_RETRY_MAX) {
+		wrqu->retry.flags = IW_RETRY_LIMIT & IW_RETRY_MAX;
+		wrqu->retry.value = priv->long_retry_limit;
+	} else {
+		wrqu->retry.flags =
+		    (priv->short_retry_limit !=
+		     priv->long_retry_limit) ?
+		    IW_RETRY_LIMIT & IW_RETRY_MIN : IW_RETRY_LIMIT;
+
+		wrqu->retry.value = priv->short_retry_limit;
+	}
+
+	IPW2100_DEBUG_WX("GET Retry -> %d \n", wrqu->retry.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_scan(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_WX("Initiating scan...\n");
+	if (ipw2100_start_scan(priv)) {
+		IPW2100_DEBUG_WX("Start scan failed.\n");
+
+		/* TODO: Mark a scan as pending so when hardware initialized
+		 *       a scan starts */
+	}
+
+	return 0;
+}
+
+/*
+ *
+ * Following logic based on the code in drivers/net/wireless/airo.c from 2.6.1
+ *
+ */
+static inline char *ipw2100_translate_scan(char *start, char *stop, 
+					   struct ipw2100_beacon *beacon)
+{
+	struct iw_event iwe;
+	int i;
+
+	/* First entry *MUST* be the AP MAC address */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER; 
+	memcpy(iwe.u.ap_addr.sa_data, beacon->bssid, ETH_ALEN);
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_ADDR_LEN);
+	
+	/* Remaining entries will be displayed in the order we provide them */
+
+	/* Add the ESSID */
+        iwe.u.data.length = beacon->ssid_len;
+        if (iwe.u.data.length > 32)
+		iwe.u.data.length = 32;
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.data.flags = 1;
+        start = iwe_stream_add_point(start, stop, &iwe, beacon->ssid);
+
+        /* Add mode */
+        iwe.cmd = SIOCGIWMODE;
+        if (beacon->capability & (SSID_CAPABILITY_BSS | SSID_CAPABILITY_IBSS)) {
+		if (beacon->capability & SSID_CAPABILITY_BSS)
+			iwe.u.mode = IW_MODE_MASTER;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(start, stop, &iwe, IW_EV_UINT_LEN);
+	}
+	
+        /* Add frequency */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = ipw2100_frequencies[beacon->channel - 1] * 100000;
+	iwe.u.freq.e = 1;
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add rates */
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	for (i = 0; i < beacon->rates_len; i++) {
+		iwe.u.bitrate.value = (beacon->rates[i] & 0x7F) * 500000;
+		start = iwe_stream_add_event(start, stop, &iwe, 
+					     IW_EV_PARAM_LEN);
+	}
+
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.qual = beacon->rssi; /* For quality, we just use signal 
+					 * strength since there is nothing
+					 * else we can measure at this point */
+	iwe.u.qual.level = beacon->rssi + IPW2100_RSSI_TO_DBM;
+	iwe.u.qual.noise = IPW2100_RSSI_TO_DBM;
+	iwe.u.qual.updated = 7;	
+
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_QUAL_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (beacon->capability & SSID_CAPABILITY_ENCRYPT)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(start, stop, &iwe, beacon->ssid);
+
+	return start;
+}
+
+static int ipw2100_wx_get_scan(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct list_head *element;
+	unsigned long flags;
+
+	char *ev = extra;
+	char *stop = ev + IW_SCAN_MAX_DATA;
+	int i;
+
+	IPW2100_DEBUG_WX("enter\n");
+	
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	for (element = priv->beacon_list.next, i = 0;
+	     element != &priv->beacon_list;
+	     element = element->next, i++) 
+		ev = ipw2100_translate_scan(
+			ev, stop, 
+			list_entry(element, struct ipw2100_beacon, list));
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	wrqu->data.length = ev -  extra;
+	wrqu->data.flags = 0;
+	
+	IPW2100_DEBUG_WX("exit: %d beacons returned.\n", i);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_IPW2100_WEP
+/*
+ * Implementation based on code in hostap-driver v0.1.3 hostap_ioctl.c
+ */
+static int ipw2100_wx_set_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	return ieee80211_wx_set_encode(&priv->ieee, info, wrqu, key);
+}
+
+static int ipw2100_wx_get_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	return ieee80211_wx_get_encode(&priv->ieee, info, wrqu, key);
+}
+#else /* CONIFG_IPW2100_WEP */
+/*
+ * Implementation based on code in wireless tools sample_enc v0.26
+ */
+static int ipw2100_wx_set_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_point *erq = &(wrqu->encoding);
+	int index = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+	if (erq->length > 0) {
+		/* Check the size of the key */
+		if (erq->length > MAX_KEY_SIZE)
+			return(-EINVAL);
+
+		/* Check the index */
+		if ((index < 0) || (index >= MAX_KEYS))
+			index = priv->key_current;
+
+		/* Copy the key in the driver */
+		memcpy(priv->key_table[index], key, erq->length);
+		priv->key_size[index] = erq->length;
+		priv->key_on = 1;
+	} else {
+		/* Do we want to just set the current key ? */
+		if ((index >= 0) && (index < MAX_KEYS)) {
+			if (priv->key_size[index] > 0) {
+				priv->key_current = index;
+				priv->key_on = 1;
+			}
+			else
+				return(-EINVAL);
+		}
+	}
+
+	/* Read the flags */
+	if (erq->flags & IW_ENCODE_DISABLED)
+		priv->key_on = 0; /* disable encryption */
+	if (erq->flags & IW_ENCODE_RESTRICTED)
+		priv->key_open = 0; /* disable open mode */
+	if (erq->flags & IW_ENCODE_OPEN)
+		priv->key_open = 1; /* enable open mode */
+
+	return 0;
+}
+
+static int ipw2100_wx_get_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_point *erq = &(wrqu->encoding);
+	int index = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+	IPW2100_DEBUG_WX("TODO: Implement ipw2100_wx_set_encode()\n");
+
+	/* Set the flags */
+	erq->flags = 0;
+	if (priv->key_on == 0)
+		erq->flags |= IW_ENCODE_DISABLED;
+	if (priv->key_open == 0)
+		erq->flags |= IW_ENCODE_RESTRICTED;
+	else
+		erq->flags |= IW_ENCODE_OPEN;
+	
+	/* Which key do we want */
+	if ((index < 0) || (index >= MAX_KEYS))
+		index = priv->key_current;
+	erq->flags |= index + 1;
+	
+	/* Copy the key to the user buffer */
+	erq->length = priv->key_size[index];
+	memcpy(key, priv->key_table[index], priv->key_size[index]);
+
+	return 0;
+}
+#endif /* CONFIG_IPW2100_WEP */
+
+static iw_handler ipw2100_wx_handlers[] =
+{
+        NULL,                     /* SIOCSIWCOMMIT */
+        ipw2100_wx_get_name,      /* SIOCGIWNAME */
+        NULL,                     /* SIOCSIWNWID */
+        NULL,                     /* SIOCGIWNWID */
+        ipw2100_wx_set_freq,      /* SIOCSIWFREQ */
+        ipw2100_wx_get_freq,      /* SIOCGIWFREQ */
+        ipw2100_wx_set_mode,      /* SIOCSIWMODE */
+        ipw2100_wx_get_mode,      /* SIOCGIWMODE */
+        NULL,                     /* SIOCSIWSENS */
+        NULL,                     /* SIOCGIWSENS */
+        NULL,                     /* SIOCSIWRANGE */
+        ipw2100_wx_get_range,     /* SIOCGIWRANGE */
+        NULL,                     /* SIOCSIWPRIV */
+        NULL,                     /* SIOCGIWPRIV */
+        NULL,                     /* SIOCSIWSTATS */
+        NULL,                     /* SIOCGIWSTATS */
+        NULL,                     /* SIOCSIWSPY */
+        NULL,                     /* SIOCGIWSPY */
+        NULL,                     /* SIOCGIWTHRSPY */
+        NULL,                     /* SIOCWIWTHRSPY */
+        ipw2100_wx_set_wap,       /* SIOCSIWAP */
+        ipw2100_wx_get_wap,       /* SIOCGIWAP */
+        NULL,                     /* -- hole -- */
+        NULL,                     /* SIOCGIWAPLIST -- depricated */
+        ipw2100_wx_set_scan,      /* SIOCSIWSCAN */
+        ipw2100_wx_get_scan,      /* SIOCGIWSCAN */
+        ipw2100_wx_set_essid,     /* SIOCSIWESSID */
+        ipw2100_wx_get_essid,     /* SIOCGIWESSID */
+        ipw2100_wx_set_nick,      /* SIOCSIWNICKN */
+        ipw2100_wx_get_nick,      /* SIOCGIWNICKN */
+        NULL,                     /* -- hole -- */
+        NULL,                     /* -- hole -- */
+        NULL,                     /* SIOCSIWRATE */
+        ipw2100_wx_get_rate,      /* SIOCGIWRATE */
+        ipw2100_wx_set_rts,       /* SIOCSIWRTS */
+        ipw2100_wx_get_rts,       /* SIOCGIWRTS */
+        ipw2100_wx_set_frag,      /* SIOCSIWFRAG */
+        ipw2100_wx_get_frag,      /* SIOCGIWFRAG */
+        ipw2100_wx_set_txpow,     /* SIOCSIWTXPOW */
+        ipw2100_wx_get_txpow,     /* SIOCGIWTXPOW */
+        ipw2100_wx_set_retry,     /* SIOCSIWRETRY */
+        ipw2100_wx_get_retry,     /* SIOCGIWRETRY */
+        ipw2100_wx_set_encode,    /* SIOCSIWENCODE */
+        ipw2100_wx_get_encode,    /* SIOCGIWENCODE */
+        NULL,                     /* SIOCSIWPOWER */
+        NULL,                     /* SIOCGIWPOWER */
+};
+
+struct iw_handler_def ipw2100_wx_handler_def = 
+{
+	.num_standard = sizeof(ipw2100_wx_handlers) / sizeof(iw_handler),
+	.num_private = 0,
+	.num_private_args = 0,
+	.standard = ipw2100_wx_handlers,
+	.private = NULL,
+	.private_args = NULL,
+};
+
+/*
+ * Get wireless statistics.
+ * Called by /proc/net/wireless
+ */
+struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device * dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_statistics *wstats;
+	u32 ord_value, ord_len = sizeof(u32);
+
+	if (!priv)
+		return (struct iw_statistics *) NULL;
+
+	/* if hw is disabled, then ipw2100_get_ordinal() can't be called.
+	 * ipw2100_wx_wireless_stats seems to be called before fw is 
+	 * initialized. */
+	if (priv->disabled)
+		return (struct iw_statistics *) NULL;
+
+	wstats = &priv->wstats;
+
+
+        /* If we don't have a connection the quality is 0*/
+	if (!priv->connected) 
+		wstats->qual.qual = 0; 
+	else {
+		if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS,
+					&ord_value, &ord_len))
+			goto fail_get_ordinal;
+		wstats->qual.qual = 100 - ord_value;
+	}
+
+	if (ipw2100_get_ordinal(priv, IPW_ORD_RSSI_AVG_CURR, 
+				&ord_value, &ord_len))
+		goto fail_get_ordinal;
+	wstats->qual.level = ord_value + IPW2100_RSSI_TO_DBM;
+
+	wstats->qual.noise = IPW2100_RSSI_TO_DBM;
+	wstats->qual.updated = 7;	
+
+	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS, 
+				&ord_value, &ord_len))
+		goto fail_get_ordinal;
+        /* FIXME: this is percent and not a # */
+	wstats->miss.beacon = ord_value; 
+
+	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_TX_RETRIES, 
+				&ord_value, &ord_len))
+		goto fail_get_ordinal;
+	wstats->discard.retries = ord_value;
+
+	return wstats;
+
+ fail_get_ordinal:
+	IPW2100_DEBUG_WX("failed querying ordinals.\n");
+
+	return (struct iw_statistics *) NULL;
+}
+
+
+
+#endif /* WIRELESS_EXT > 12 */ 
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipw2100_wx.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,46 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef __IPW2100_WX_H
+#define __IPW2100_WX_H
+
+#if WIRELESS_EXT > 12
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+
+#ifndef WIRELESS_SPY
+#define WIRELESS_SPY		// enable iwspy support
+#endif
+#include <net/iw_handler.h>	// new driver API
+
+#include "ipw2100.h"
+
+extern struct iw_handler_def ipw2100_wx_handler_def;
+extern struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device * dev);
+
+#endif /* WIRELESS_EXT */
+#endif /* __IPW2100_WX_H */
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/ipwversion.h ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipwversion.h
--- linux-2.6.4/drivers/net/wireless/ipw2100/ipwversion.h	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/ipwversion.h	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,6 @@
+
+#ifndef __IPWVERSION_h
+#define __IPWVERSION_h
+#define IPW2100_VERSION "0.40-pre"
+#endif
+
diff -Nur --exclude=RCS --exclude=CVS --exclude=SCCS --exclude=BitKeeper --exclude=ChangeSet linux-2.6.4/drivers/net/wireless/ipw2100/pbe5.c ipw2100-2.6.4/drivers/net/wireless/ipw2100/pbe5.c
--- linux-2.6.4/drivers/net/wireless/ipw2100/pbe5.c	Wed Dec 31 18:00:00 1969
+++ ipw2100-2.6.4/drivers/net/wireless/ipw2100/pbe5.c	Mon Mar 29 22:08:53 2004
@@ -0,0 +1,195 @@
+/*******************************************************************************
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Author:
+  Pedro Ramalhais <pmr09313@students.fct.unl.pt>
+  
+  Based on:
+  av5100.c from http://ipw2100.sourceforge.net/
+
+*******************************************************************************/
+
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include "ipwversion.h"
+
+#define DRV_NAME		"pbe5"
+#define DRV_VERSION		"1.0-ipw" IPW2100_VERSION
+#define DRV_DESCRIPTION		"SW RF kill switch for Packard Bell EasyNote E5"
+#define DRV_AUTHOR		"Pedro Ramalhais"
+#define DRV_LICENSE		"GPL"
+
+static int radio = 1;
+MODULE_PARM(radio, "i");
+
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR(DRV_AUTHOR);
+MODULE_LICENSE(DRV_LICENSE);
+
+/*
+ * NOTE: These values were obtained from disassembling the Icon.exe program
+ * installed in the Packard Bell EasyNote E5 laptop. The names were guessed,
+ * so don't rely on them.
+ */
+#define PBE5_PORT_TOGGLE	0x0b3
+#define PBE5_VALUE_TOGGLE_ON	0x01
+#define PBE5_VALUE_TOGGLE_OFF	0x00
+#define PBE5_PORT_APPLY		0x0b2
+#define PBE5_VALUE_APPLY	0xef
+
+// Some "booleans" =;-)
+#define PBE5_RADIO_OFF	0
+#define PBE5_RADIO_ON	1
+
+static int pbe5_radio_status = PBE5_RADIO_ON;
+
+unsigned char pbe5_get_radio(void)
+{
+	unsigned char val = 0x00;
+	
+	val = inb(PBE5_PORT_TOGGLE);
+	
+	return val;
+}
+
+static void pbe5_set_radio(int state_set)
+{
+	pbe5_radio_status = pbe5_get_radio();
+
+	if (pbe5_radio_status != state_set) {
+		// Set the radio toggle register
+		outb(PBE5_VALUE_TOGGLE_ON, PBE5_PORT_TOGGLE);
+		// Commit the radio toggle register value
+		outb(PBE5_VALUE_APPLY, PBE5_PORT_APPLY);
+		// Update the radio status
+		pbe5_radio_status = pbe5_get_radio();
+
+		printk(KERN_INFO DRV_NAME ": Radio turned %s\n",
+			(state_set  == PBE5_RADIO_ON) ? "ON" : "OFF");
+	} else {
+		printk(KERN_INFO DRV_NAME ": Radio already %s\n",
+			(state_set  == PBE5_RADIO_ON) ? "ON" : "OFF");
+	}
+}
+
+
+/*
+ * proc stuff
+ */
+static struct proc_dir_entry *dir_base = NULL;
+
+static int proc_set_radio(struct file *file, const char *buffer, 
+			  unsigned long count, void *data)
+{
+	pbe5_set_radio(buffer[0] == '0' ? PBE5_RADIO_OFF : PBE5_RADIO_ON);
+	
+	return count;
+}
+
+static int proc_get_radio(char *page, char **start, off_t offset,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	
+	len += snprintf(page, count, DRV_NAME ": %d\n", 
+			pbe5_radio_status == PBE5_RADIO_OFF ? 0 : 1);
+	
+	*eof = 1;
+	return len;
+}
+
+
+static void pbe5_proc_cleanup(void)
+{
+	if (dir_base) {
+		remove_proc_entry("radio", dir_base);
+		remove_proc_entry(DRV_NAME, &proc_root);
+		dir_base = NULL;
+	}
+}
+
+
+static int pbe5_proc_init(void)
+{
+	struct proc_dir_entry *ent;
+	int err = 0;
+
+	dir_base = create_proc_entry(DRV_NAME, S_IFDIR, &proc_root);
+	if (dir_base == NULL) {
+		printk(KERN_ERR DRV_NAME ": Unable to initialise /proc/" 
+		       DRV_NAME "\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+
+	ent = create_proc_entry("radio", S_IFREG | S_IRUGO | S_IWUSR, 
+				dir_base);
+	if (ent) {
+		ent->read_proc = proc_get_radio;
+		ent->write_proc = proc_set_radio;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/" DRV_NAME "/radio\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	return 0;
+
+ fail:
+	pbe5_proc_cleanup();
+	return err;
+}
+
+/*
+ * module stuff
+ */
+static int __init pbe5_init(void)
+{
+	pbe5_proc_init();
+
+	pbe5_set_radio((radio == 1) ? PBE5_RADIO_ON : PBE5_RADIO_OFF);
+	
+	return 0;
+}
+
+static void __exit pbe5_exit(void)
+{
+	pbe5_set_radio(PBE5_RADIO_OFF);
+
+	pbe5_proc_cleanup();
+}
+
+module_init(pbe5_init);
+module_exit(pbe5_exit);
+
+/*
+         1         2         3         4         5         6         7
+12345678901234567890123456789012345678901234567890123456789012345678901234567890
+*/
