diff -urN linux-2.6.6/Documentation/networking/README.ipw2100 linux-2.6.6-gentoo1/Documentation/networking/README.ipw2100
--- linux-2.6.6/Documentation/networking/README.ipw2100	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/Documentation/networking/README.ipw2100	2004-05-22 09:13:01.748997873 -0500
@@ -0,0 +1,116 @@
+Intel PRO/Wireless 2100 802.11b Driver for Linux
+README.ipw2100
+
+March 18, 2004
+
+
+Release 0.34 Current Features
+------------ -----   -----       ----       ---       --         -     
+
+- BSS (infrastructure) only
+- limited wireless extension support 
+- 802.11 fragmentation
+
+
+TODO
+------------ -----   -----       ----       ---       --         -     
+- encryption (WEP)
+- long/short preamble support
+- enhance wireless extension support
+- adhoc
+- continue to add support for addtional SW RF kill switch implementations
+- "shared" authentication
+- transmit power control
+- power states support (ACPI)
+
+
+Command Line Parameters
+------------ -----   -----       ----       ---       --         -     
+
+If the driver is built as a module, the following optional parameters are used
+by entering them on the command line with the modprobe command using this
+syntax:
+
+	modprobe ipw2100 [<option>=<VAL1><,VAL2>...]
+
+For example, to set the interface name for driver, entering:
+
+	modprobe ipw2100 if_name=wlan%d
+
+results in the ipw2100 driver defaulting to the wlan prefix, with the system
+assigning a unique number in place of %d.  The default interface name is eth%d.
+
+
+
+Radio Kill Switch
+------------ -----   -----       ----       ---       --         -     
+Most laptops provide the ability for the user to physically disable the radio.
+Some vendors have implemented this as a physical switch that requires no
+software to turn the radio off and on.  On other laptops, however, the switch
+is controlled through a button being pressed and a software driver then making
+calls to turn the radio off and on.  This is referred to as a "software based
+RF kill switch"
+
+Currently this project provides modules for controlling the software RF kill
+switch on the Averatec 5100P and Packard Bell EasyNote E5.  The code may work
+on other laptops, but these are the only models on which it has been tested.
+
+Simply by loading and unloading the av5100/pbe5 module the radio will be toggled
+on and off.  In addition, you can turn the driver on and off by writing either
+a 1 or 0 to /proc/av5100/radio or /proc/pbe5/radio.  If you automatically load
+the av5100/pbe5 module when your system boots, you may wish to use the radio
+module parameter to control the state of the radio upon loading:
+
+	modprobe av5100 radio=0
+	modprobe pbe5 radio=0
+
+results in the module loading with the radio turned off.  You can then turn the
+radio on by:
+
+	echo 1 > /proc/av5100/radio
+	echo 1 > /proc/pbe5/radio
+
+
+Dynamic Firmware
+------------ -----   -----       ----       ---       --         -     
+As the firmware is licensed under a restricted use license, it can not be 
+included within the kernel sources.  To enable the IPW2100 you will need a 
+firmware image to load into the wireless NIC's processors.
+
+You can obtain these images from <http://ipw2100.sf.net/firmware.php>.
+
+See INSTALL for instructions on installing the firmware.
+
+
+Support
+------------ -----   -----       ----       ---       --         -     
+
+For general information and support, go to:
+	
+    http://ipw2100.sf.net/
+
+License
+------------ -----   -----       ----       ---       --         -     
+
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
diff -urN linux-2.6.6/Documentation/scsi/dpti.txt linux-2.6.6-gentoo1/Documentation/scsi/dpti.txt
--- linux-2.6.6/Documentation/scsi/dpti.txt	2004-05-09 21:32:54.000000000 -0500
+++ linux-2.6.6-gentoo1/Documentation/scsi/dpti.txt	2004-05-22 09:13:10.430700652 -0500
@@ -1,4 +1,4 @@
- /* TERMS AND CONDITIONS OF USE
+/* TERMS AND CONDITIONS OF USE
  * 
  * Redistribution and use in source form, with or without modification, are
  * permitted provided that redistributions of source code must retain the
@@ -56,8 +56,13 @@
  *         FW without having to reboot)
  *      Changed proc output
  *
+ * V2.5
+ *   Changes:
+ *	Added 64 bit Scatter Gather when compiled on big memory aaccess
+ *	   architectures.
+ *	Altered driver in support of 2.5+ kernels
+ *
  * TODO:
- *      Add 64 bit Scatter Gather when compiled on 64 bit architectures
  *      Add sparse lun scanning 
  *      Add code that checks if a device that had been taken offline is
  *         now online (at the FW level) when test unit ready or inquiry 
@@ -75,9 +80,25 @@
  * to the board.  
  *
  * The files dpti_ioctl.h dptsig.h osd_defs.h osd_util.h sys_info.h are part of the
- * interface files for Adaptec's management routines.  These define the structures used
+ * interface files for Adaptecs managment routines.  These define the structures used
  * in the ioctls.  They are written to be portable.  They are hard to read, but I need
  * to use them 'as is' or I can miss changes in the interface.
  *
+ * Cards supported:
+ *	PM2554
+ *	PM2654
+ *	PM2564
+ *	PM3754
+ *	PM3755
+ *	PM3757
+ *	3200S
+ *	3400S
+ *	3210S
+ *	3410S
+ *	2000S
+ *	2005S
+ *	2015S
+ *	2020S
+ *	2400A
  */
 
diff -urN linux-2.6.6/drivers/net/wireless/Kconfig linux-2.6.6-gentoo1/drivers/net/wireless/Kconfig
--- linux-2.6.6/drivers/net/wireless/Kconfig	2004-05-09 21:32:26.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/net/wireless/Kconfig	2004-05-22 09:13:01.771994437 -0500
@@ -137,6 +137,146 @@
 comment "Wireless 802.11b ISA/PCI cards support"
 	depends on NET_RADIO && (ISA || PCI || PPC_PMAC || PCMCIA)
 
+config IPW2100
+	tristate "Intel PRO/Wireless 2100 802.11b"
+	depends on NET_RADIO && PCI
+	select FW_LOADER
+	---help---
+          A driver for the Intel PRO/Wireless 2100 802.11b wireless network
+          adapter.
+
+          See <file:Documentation/networking/README.ipw2100> for information on
+          the capabilities currently enabled in this driver and for tips
+          for debugging issues and problems.
+
+	  In order to use this driver, you will need a firmware image for it.
+          You can obtain the firmware from
+	  <http://ipw2100.sf.net/>.  Once you have the firmware image, you 
+	  will need to place it in /etc/firmware.
+
+          You will also very likely need the Wireless Tools in order to
+          configure your card:
+
+          <http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux/Tools.html>.
+ 
+          If you want to compile the driver as a module ( = code which can be
+          inserted in and remvoed from the running kernel whenever you want),
+          say M here and read <file:Documentation/modules.txt>.  The module
+          will be called ipw2100.ko.
+	
+config IPW2100_LEGACY_FW_LOAD
+	bool "Legacy firmware loading (non-hotplug)"
+	depends on IPW2100
+	---help---
+	  As of 0.33 we added the ability to use the hotplug request_firmware
+	  capability of Linux to load the firmware image.  If you do not have
+	  hot plug configured, or have compilation or other errors while trying
+	  to use the new mechanism, you can enable this option to use the
+	  legacy approach (loading the firmware from /etc/firmware/)
+
+	  Saying Y here will result in the kernel module being ~4k larger.
+
+config IPW2100_WEP
+	bool "Development WEP support (may not compile)"
+	depends on IPW2100
+	---help---
+	  We are starting to add support for WEP through the incorporation of
+	  generalized code from the Host AP project.  This portion of code
+	  is under _heavy_ development--it may not compile on your machine.  If
+	  it does, it is likely to crash.
+
+	  Only turn this on if you wish to help in the development of this
+	  feature.
+
+	  Saying Y here may break your build.  When in doubt, say N.
+
+config IPW2100_DEBUG
+	bool "Enable full debugging output"
+	depends on IPW2100
+	---help---
+	  This option will enable debug tracing output for the IPW2100.  
+
+	  This will result in the kernel module being ~60k larger.  You can 
+	  control which debug output is sent to the kernel log by setting the 
+	  value in 
+
+	  /proc/ipw2100/debug_level
+
+	  This entry will only exist if this option is enabled.  For a list of 
+	  values you can assign to debug_level, simply perform:
+
+	  % cat /proc/ipw2100/debug_level
+
+	  To set a value, simply echo an 8-byte hex value to the same file:
+
+	  % echo 00000FFO > /proc/ipw2100/debug_level
+
+	  If you are not trying to debug or develop the IPW2100 driver, you 
+	  most likely want to say N here.
+
+config IPW2100_AVERATEC_5100P
+	tristate "Averatec 5100P RF Kill Switch"
+	depends on IPW2100 && PCI
+	---help---
+          If you have an Averatec 5100P, say M or Y here to build support for
+	  controlling the software based radio kill switch on your laptop.
+
+	  Some laptops are enabled with a RF kill switch that is typically
+          controlled through either a physical switch or through software
+          outside of the IPW2100.  We are looking to add support for as many
+          laptops as possible, as quickly as possible.  If you have a laptop
+          exhibiting the symptoms described in
+          <file:/Documentation/networking/README.ipw2100> then please follow the
+          instructions detailed in that file.
+
+	  Upon loading, this driver will attempt to turn the radio ON.  Upon
+	  exiting, it will turn the radio OFF.  You can also toggle the state
+	  of the radio:
+
+	  % # Turn the radio ON
+	  % echo 1 > /proc/av5100/radio
+	  % # Turn the radio OFF
+	  % echo 0 > /proc/av5100/radio
+
+	  If you want to compile the driver as a module ( = code which can be
+	  inserted in and remvoed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called av5100.ko.
+
+          If unsure of what to do, say N here.
+
+config IPW2100_PACKARDBELL_E5
+	tristate "Packard Bell EasyNote E5 RF Kill Switch"
+	depends on IPW2100 && PCI
+	---help---
+          If you have a Packard Bell EasyNote E5, say M or Y here to build
+	  support for controlling the software based radio kill switch on your
+	  laptop.
+
+	  Some laptops are enabled with a RF kill switch that is typically
+          controlled through either a physical switch or through software
+          outside of the IPW2100.  We are looking to add support for as many
+          laptops as possible, as quickly as possible.  If you have a laptop
+          exhibiting the symptoms described in
+          <file:/Documentation/networking/README.ipw2100> then please follow the
+          instructions detailed in that file.
+
+	  Upon loading, this driver will attempt to turn the radio ON.  Upon
+	  exiting, it will turn the radio OFF.  You can also toggle the state
+	  of the radio:
+
+	  % # Turn the radio ON
+	  % echo 1 > /proc/pbe5/radio
+	  % # Turn the radio OFF
+	  % echo 0 > /proc/pbe5/radio
+
+	  If you want to compile the driver as a module ( = code which can be
+	  inserted in and remvoed from the running kernel whenever you want),
+	  say M here and read <file:Documentation/modules.txt>.  The module
+	  will be called pbe5.ko.
+
+          If unsure of what to do, say N here.
+
 config AIRO
 	tristate "Cisco/Aironet 34X/35X/4500/4800 ISA and PCI cards"
 	depends on NET_RADIO && (ISA || PCI)
diff -urN linux-2.6.6/drivers/net/wireless/Makefile linux-2.6.6-gentoo1/drivers/net/wireless/Makefile
--- linux-2.6.6/drivers/net/wireless/Makefile	2004-05-09 21:33:22.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/net/wireless/Makefile	2004-05-22 09:13:01.779993241 -0500
@@ -1,6 +1,7 @@
 #
 # Makefile for the Linux Wireless network device drivers.
 #
+obj-$(CONFIG_IPW2100) += ipw2100/
 
 obj-$(CONFIG_STRIP) += strip.o
 obj-$(CONFIG_ARLAN) += arlan.o 
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/CHANGES linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/CHANGES
--- linux-2.6.6/drivers/net/wireless/ipw2100/CHANGES	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/CHANGES	2004-05-22 09:13:01.791991449 -0500
@@ -0,0 +1,173 @@
+
+Mar 29 2004 Changes in 0.40-pre...
+NOTE:  
+  A lot of folks on IRC wanted a code drop now that I have WEP limping 
+  along.  The changes in this version have not been extensively tested.
+  So, if you upgrade to 0.40 you may see a regression in features or 
+  stability--even with WEP disabled.
+
+  To use the WEP, you must install hostap-drivers-0.1.3 (you will need
+  the hostap and hostap_crypt_wep modules)
+
+* Added IPWINFO gathering script (thanks to Jordi Martinez)
+* Added full WEP authentication (HW) and Tx/Rx (SW) built on Host AP's WEP
+  alorigthm.  This is UNSTABLE.  You can play with it by configuring 
+  CONFIG_IPW2100_WEP=y.
+* Added ieee80211.c and ieee80211_wx.c as generic implementations of more 
+  ieee80211 frame handling.  These are based on code from the Host AP project.
+* Added rate/bitrate, channel/frequency support for iwlist (thanks to Pedro
+  Ramalhais)
+* Switched ieee80211_cryto_ops to hostap_crypto_ops and added a copy of 
+  Host AP v0.1.3's hostap_crypt.h to ensure that we are using the same 
+  structures as hostap.
+* Fixed AP scanning to use Probe Response frames vs. Beacon frames for 
+  collecting APs from a scan
+* Added code such that if commands fail to be sent, a firmware restart is 
+  scheduled.
+* Switched firmware init to use schedule_timeout vs. udelay
+* There is s a memory write flush test in place to see if C2->C3 transition 
+  problems can be improved (search for !!!!TEST!!!! in ipw2100_main.c)
+* Packets are only processed if the interface is up
+* Some overly verbose Tx/Rx debug log messages were removed
+* Fixed ISR incorrectly outputting the INTA value to the debug log
+* Tx queue is flushed when interface is closed
+* Added kernel compilation check to only use ethtool_ops if kernel > 2.4.23 
+  (let me know if there is a better way to check for this)
+* Added ieee80211_init to initialize the ieee80211_device struct
+* Firmware load now tied to modprobe/rmmmod vs. ifup/ifdown.  This hasn't been
+  thoroughly tested.
+* Added addition compiler check on wake_up_interruptible_sync to help building
+  on 2.4.22 (thanks to Giuseppe Della Ricca)
+
+Known Issues in 0.40-pre... 
+!-The WEP code is unstable.  
+!-If WEP is enabled (CONFIG_IPW2100_WEP=y), it will eventually crash.
+!-Occassionally, packets start failing decryption.
+!-If the firmware restarts, it does not re configure the WEP keys correctly,
+  so while you may re-associate with the WEP AP, you won't have keys 
+  configured to actually exchange WEP packets.
+!-ieee80211 packet stats are not reported through the /proc/net/wireless (just
+  haven't switched that code over)
+!-WEP Tx is a quick-fix to get the code working.  It will be restructured into
+  a generic 802.11 mechanism.
+!-Firmware restarts are still occuring too frequently.
+ 
+
+Mar 26 2004 Changes in 0.39...
+* Added 'make clean' and error message cleanup (thanks to Luca Capello)
+* Fixed suspend/resume support C3 issue (thanks to Moled on IRC)
+* Moved timer kill to ipw2100_down from the exit routine to stop timers when
+  the interface goes down--otherwise the firmware hang check might kick in.
+* More Makefile cleanups (thanks to Michael Rickmann)
+* Attempted fix for using the external Makefile in a kernel configured for 
+  building ipw2100 internally (in the case when ipw2100 has been added via
+  menuconfig).
+* Modified range settings for quality and level, also switched RSSI to DBM back
+  to the original -98.  Otherwise if you have a strong signal, the value goes
+  positive and the wireless tools switch to displaying as a ratio vs. dBm.
+* Added /proc/net/ipw2100/[if_name]/internals to display some internal 
+  variables to help track issues.
+* Added connection check to quality return for iwconfig (thanks to Pedro 
+  Corte-Real)
+
+Mar 24 2004 Changes in 0.38...
+* Added SW RF Kill switch support for Packard Bell EasyNote E5 (thanks to 
+  Pedro Ramalhais)
+* Fixed RSSI to DBM constant from 98 to 90
+* Added patch for quality metrics in /proc/net/wireless (thanks to Martin 
+  Schrodt)
+* Refactored the start/stop code into ipw2100_up / down, and hooked the code 
+  into the suspend/resume code.
+* Added a 2s heartbeat timer to the firmware; if the RTC stalls then a reset
+  is performed.
+* Fixed ISR code to use a tasklet instead of scheduled work (fixes 
+  'hw_command_send timed out' during firmware restart)
+* Added 'firmware resets' and 'firmware hangs' counters to 
+  /proc/net/ipw2100/[if_name]/stats
+
+Mar 22 2004 Changes in 0.37...
+* Fixed /proc/net/ipw2100 cleanup on exit (thanks to Giuseppe)
+* Added initial eth_tool support for link detection (thanks to Martin Schrodt)
+* Began code changes for WEP support (leveraging Host AP projec)
+* Fixed firmware version # reporting in /proc/ipw2100/[if_name]/version with i
+  CONFIG_IPW2100_LEGACY_FW_LOAD
+* Changed to unified build Makefile for all release versions
+* Switched ISR code to a scheduled work item
+* Upgraded patchset to 2.6.4
+
+Mar 19 2004 Changes in 0.36...
+* Fixed pci_free_consistent bug in ipw2100_msg_free (thanks to Damien 
+  Bergamini).  Defect # 918004.
+* Added dumping of status structure if payload size reported to be greater than
+  allowable 802_11 payload size.
+* Added firmware restart on bogus payload size; temporary work around until we i
+  root cause the data corruption.
+* Added printk() to output which firmware loading method is being used
+* Added printk() to ipw2100_tx_timeout to track firmware stalls
+* Several changes to the Makefile for supporting external and internal building
+
+Mar 18 2004 Changes in 0.35...
+* Added wireless extension get range support
+* Added /proc/net/ipw2100/[if_name]/{ordinals,hw,registers,pci} for dumping 
+  various pieces of data.
+* Code cleanup in a couple spots
+* Removed max transit unit (MTU) check in isr_rx (should fix MTU conflict some 
+  users are seeing)
+* Modified code path so that if wake_up_sync is not defined, we define
+  wake_up_interruptible_sync to wake_up_interruptible so that the 
+  __wake_up_sync patch is no longer needed.
+* Added initial start for suspend/resume (thanks to Len Brown).
+
+Mar 17 2004 Changes in 0.34...
+* ACPI C3 conflict resolved. If you have applied the C3 patch to 
+  drivers/acpi/processor.c, you can now reverse that patch and turn C3 back on. * Added HW register and PCI configuration data dump entries to 
+  proc/net/ipw2100/[if_name]/{hw,pci} 
+* Updated Makefile in the -full version (will migrate to the -2.4 and -2.6 
+  patch versions soon) 
+
+Mar 16 2004 Changes in 0.33...
+* Added hotplug firmware loading support (thanks to Luc Saillard). If you need 
+  to continue using the old style, you can turn it on via kernel configuration
+  options. It defaults to the new mechanism. See INSTALL for information. 
+* Added interface name module parameter (if_name) (thanks to Stanley Wang, 
+  Boris Hu, and Cyril Jaquier for all submitting roughly the same patch) 
+* Added port IO debug output for tracing IO to the actual hardware 
+  (IPW2100_DEBUG_IO) 
+* Moved proc info into /proc/net/ipw2100 from /proc/ipw2100 
+* Added support for /proc/net/wireless (thanks to Luc Saillard). 
+* Added external makefile (thanks to Peter Johanson). This Makefile was 
+  modified slightly to target .../wireless/ipw2100 vs. .../wireless (thanks to 
+  Luca Capello). 
+
+Mar 12 2004 Changes in 0.32...
+* Added support for toggling RF switch. If you have a HW based RF switch you 
+  can now toggle it ON/OFF and the driver will resync. 
+* Added IPW2100_DEBUG_RF_KILL to monitor RF transitions in debug log 
+* Fixed module fault on iwconfig ethX nick (thanks Radu Graeb) 
+
+Mar 12 2004 Changes in 0.31
+* Hardware reset now supported 
+* Support for hardware reset in response to fatal_interrupt 
+* proc oops fixed (thanks to Radu Greab) 
+* Fixed problem with dev->mem_end being set incorrectly 
+* Fixed oops with accesing some iwconfig query commands while the driver is 
+  uninitialized. 
+
+Mar 11 2004 Changes in 0.30...
+* Updated INSTALL with externa build steps (thanks Andrea) 
+* Added IPW2100_DEBUG_FRAG for fragmentation tracing 
+* Fixed oops if module unloaded before interface initialized/up 
+* Fixed oops if attempt to load corrupt firmware 
+* Fixed oops if iwlist scan used before interface initialized/up 
+* Moved printk() device info to after the device is registered (so you don't 
+  see eth%d in the kernel log) 
+* Began cleaning up the open/close logic so that it can reset the firmware 
+  correctly on critical errors. 
+* Incorporated several recommended code fixes by Jeff Garzik (still have quite 
+  a few to incorporate) 
+
+Mar 10 2004 Changes in 0.29
+* Initial release 
+* BSS support 
+* Fragmentation 
+* Some wireless extension support 
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/INSTALL linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/INSTALL
--- linux-2.6.6/drivers/net/wireless/ipw2100/INSTALL	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/INSTALL	2004-05-22 09:13:01.797990552 -0500
@@ -0,0 +1,182 @@
+Intel PRO/Wireless 2100 802.11b Linux Driver
+Copyright (C) 2004, Intel Corporation
+For additional information, contact James Ketrenos <jketreno@linux.intel.com>
+
+COMPILER REQUIREMENTS
+---------   ------     ----       ---    --       --       -          -
+
+You need to be using GCC v 3.0 or higher in order to build the ipw2100 project.
+Using older versions will result in several compilation errors.
+
+
+INSTALLING THE BITS
+------------ -----   -----       ----       ---       --         -     
+
+There are two ways to build the module, either via a patch to your kernel, or
+as a stand alone module.  For the first, read on, for the later skip to 
+BUILDING EXTERNAL
+
+To install the driver download the package appropriate for your kernel (2.4 or 
+2.6).  Once you have that, simply change to the root of your kernel and
+apply the patch:
+
+% export K=2.4.24
+% export V=0.17
+% tar xzfO ~/ipw2100-$K-$V.tgz ipw2100-$K-$V-patch | patch -p1
+
+NOTE:  If you are upgrading to a new version, first remove the old one by 
+reversing the previous patch.  For example:
+
+% export V=0.16
+% tar xzfO ~/ipw2100-$K-$V.tgz ipw2100-$K-$V-patch | patch -p1 -R
+
+You can then apply the new patch.  
+
+The patch should proceed without errors.  Once you have applied the patch, you
+can configure and build the kernel:
+
+
+CONFIGURING THE KERNEL
+------------ -----   -----       ----       ---       --         -     
+
+# Configure the kernel
+% make menuconfig
+
+# Enable Intel PRO/Wireless 2100 under Network Devices => Wireless
+#
+# NOTE:  You must have EXPERIMENTAL turned on to see the Intel PRO/Wireless
+#        option.  You can set this in Code Maturity Setting Options.
+#
+# ALSO NOTE:  
+#        You only need the av5100 module if you have an Averatec laptop.
+#        You only need the pbe5 module if you have a Packard Bell EasyNote E5 laptop.
+#
+
+BUILDING THE MODULE
+------------ -----   -----       ----       ---       --         -     
+
+# Build the kernel module
+
+% make modules modules_install
+
+If you built as a module and didn't change any other kernel options, you are 
+ready to go.  Proceed to LOADING THE DRIVER
+
+
+BUILDING EXTERNAL
+----------- -----   ----   ----      ---       --       -             -
+
+The -full driver package now contains a Makefile that can be used for building
+the driver outside of the kernel tree.  To build it for the currently running
+kernel, sipmly type:
+
+# make && make install
+
+To build it for a different kernel than the running one, use the KSRC 
+parameter:
+
+# make KSRC=/path/to/kernel/ && make install
+
+Thanks to Peter Johanson for the original Makefile, and several others on the
+ipw2100-devel mailing list for helping to enhance it.
+
+Now proceed to LOADING THE DRIVER
+
+
+LOADING THE FIRMWARE
+------------ -----   -----       ----       ---       --         -     
+
+Before you can load the driver, you need the firmware image.  You can find
+instructions for obtaining the firmware by going to 
+http://ipw2100.sf.net/firmware.php.
+
+Once you have the firmware, uncompress the archive (it may be a .zip which 
+in turn contains a .tgz that you need to uncompress).  You should find a file
+named ipw2100-1.0.fw.  
+
+LOADING FIRMWARE VIA HOTPLUG... (new 0.33)
+------- ----    --    -      -        -
+As of v0.33, the IPW2100 supports loading of firmware via the Linux firmware 
+hotplug capability.  In order to use this, you must enable CONFIG_FW_LOADER in
+your kernel configuration.  In 2.6.x this option is enabled via: 
+
+	Device Drivers -> 
+		Generic Driver Options -> 
+			Hotplug firmware loading support
+
+In 2.4.x, it can be found here:
+	Library Routines ->
+		Hotplug firmware loading support
+
+In addition, you will need the Linux hotplug scripts dated later than 
+2003_10_07 (if you do not have /etc/hotplug/firmware.agent then you need to 
+upgrade).  
+
+You will also need to have sysfs mounted.  You can do this by adding an entry
+to /etc/fstab similar to this:
+
+none            /sys            sysfs   defaults                0       0
+
+If the directory /sys does not already exist, you will need to create it:
+
+# mkdir /sys
+
+You can then mount the sysfs partition via:
+
+# mount -a
+
+You can obtain the latest hotplug scripts via the following link:
+
+http://sourceforge.net/project/showfiles.php?group_id=17679
+
+Once set up, you can copy ipw2100-1.0.fw into /usr/lib/hotplug/firmware/ (you 
+may need to create that directory).  When the driver requests the firmware, 
+the hotplug agent will then push the firmware image to it.
+
+LOADING THE LEGACY WAY... 
+------- ----    --    -      -        -
+If, for some reason, you do not wish to use the hotplug system, IPW2100 still 
+provides a direct mechanism for loading the firmware.  To use this, simply 
+configure your kernel to use the CONFIG_IPW2100_LEGACY_FW_LOAD option. 
+
+You can then place a copy of ipw2100-1.0.fw into /etc/firmware.  The driver will
+then load the firmware directly from the file system.
+
+
+LOADING THE DRIVER
+------------ -----   -----       ----       ---       --         -     
+
+First, create a file in /etc/sysconfig/network-scripts/ called ifcfg-eth1 
+(or eth2, etc. as appropriate).  Place the following within it:
+
+DEVICE=eth1
+ONBOOT=yes
+BOOTPROTO=dhcp
+TYPE=Wireless
+
+% modprobe ipw2100
+% ifup eth1
+
+If you have DHCP configured on your network, and you have a wireless access
+point nearby, you should be up and running.
+
+You can check and see if your interface is up by running 
+
+% ifconfig eth1
+
+To test the connection, you can ping a machine using the wireless interface:
+
+% ping www.intel.com -I eth1
+
+If you want to use the wireless interface for all traffic, set up the default
+gateway to go through it.  I usually perform the following:
+
+# Disable eth0 completely
+% ifdown eth0
+
+# Configure the routing table to go through the wireless NIC
+% route add default gw 192.168.1.1 eth1
+
+If you had brought down eth0 before you load the ipw2100 module, the system
+should set up your routes for you.
+
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/Makefile linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/Makefile
--- linux-2.6.6/drivers/net/wireless/ipw2100/Makefile	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/Makefile	2004-05-22 09:13:01.804989506 -0500
@@ -0,0 +1,185 @@
+#
+# Makefile for the Linux Wireless network device drivers.
+# 
+# Original makefile by Peter Johanson
+#
+# NOTE: This make file can serve as both an external Makefile (launched
+#       directly by the user), or as the sub-dir Makefile used by the kernel
+# 	build system.
+
+
+
+
+# If CONFIG_IPW2100 isn't set, we'll assume the user has never configured
+# their kernel to include this module and set up some defaults.
+#
+# NOTE: If you have previously added IPW2100 to your kernel and configured it 
+#       for inclusion, these settings will be overridden by your kernel
+#       configuration.
+
+ifndef CONFIG_IPW2100
+EXTERNAL_BUILD=y
+CONFIG_IPW2100=m
+CONFIG_IPW2100_AVERATEC_5100P=m
+CONFIG_IPW2100_PACKARDBELL_E5=m
+CONFIG_IPW2100_DEBUG=y
+
+# If you are building externally and you want to use the legacy firmware,
+# then uncomment the following line:
+# CONFIG_IPW2100_LEGACY_FW_LOAD=y
+
+# If you are building externally and want to play with the WEP code being
+# addeded, then uncomment the following line:
+# CONFIG_IPW2100_WEP=y
+endif
+
+list-m :=
+list-$(CONFIG_IPW2100) += ipw2100
+list-$(CONFIG_IPW2100_AVERATEC_5100P) += av5100
+list-$(CONFIG_IPW2100_PACKARDBELL_E5) += pbe5
+
+obj-$(CONFIG_IPW2100) += ipw2100.o
+obj-$(CONFIG_IPW2100_AVERATEC_5100P) += av5100.o
+obj-$(CONFIG_IPW2100_PACKARDBELL_E5) += pbe5.o
+ipw2100-objs := \
+        ipw2100_main.o \
+        ipw2100_fw.o \
+        ipw2100_wx.o \
+        ipw2100_frag.o 
+
+ifeq ($(CONFIG_IPW2100_WEP),y)
+ipw2100-objs += ieee80211_rx.o ieee80211.o ieee80211_wx.o
+endif
+
+#
+# Begin dual Makefile mode here.  First we provide support for when we
+# are being invoked by the kernel build system
+#
+ifneq ($(KERNELRELEASE),)
+
+#
+# If you receive a compile message about multiple definitions of
+# CONFIG_IPW2100_DEBUG or CONFIG_IPW2100_LEGACY_FW_LOAD, then you have
+# likely previously included the IPW2100 into the full kernel build, and 
+# these definitions are now being set up by the kernel build system.  
+#
+# To correct this, remove any CONFIG_IPW2100_* lines from $(KSRC)/.config
+#
+ifeq ($(EXTERNAL_BUILD),y)
+ifdef CONFIG_IPW2100_DEBUG	
+EXTRA_CFLAGS += -DCONFIG_IPW2100_DEBUG=$(CONFIG_IPW2100_DEBUG)
+endif	
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+EXTRA_CFLAGS += -DCONFIG_IPW2100_LEGACY_FW_LOAD=$(CONFIG_IPW2100_LEGACY_FW_LOAD)
+endif
+ifdef CONFIG_IPW2100_WEP
+EXTRA_CFLAGS += -DCONFIG_IPW2100_WEP=$(CONFIG_IPW2100_WEP)
+endif
+endif
+
+ifneq ($(PATCHLEVEL),6) # If we are not on a 2.6, then do 2.4 specific things
+
+O_TARGET := ipw.o
+
+include $(TOPDIR)/Rules.make
+
+ipw2100.o: $(ipw2100-objs)
+	$(LD) -r -o $@ $(ipw2100-objs)
+
+endif # End if 2.4 specific settings
+
+else 
+# Here we begin the portion that is executed if the user invoked this Makefile
+# directly.
+
+# KSRC should be set to the path to your sources
+# modules are installed into KMISC
+KVER  := $(shell uname -r)
+KSRC := /lib/modules/$(KVER)/build
+KMISC := /lib/modules/$(KVER)/kernel/drivers/net/wireless/ipw2100/
+
+# KSRC_OUTPUT should be overridden if you are using a 2.6 kernel that
+# has it's output sent elsewhere via KBUILD_OUTPUT= or O=
+KSRC_OUTPUT := $(KSRC)
+
+# If we find Rules.make, we can assume we're using the old 2.4 style building
+OLDMAKE=$(wildcard $(KSRC)/Rules.make)
+PWD=$(shell pwd)
+
+VERFILE := $(KSRC_OUTPUT)/include/linux/version.h
+KERNELRELEASE := $(shell \
+	if [ -r $(VERFILE) ]; then \
+		(cat $(VERFILE); echo UTS_RELEASE) | \
+		$(CC) -I$(KSRC_OUTPUT) $(CFLAGS) -E - | \
+		tail -n 1 | \
+		xargs echo; \
+        else \
+		uname -r; \
+	fi)
+
+MODPATH := $(DESTDIR)/lib/modules/$(KERNELRELEASE)
+
+all: modules
+
+clean:
+	rm -f *.mod.c *.mod *.o *.ko .*.cmd
+	rm -rf $(PWD)/tmp
+
+ifeq ($(OLDMAKE),)
+
+TMP=$(PWD)/tmp
+MODVERDIR=$(TMP)/.tmp_versions
+
+modules:
+ifdef ($(KSRC_OUTPUT)/.tmp_versions)
+	mkdir -p $(MODVERDIR)
+	-cp $(KSRC_OUTPUT)/.tmp_versions/*.mod $(MODVERDIR)
+endif
+ifeq ($(KSRC),$(KSRC_OUTPUT)) # We're not outputting elsewhere
+ifdef ($(KSRC)/.tmp_versions)
+	-cp $(KSRC)/.tmp_versions/*.mod $(MODVERDIR)
+endif
+	make -C $(KSRC) SUBDIRS=$(PWD) MODVERDIR=$(PWD) modules
+else # We've got a kernel with seperate output, copy the config, and use O=
+	mkdir -p $(TMP)
+	cp $(KSRC_OUTPUT)/.config $(TMP)
+	make -C $(KSRC) SUBDIRS=$(PWD) MODVERDIR=$(PWD) O=$(PWD)/tmp modules
+endif
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .ko,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	@echo "Don't forget to copy firmware to /etc/firmware/."
+else
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ and have the "
+	@echo "hotplug tools in place."
+endif
+	@echo "See INSTALL for more information."
+
+
+else # We're on 2.4, and things are slightly different
+
+modules:
+	make -C $(KSRC) SUBDIRS=$(PWD) BUILD_DIR=$(PWD) modules
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .o,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	@echo "Don't forget to copy firmware to /etc/firmware/."
+else
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ "
+	@echo "and have the hotplug tools in place."
+endif
+	@echo "See INSTALL for more information."
+
+endif
+
+uninstall:
+	rm -rf $(KMISC)
+	/sbin/depmod -a
+
+endif
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/av5100.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/av5100.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/av5100.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/av5100.c	2004-05-22 09:13:01.810988610 -0500
@@ -0,0 +1,164 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include "ipwversion.h"
+
+
+#define DRV_NAME		"av5100"
+#define DRV_VERSION		"0." IPW2100_VERSION
+#define DRV_DESCRIPTION		"SW RF kill switch for Averatec 5100P"
+#define DRV_COPYRIGHT		"Copyright(c) 2003-2004 Intel Corporation"
+
+static int radio = 1;
+MODULE_PARM(radio, "i");
+
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR(DRV_COPYRIGHT);
+MODULE_LICENSE("GPL");
+
+#define AV5100_RADIO_ON (0xe0)
+#define AV5100_RADIO_OFF (0xe1)
+
+static int av5100_radio = AV5100_RADIO_OFF;
+
+static void av5100_set_radio(int state)
+{
+	printk(KERN_INFO DRV_NAME ": Radio being turned %s\n",
+	       (state  == AV5100_RADIO_ON) ? "ON" : "OFF");
+	outl(0x80020800, 0xcf8);
+	outb(0x6f, 0x0072);
+	outl(0x1800ffff, 0x1184); 
+	outb(state, 0x00b2);
+	av5100_radio = state;
+}
+
+
+/*
+ * proc stuff
+ */
+static struct proc_dir_entry *dir_base = NULL;
+
+static int proc_set_radio(struct file *file, const char *buffer, 
+			  unsigned long count, void *data)
+{
+	av5100_set_radio(buffer[0] == '0' ? AV5100_RADIO_OFF : AV5100_RADIO_ON);
+	
+	return count;
+}
+
+static int proc_get_radio(char *page, char **start, off_t offset,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	
+	len += snprintf(page, count, DRV_NAME ": %d\n", 
+			av5100_radio == AV5100_RADIO_OFF ? 0 : 1);
+	
+	*eof = 1;
+	return len;
+}
+
+
+static void av5100_proc_cleanup(void)
+{
+	if (dir_base) {
+		remove_proc_entry("radio", dir_base);
+		remove_proc_entry(DRV_NAME, &proc_root);
+		dir_base = NULL;
+	}
+}
+
+
+static int av5100_proc_init(void)
+{
+	struct proc_dir_entry *ent;
+	int err = 0;
+
+	dir_base = create_proc_entry(DRV_NAME, S_IFDIR, &proc_root);
+	if (dir_base == NULL) {
+		printk(KERN_ERR DRV_NAME ": Unable to initialise /proc/" 
+		       DRV_NAME "\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+
+	ent = create_proc_entry("radio", S_IFREG | S_IRUGO | S_IWUSR, 
+				dir_base);
+	if (ent) {
+		ent->read_proc = proc_get_radio;
+		ent->write_proc = proc_set_radio;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/" DRV_NAME "/radio\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	return 0;
+
+ fail:
+	av5100_proc_cleanup();
+	return err;
+}
+
+/*
+ * module stuff
+ */
+static int __init av5100_init(void)
+{
+	av5100_proc_init();
+
+	av5100_set_radio((radio == 1) ? AV5100_RADIO_ON : AV5100_RADIO_OFF);
+	
+	return 0;
+}
+
+static void __exit av5100_exit(void)
+{
+	av5100_set_radio(AV5100_RADIO_OFF);
+
+	av5100_proc_cleanup();
+}
+
+module_init(av5100_init);
+module_exit(av5100_exit);
+
+/*
+         1         2         3         4         5         6         7
+12345678901234567890123456789012345678901234567890123456789012345678901234567890
+*/
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/hostap/hostap_crypt.h	2004-05-22 09:13:01.818987415 -0500
@@ -0,0 +1,39 @@
+#ifndef PRISM2_CRYPT_H
+#define PRISM2_CRYPT_H
+
+struct hostap_crypto_ops {
+	char *name;
+
+	/* init new crypto context (e.g., allocate private data space,
+	 * select IV, etc.); returns NULL on failure or pointer to allocated
+	 * private data on success */
+	void * (*init)(void);
+
+	/* deinitialize crypto context and free allocated private data */
+	void (*deinit)(void *priv);
+
+	/* encrypt/decrypt return < 0 on error or number of bytes written
+	 * to out_buf; len is number of bytes in in_buf */
+	int (*encrypt)(u8 *buf, int len, void *priv);
+	int (*decrypt)(u8 *buf, int len, void *priv);
+
+	int (*set_key)(int idx, void *key, int len, void *priv);
+	int (*get_key)(int idx, void *key, int len, void *priv);
+
+	int (*set_key_idx)(int idx, void *priv);
+	int (*get_key_idx)(void *priv);
+
+	/* maximum number of bytes added by encryption; encrypt buf is
+	 * allocated with extra_prefix_len bytes, copy of in_buf, and
+	 * extra_postfix_len; encrypt need not use all this space, but
+	 * the result must start at the beginning of the buffer and correct
+	 * length must be returned */
+	int extra_prefix_len, extra_postfix_len;
+};
+
+
+int hostap_register_crypto_ops(struct hostap_crypto_ops *ops);
+int hostap_unregister_crypto_ops(struct hostap_crypto_ops *ops);
+struct hostap_crypto_ops * hostap_get_crypto_ops(const char *name);
+
+#endif /* PRISM2_CRYPT_H */
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211.c	2004-05-22 09:13:01.826986220 -0500
@@ -0,0 +1,190 @@
+/*******************************************************************************
+  
+  Copyright(c) 2004 Intel Corporation. All rights reserved.
+
+  Portions of this file are based on the WEP enablement code provided by the
+  Host AP project hostap-drivers v0.1.3
+  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+  <jkmaline@cc.hut.fi>
+  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <asm/uaccess.h>
+
+#include "ieee80211.h"
+
+int ieee80211_set_encryption(struct ieee80211_device *ieee)
+{
+	int len, idx;
+	char keybuf[WEP_KEY_LEN + 1];
+	enum { NONE, WEP, OTHER } encrypt_type;
+
+	if (ieee->crypt == NULL || ieee->crypt->ops == NULL)
+		encrypt_type = NONE;
+	else if (strcmp(ieee->crypt->ops->name, "WEP") == 0)
+		encrypt_type = WEP;
+	else
+		encrypt_type = OTHER;
+
+	if (ieee->func->set_unencrypted_filter) {
+		if (ieee->open_wep || encrypt_type == NONE ||
+		    (ieee->ieee_802_1x && ieee->host_decrypt))
+			ieee->func->set_unencrypted_filter(ieee, 0);
+		else
+			ieee->func->set_unencrypted_filter(ieee, 1);
+	}
+
+	if (encrypt_type != WEP) {
+		if (ieee->func->set_wep_authentication)
+			ieee->func->set_wep_authentication(ieee, 0);
+		return 0;
+	}
+
+	/* For now, we have set it to only support host based encryption
+	 * and decryption.  Since it is not uncommon to have host based WEP
+	 * for general communication, but the authentication process occur
+	 * via the hardware, we must tell the HW which WEP key is being used.
+	 */
+
+	if (!ieee->func->set_key ||
+	    !ieee->func->set_key_idx ||
+	    !ieee->func->set_wep_authentication)
+		return 0;
+
+#ifdef NOTYET
+	/* 104-bit support seems to require that all the keys are set to the
+	 * same keylen */
+	keylen = 6; /* first 5 octets */
+
+#endif
+	idx = ieee->crypt->ops->get_key_idx(ieee->crypt->priv);
+	len = ieee->crypt->ops->get_key(idx, keybuf, sizeof(keybuf),
+					ieee->crypt->priv);
+	
+#ifdef NOTYET
+	if (idx >= 0 && idx < WEP_KEYS && len > 5)
+		keylen = WEP_KEY_LEN + 1; /* first 13 octets */
+
+	for (i = 0; i < WEP_KEYS; i++) {
+		memset(keybuf, 0, sizeof(keybuf));
+		(void) ieee->crypt->ops->get_key(i, keybuf, sizeof(keybuf),
+						  ieee->crypt->priv);
+	}
+#endif
+
+	ieee->func->set_key(ieee, idx, keybuf, len);
+//	ieee->func->set_key_idx(ieee, idx);
+	ieee->func->set_wep_authentication(ieee, 1);
+
+	return 0;
+}
+
+static void ieee80211_crypt_deinit_entries(struct ieee80211_device *ieee, 
+					   int force)
+{
+	struct list_head *ptr, *n;
+	struct ieee80211_crypt_data *entry;
+
+	for (ptr = ieee->crypt_deinit_list.next, n = ptr->next;
+	     ptr != &ieee->crypt_deinit_list; ptr = n, n = ptr->next) {
+		entry = list_entry(ptr, struct ieee80211_crypt_data, list);
+
+		if (atomic_read(&entry->refcnt) != 0 && !force)
+			continue;
+
+		list_del(ptr);
+
+		if (entry->ops)
+			entry->ops->deinit(entry->priv);
+		kfree(entry);
+	}
+}
+
+
+static void ieee80211_crypt_deinit_handler(unsigned long data)
+{
+	struct ieee80211_device *ieee = (struct ieee80211_device *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+	ieee80211_crypt_deinit_entries(ieee, 0);
+	if (!list_empty(&ieee->crypt_deinit_list)) {
+		printk(KERN_DEBUG "%s: entries remaining in delayed crypt "
+		       "deletion list\n", ieee->dev->name);
+		ieee->crypt_deinit_timer.expires = jiffies + HZ;
+		add_timer(&ieee->crypt_deinit_timer);
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+
+}
+
+void ieee80211_init(struct ieee80211_device *ieee, struct net_device *dev,
+		    void *priv)
+{
+	memset(ieee, 0, sizeof(*ieee));
+	ieee->dev = dev;
+	ieee->priv = priv;
+
+	/* Default to enabling full open WEP with host based encrypt/decrypt */
+	ieee->open_wep = 1;
+	ieee->host_encrypt = 1;
+	ieee->host_decrypt = 1;
+	
+	INIT_LIST_HEAD(&ieee->crypt_deinit_list);
+	init_timer(&ieee->crypt_deinit_timer);
+	ieee->crypt_deinit_timer.data = (unsigned long)ieee;
+	ieee->crypt_deinit_timer.function = ieee80211_crypt_deinit_handler;
+
+	spin_lock_init(&ieee->lock);
+}
+
+void ieee80211_deinit(struct ieee80211_device *ieee)
+{
+	ieee80211_crypt_deinit_entries(ieee, 1);
+	if (ieee->crypt && ieee->crypt->ops) {
+		ieee->crypt->ops->deinit(ieee->crypt->priv);
+		kfree(ieee->crypt);
+		ieee->crypt = NULL;
+	}
+}
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211.h	2004-05-22 09:13:01.837984576 -0500
@@ -0,0 +1,335 @@
+/*
+ * Original code based on Host AP (software wireless LAN access point) driver 
+ * for Intersil Prism2/2.5/3.
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * Adaption to a generic IEEE 802.11 stack by James Ketrenos 
+ * <jketreno@linux.intel.com>
+ *
+ * Copyright (c) 2004, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. See README and COPYING for
+ * more details.
+ */
+#ifndef IEEE80211_H
+#define IEEE80211_H
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+
+#ifndef WIRELESS_SPY
+#define WIRELESS_SPY		// enable iwspy support
+#endif
+#include <net/iw_handler.h>	// new driver API
+
+#define BIT(x) (1 << (x))
+
+#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
+#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
+
+
+#ifndef ETH_P_PAE
+#define ETH_P_PAE 0x888E /* Port Access Entity (IEEE 802.1X) */
+#endif /* ETH_P_PAE */
+
+/* IEEE 802.11 defines */
+
+#define WLAN_FC_PVER (BIT(1) | BIT(0))
+#define WLAN_FC_TODS BIT(8)
+#define WLAN_FC_FROMDS BIT(9)
+#define WLAN_FC_MOREFRAG BIT(10)
+#define WLAN_FC_RETRY BIT(11)
+#define WLAN_FC_PWRMGT BIT(12)
+#define WLAN_FC_MOREDATA BIT(13)
+#define WLAN_FC_ISWEP BIT(14)
+#define WLAN_FC_ORDER BIT(15)
+
+#define WLAN_FC_GET_TYPE(fc) (((fc) & (BIT(3) | BIT(2))) >> 2)
+#define WLAN_FC_GET_STYPE(fc) \
+	(((fc) & (BIT(7) | BIT(6) | BIT(5) | BIT(4))) >> 4)
+
+#define WLAN_GET_SEQ_FRAG(seq) ((seq) & (BIT(3) | BIT(2) | BIT(1) | BIT(0)))
+#define WLAN_GET_SEQ_SEQ(seq) \
+	(((seq) & (~(BIT(3) | BIT(2) | BIT(1) | BIT(0)))) >> 4)
+
+#define WLAN_FC_TYPE_MGMT 0
+#define WLAN_FC_TYPE_CTRL 1
+#define WLAN_FC_TYPE_DATA 2
+
+/* management */
+#define WLAN_FC_STYPE_ASSOC_REQ 0
+#define WLAN_FC_STYPE_ASSOC_RESP 1
+#define WLAN_FC_STYPE_REASSOC_REQ 2
+#define WLAN_FC_STYPE_REASSOC_RESP 3
+#define WLAN_FC_STYPE_PROBE_REQ 4
+#define WLAN_FC_STYPE_PROBE_RESP 5
+#define WLAN_FC_STYPE_BEACON 8
+#define WLAN_FC_STYPE_ATIM 9
+#define WLAN_FC_STYPE_DISASSOC 10
+#define WLAN_FC_STYPE_AUTH 11
+#define WLAN_FC_STYPE_DEAUTH 12
+
+/* control */
+#define WLAN_FC_STYPE_PSPOLL 10
+#define WLAN_FC_STYPE_RTS 11
+#define WLAN_FC_STYPE_CTS 12
+#define WLAN_FC_STYPE_ACK 13
+#define WLAN_FC_STYPE_CFEND 14
+#define WLAN_FC_STYPE_CFENDACK 15
+
+/* data */
+#define WLAN_FC_STYPE_DATA 0
+#define WLAN_FC_STYPE_DATA_CFACK 1
+#define WLAN_FC_STYPE_DATA_CFPOLL 2
+#define WLAN_FC_STYPE_DATA_CFACKPOLL 3
+#define WLAN_FC_STYPE_NULLFUNC 4
+#define WLAN_FC_STYPE_CFACK 5
+#define WLAN_FC_STYPE_CFPOLL 6
+#define WLAN_FC_STYPE_CFACKPOLL 7
+
+/* Authentication algorithms */
+#define WLAN_AUTH_OPEN 0
+#define WLAN_AUTH_SHARED_KEY 1
+
+#define WLAN_AUTH_CHALLENGE_LEN 128
+
+#define WLAN_CAPABILITY_ESS BIT(0)
+#define WLAN_CAPABILITY_IBSS BIT(1)
+#define WLAN_CAPABILITY_CF_POLLABLE BIT(2)
+#define WLAN_CAPABILITY_CF_POLL_REQUEST BIT(3)
+#define WLAN_CAPABILITY_PRIVACY BIT(4)
+
+/* Status codes */
+#define WLAN_STATUS_SUCCESS 0
+#define WLAN_STATUS_UNSPECIFIED_FAILURE 1
+#define WLAN_STATUS_CAPS_UNSUPPORTED 10
+#define WLAN_STATUS_REASSOC_NO_ASSOC 11
+#define WLAN_STATUS_ASSOC_DENIED_UNSPEC 12
+#define WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG 13
+#define WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION 14
+#define WLAN_STATUS_CHALLENGE_FAIL 15
+#define WLAN_STATUS_AUTH_TIMEOUT 16
+#define WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA 17
+#define WLAN_STATUS_ASSOC_DENIED_RATES 18
+/* 802.11b */
+#define WLAN_STATUS_ASSOC_DENIED_NOSHORT 19
+#define WLAN_STATUS_ASSOC_DENIED_NOPBCC 20
+#define WLAN_STATUS_ASSOC_DENIED_NOAGILITY 21
+
+/* Reason codes */
+#define WLAN_REASON_UNSPECIFIED 1
+#define WLAN_REASON_PREV_AUTH_NOT_VALID 2
+#define WLAN_REASON_DEAUTH_LEAVING 3
+#define WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY 4
+#define WLAN_REASON_DISASSOC_AP_BUSY 5
+#define WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA 6
+#define WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA 7
+#define WLAN_REASON_DISASSOC_STA_HAS_LEFT 8
+#define WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH 9
+
+
+/* Information Element IDs */
+#define WLAN_EID_SSID 0
+#define WLAN_EID_SUPP_RATES 1
+#define WLAN_EID_FH_PARAMS 2
+#define WLAN_EID_DS_PARAMS 3
+#define WLAN_EID_CF_PARAMS 4
+#define WLAN_EID_TIM 5
+#define WLAN_EID_IBSS_PARAMS 6
+#define WLAN_EID_CHALLENGE 16
+
+#define IEEE80211_MGMT_HDR_LEN 24
+#define IEEE80211_DATA_HDR3_LEN 24
+#define IEEE80211_DATA_HDR4_LEN 30
+
+
+struct ieee80211_hdr {
+	u16 frame_control;
+	u16 duration_id;
+	u8 addr1[6];
+	u8 addr2[6];
+	u8 addr3[6];
+	u16 seq_ctrl;
+	u8 addr4[6];
+} __attribute__ ((packed));
+
+/* NOTE: This data is for statistical purposes; not all hardware provides this
+ *       information for frames received.  Not setting these will not cause
+ *       any adverse affects. */
+struct ieee80211_rx_stats {
+	u32 mac_time;
+	u8 signal;
+	u8 noise;
+	u16 rate; /* in 100 kbps */
+};
+
+/* IEEE 802.11 requires that STA supports concurrent reception of at least
+ * three fragmented frames. This define can be increased to support more
+ * concurrent frames, but it should be noted that each entry can consume about
+ * 2 kB of RAM and increasing cache size will slow down frame reassembly. */
+#define IEEE80211_FRAG_CACHE_LEN 4
+
+struct ieee80211_frag_entry {
+	unsigned long first_frag_time;
+	unsigned int seq;
+	unsigned int last_frag;
+	struct sk_buff *skb;
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+};
+
+struct ieee80211_stats {
+	unsigned int tx_unicast_frames;
+	unsigned int tx_multicast_frames;
+	unsigned int tx_fragments;
+	unsigned int tx_unicast_octets;
+	unsigned int tx_multicast_octets;
+	unsigned int tx_deferred_transmissions;
+	unsigned int tx_single_retry_frames;
+	unsigned int tx_multiple_retry_frames;
+	unsigned int tx_retry_limit_exceeded;
+	unsigned int tx_discards;
+	unsigned int rx_unicast_frames;
+	unsigned int rx_multicast_frames;
+	unsigned int rx_fragments;
+	unsigned int rx_unicast_octets;
+	unsigned int rx_multicast_octets;
+	unsigned int rx_fcs_errors;
+	unsigned int rx_discards_no_buffer;
+	unsigned int tx_discards_wrong_sa;
+	unsigned int rx_discards_wep_undecryptable;
+	unsigned int rx_message_in_msg_fragments;
+	unsigned int rx_message_in_bad_msg_fragments;
+};
+
+#include "ieee80211_crypt.h"
+
+struct ieee80211_device;
+
+struct ieee80211_helper_functions {
+	void (*set_key)(struct ieee80211_device *ieee, int idx, char *key, 
+		     int len);
+	void (*set_key_idx)(struct ieee80211_device *ieee, int idx);
+	void (*set_wep_authentication)(struct ieee80211_device *ieee, 
+				       int enable);
+
+	/* these functions are defined in hardware model specific files
+	 * (hostap_{cs,plx,pci}.c */
+	int (*card_present)(struct ieee80211_device *ieee);
+	void (*cor_sreset)(struct ieee80211_device *ieee);
+	int (*dev_open)(struct ieee80211_device *ieee);
+	int (*dev_close)(struct ieee80211_device *ieee);
+	void (*genesis_reset)(struct ieee80211_device *ieee, int hcr);
+
+	
+	/* Turn on unencrypted packet filtering at the HW level */
+	void (*set_unencrypted_filter)(struct ieee80211_device *ieee, int flag);
+
+	/* the following functions are from hostap_hw.c, but they may have some
+	 * hardware model specific code */
+
+	int (*hw_enable)(struct net_device *dev, int initial);
+	int (*hw_config)(struct net_device *dev, int initial);
+	void (*hw_reset)(struct net_device *dev);
+	void (*hw_shutdown)(struct net_device *dev, int no_disable);
+	int (*reset_port)(struct net_device *dev);
+	int (*tx)(struct sk_buff *skb, struct net_device *dev);
+	void (*schedule_reset)(struct ieee80211_device *ieee);
+	int (*tx_80211)(struct sk_buff *skb, struct net_device *dev);
+};
+
+struct ieee80211_device {
+	struct net_device *dev;
+
+	/* Bookkeeping structures */
+	struct net_device_stats stats;
+	struct ieee80211_stats ieee_stats;
+	void *priv;
+
+	int iw_mode; /* operating mode (IW_MODE_*) */
+
+	spinlock_t lock;
+
+	/* WEP and other encryption related settings at the device level */
+#define WEP_KEYS 4
+#define WEP_KEY_LEN 13
+	int open_wep; /* Set to 1 to allow unencrypted frames */
+
+	int reset_on_keychange; /* Set to 1 if the HW needs to be reset on
+				 * WEP key changes */
+
+	/* If the host performs {en,de}cryption, then set to 1 */
+	int host_encrypt;
+	int host_decrypt;
+
+	int ieee_802_1x; /* is IEEE 802.1X used */
+
+	struct list_head crypt_deinit_list;
+	struct ieee80211_crypt_data *crypt;
+	struct timer_list crypt_deinit_timer;
+
+	int bcrx_sta_key; /* use individual keys to override default keys even
+			   * with RX of broad/multicast frames */
+
+	/* Fragmentation structures */
+	struct ieee80211_frag_entry frag_cache[IEEE80211_FRAG_CACHE_LEN];
+	unsigned int frag_next_idx;
+
+
+	/* Callback vtable */
+	struct ieee80211_helper_functions *func;
+
+};
+
+
+extern inline int ieee80211_get_hdrlen(u16 fc)
+{
+	int hdrlen = 24;
+
+	switch (WLAN_FC_GET_TYPE(fc)) {
+	case WLAN_FC_TYPE_DATA:
+		if ((fc & WLAN_FC_FROMDS) && (fc & WLAN_FC_TODS))
+			hdrlen = 30; /* Addr4 */
+		break;
+	case WLAN_FC_TYPE_CTRL:
+		switch (WLAN_FC_GET_STYPE(fc)) {
+		case WLAN_FC_STYPE_CTS:
+		case WLAN_FC_STYPE_ACK:
+			hdrlen = 10;
+			break;
+		default:
+			hdrlen = 16;
+			break;
+		}
+		break;
+	}
+
+	return hdrlen;
+}
+
+/* ieee80211.c */
+extern void ieee80211_init(struct ieee80211_device *ieee, 
+			   struct net_device *dev,
+			   void *priv);
+extern void ieee80211_deinit(struct ieee80211_device *ieee);
+extern int ieee80211_set_encryption(struct ieee80211_device *ieee);
+
+
+/* ieee80211_rx.c */
+extern int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+			struct ieee80211_rx_stats *rx_stats);
+
+/* iee80211_wx.c */
+extern int ieee80211_wx_set_encode(struct ieee80211_device *ieee, 
+				   struct iw_request_info *info, 
+				   union iwreq_data *wrqu, char *key);
+extern int ieee80211_wx_get_encode(struct ieee80211_device *ieee, 
+				   struct iw_request_info *info, 
+				   union iwreq_data *wrqu, char *key);
+
+#endif /* IEEE80211_H */
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211_crypt.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211_crypt.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211_crypt.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211_crypt.h	2004-05-22 09:13:01.839984278 -0500
@@ -0,0 +1,35 @@
+/*
+ * Original code based on Host AP (software wireless LAN access point) driver 
+ * for Intersil Prism2/2.5/3.
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ *
+ * Adaption to a generic IEEE 802.11 stack by James Ketrenos 
+ * <jketreno@linux.intel.com>
+ *
+ * Copyright (c) 2004, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. See README and COPYING for
+ * more details.
+ */
+
+/*
+ * This file defines the interface to the ieee80211 crypto module.  
+ */
+#ifndef IEEE80211_CRYPT_H
+#define IEEE80211_CRYPT_H
+
+#include "hostap/hostap_crypt.h"
+
+struct ieee80211_crypt_data {
+	struct list_head list; /* delayed deletion list */
+	struct hostap_crypto_ops *ops;
+	void *priv;
+	atomic_t refcnt;
+};
+
+#endif
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211_rx.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211_rx.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211_rx.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211_rx.c	2004-05-22 09:13:01.855981887 -0500
@@ -0,0 +1,681 @@
+/*
+ * Original code based Host AP (software wireless LAN access point) driver 
+ * for Intersil Prism2/2.5/3 - hostap.o module, common routines
+ *
+ * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+ * <jkmaline@cc.hut.fi>
+ * Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+ * Copyright (c) 2004, Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation. See README and COPYING for
+ * more details.
+ */
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wireless.h>
+#include <linux/etherdevice.h>
+#include <asm/uaccess.h>
+
+#include "ieee80211.h"
+
+/* See IEEE 802.1H for LLC/SNAP encapsulation/decapsulation */
+/* Ethernet-II snap header (RFC1042 for most EtherTypes) */
+static unsigned char rfc1042_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
+/* Bridge-Tunnel header (for EtherTypes ETH_P_AARP and ETH_P_IPX) */
+static unsigned char bridge_tunnel_header[] =
+{ 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };
+/* No encapsulation header if EtherType < 0x600 (=length) */
+
+
+/* Called by ieee80211_rx_frame_decrypt */
+static inline int ieee80211_is_eapol_frame(struct ieee80211_device *ieee,
+					   struct ieee80211_hdr *hdr, u8 *buf,
+					   int len)
+{
+	struct net_device *dev = ieee->dev;
+	u16 fc, ethertype;
+
+	fc = le16_to_cpu(hdr->frame_control);
+
+	/* check that the frame is unicast frame to us */
+	if ((fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_TODS &&
+	    memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0 &&
+	    memcmp(hdr->addr3, dev->dev_addr, ETH_ALEN) == 0) {
+		/* ToDS frame with own addr BSSID and DA */
+	} else if ((fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_FROMDS &&
+		   memcmp(hdr->addr1, dev->dev_addr, ETH_ALEN) == 0) {
+		/* FromDS frame with own addr as DA */
+	} else
+		return 0;
+
+	if (len < 8)
+		return 0;
+
+	/* check for port access entity Ethernet type */
+	ethertype = (buf[6] << 8) | buf[7];
+	if (ethertype == ETH_P_PAE)
+		return 1;
+
+	return 0;
+}
+
+#define STR_12c "%02X%02X%02X%02X-%02X%02X%02X%02X-%02X%02X%02X%02X"
+#define VAR_12c(x) ((u8*)x)[0],((u8*)x)[1],((u8*)x)[2],((u8*)x)[3],\
+ ((u8*)x)[4],((u8*)x)[5],((u8*)x)[6],((u8*)x)[7], \
+ ((u8*)x)[8],((u8*)x)[9],((u8*)x)[10],((u8*)x)[11] 
+
+/* Called only as a tasklet (software IRQ), by ieee80211_rx */
+static inline int
+ieee80211_rx_frame_decrypt(struct ieee80211_device* ieee, int iswep, 
+			   struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr;
+	struct ieee80211_crypt_data *crypt;
+	void *sta = NULL;
+	int ret = 0, olen, len, hdrlen;
+	char *payload;
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	hdrlen = ieee80211_get_hdrlen(le16_to_cpu(hdr->frame_control));
+
+	len = skb->len - hdrlen;
+	payload = ((char *) (hdr)) + hdrlen;
+	crypt = ieee->crypt;
+	sta = NULL;
+
+#ifdef NOT_YET
+	/* Use station specific key to override default keys if the receiver
+	 * address is a unicast address ("individual RA"). If bcrx_sta_key
+	 * parameter is set, station specific key is used even with
+	 * broad/multicast targets (this is against IEEE 802.11, but makes it
+	 * easier to use different keys with stations that do not support WEP
+	 * key mapping). */
+	if (!(hdr->addr1[0] & 0x01) || local->bcrx_sta_key)
+		(void) hostap_handle_sta_crypto(local, hdr, &crypt, &sta);
+#endif
+
+	/* allow NULL decrypt to indicate an station specific override for
+	 * default encryption */
+	if (crypt && (crypt->ops == NULL || crypt->ops->decrypt == NULL))
+		crypt = NULL;
+
+	if (!crypt && iswep) {
+		printk(KERN_DEBUG "%s: WEP decryption failed (not set) (SA="
+		       MACSTR ")\n", ieee->dev->name, MAC2STR(hdr->addr2));
+		ieee->ieee_stats.rx_discards_wep_undecryptable++;
+		ret = -1;
+		goto done;
+	}
+
+	if (!crypt)
+		goto done;
+
+	if (!iswep && !ieee->open_wep) {
+		if (ieee->ieee_802_1x &&
+		    ieee80211_is_eapol_frame(ieee, hdr, payload, len)) {
+			/* pass unencrypted EAPOL frames even if encryption is
+			 * configured */
+			printk(KERN_DEBUG "%s: RX: IEEE 802.1X - passing "
+			       "unencrypted EAPOL frame\n", ieee->dev->name);
+			goto done;
+		}
+		printk(KERN_DEBUG "%s: encryption configured, but RX frame "
+		       "not encrypted (SA=" MACSTR ")\n",
+		       ieee->dev->name, MAC2STR(hdr->addr2));
+		ret = -1;
+		goto done;
+	}
+
+	/* decrypt WEP part of the frame: IV (4 bytes), encrypted
+	 * payload (including SNAP header), ICV (4 bytes) */
+	atomic_inc(&crypt->refcnt);
+
+/*	printk(KERN_INFO "%s: Before decrypt: " STR_12c "\n",
+	ieee->dev->name, VAR_12c(payload)); */
+	olen = crypt->ops->decrypt(payload, len, crypt->priv);
+/*	printk(KERN_INFO "%s: After decrypt : " STR_12c "\n",
+	ieee->dev->name, VAR_12c(payload));*/
+	atomic_dec(&crypt->refcnt);
+	if (olen < 0) {
+		printk(KERN_DEBUG "%s: WEP decryption failed (SA=" MACSTR
+		       ") len = %d\n", ieee->dev->name, MAC2STR(hdr->addr2),
+		       len);
+		ieee->ieee_stats.rx_discards_wep_undecryptable++;
+		ret = -1;
+		goto done;
+	}
+
+	skb_trim(skb, skb->len - (len - olen));
+
+ done:
+#ifdef NOT_YET
+	if (sta)
+		hostap_handle_sta_release(sta);
+#endif
+
+	return ret;
+}
+
+/* ieee80211_rx_frame_mgtmt
+ *
+ * Responsible for handling management control frames
+ * 
+ * Called by ieee80211_rx */
+static inline int
+ieee80211_rx_frame_mgmt(struct ieee80211_device *ieee, struct sk_buff *skb,
+			struct ieee80211_rx_stats *rx_stats, u16 type,
+			u16 stype)
+{
+	if (ieee->iw_mode == IW_MODE_MASTER) {
+		printk(KERN_DEBUG "%s: Master mode not yet suppported.\n",
+		       ieee->dev->name);
+#ifdef NOT_YET
+		hostap_update_sta_ps(ieee, (struct hostap_ieee80211_hdr *)
+				     skb->data);
+#endif
+	}
+
+#ifdef NOT_YET
+	if (ieee->hostapd && type == WLAN_FC_TYPE_MGMT) {
+		if (stype == WLAN_FC_STYPE_BEACON &&
+		    ieee->iw_mode == IW_MODE_MASTER) {
+			struct sk_buff *skb2;
+			/* Process beacon frames also in kernel driver to
+			 * update STA(AP) table statistics */
+			skb2 = skb_clone(skb, GFP_ATOMIC);
+			if (skb2)
+				hostap_rx(skb2->dev, skb2, rx_stats);
+		}
+
+		/* send management frames to the user space daemon for
+		 * processing */
+		ieee->apdevstats.rx_packets++;
+		ieee->apdevstats.rx_bytes += skb->len;
+		prism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);
+		return 0;
+	}
+#endif
+
+#ifdef NOT_YET
+	if (ieee->iw_mode == IW_MODE_MASTER) {
+		if (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {
+			printk(KERN_DEBUG "%s: unknown management frame "
+			       "(type=0x%02x, stype=0x%02x) dropped\n",
+			       skb->dev->name, type, stype);
+			return -1;
+		}
+
+		hostap_rx(skb->dev, skb, rx_stats);
+		return 0;
+	} 
+#endif
+	printk(KERN_DEBUG "%s: hostap_rx_frame_mgmt: management frame "
+	       "received in non-Host AP mode\n", skb->dev->name);
+	return -1;
+}
+
+/* Called only as a tasklet (software IRQ) */
+static struct ieee80211_frag_entry *
+ieee80211_frag_cache_find(struct ieee80211_device *ieee, unsigned int seq,
+			  unsigned int frag, u8 *src, u8 *dst)
+{
+	struct ieee80211_frag_entry *entry;
+	int i;
+
+	for (i = 0; i < IEEE80211_FRAG_CACHE_LEN; i++) {
+		entry = &ieee->frag_cache[i];
+		if (entry->skb != NULL &&
+		    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {
+			printk(KERN_DEBUG "%s: expiring fragment cache entry "
+			       "seq=%u last_frag=%u\n",
+			       ieee->dev->name, entry->seq, entry->last_frag);
+			dev_kfree_skb(entry->skb);
+			entry->skb = NULL;
+		}
+
+		if (entry->skb != NULL && entry->seq == seq &&
+		    (entry->last_frag + 1 == frag || frag == -1) &&
+		    memcmp(entry->src_addr, src, ETH_ALEN) == 0 &&
+		    memcmp(entry->dst_addr, dst, ETH_ALEN) == 0)
+			return entry;
+	}
+
+	return NULL;
+}
+
+/* Called only as a tasklet (software IRQ) */
+static struct sk_buff *
+ieee80211_frag_cache_get(struct ieee80211_device *ieee, 
+			 struct ieee80211_hdr *hdr)
+{
+	struct sk_buff *skb = NULL;
+	u16 sc;
+	unsigned int frag, seq;
+	struct ieee80211_frag_entry *entry;
+	
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	frag = WLAN_GET_SEQ_FRAG(sc);
+	seq = WLAN_GET_SEQ_SEQ(sc);
+
+	if (frag == 0) {
+		/* Reserve enough space to fit maximum frame length */
+		skb = dev_alloc_skb(ieee->dev->mtu +
+				    sizeof(struct ieee80211_hdr) +
+				    8 /* LLC */ +
+				    2 /* alignment */ +
+				    8 /* WEP */ + ETH_ALEN /* WDS */);
+		if (skb == NULL)
+			return NULL;
+
+		entry = &ieee->frag_cache[ieee->frag_next_idx];
+		ieee->frag_next_idx++;
+		if (ieee->frag_next_idx >= IEEE80211_FRAG_CACHE_LEN)
+			ieee->frag_next_idx = 0;
+
+		if (entry->skb != NULL)
+			dev_kfree_skb(entry->skb);
+
+		entry->first_frag_time = jiffies;
+		entry->seq = seq;
+		entry->last_frag = frag;
+		entry->skb = skb;
+		memcpy(entry->src_addr, hdr->addr2, ETH_ALEN);
+		memcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);
+	} else {
+		/* received a fragment of a frame for which the head fragment
+		 * should have already been received */
+		entry = ieee80211_frag_cache_find(ieee, seq, frag, hdr->addr2,
+						  hdr->addr1);
+		if (entry != NULL) {
+			entry->last_frag = frag;
+			skb = entry->skb;
+		}
+	}
+
+	return skb;
+}
+
+
+/* Called only as a tasklet (software IRQ) */
+static int ieee80211_frag_cache_invalidate(struct ieee80211_device *ieee,
+					   struct ieee80211_hdr *hdr)
+{
+	u16 sc;
+	unsigned int seq;
+	struct ieee80211_frag_entry *entry;
+
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	seq = WLAN_GET_SEQ_SEQ(sc);
+
+	entry = ieee80211_frag_cache_find(ieee, seq, -1, hdr->addr2, 
+					  hdr->addr1);
+
+	if (entry == NULL) {
+		printk(KERN_DEBUG "%s: could not invalidate fragment cache "
+		       "entry (seq=%u)\n",
+		       ieee->dev->name, seq);
+		return -1;
+	}
+
+	entry->skb = NULL;
+	return 0;
+}
+ 
+
+/* All received frames are sent to this function. @skb contains the frame in
+ * IEEE 802.11 format, i.e., in the format it was sent over air.
+ * This function is called only as a tasklet (software IRQ). */
+int ieee80211_rx(struct ieee80211_device *ieee, struct sk_buff *skb,
+		 struct ieee80211_rx_stats *rx_stats)
+{
+	struct net_device *dev = ieee->dev;
+	struct ieee80211_hdr *hdr;
+	size_t hdrlen;
+	u16 fc, type, stype, sc;
+	struct net_device *wds = NULL;
+	struct net_device_stats *stats;
+	unsigned int frag;
+	u8 *payload;
+	struct sk_buff *skb2 = NULL;
+	u16 ethertype;
+#ifdef NOT_YET
+	int frame_authorized = 0;
+	int from_assoc_ap = 0;
+#endif
+	u8 dst[ETH_ALEN];
+	u8 src[ETH_ALEN];
+
+	hdr = (struct ieee80211_hdr *) skb->data;
+	stats = &ieee->stats;
+
+	if (skb->len < 10) {
+		printk(KERN_INFO "%s: SKB length < 10\n",
+		       dev->name);
+		goto rx_dropped;
+	}
+
+	fc = le16_to_cpu(hdr->frame_control);
+	type = WLAN_FC_GET_TYPE(fc);
+	stype = WLAN_FC_GET_STYPE(fc);
+	sc = le16_to_cpu(hdr->seq_ctrl);
+	frag = WLAN_GET_SEQ_FRAG(sc);
+	hdrlen = ieee80211_get_hdrlen(fc);
+
+#ifdef NOT_YET
+
+#if WIRELESS_EXT > 15
+	/* Put this code here so that we avoid duplicating it in all
+	 * Rx paths. - Jean II */
+#ifdef IW_WIRELESS_SPY		/* defined in iw_handler.h */
+	/* If spy monitoring on */
+	if (iface->spy_data.spy_number > 0) {
+		struct iw_quality wstats;
+		wstats.level = rx_stats->signal;
+		wstats.noise = rx_stats->noise;
+		wstats.updated = 6;	/* No qual value */
+		/* Update spy records */
+		wireless_spy_update(dev, hdr->addr2, &wstats);
+	}
+#endif /* IW_WIRELESS_SPY */
+#endif /* WIRELESS_EXT > 15 */
+
+	if (ieee->iw_mode == IW_MODE_MONITOR) {
+		monitor_rx(dev, skb, rx_stats);
+		return 1;
+	}
+
+#endif
+
+	if (type != WLAN_FC_TYPE_DATA) {
+		if (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&
+		    fc & WLAN_FC_ISWEP && ieee->host_decrypt &&
+		    ieee80211_rx_frame_decrypt(ieee, fc & WLAN_FC_ISWEP, 
+					       skb)) {
+			printk(KERN_DEBUG "%s: failed to decrypt mgmt::auth "
+			       "from " MACSTR "\n", dev->name,
+			       MAC2STR(hdr->addr2));
+			/* TODO: could inform hostapd about this so that it
+			 * could send auth failure report */
+			goto rx_dropped;
+		}
+
+		if (ieee80211_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))
+			goto rx_dropped;
+		else
+			goto rx_exit;
+	}
+
+	/* Data frame - extract src/dst addresses */
+	if (skb->len < IEEE80211_DATA_HDR3_LEN)
+		goto rx_dropped;
+
+	switch (fc & (WLAN_FC_FROMDS | WLAN_FC_TODS)) {
+	case WLAN_FC_FROMDS:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr3, ETH_ALEN);
+		break;
+	case WLAN_FC_TODS:
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		break;
+	case WLAN_FC_FROMDS | WLAN_FC_TODS:
+		if (skb->len < IEEE80211_DATA_HDR4_LEN)
+			goto rx_dropped;
+		memcpy(dst, hdr->addr3, ETH_ALEN);
+		memcpy(src, hdr->addr4, ETH_ALEN);
+		break;
+	case 0:
+		memcpy(dst, hdr->addr1, ETH_ALEN);
+		memcpy(src, hdr->addr2, ETH_ALEN);
+		break;
+	}
+
+#ifdef NOT_YET
+	if (hostap_rx_frame_wds(ieee, hdr, fc, &wds))
+		goto rx_dropped;
+	if (wds) {
+		skb->dev = dev = wds;
+		stats = hostap_get_stats(dev);
+	}
+
+	if (ieee->iw_mode == IW_MODE_MASTER && !wds &&
+	    (fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_FROMDS &&
+	    ieee->stadev &&
+	    memcmp(hdr->addr2, ieee->assoc_ap_addr, ETH_ALEN) == 0) {
+		/* Frame from BSSID of the AP for which we are a client */
+		skb->dev = dev = ieee->stadev;
+		stats = hostap_get_stats(dev);
+		from_assoc_ap = 1;
+	}
+#endif
+
+	dev->last_rx = jiffies;
+
+#ifdef NOT_YET
+	if ((ieee->iw_mode == IW_MODE_MASTER ||
+	     ieee->iw_mode == IW_MODE_REPEAT) &&
+	    !from_assoc_ap) {
+		switch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,
+					     wds != NULL)) {
+		case AP_RX_CONTINUE_NOT_AUTHORIZED:
+			frame_authorized = 0;
+			break;
+		case AP_RX_CONTINUE:
+			frame_authorized = 1;
+			break;
+		case AP_RX_DROP:
+			goto rx_dropped;
+		case AP_RX_EXIT:
+			goto rx_exit;
+		}
+	} else if (ieee->iw_mode == IW_MODE_REPEAT ||
+		   ieee->wds_type & HOSTAP_WDS_AP_CLIENT)
+		hostap_update_rx_stats(ieee->ap, hdr, rx_stats);
+#endif
+
+	/* Nullfunc frames may have PS-bit set, so they must be passed to
+	 * hostap_handle_sta_rx() before being dropped here. */
+	if (stype != WLAN_FC_STYPE_DATA &&
+	    stype != WLAN_FC_STYPE_DATA_CFACK &&
+	    stype != WLAN_FC_STYPE_DATA_CFPOLL &&
+	    stype != WLAN_FC_STYPE_DATA_CFACKPOLL) {
+		if (stype != WLAN_FC_STYPE_NULLFUNC)
+			printk(KERN_DEBUG "%s: RX: dropped data frame "
+			       "with no data (type=0x%02x, subtype=0x%02x)\n",
+			       dev->name, type, stype);
+		goto rx_dropped;
+	}
+
+	/* skb: hdr + (possibly fragmented, possibly encrypted) payload */
+
+	if (ieee->host_decrypt &&
+	    ieee80211_rx_frame_decrypt(ieee, fc & WLAN_FC_ISWEP, skb)) 
+		goto rx_dropped;
+
+	/* skb: hdr + (possibly fragmented) plaintext payload */
+
+	if (/*ieee->host_decrypt && (fc & WLAN_FC_ISWEP) &&*/
+	    (frag != 0 || (fc & WLAN_FC_MOREFRAG))) {
+		int flen;
+		struct sk_buff *frag_skb = 
+			ieee80211_frag_cache_get(ieee, hdr);
+		if (!frag_skb) {
+			printk(KERN_DEBUG "%s: Rx cannot get skb from "
+			       "fragment cache (morefrag=%d seq=%u frag=%u)\n",
+			       dev->name, (fc & WLAN_FC_MOREFRAG) != 0,
+			       WLAN_GET_SEQ_SEQ(sc), frag);
+			goto rx_dropped;
+		}
+
+		flen = skb->len;
+		if (frag != 0)
+			flen -= hdrlen;
+
+		if (frag_skb->tail + flen > frag_skb->end) {
+			printk(KERN_WARNING "%s: host decrypted and "
+			       "reassembled frame did not fit skb\n",
+			       dev->name);
+			ieee80211_frag_cache_invalidate(ieee, hdr);
+			goto rx_dropped;
+		}
+
+		if (frag == 0) {
+			/* copy first fragment (including full headers) into
+			 * beginning of the fragment cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data, flen);
+		} else {
+			/* append frame payload to the end of the fragment
+			 * cache skb */
+			memcpy(skb_put(frag_skb, flen), skb->data + hdrlen,
+			       flen);
+		}
+		dev_kfree_skb(skb);
+		skb = NULL;
+
+		if (fc & WLAN_FC_MOREFRAG) {
+			/* more fragments expected - leave the skb in fragment
+			 * cache for now; it will be delivered to upper layers
+			 * after all fragments have been received */
+			goto rx_exit;
+		}
+
+		/* this was the last fragment and the frame will be
+		 * delivered, so remove skb from fragment cache */
+		skb = frag_skb;
+		hdr = (struct ieee80211_hdr *) skb->data;
+		ieee80211_frag_cache_invalidate(ieee, hdr);
+	}
+
+	/* skb: hdr + (possible reassembled) full plaintext payload */
+
+	payload = skb->data + hdrlen;
+	ethertype = (payload[6] << 8) | payload[7];
+
+#ifdef NOT_YET
+	/* If IEEE 802.1X is used, check whether the port is authorized to send
+	 * the received frame. */
+	if (ieee->ieee_802_1x && ieee->iw_mode == IW_MODE_MASTER) {
+		if (ethertype == ETH_P_PAE) {
+			printk(KERN_DEBUG "%s: RX: IEEE 802.1X frame\n",
+			       dev->name);
+			if (ieee->hostapd && ieee->apdev) {
+				/* Send IEEE 802.1X frames to the user
+				 * space daemon for processing */
+				prism2_rx_80211(ieee->apdev, skb, rx_stats,
+						PRISM2_RX_MGMT);
+				ieee->apdevstats.rx_packets++;
+				ieee->apdevstats.rx_bytes += skb->len;
+				goto rx_exit;
+			}
+		} else if (!frame_authorized) {
+			printk(KERN_DEBUG "%s: dropped frame from "
+			       "unauthorized port (IEEE 802.1X): "
+			       "ethertype=0x%04x\n",
+			       dev->name, ethertype);
+			goto rx_dropped;
+		}
+	}
+#endif
+
+	/* convert hdr + possible LLC headers into Ethernet header */
+	if (skb->len - hdrlen >= 8 &&
+	    ((memcmp(payload, rfc1042_header, 6) == 0 &&
+	      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||
+	     memcmp(payload, bridge_tunnel_header, 6) == 0)) {
+		/* remove RFC1042 or Bridge-Tunnel encapsulation and
+		 * replace EtherType */
+		skb_pull(skb, hdrlen + 6);
+		memcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);
+		memcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);
+	} else {
+		u16 len;
+		/* Leave Ethernet header part of hdr and full payload */
+		skb_pull(skb, hdrlen);
+		len = htons(skb->len);
+		memcpy(skb_push(skb, 2), &len, 2);
+		memcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);
+		memcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);
+	}
+
+	if (wds && ((fc & (WLAN_FC_TODS | WLAN_FC_FROMDS)) == WLAN_FC_TODS) &&
+	    skb->len >= ETH_HLEN + ETH_ALEN) {
+		/* Non-standard frame: get addr4 from its bogus location after
+		 * the payload */
+		memcpy(skb->data + ETH_ALEN,
+		       skb->data + skb->len - ETH_ALEN, ETH_ALEN);
+		skb_trim(skb, skb->len - ETH_ALEN);
+	}
+
+	stats->rx_packets++;
+	stats->rx_bytes += skb->len;
+
+#ifdef NOT_YET
+	if (ieee->iw_mode == IW_MODE_MASTER && !wds &&
+	    ieee->ap->bridge_packets) {
+		if (dst[0] & 0x01) {
+			/* copy multicast frame both to the higher layers and
+			 * to the wireless media */
+			ieee->ap->bridged_multicast++;
+			skb2 = skb_clone(skb, GFP_ATOMIC);
+			if (skb2 == NULL)
+				printk(KERN_DEBUG "%s: skb_clone failed for "
+				       "multicast frame\n", dev->name);
+		} else if (hostap_is_sta_assoc(ieee->ap, dst)) {
+			/* send frame directly to the associated STA using
+			 * wireless media and not passing to higher layers */
+			ieee->ap->bridged_unicast++;
+			skb2 = skb;
+			skb = NULL;
+		}
+	}
+#endif
+
+	if (skb2 != NULL) {
+		/* send to wireless media */
+		skb2->protocol = __constant_htons(ETH_P_802_3);
+		skb2->mac.raw = skb2->nh.raw = skb2->data;
+		/* skb2->nh.raw = skb2->data + ETH_HLEN; */
+		skb2->dev = dev;
+		dev_queue_xmit(skb2);
+	}
+
+	if (skb) {
+		skb->protocol = eth_type_trans(skb, dev);
+		memset(skb->cb, 0, sizeof(skb->cb));
+		skb->dev = dev;
+		netif_rx(skb);
+	}
+
+ rx_exit:
+	return 1;
+
+ rx_dropped:
+	/* dev_kfree_skb(skb); */
+
+	stats->rx_dropped++;
+
+	/* Returning 0 indicates to caller that we have not handled the SKB--
+	 * so it is still allocated and can be used again by underlying
+	 * hardware as a DMA target */
+	return 0;
+}
+
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211_wx.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211_wx.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/ieee80211_wx.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ieee80211_wx.c	2004-05-22 09:13:01.863980692 -0500
@@ -0,0 +1,215 @@
+/*******************************************************************************
+  
+  Copyright(c) 2004 Intel Corporation. All rights reserved.
+
+  Portions of this file are based on the WEP enablement code provided by the
+  Host AP project hostap-drivers v0.1.3
+  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+  <jkmaline@cc.hut.fi>
+  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#include <linux/wireless.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/kmod.h> /* request_module */
+#endif
+
+#include "ieee80211.h"
+
+static void ieee80211_crypt_delayed_deinit(struct ieee80211_device *ieee,
+					   struct ieee80211_crypt_data **crypt)
+{
+	struct ieee80211_crypt_data *tmp;
+	unsigned long flags;
+
+	if (*crypt == NULL)
+		return;
+	
+	tmp = *crypt;
+	*crypt = NULL;
+
+	/* must not run ops->deinit() while there may be pending encrypt or
+	 * decrypt operations. Use a list of delayed deinits to avoid needing
+	 * locking. */
+
+	spin_lock_irqsave(&ieee->lock, flags);
+	list_add(&tmp->list, &ieee->crypt_deinit_list);
+	if (!timer_pending(&ieee->crypt_deinit_timer)) {
+		ieee->crypt_deinit_timer.expires = jiffies + HZ;
+		add_timer(&ieee->crypt_deinit_timer);
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+}
+
+
+int ieee80211_wx_set_encode(struct ieee80211_device *ieee,
+			   struct iw_request_info *info, 
+			   union iwreq_data *wrqu, char *key)
+{
+	struct net_device *dev = ieee->dev;
+	struct iw_point *erq = &(wrqu->encoding);
+	int first = 0;
+	int i;
+
+	if (erq->flags & IW_ENCODE_DISABLED) {
+		ieee80211_crypt_delayed_deinit(ieee, &ieee->crypt);
+		goto done;
+	}
+	
+	if (ieee->crypt != NULL && ieee->crypt->ops != NULL &&
+	    strcmp(ieee->crypt->ops->name, "WEP") != 0) {
+		/* changing to use WEP; deinit previously used algorithm */
+		ieee80211_crypt_delayed_deinit(ieee, &ieee->crypt);
+	}
+	
+	if (ieee->crypt == NULL) {
+		struct ieee80211_crypt_data *new_crypt;
+		
+		/* take WEP into use */
+		new_crypt = (struct ieee80211_crypt_data *)
+			kmalloc(sizeof(struct ieee80211_crypt_data), 
+				GFP_KERNEL);
+		if (new_crypt == NULL)
+			return -ENOMEM;
+		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
+		new_crypt->ops = hostap_get_crypto_ops("WEP");
+		if (!new_crypt->ops) {
+			request_module("hostap_crypt_wep");
+			new_crypt->ops = hostap_get_crypto_ops("WEP");
+		}
+		if (new_crypt->ops)
+			new_crypt->priv = new_crypt->ops->init();
+		if (!new_crypt->ops || !new_crypt->priv) {
+			kfree(new_crypt);
+			new_crypt = NULL;
+
+			printk(KERN_WARNING "%s: could not initialize WEP: "
+			       "load module hostap_crypt_wep.o\n",
+			       dev->name);
+			return -EOPNOTSUPP;
+		}
+		first = 1;
+		ieee->crypt = new_crypt;
+	}
+
+	i = erq->flags & IW_ENCODE_INDEX;
+	if (i < 1 || i > 4)
+		i = ieee->crypt->ops->get_key_idx(ieee->crypt->priv);
+	else
+		i--;
+	if (i < 0 || i >= WEP_KEYS)
+		return -EINVAL;
+
+	if (erq->length > 0) {
+		int len = erq->length <= 5 ? 5 : 13;
+		printk(KERN_INFO "%s: Setting key %d to %c%c%c%c%c\n",
+		       ieee->dev->name, i, key[0], key[1], key[2], key[3],
+		       key[4]);
+		if (len > erq->length)
+			memset(key + erq->length, 0, len - erq->length);
+		ieee->crypt->ops->set_key(i, key, len, ieee->crypt->priv);
+		if (first) {
+			printk(KERN_INFO "%s: Setting index to %d\n",
+			       ieee->dev->name, i);
+			ieee->crypt->ops->set_key_idx(i, ieee->crypt->priv);
+		}
+	} else {
+		if (ieee->crypt->ops->set_key_idx(i, ieee->crypt->priv) < 0)
+			return -EINVAL; /* keyidx not valid */
+	}
+
+ done:
+	ieee->open_wep = erq->flags & IW_ENCODE_OPEN;
+
+	if (ieee80211_set_encryption(ieee)) {
+		printk(KERN_DEBUG "%s: set_encryption failed\n", dev->name);
+		return -EINVAL;
+	}
+
+	/* Do not reset port if card is in Managed mode since resetting will
+	 * generate new IEEE 802.11 authentication which may end up in looping
+	 * with IEEE 802.1X.  If your hardware requires a reset after WEP
+	 * configuration (for example... Prism2), implement the reset_port in 
+	 * the callbacks structures used to initialize the 802.11 stack. */
+	if (ieee->reset_on_keychange &&
+	    ieee->iw_mode != IW_MODE_INFRA && 
+	    ieee->func->reset_port &&
+	    ieee->func->reset_port(dev)) {
+		printk(KERN_DEBUG "%s: reset_port failed\n", dev->name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int ieee80211_wx_get_encode(struct ieee80211_device *ieee,
+			   struct iw_request_info *info, 
+			   union iwreq_data *wrqu, char *key)
+{
+	struct iw_point *erq = &(wrqu->encoding);
+	int i, len;
+
+	if (ieee->crypt == NULL || ieee->crypt->ops == NULL) {
+		erq->length = 0;
+		erq->flags = IW_ENCODE_DISABLED;
+		return 0;
+	}
+
+	if (strcmp(ieee->crypt->ops->name, "WEP") != 0) {
+		/* only WEP is supported with wireless extensions, so just
+		 * report that encryption is used */
+		erq->length = 0;
+		erq->flags = IW_ENCODE_ENABLED;
+		return 0;
+	}
+
+	i = erq->flags & IW_ENCODE_INDEX;
+	if (i < 1 || i > 4)
+		i = ieee->crypt->ops->get_key_idx(ieee->crypt->priv);
+	else
+		i--;
+	if (i < 0 || i >= WEP_KEYS)
+		return -EINVAL;
+
+	erq->flags = i + 1;
+
+	len = ieee->crypt->ops->get_key(i, key, WEP_KEY_LEN,
+					ieee->crypt->priv);
+	erq->length = (len >= 0 ? len : 0);
+
+	printk(KERN_INFO "%s: Key %d %08X%08X len %d\n", 
+	       ieee->dev->name, i, ((u32*)key)[0], ((u32*)key)[1], len);
+
+	if (ieee->host_encrypt)
+		erq->flags |= IW_ENCODE_ENABLED;
+	else
+		erq->flags |= IW_ENCODE_DISABLED;
+	if (ieee->open_wep)
+		erq->flags |= IW_ENCODE_OPEN;
+	else
+		erq->flags |= IW_ENCODE_RESTRICTED;
+
+	return 0;
+}
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100.h	2004-05-22 09:13:01.901975015 -0500
@@ -0,0 +1,1226 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_H
+#define _IPW2100_H
+
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+#include <linux/socket.h>
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+#include <linux/version.h>
+
+#ifdef CONFIG_IPW2100_WEP
+#include "ieee80211.h"
+#endif /* CONFIG_IPW2100_WEP */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define work_struct tq_struct
+#define schedule_work schedule_task
+#define INIT_WORK INIT_TQUEUE
+#endif
+
+struct ipw2100_priv;
+struct ipw2100_hw_packet;
+
+#include "ipw2100_frag.h"
+
+
+#ifdef CONFIG_IPW2100_DEBUG
+#define IPW2100_DEBUG(level, fmt, args...) \
+do { if (ipw2100_debug_level & level) \
+  printk(KERN_DEBUG "ipw2100: %c %s " fmt, \
+         in_interrupt() ? 'I' : 'U', __FUNCTION__, ## args); } while (0) 
+extern unsigned long ipw2100_debug_level;
+#else
+#define IPW2100_DEBUG(level, fmt, args...) do {} while (0);
+#endif /* CONFIG_IPW2100_DEBUG */
+
+#define IPW2100_DL_UNINIT    0x80000000
+#define IPW2100_DL_NONE      0x00000000
+#define IPW2100_DL_ALL       0x7FFFFFFF
+
+/*
+ * To use the debug system;
+ *
+ * If you are defining a new debug classification, simply add it to the #define
+ * list here in the form of:
+ *
+ * #define IPW2100_DL_xxxx VALUE
+ * 
+ * shifting value to the left one bit from the previous entry.  xxxx should be
+ * the name of the classification (for example, WEP)
+ *
+ * You then need to either add a IPW2100_xxxx_DEBUG() macro definition for your
+ * classification, or use IPW2100_DEBUG(IPW2100_DL_xxxx, ...) whenever you want
+ * to send output to that classification.
+ *
+ * To add your debug level to the list of levels seen when you perform
+ *
+ * % cat /proc/ipw2100/debug_level
+ *
+ * you simply need to add your entry to the ipw2100_debug_levels array.
+ *
+ * If you do not see debug_level in /proc/ipw2100 then you do not have 
+ * CONFIG_IPW2100_DEBUG defined in your kernel configuration
+ *
+ */
+
+#define IPW2100_DL_ERROR         0x00000001
+#define IPW2100_DL_WARNING       0x00000002
+#define IPW2100_DL_INFO          0x00000004
+#define IPW2100_DL_WIRELESS_EXT  0x00000008
+#define IPW2100_DL_ISR           0x00000010
+#define IPW2100_DL_SCAN          0x00000020
+#define IPW2100_DL_STATUS        0x00000040
+#define IPW2100_DL_TRACE         0x00000080
+#define IPW2100_DL_RX            0x00000100
+#define IPW2100_DL_TX            0x00000200
+#define IPW2100_DL_MANAGE        0x00000400
+#define IPW2100_DL_WEP           0x00000800
+#define IPW2100_DL_FW_COMMAND    0x00001000
+#define IPW2100_DL_FRAG          0x00002000
+#define IPW2100_DL_FW            0x00004000
+#define IPW2100_DL_RF_KILL       0x00008000
+#define IPW2100_DL_IO		 0x00010000
+
+#ifdef CONFIG_IPW2100_DEBUG 
+#ifdef IPW2100_MAIN
+struct ipw2100_dl {
+	const char *name;
+	unsigned long value;
+};
+#define IPW2100_DL(v) { .name = #v, .value = v }
+
+const struct ipw2100_dl ipw2100_debug_levels[] = {
+	IPW2100_DL(IPW2100_DL_ERROR),
+	IPW2100_DL(IPW2100_DL_WARNING),
+	IPW2100_DL(IPW2100_DL_INFO),
+	IPW2100_DL(IPW2100_DL_WIRELESS_EXT),
+	IPW2100_DL(IPW2100_DL_ISR),
+	IPW2100_DL(IPW2100_DL_SCAN),
+	IPW2100_DL(IPW2100_DL_STATUS),
+	IPW2100_DL(IPW2100_DL_TRACE),
+	IPW2100_DL(IPW2100_DL_RX),
+	IPW2100_DL(IPW2100_DL_TX),
+	IPW2100_DL(IPW2100_DL_MANAGE),
+	IPW2100_DL(IPW2100_DL_WEP),
+	IPW2100_DL(IPW2100_DL_FW_COMMAND),
+	IPW2100_DL(IPW2100_DL_FRAG),
+	IPW2100_DL(IPW2100_DL_FW),
+	IPW2100_DL(IPW2100_DL_RF_KILL),
+	IPW2100_DL(IPW2100_DL_IO),
+};
+#endif
+#endif
+
+#define IPW2100_DEBUG_ERROR(f, a...)   IPW2100_DEBUG(IPW2100_DL_ERROR, f, ## a)
+#define IPW2100_DEBUG_WARNING(f, a...) IPW2100_DEBUG(IPW2100_DL_WARNING, f, ## a)
+#define IPW2100_DEBUG_INFO(f, a...)    IPW2100_DEBUG(IPW2100_DL_INFO, f, ## a)
+
+
+#define IPW2100_DEBUG_WX(f, a...)     IPW2100_DEBUG(IPW2100_DL_WIRELESS_EXT, f, ## a)
+#define IPW2100_DEBUG_SCAN(f, a...)   IPW2100_DEBUG(IPW2100_DL_SCAN, f, ## a)
+#define IPW2100_DEBUG_STATUS(f, a...) IPW2100_DEBUG(IPW2100_DL_STATUS, f, ## a)
+#define IPW2100_DEBUG_TRACE(f, a...)  IPW2100_DEBUG(IPW2100_DL_TRACE, f, ## a)
+#define IPW2100_DEBUG_RX(f, a...)     IPW2100_DEBUG(IPW2100_DL_RX, f, ## a)
+#define IPW2100_DEBUG_TX(f, a...)     IPW2100_DEBUG(IPW2100_DL_TX, f, ## a)
+#define IPW2100_DEBUG_ISR(f, a...)    IPW2100_DEBUG(IPW2100_DL_ISR, f, ## a)
+#define IPW2100_DEBUG_MANAGEMENT(f, a...) IPW2100_DEBUG(IPW2100_DL_MANAGE, f, ## a)
+#define IPW2100_DEBUG_WEP(f, a...)    IPW2100_DEBUG(IPW2100_DL_WEP, f, ## a)
+#define IPW2100_DEBUG_FW_COMMAND(f, a...) IPW2100_DEBUG(IPW2100_DL_FW_COMMAND, f, ## a)
+#define IPW2100_DEBUG_FRAG(f, a...) IPW2100_DEBUG(IPW2100_DL_FRAG, f, ## a)
+#define IPW2100_DEBUG_FW(f, a...) IPW2100_DEBUG(IPW2100_DL_FW, f, ## a)
+#define IPW2100_DEBUG_RF_KILL(f, a...) IPW2100_DEBUG(IPW2100_DL_RF_KILL, f, ## a)
+#define IPW2100_DEBUG_IO(f, a...) IPW2100_DEBUG(IPW2100_DL_IO, f, ## a)
+
+
+#define VERIFY(f) \
+{ \
+  int status = 0; \
+  status = f; \
+  if(status) \
+     return status; \
+}
+
+enum {
+	STATE_DISABLED = 1,
+	STATE_ENABLED = 0
+};
+
+struct ssid_context {
+	char ssid[IW_ESSID_MAX_SIZE + 1];
+	unsigned char bssid[ETH_ALEN];
+	int port_type;
+	int channel;
+
+};
+
+extern const char *port_type_str[];
+extern const char *band_str[];
+
+#define NUMBER_OF_BD_PER_COMMAND_PACKET		1
+#define NUMBER_OF_BD_PER_DATA_PACKET		2
+
+#define NUMBER_OF_OVERHEAD_BDS_PER_PACKETR	2
+#define NUMBER_OF_BDS_TO_LEAVE_FOR_COMMANDS	1
+
+#define REQUIRED_SPACE_IN_RING_FOR_COMMAND_PACKET \
+    (IPW_BD_QUEUE_W_R_MIN_SPARE + NUMBER_OF_BD_PER_COMMAND_PACKET)
+
+struct bd_status {
+	union {
+		struct { u8 nlf:1, txType:2, intEnabled:1, reserved:4; };
+		u8 field;
+	};
+} __attribute__ ((packed));
+
+#define	IPW_BUFDESC_LAST_FRAG 0
+
+struct ipw2100_bd {
+	u32 host_addr;
+	u32 buf_length;
+	struct bd_status status;
+        /* number of fragments for frame (should be set only for 
+	 * 1st TBD) */
+	u8 num_fragments;	
+	u8 reserved[6];
+} __attribute__ ((packed));
+
+#define IPW_BD_QUEUE_LENGTH(n) (1<<n)
+#define IPW_BD_ALIGNMENT(L)    (L*sizeof(struct ipw2100_bd))
+
+#define IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT	0x01
+#define IPW_BD_STATUS_TX_FRAME_COMMAND		0x02
+#define IPW_BD_STATUS_TX_FRAME_802_11	        0x04
+#define IPW_BD_STATUS_TX_INTERRUPT_ENABLE	        0x08
+#define IPW_BD_STATUS_TX_FRAME_802_3              0x00
+
+struct ipw2100_bd_queue {
+	/* driver (virtual) pointer to queue */
+	struct ipw2100_bd *drv;
+
+	/* firmware (physical) pointer to queue */
+	dma_addr_t nic;
+
+	/* Length of phy memory allocated for BDs */
+	u32 size;
+
+	/* Number of BDs in queue (and in array) */
+	u32 entries;
+
+	/* Number of available BDs (invalid for NIC BDs) */
+	u32 available;
+
+	/* Offset of oldest used BD in array (next one to 
+	 * check for completion) */
+	u32 oldest;
+
+	/* Offset of next available (unused) BD */
+	u32 next;
+};
+
+#define STATUS_TYPE_MASK	0x0000000f
+#define COMMAND_STATUS_VAL	0
+#define STATUS_CHANGE_VAL	1
+#define P80211_DATA_VAL 	2
+#define P8023_DATA_VAL		3
+#define HOST_NOTIFICATION_VAL	4
+
+#define IPW2100_RSSI_TO_DBM (-98)
+
+struct ipw2100_status {
+	u32 frame_size;
+	u16 status_fields;
+	u8 flags;
+#define IPW_STATUS_FLAG_DECRYPTED	(1)
+#define IPW_STATUS_FLAG_WEP_ENCRYPTED	(1<<1)
+	u8 rssi;
+} __attribute__ ((packed));
+
+struct ipw2100_status_queue {
+	/* driver (virtual) pointer to queue */
+	struct ipw2100_status *drv;
+
+	/* firmware (physical) pointer to queue */
+	dma_addr_t nic;
+
+	/* Length of phy memory allocated for BDs */
+	u32 size;
+};
+
+enum {
+	BSS = 1,
+	IBSS,
+	MONITOR
+};
+
+/**
+ * @struct _tx_cmd - HWCommand
+ * @brief H/W command structure.
+ */
+#define HOST_COMMAND_PARAMS_REG_LEN				100
+#define CMD_STATUS_PARAMS_REG_LEN 			3
+
+struct ipw2100_cmd_header {
+	u32 host_command_reg;
+	u32 host_command_reg1;
+	u32 sequence;
+	u32 host_command_len_reg;
+	u32 host_command_params_reg[HOST_COMMAND_PARAMS_REG_LEN];
+	u32 cmd_status_reg;
+	u32 cmd_status_params_reg[CMD_STATUS_PARAMS_REG_LEN];
+	u32 rxq_base_ptr;
+	u32 rxq_next_ptr;
+	u32 rxq_host_ptr;
+	u32 txq_base_ptr;
+	u32 txq_next_ptr;
+	u32 txq_host_ptr;
+	u32 tx_status_reg;
+	u32 reserved;
+	u32 status_change_reg;
+	u32 reserved1[3];
+	u32 *ordinal1_ptr;
+	u32 *ordinal2_ptr;
+} __attribute__ ((packed));
+
+struct ipw2100_data_header {
+	u32 host_command_reg;	
+	u32 host_command_reg1;
+	u8 encrypted;	// BOOLEAN in win! TRUE if frame is enc by driver
+	u8 needs_encryption;	// BOOLEAN in win! TRUE if frma need to be enc in NIC
+	u8 wep_index;		// 0 no key, 1-4 key index, 0xff immediate key
+	u8 key_size;	// 0 no imm key, 0x5 64bit encr, 0xd 128bit encr, 0x10 128bit encr and 128bit IV
+	u8 key[16];
+	u8 reserved[10];	// f/w reserved
+	u8 src_addr[ETH_ALEN];
+	u8 dst_addr[ETH_ALEN];
+	u16 fragment_size;
+} __attribute__ ((packed));
+
+// Host command data structure
+struct host_command {
+	u32 host_command;		// COMMAND ID
+	u32 host_command1;		// COMMAND ID
+	u32 host_command_sequence;	// UNIQUE COMMAND NUMBER (ID)
+	u32 host_command_length;	// LENGTH
+	u32 host_command_parameters[HOST_COMMAND_PARAMS_REG_LEN];	// COMMAND PARAMETERS
+} __attribute__ ((packed));
+
+
+typedef enum {
+	POWER_ON_RESET,
+	EXIT_POWER_DOWN_RESET,
+	SW_RESET,
+	EEPROM_RW,
+	SW_RE_INIT
+} ipw2100_reset_event;
+
+enum {
+	COMMAND = 0xCAFE,
+	DATA,
+	RX
+};
+
+struct ipw2100_hw_packet {
+	int type;
+	int index;
+	union {
+		struct { /* COMMAND */
+			struct ipw2100_cmd_header* cmd;
+			dma_addr_t cmd_phys;
+		};
+		struct { /* DATA */
+			struct ipw2100_data_header* data;
+			dma_addr_t data_phys;
+			dma_addr_t skb_phys;
+		};
+
+		struct { /* RX */
+			struct ipw2100_rx_packet *rxp;
+			dma_addr_t dma_addr;
+		};
+	};
+	struct sk_buff *skb;
+	int jiffy_start;
+
+	struct list_head list;
+};
+
+#define DEFAULT_RTS_THRESHOLD     2304U
+#define DEFAULT_BEACON_INTERVAL   100U
+#define	DEFAULT_SHORT_RETRY_LIMIT 7U
+#define	DEFAULT_LONG_RETRY_LIMIT  4U
+
+struct ipw2100_ordinals {
+	u32 table1_addr;
+	u32 table2_addr;
+	u32 table1_size;
+	u32 table2_size;
+};
+
+/* Host Notification header */
+struct ipw2100_notification {
+	u32 hnhdr_subtype;	/* type of host notification */
+	u32 hnhdr_size;		/* size in bytes of data 
+				   or number of entries, if table.
+				   Does NOT include header */
+} __attribute__ ((packed));
+
+
+/* SWEEP TABLE ENTRIES NUBMER*/
+#define MAX_SWEEP_TAB_ENTRIES		  42
+#define MAX_SWEEP_TAB_ENTRIES_PER_PACKET  7
+#define MAX_RATES_LENGTH                  ((u8)8)
+#define MAX_BEACON_COUNT                  128
+
+#define SSID_LENGTH                       ((u8)32)
+#define CRC_LENGTH                 4U
+
+#define SSID_CAPABILITY_BSS        0x0001  // Communicating in BSS Mode (Bit 0)
+#define SSID_CAPABILITY_IBSS       0x0002  // Communicating in IBSS Mode (Bit 1)
+#define SSID_CAPABILITY_POWER      0x0004  // Supports PS Mode (Bit 3)
+#define SSID_CAPABILITY_ENCRYPT    0x0010  // Requires Encryption (Bit 4)
+#define PREAMBLE_CAPABILITY_SHORT  0x0020  // Uses Short Preamble (Bit 5)
+
+#define SSID_11B_RATE_1MB          0x0001
+#define SSID_11B_RATE_2MB          0x0002
+#define SSID_11B_RATE_5MB          0x0004
+#define SSID_11B_RATE_11MB         0x0008
+#define SSID_11B_RATE_22MB         0x0010
+
+#ifndef CONFIG_IPW2100_WEP
+/* Structure used by de-fragmantation*/
+#define MAX_DEFRAG_RX        5
+
+struct defrag_info {
+	u32 seq_num;
+	u16 num_of_frags;
+	u16 free_space;
+	struct sk_buff *skb;
+	struct timer_list defrag_timer;
+	struct ipw2100_priv *priv;
+	u8 valid;
+	struct list_head list;
+};
+#endif
+
+struct ipw2100_beacon;
+
+#define MAX_KEY_SIZE	16
+#define	MAX_KEYS	8
+
+#define IPW2100_WEP_DROP_CLEAR (1<<1)
+#define IPW2100_WEP_ENABLE     (1)
+
+#define NONE_CIPHER   0x00000001
+#define WEP40_CIPHER  0x00000002
+#define WEP104_CIPHER 0x00000020
+#define	AUTH_OPEN     1
+#define	AUTH_SHARED   2
+
+struct ipw2100_priv {
+#ifdef CONFIG_IPW2100_WEP
+	struct ieee80211_device ieee;
+#endif /* CONFIG_IPW2100_WEP */
+	int reset_pending; /* 1 if a reset has been scheduled or is running */
+	int open;
+	int stopped;
+	int disabled;
+	int phy_off;
+	int connected;
+	int been_powered; /* 1 if HW has been powered */
+	int fatal_error;
+	int rf_kill;
+	int eeprom_version;
+	int firmware_version;
+	int irq_enabled; /* 1 when IRQ on 0 when off */
+	unsigned long hw_features;
+	int resets;
+	int hangs;
+	u32 last_rtc;
+
+	struct timer_list hang_check_timer;
+	int stop_hang_check; /* Set 1 when shutting down to kill timer */
+	struct timer_list rf_switch_timer;
+	int stop_rf_check; /* Set 1 when shutting down to kill timer */
+ 
+	/* WEP data */
+	int authentication; /* AUTH_{OPEN,SHARED} */
+	int key_on;
+	int key_open;
+	int key_size[MAX_KEYS];
+	char key_table[MAX_KEYS][MAX_KEY_SIZE];
+	int key_current;
+
+	int message_sending;
+	int messages_sent;
+	
+
+	int short_retry_limit;
+	int long_retry_limit;
+
+	int rts_threshold;
+	u32 frag_threshold;
+	u8 frag_enabled;
+	int in_isr;
+
+	int tx_power;
+	u32 beacon_interval;
+	int port_type;
+
+	char nick[IW_ESSID_MAX_SIZE + 1];
+
+	struct ssid_context *ctx;
+	struct ssid_context active_ctx;
+	struct ssid_context backup_ctx;
+
+	struct ipw2100_status_queue status_queue;
+
+	struct ipw2100_bd_queue rx_queue;
+	struct ipw2100_bd_queue tx_queue;
+	struct ipw2100_hw_packet *rx_buffers;
+
+	struct list_head beacon_free_list;
+	struct list_head beacon_list;
+	struct ipw2100_beacon *beacons;
+
+	struct list_head fw_pend_list;
+
+	struct list_head msg_free_list;
+	struct list_head msg_pend_list;
+	struct ipw2100_hw_packet *msg_buffers;
+
+	struct list_head tx_free_list;
+	struct list_head tx_pend_list;
+	struct ipw2100_hw_packet *tx_buffers;
+
+	struct ipw2100_ordinals ordinals;
+
+	struct pci_dev *pdev;
+
+	struct proc_dir_entry *dir_dev;
+
+	struct net_device *ndev;
+	struct net_device_stats stats;
+	struct iw_statistics wstats;
+
+	struct tasklet_struct irq_tasklet;
+
+	struct work_struct reset_work;
+	struct work_struct tx_work;
+	
+#ifndef CONFIG_IPW2100_WEP
+	struct defrag_info *defrag_pool;
+	struct list_head defrag_list;
+	struct list_head defrag_free_list;
+	u32 num_of_defrag_rx;	
+	unsigned long defrag_timeout;
+#endif
+
+	u32 interrupts;
+	int tx_interrupts;
+	int rx_interrupts;
+	
+
+	u32 proc_cardmemaddr;
+
+	spinlock_t low_lock;
+
+	wait_queue_head_t wait_command_queue;
+#ifdef CONFIG_PM
+	u32 pm_state[16];
+#endif
+};
+
+/*********************************************************
+ * Host Command -> From Driver to FW
+ *********************************************************/
+
+/**
+ * Host command identifiers
+ */
+#define HOST_COMPLETE           2
+#define SYSTEM_CONFIG           6
+#define SSID                    8
+#define MANDATORY_BSSID         9
+#define AUTHENTICATION_TYPE    10
+#define ADAPTER_ADDRESS        11
+#define PORT_TYPE              12
+#define INTERNATIONAL_MODE     13
+#define CHANNEL                14
+#define RTS_THRESHOLD          15
+#define FRAG_THRESHOLD         16
+#define POWER_MODE             17
+#define TX_RATES               18
+#define BASIC_TX_RATES         19
+#define WEP_KEY_INFO           20
+#define WEP_KEY_INDEX          25
+#define WEP_FLAGS              26
+#define ADD_MULTICAST          27
+#define CLEAR_ALL_MULTICAST    28
+#define BEACON_INTERVAL        29
+#define ATIM_WINDOW            30
+#define CLEAR_STATISTICS       31
+#define SEND		       33
+#define TX_POWER_INDEX         36
+#define BROADCAST_SCAN         43
+#define CARD_DISABLE           44
+#define PREFERRED_BSSID        45
+#define SET_SCAN_OPTIONS       46
+#define SCAN_DWELL_TIME        47
+#define SWEEP_TABLE            48
+#define AP_OR_STATION_TABLE    49
+#define GROUP_ORDINALS         50
+#define SHORT_RETRY_LIMIT      51
+#define LONG_RETRY_LIMIT       52
+
+#define HOST_PRE_POWER_DOWN    58
+#define CARD_DISABLE_PHY_OFF   61
+#define MSDU_TX_RATES          62
+
+
+// Rogue AP Detection 
+#define SET_STATION_STAT_BITS      64
+#define CLEAR_STATIONS_STAT_BITS   65
+#define LEAP_ROGUE_MODE            66	//TODO tbw replaced by CFG_LEAP_ROGUE_AP
+#define SET_SECURITY_INFORMATION   67
+#define DISASSOCIATION_BSSID	   68
+#define SET_WPA_ASS_IE             69
+
+
+
+// system configuration bit mask:
+//#define CFG_ANTENNA_SETTING           0x03
+//#define CFG_ANTENNA_A                 0x01
+//#define CFG_ANTENNA_B                 0x02
+#define CFG_PROMISCUOUS         0x00004
+//#define CFG_TX_STATUS_ENABLE    0x00008
+#define CFG_PREAMBLE_LEN        0x00010
+#define CFG_IBSS_AUTO_START     0x00020
+//#define CFG_KERBEROS_ENABLE     0x00040
+#define CFG_LOOPBACK            0x00100
+//#define CFG_WNMP_PING_PASS      0x00200
+//#define CFG_DEBUG_ENABLE        0x00400
+#define CFG_ANSWER_BCSSID_PROBE 0x00800
+//#define CFG_BT_PRIORITY         0x01000
+#define CFG_BT_SIDEBAND_SIGNAL	0x02000
+#define CFG_802_1x_ENABLE       0x04000
+#define CFG_BSS_MASK		0x08000
+#define CFG_IBSS_MASK		0x10000
+//#define CFG_DYNAMIC_CW          0x10000 
+
+
+
+#define IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND			0x200
+#define IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND  	IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0D80
+
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x00)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x04)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x08)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0c)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x10)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x14)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_BD_BASE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x18)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_BD_SIZE          (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x1c)
+#define IPW_MEM_HOST_SHARED_RX_BD_BASE                  (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x40)
+#define IPW_MEM_HOST_SHARED_RX_STATUS_BASE              (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x44)
+#define IPW_MEM_HOST_SHARED_RX_BD_SIZE                  (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x48)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x80)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x84)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x88)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_READ_INDEX       (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x8c)
+#define IPW_MEM_HOST_SHARED_RX_READ_INDEX               (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0xa0)
+
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_BD_BASE(QueueNum) \
+    (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + (QueueNum<<3))
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_BD_SIZE(QueueNum) \
+    (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0004+(QueueNum<<3))
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(QueueNum) \
+    (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x0080+(QueueNum<<2))
+
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_0_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x00)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_1_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x04)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_2_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x08)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_3_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x0c)
+#define IPW_MEM_HOST_SHARED_RX_WRITE_INDEX \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x20)
+#define IPW_MEM_HOST_SHARED_SLAVE_MODE_INT_REGISTER \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + 0x78)
+#define IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(QueueNum) \
+    (IPW_MEM_SRAM_HOST_INTERRUPT_AREA_LOWER_BOUND + (QueueNum<<2))
+
+#define IPW_MEM_HOST_SHARED_ORDINALS_TABLE_1   (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x180)
+#define IPW_MEM_HOST_SHARED_ORDINALS_TABLE_2   (IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND + 0x184)
+
+#define IPW2100_INTA_TX_TRANSFER               (0x00000001)	// Bit 0 (LSB)
+#define IPW2100_INTA_RX_TRANSFER               (0x00000002)	// Bit 1
+#define IPW2100_INTA_TX_COMPLETE	       (0x00000004)	// Bit 2
+#define IPW2100_INTA_EVENT_INTERRUPT           (0x00000008)     // Bit 3 
+#define IPW2100_INTA_STATUS_CHANGE             (0x00000010)	// Bit 4
+#define IPW2100_INTA_BEACON_PERIOD_EXPIRED     (0x00000020)	// Bit 5
+#define IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE  (0x00010000)	// Bit 16
+#define IPW2100_INTA_FW_INIT_DONE              (0x01000000)	// Bit 24
+#define IPW2100_INTA_FW_CALIBRATION_CALC       (0x02000000)	// Bit 25
+#define IPW2100_INTA_FATAL_ERROR               (0x40000000)	// Bit 30
+#define IPW2100_INTA_PARITY_ERROR              (0x80000000)	// Bit 31 (MSB)
+
+#define IPW_AUX_HOST_RESET_REG_PRINCETON_RESET              (0x00000001)	// Bit 0 (LSB)
+#define IPW_AUX_HOST_RESET_REG_FORCE_NMI                    (0x00000002)	// Bit 1
+#define IPW_AUX_HOST_RESET_REG_PCI_HOST_CLUSTER_FATAL_NMI   (0x00000004)	// Bit 2
+#define IPW_AUX_HOST_RESET_REG_CORE_FATAL_NMI               (0x00000008)	// Bit 3
+#define IPW_AUX_HOST_RESET_REG_SW_RESET                     (0x00000080)	// Bit 7
+#define IPW_AUX_HOST_RESET_REG_MASTER_DISABLED              (0x00000100)	// Bit 8
+#define IPW_AUX_HOST_RESET_REG_STOP_MASTER                  (0x00000200)	// Bit 9
+
+#define IPW_AUX_HOST_GP_CNTRL_BIT_CLOCK_READY           (0x00000001)	// Bit 0 (LSB)
+#define IPW_AUX_HOST_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY   (0x00000002)	// Bit 1
+#define IPW_AUX_HOST_GP_CNTRL_BIT_INIT_DONE             (0x00000004)	// Bit 2
+#define IPW_AUX_HOST_GP_CNTRL_BITS_SYS_CONFIG           (0x000007c0)	// Bits 6-10
+#define IPW_AUX_HOST_GP_CNTRL_BIT_BUS_TYPE              (0x00000200)	// Bit 9
+#define IPW_AUX_HOST_GP_CNTRL_BIT_BAR0_BLOCK_SIZE       (0x00000400)	// Bit 10
+#define IPW_AUX_HOST_GP_CNTRL_BIT_USB_MODE              (0x20000000)	// Bit 29
+#define IPW_AUX_HOST_GP_CNTRL_BIT_HOST_FORCES_SYS_CLK   (0x40000000)	// Bit 30
+#define IPW_AUX_HOST_GP_CNTRL_BIT_FW_FORCES_SYS_CLK     (0x80000000)	// Bit 31 (MSB)
+
+#define IPW_BIT_GPIO_GPIO1_MASK         0x0000000C
+#define IPW_BIT_GPIO_GPIO3_MASK         0x000000C0
+#define IPW_BIT_GPIO_GPIO1_ENABLE       0x00000008
+#define IPW_BIT_GPIO_RF_KILL            0x00010000
+
+#define IPW_BIT_GPIO_LED_OFF            0x00002000	// Bit 13 = 1
+
+#define IPW_REG_DOMAIN_0_OFFSET 	0x0000
+#define IPW_REG_DOMAIN_1_OFFSET 	IPW_MEM_SRAM_HOST_SHARED_LOWER_BOUND
+
+#define IPW_REG_INTA			IPW_REG_DOMAIN_0_OFFSET + 0x0008
+#define IPW_REG_INTA_MASK		IPW_REG_DOMAIN_0_OFFSET + 0x000C
+#define IPW_REG_INDIRECT_ACCESS_ADDRESS	IPW_REG_DOMAIN_0_OFFSET + 0x0010
+#define IPW_REG_INDIRECT_ACCESS_DATA	IPW_REG_DOMAIN_0_OFFSET + 0x0014
+#define IPW_REG_AUTOINCREMENT_ADDRESS	IPW_REG_DOMAIN_0_OFFSET + 0x0018
+#define IPW_REG_AUTOINCREMENT_DATA	IPW_REG_DOMAIN_0_OFFSET + 0x001C
+#define IPW_REG_RESET_REG		IPW_REG_DOMAIN_0_OFFSET + 0x0020
+#define IPW_REG_GP_CNTRL		IPW_REG_DOMAIN_0_OFFSET + 0x0024
+#define IPW_REG_GPIO			IPW_REG_DOMAIN_0_OFFSET + 0x0030
+#define IPW_REG_FW_TYPE                 IPW_REG_DOMAIN_1_OFFSET + 0x0188
+#define IPW_REG_FW_VERSION 		IPW_REG_DOMAIN_1_OFFSET + 0x018C
+#define IPW_REG_FW_COMPATABILITY_VERSION IPW_REG_DOMAIN_1_OFFSET + 0x0190
+
+#define IPW_REG_INDIRECT_ADDR_MASK	0x00FFFFFC
+
+#define IPW_INTERRUPT_MASK		0xC1010013
+
+#define IPW2100_CONTROL_REG             0x220000
+#define IPW2100_CONTROL_PHY_OFF         0x8
+
+#define IPW2100_COMMAND			0x00300004
+#define IPW2100_COMMAND_PHY_ON		0x0
+#define IPW2100_COMMAND_PHY_OFF		0x1
+
+/* in DEBUG_AREA, values of memory always 0xd55555d5 */
+#define IPW_REG_DOA_DEBUG_AREA_START    IPW_REG_DOMAIN_0_OFFSET + 0x0090
+#define IPW_REG_DOA_DEBUG_AREA_END      IPW_REG_DOMAIN_0_OFFSET + 0x00FF
+#define IPW_DATA_DOA_DEBUG_VALUE        0xd55555d5
+
+#define IPW_INTERNAL_REGISTER_HALT_AND_RESET	0x003000e0
+
+#define IPW_WAIT_CLOCK_STABILIZATION_DELAY	    50	// micro seconds
+#define IPW_WAIT_RESET_ARC_COMPLETE_DELAY	    10	// micro seconds
+#define IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY 10	// micro seconds
+
+// BD ring queue read/write difference
+#define IPW_BD_QUEUE_W_R_MIN_SPARE 2	
+
+#define IPW_CACHE_LINE_LENGTH_DEFAULT		    0x80
+
+#define IPW_CARD_DISABLE_COMPLETE_WAIT		    100	// 100 milli
+#define IPW_CARD_DISABLE_PHY_OFF_COMPLETE_WAIT	    100	// 100 milli
+#define IPW_PREPARE_POWER_DOWN_COMPLETE_WAIT	    100	// 100 milli
+
+
+#define MANAGMENT_802_11_PACKET_TYPE		     0
+#define CONTROL_802_11_PACKET_TYPE		     1
+#define DATA_802_11_PACKET_TYPE			     2
+
+#define ASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE   1
+#define REASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE 3
+#define PROBE_RESPONSE_802_11_PACKET_SUBTYPE         5
+#define BEACON_802_11_PACKET_SUBTYPE		     8
+
+#define IPW_HEADER_802_11_SIZE			\
+        sizeof(struct ipw2100_802_11_header)
+#define IPW_MAX_802_11_PAYLOAD_LENGTH		2312
+#define IPW_MAX_ACCEPTABLE_TX_FRAME_LENGTH	1536
+#define IPW_MIN_ACCEPTABLE_RX_FRAME_LENGTH	60
+#define IPW_MAX_ACCEPTABLE_RX_FRAME_LENGTH \
+	(IPW_MAX_ACCEPTABLE_TX_FRAME_LENGTH + IPW_HEADER_802_11_SIZE - \
+        sizeof(struct ethhdr))
+
+#define IPW_RX_NIC_BUFFER_LENGTH \
+        (IPW_MAX_802_11_PAYLOAD_LENGTH + IPW_HEADER_802_11_SIZE)
+
+#define IPW_802_11_PAYLOAD_OFFSET \
+        (sizeof(struct ipw2100_802_11_header) + \
+         sizeof(struct ieee_802_11_snap_header))
+
+struct ipw2100_802_11_header {
+	union {
+		struct {
+			u8 version:2, type:2, sub_type:4;
+		};
+		u8 ctrl1;
+	};
+	union {
+		struct {
+			u8 to_ds:1, from_ds:1, flags:1, retry:1,
+			    power_mgt:1, more_data:1, wep:1, order:1;
+		};
+		u8 ctrl2;
+	};
+	u16 duration;
+	u8 address1[ETH_ALEN];
+	u8 address2[ETH_ALEN];
+	u8 address3[ETH_ALEN];
+	u16 seq_ctrl;
+} __attribute__ ((packed));
+
+#define BEACON_PROBE_SSID_ID_POSITION 12
+
+/* Management Frame Information Element Types */
+#define MFIE_TYPE_SSID       0
+#define MFIE_TYPE_RATES      1
+#define MFIE_TYPE_FH_SET     2
+#define MFIE_TYPE_DS_SET     3
+#define MFIE_TYPE_CF_SET     4
+#define MFIE_TYPE_TIM        5
+#define MFIE_TYPE_IBSS_SET   6
+#define MFIE_TYPE_CHALLENGE  16
+
+struct ipw2100_802_11_info_element_hdr {
+	u8 id;
+	u8 len;
+} __attribute__ ((packed));
+
+struct ipw2100_802_11_info_element {
+	u8 id;
+	u8 len;
+	u8 data[1];
+} __attribute__ ((packed));
+
+/*
+ * These are the data types that can make up management packets
+ *
+	u16 auth_algorithm;
+	u16 auth_sequence;
+	u16 beacon_interval;
+	u16 capability;
+	u8 current_ap[ETH_ALEN];
+	u16 listen_interval;
+	struct {
+		u16 association_id:14, reserved:2;
+	} __attribute__ ((packed));
+	u32 time_stamp[2];
+	u16 reason;
+	u16 status;
+*/
+
+struct ipw2100_802_11_authentication {
+	struct ipw2100_802_11_header header;
+	u16 algorithm;
+	u16 transaction;
+	u16 status;
+	struct ipw2100_802_11_info_element info_element;
+} __attribute__ ((packed));
+
+
+struct ipw2100_802_11_probe_response {
+	struct ipw2100_802_11_header header;
+	u32 time_stamp[2];
+	u16 beacon_interval;
+	u16 capability;
+	struct ipw2100_802_11_info_element info_element;
+} __attribute__ ((packed));
+
+struct ipw2100_beacon {
+	u8 bssid[ETH_ALEN];
+	u8 ssid[SSID_LENGTH];
+	u8 ssid_len;
+/*	u8 beacon[IPW_MAX_802_11_PAYLOAD_LENGTH];
+	u32 beacon_len;
+	u8 response[IPW_MAX_802_11_PAYLOAD_LENGTH];
+	u32 response_len;*/
+	s8 rssi;
+	u16 capability;
+	u8 channel;
+	u8 rates[MAX_RATES_LENGTH];
+	u8 rates_len;
+	struct list_head list;
+};
+
+struct ipw2100_rx_packet {
+	union {
+		unsigned char payload[IPW_RX_NIC_BUFFER_LENGTH];
+		struct ipw2100_802_11_header header;
+		u32 status;
+		struct ipw2100_notification notification;
+		struct ipw2100_cmd_header command;
+	};
+} __attribute__ ((packed));
+
+// Bit 0-7 are for 802.11b tx rates - .  Bit 5-7 are reserved  
+#define TX_RATE_1_MBIT              0x0001
+#define TX_RATE_2_MBIT              0x0002
+#define TX_RATE_5_5_MBIT            0x0004
+#define TX_RATE_11_MBIT             0x0008
+#define TX_RATE_MASK                0x000F
+
+#define IPW_POWER_MODE_CAM           0	//(always on)
+#define IPW_POWER_INDEX_1            1
+#define IPW_POWER_INDEX_2            2
+#define IPW_POWER_INDEX_3            3
+#define IPW_POWER_INDEX_4            4
+#define IPW_POWER_INDEX_5            5
+#define IPW_POWER_AUTOMATIC          6
+
+#define FW_SCAN_DONOT_ASSOCIATE     0x0001 // Dont Attempt to Associate after Scan
+#define FW_SCAN_PASSIVE             0x0008 // Force PASSSIVE Scan
+
+#define REG_MIN_CHANNEL             0
+#define REG_MAX_CHANNEL             14
+
+#define REG_CHANNEL_MASK            0x00003FFF
+
+#define DIVERSITY_EITHER            0	// Use both antennas
+#define DIVERSITY_ANTENNA_A         1	// Use antenna A
+#define DIVERSITY_ANTENNA_B         2	// Use antenna B
+
+
+#define HOST_COMMAND_WAIT 0
+#define HOST_COMMAND_NO_WAIT 1
+
+#define LOCK_NONE 0
+#define LOCK_DRIVER 1
+#define LOCK_FW 2
+
+#define STATUS_INIT_COMPLETE		0x0001
+#define STATUS_COUNTRY_FOUND		0x0002
+#define STATUS_ASSOCIATED		0x0004
+#define STATUS_ASSN_LOST		0x0008
+#define STATUS_ASSN_CHANGED 		0x0010
+#define STATUS_SCAN_COMPLETE		0x0020
+#define STATUS_ENTERED_PSP		0x0040
+#define STATUS_WAKEN_FROM_PSP		0x0080
+#define STATUS_RF_KILL_SWITCH		0x0100
+#define STATUS_CARD_DISABLE_COMPLETE	0x0200
+#define STATUS_PREP_PWR_DOWN_COMPLETE	0x0400
+#define STATUS_SCANNING 		0x0800	// STATUS_FW_SCAN_KEEP_ALIVE
+
+#define TYPE_SWEEP_ORD                  0x000D
+#define TYPE_IBSS_STTN_ORD              0x000E
+#define TYPE_BSS_AP_ORD                 0x000F
+#define TYPE_RAW_BEACON_ENTRY           0x0010
+#define TYPE_CALIBRATION_DATA           0x0011
+#define TYPE_ROGUE_AP_DATA              0x0012
+#define TYPE_ASSOCIATION_REQUEST	0x0013
+#define TYPE_REASSOCIATION_REQUEST	0x0014
+
+
+#define HW_FEATURE_RFKILL (0x0001)
+#define RF_KILLSWITCH_OFF (1)
+#define RF_KILLSWITCH_ON  (0)
+
+#define IPW_COMMAND_POOL_SIZE        40
+
+#define IPW_START_ORD_TAB_1			1
+#define IPW_START_ORD_TAB_2			1000
+
+#define IPW_ORD_TAB_1_ENTRY_SIZE		sizeof(u32)
+
+#define IS_ORDINAL_TABLE_ONE(mgr,id) \
+    ((id >= IPW_START_ORD_TAB_1) && (id < mgr->table1_size))
+#define IS_ORDINAL_TABLE_TWO(mgr,id) \
+    ((id >= IPW_START_ORD_TAB_2) && (id < (mgr->table2_size + IPW_START_ORD_TAB_2)))
+
+#define BSS_ID_LENGTH               6
+
+// Fixed size data: Ordinal Table 1
+typedef enum _ORDINAL_TABLE_1 {	// NS - means Not Supported by FW
+// Transmit statistics
+	IPW_ORD_STAT_TX_HOST_REQUESTS = 1,// # of requested Host Tx's (MSDU)
+	IPW_ORD_STAT_TX_HOST_COMPLETE,	// # of successful Host Tx's (MSDU)
+	IPW_ORD_STAT_TX_DIR_DATA,	// # of successful Directed Tx's (MSDU)
+
+	IPW_ORD_STAT_TX_DIR_DATA1 = 4,	// # of successful Directed Tx's (MSDU) @ 1MB
+	IPW_ORD_STAT_TX_DIR_DATA2,	// # of successful Directed Tx's (MSDU) @ 2MB
+	IPW_ORD_STAT_TX_DIR_DATA5_5,	// # of successful Directed Tx's (MSDU) @ 5_5MB
+	IPW_ORD_STAT_TX_DIR_DATA11,	// # of successful Directed Tx's (MSDU) @ 11MB
+	IPW_ORD_STAT_TX_DIR_DATA22,	// # of successful Directed Tx's (MSDU) @ 22MB
+
+	IPW_ORD_STAT_TX_NODIR_DATA1 = 13,// # of successful Non_Directed Tx's (MSDU) @ 1MB
+	IPW_ORD_STAT_TX_NODIR_DATA2,	// # of successful Non_Directed Tx's (MSDU) @ 2MB
+	IPW_ORD_STAT_TX_NODIR_DATA5_5,	// # of successful Non_Directed Tx's (MSDU) @ 5.5MB
+	IPW_ORD_STAT_TX_NODIR_DATA11,	// # of successful Non_Directed Tx's (MSDU) @ 11MB
+
+	IPW_ORD_STAT_NULL_DATA = 21,	// # of successful NULL data Tx's
+	IPW_ORD_STAT_TX_RTS,	        // # of successful Tx RTS
+	IPW_ORD_STAT_TX_CTS,	        // # of successful Tx CTS            
+	IPW_ORD_STAT_TX_ACK,	        // # of successful Tx ACK
+	IPW_ORD_STAT_TX_ASSN,	        // # of successful Association Tx's               
+	IPW_ORD_STAT_TX_ASSN_RESP,	// # of successful Association response Tx's   
+	IPW_ORD_STAT_TX_REASSN,	        // # of successful Reassociation Tx's           
+	IPW_ORD_STAT_TX_REASSN_RESP,	// # of successful Reassociation response Tx's                
+	IPW_ORD_STAT_TX_PROBE,	        // # of probes successfully transmitted 
+	IPW_ORD_STAT_TX_PROBE_RESP,	// # of probe responses successfully transmitted                
+	IPW_ORD_STAT_TX_BEACON,	        // # of tx beacon             
+	IPW_ORD_STAT_TX_ATIM,	        // # of Tx ATIM            
+	IPW_ORD_STAT_TX_DISASSN,	// # of successful Disassociation TX           
+	IPW_ORD_STAT_TX_AUTH,	        // # of successful Authentication Tx                 
+	IPW_ORD_STAT_TX_DEAUTH,	        // # of successful Deauthentication TX                
+
+	IPW_ORD_STAT_TX_TOTAL_BYTES = 41,// Total successful Tx data bytes
+	IPW_ORD_STAT_TX_RETRIES,         // # of Tx retries
+	IPW_ORD_STAT_TX_RETRY1,          // # of Tx retries at 1MBPS
+	IPW_ORD_STAT_TX_RETRY2,          // # of Tx retries at 2MBPS
+	IPW_ORD_STAT_TX_RETRY5_5,	 // # of Tx retries at 5.5MBPS
+	IPW_ORD_STAT_TX_RETRY11,	 // # of Tx retries at 11MBPS
+
+	IPW_ORD_STAT_TX_FAILURES = 51,	// # of Tx Failures
+	IPW_ORD_STAT_TX_ABORT_AT_HOP,	//NS // # of Tx's aborted at hop time
+	IPW_ORD_STAT_TX_MAX_TRIES_IN_HOP,// # of times max tries in a hop failed
+	IPW_ORD_STAT_TX_ABORT_LATE_DMA,	//NS // # of times tx aborted due to late dma setup
+	IPW_ORD_STAT_TX_ABORT_STX,	//NS // # of times backoff aborted
+	IPW_ORD_STAT_TX_DISASSN_FAIL,	// # of times disassociation failed
+	IPW_ORD_STAT_TX_ERR_CTS,         // # of missed/bad CTS frames
+	IPW_ORD_STAT_TX_BPDU,	        //NS // # of spanning tree BPDUs sent
+	IPW_ORD_STAT_TX_ERR_ACK,	// # of tx err due to acks
+
+	// Receive statistics
+	IPW_ORD_STAT_RX_HOST = 61,	// # of packets passed to host
+	IPW_ORD_STAT_RX_DIR_DATA,	// # of directed packets                
+	IPW_ORD_STAT_RX_DIR_DATA1,	// # of directed packets at 1MB            
+	IPW_ORD_STAT_RX_DIR_DATA2,	// # of directed packets at 2MB           
+	IPW_ORD_STAT_RX_DIR_DATA5_5,	// # of directed packets at 5.5MB            
+	IPW_ORD_STAT_RX_DIR_DATA11,	// # of directed packets at 11MB            
+	IPW_ORD_STAT_RX_DIR_DATA22,	// # of directed packets at 22MB            
+
+	IPW_ORD_STAT_RX_NODIR_DATA = 71,// # of nondirected packets        
+	IPW_ORD_STAT_RX_NODIR_DATA1,	// # of nondirected packets at 1MB            
+	IPW_ORD_STAT_RX_NODIR_DATA2,	// # of nondirected packets at 2MB           
+	IPW_ORD_STAT_RX_NODIR_DATA5_5,	// # of nondirected packets at 5.5MB            
+	IPW_ORD_STAT_RX_NODIR_DATA11,	// # of nondirected packets at 11MB            
+
+	IPW_ORD_STAT_RX_NULL_DATA = 80,	// # of null data rx's            
+	IPW_ORD_STAT_RX_POLL,	//NS // # of poll rx                    
+	IPW_ORD_STAT_RX_RTS,	// # of Rx RTS                
+	IPW_ORD_STAT_RX_CTS,	// # of Rx CTS                
+	IPW_ORD_STAT_RX_ACK,	// # of Rx ACK                
+	IPW_ORD_STAT_RX_CFEND,	// # of Rx CF End                
+	IPW_ORD_STAT_RX_CFEND_ACK,	// # of Rx CF End + CF Ack             
+	IPW_ORD_STAT_RX_ASSN,	// # of Association Rx's                    
+	IPW_ORD_STAT_RX_ASSN_RESP,	// # of Association response Rx's            
+	IPW_ORD_STAT_RX_REASSN,	// # of Reassociation Rx's            
+	IPW_ORD_STAT_RX_REASSN_RESP,	// # of Reassociation response Rx's            
+	IPW_ORD_STAT_RX_PROBE,	// # of probe Rx's                
+	IPW_ORD_STAT_RX_PROBE_RESP,	// # of probe response Rx's            
+	IPW_ORD_STAT_RX_BEACON,	// # of Rx beacon            
+	IPW_ORD_STAT_RX_ATIM,	// # of Rx ATIM                    
+	IPW_ORD_STAT_RX_DISASSN,	// # of disassociation Rx            
+	IPW_ORD_STAT_RX_AUTH,	// # of authentication Rx                    
+	IPW_ORD_STAT_RX_DEAUTH,	// # of deauthentication Rx            
+
+	IPW_ORD_STAT_RX_TOTAL_BYTES = 101,// Total rx data bytes received
+	IPW_ORD_STAT_RX_ERR_CRC,	 // # of packets with Rx CRC error
+	IPW_ORD_STAT_RX_ERR_CRC1,	 // # of Rx CRC errors at 1MB
+	IPW_ORD_STAT_RX_ERR_CRC2,	 // # of Rx CRC errors at 2MB
+	IPW_ORD_STAT_RX_ERR_CRC5_5,	 // # of Rx CRC errors at 5.5MB
+	IPW_ORD_STAT_RX_ERR_CRC11,	 // # of Rx CRC errors at 11MB
+
+	IPW_ORD_STAT_RX_DUPLICATE1 = 112, // # of duplicate rx packets at 1MB
+	IPW_ORD_STAT_RX_DUPLICATE2,	 // # of duplicate rx packets at 2MB
+	IPW_ORD_STAT_RX_DUPLICATE5_5,	 // # of duplicate rx packets at 5.5MB
+	IPW_ORD_STAT_RX_DUPLICATE11,	 // # of duplicate rx packets at 11MB
+	IPW_ORD_STAT_RX_DUPLICATE = 119, // # of duplicate rx packets            
+
+	IPW_ORD_PERS_DB_LOCK = 120,	// # locking fw permanent  db
+	IPW_ORD_PERS_DB_SIZE,	// # size of fw permanent  db           
+	IPW_ORD_PERS_DB_ADDR,	// # address of fw permanent  db           
+	IPW_ORD_STAT_RX_INVALID_PROTOCOL,	// # of rx frames with invalid protocol        
+	IPW_ORD_SYS_BOOT_TIME,	// # Boot time 
+	IPW_ORD_STAT_RX_NO_BUFFER,	// # of rx frames rejected due to no buffer 
+	IPW_ORD_STAT_RX_ABORT_LATE_DMA,	//NS // # of rx frames rejected due to dma setup too late    
+	IPW_ORD_STAT_RX_ABORT_AT_HOP,	//NS // # of rx frames aborted due to hop            
+	IPW_ORD_STAT_RX_MISSING_FRAG,	// # of rx frames dropped due to missing fragment            
+	IPW_ORD_STAT_RX_ORPHAN_FRAG,	// # of rx frames dropped due to non-sequential fragment        
+	IPW_ORD_STAT_RX_ORPHAN_FRAME,	// # of rx frames dropped due to unmatched 1st frame            
+	IPW_ORD_STAT_RX_FRAG_AGEOUT,	// # of rx frames dropped due to uncompleted frame        
+	IPW_ORD_STAT_RX_BAD_SSID,	//NS // Bad SSID (unused)            
+	IPW_ORD_STAT_RX_ICV_ERRORS,	// # of ICV errors during decryption        
+
+// PSP Statistics
+	IPW_ORD_STAT_PSP_SUSPENSION = 137,// # of times adapter suspended        
+	IPW_ORD_STAT_PSP_BCN_TIMEOUT,	// # of beacon timeout           
+	IPW_ORD_STAT_PSP_POLL_TIMEOUT,	// # of poll response timeouts       
+	IPW_ORD_STAT_PSP_NONDIR_TIMEOUT,// # of timeouts waiting for last broadcast/muticast pkt
+	IPW_ORD_STAT_PSP_RX_DTIMS,	// # of PSP DTIMs received
+	IPW_ORD_STAT_PSP_RX_TIMS,	// # of PSP TIMs received
+	IPW_ORD_STAT_PSP_STATION_ID,	// PSP Station ID
+
+// Association and roaming
+	IPW_ORD_LAST_ASSN_TIME = 147,	// RTC time of last association               
+	IPW_ORD_STAT_PERCENT_MISSED_BCNS,// current calculation of % missed beacons       
+	IPW_ORD_STAT_PERCENT_RETRIES,	// current calculation of % missed tx retries            
+	IPW_ORD_ASSOCIATED_AP_PTR,	// If associated, this is ptr to the associated
+	// AP table entry. set to 0 if not associated
+	IPW_ORD_AVAILABLE_AP_CNT,	// # of AP's decsribed in the AP table
+	IPW_ORD_AP_LIST_PTR,	// Ptr to list of available APs
+	IPW_ORD_STAT_AP_ASSNS,	// # of associations       
+	IPW_ORD_STAT_ASSN_FAIL,	// # of association failures       
+	IPW_ORD_STAT_ASSN_RESP_FAIL,	// # of failuresdue to response fail       
+	IPW_ORD_STAT_FULL_SCANS,	// # of full scans
+
+	IPW_ORD_CARD_DISABLED,	// # Card Disabled 
+	IPW_ORD_STAT_ROAM_INHIBIT,	// # of times roaming was inhibited due to ongoing activity       
+	IPW_FILLER_40,
+	IPW_ORD_RSSI_AT_ASSN = 160,	// RSSI of associated AP at time of association           
+	IPW_ORD_STAT_ASSN_CAUSE1,	// # of reassociations due to no tx from AP in last N
+	// hops or no probe responses in last 3 minutes           
+	IPW_ORD_STAT_ASSN_CAUSE2,	// # of reassociations due to poor tx/rx quality            
+	IPW_ORD_STAT_ASSN_CAUSE3,	// # of reassociations due to tx/rx quality with excessive 
+	// load at the AP        
+	IPW_ORD_STAT_ASSN_CAUSE4,	// # of reassociations due to AP RSSI level fell below
+	// eligible group             
+	IPW_ORD_STAT_ASSN_CAUSE5,	// # of reassociations due to load leveling            
+	IPW_ORD_STAT_ASSN_CAUSE6,	//NS // # of reassociations due to dropped by Ap            
+	IPW_FILLER_41,
+	IPW_FILLER_42,
+	IPW_FILLER_43,
+	IPW_ORD_STAT_AUTH_FAIL,	// # of times authentication failed        
+	IPW_ORD_STAT_AUTH_RESP_FAIL,	// # of times authentication response failed       
+	IPW_ORD_STATION_TABLE_CNT,	// # of entries in association table        
+
+// Other statistics
+	IPW_ORD_RSSI_AVG_CURR = 173,	// Current avg RSSI
+	IPW_ORD_STEST_RESULTS_CURR,	//NS // Current self test results word       
+	IPW_ORD_STEST_RESULTS_CUM,	//NS // Cummulative self test results word       
+	IPW_ORD_SELF_TEST_STATUS,	//NS //        
+	IPW_ORD_POWER_MGMT_MODE,	// Power mode - 0=CAM, 1=PSP       
+	IPW_ORD_POWER_MGMT_INDEX,	//NS //            
+	IPW_ORD_COUNTRY_CODE,	// IEEE country code as recv'd from beacon
+	IPW_ORD_COUNTRY_CHANNELS,	// channels suported by country           
+// IPW_ORD_COUNTRY_CHANNELS:
+// For 11b the lower 2-byte are used for channels from 1-14 
+//   and the higher 2-byte are not used.
+	IPW_ORD_RESET_CNT,	// # of adapter resets (warm)       
+	IPW_ORD_BEACON_INTERVAL,	// Beacon interval       
+
+	IPW_ORD_PRINCETON_VERSION = 184,	//NS // Princeton Version       
+	IPW_ORD_ANTENNA_DIVERSITY,	// TRUE if antenna diversity is disabled       
+	IPW_ORD_CCA_RSSI,	//NS // CCA RSSI value (factory programmed)           
+	IPW_ORD_STAT_EEPROM_UPDATE,	//NS // # of times config EEPROM updated       
+	IPW_ORD_DTIM_PERIOD,	// # of beacon intervals between DTIMs       
+	IPW_ORD_OUR_FREQ,	// current radio freq lower digits - channel ID
+
+	IPW_ORD_RTC_TIME = 190,	// current RTC time           
+	IPW_ORD_PORT_TYPE,	// operating mode       
+	IPW_ORD_CURRENT_TX_RATE,	// current tx rate
+	IPW_ORD_SUPPORTED_RATES,	// Bitmap of supported tx rates       
+	IPW_ORD_ATIM_WINDOW,	// current ATIM Window
+	IPW_ORD_BASIC_RATES,	// bitmap of basic tx rates       
+	IPW_ORD_NIC_HIGHEST_RATE,	// bitmap of basic tx rates       
+	IPW_ORD_AP_HIGHEST_RATE,	// bitmap of basic tx rates       
+	IPW_ORD_CAPABILITIES,	// Management frame capability field           
+	IPW_ORD_AUTH_TYPE,	// Type of authentication       
+	IPW_ORD_RADIO_TYPE,	// Adapter card platform type       
+	IPW_ORD_RTS_THRESHOLD = 201,	// Min length of packet after which RTS handshaking is used       
+	IPW_ORD_INT_MODE,	// International mode           
+	IPW_ORD_FRAGMENTATION_THRESHOLD,	// protocol frag threshold       
+	IPW_ORD_EEPROM_SRAM_DB_BLOCK_START_ADDRESS,	// EEPROM offset in SRAM
+	IPW_ORD_EEPROM_SRAM_DB_BLOCK_SIZE,	// EEPROM size in SRAM
+	IPW_ORD_EEPROM_SKU_CAPABILITY,	// EEPROM SKU Capability    206 =  
+	IPW_ORD_EEPROM_IBSS_11B_CHANNELS,	// EEPROM IBSS 11b channel set       
+
+	IPW_ORD_MAC_VERSION = 209,	// MAC Version       
+	IPW_ORD_MAC_REVISION,	// MAC Revision       
+	IPW_ORD_RADIO_VERSION,	// Radio Version       
+	IPW_ORD_NIC_MANF_DATE_TIME,	// MANF Date/Time STAMP
+	IPW_ORD_UCODE_VERSION,	// Ucode Version       
+	IPW_ORD_HW_RF_SWITCH_STATE = 214,	// HW RF Kill Switch State       
+} ORDINALTABLE1;
+//ENDOF TABLE1
+
+// ordinal table 2
+// Variable length data:
+#define IPW_FIRST_VARIABLE_LENGTH_ORDINAL   1001
+
+typedef enum _ORDINAL_TABLE_2 {	// NS - means Not Supported by FW
+	IPW_ORD_STAT_BASE = 1000,	// contains number of variable ORDs
+	IPW_ORD_STAT_ADAPTER_MAC = 1001,	// 6 bytes: our adapter MAC address  
+	IPW_ORD_STAT_PREFERRED_BSSID = 1002,	// 6 bytes: BSSID of the preferred AP
+	IPW_ORD_STAT_MANDATORY_BSSID = 1003,	// 6 bytes: BSSID of the mandatory AP
+	IPW_FILL_1,		//NS // 
+	IPW_ORD_STAT_COUNTRY_TEXT = 1005,	// 36 bytes: Country name text, First two bytes are Country code
+	IPW_ORD_STAT_ASSN_SSID = 1006,	// 32 bytes: ESSID String
+	IPW_ORD_STATION_TABLE = 1007,	// ? bytes: Station/AP table (via Direct SSID Scans)
+	IPW_ORD_STAT_SWEEP_TABLE = 1008,	// ? bytes: Sweep/Host Table table (via Broadcast Scans)
+	IPW_ORD_STAT_ROAM_LOG = 1009,	// ? bytes: Roaming log
+	IPW_ORD_STAT_RATE_LOG = 1010,	//NS // 0 bytes: Rate log
+	IPW_ORD_STAT_FIFO = 1011,	//NS // 0 bytes: Fifo buffer data structures
+	IPW_ORD_STAT_FW_VER_NUM = 1012,	// 14 bytes: fw version ID string as in (a.bb.ccc; "0.08.011")
+	IPW_ORD_STAT_FW_DATE = 1013,	// 14 bytes: fw date string (mmm dd yyyy; "Mar 13 2002")
+	IPW_ORD_STAT_ASSN_AP_BSSID = 1014,	// 6 bytes: MAC address of associated AP
+	IPW_ORD_STAT_DEBUG = 1015,	//NS // ? bytes:
+	IPW_ORD_STAT_NIC_BPA_NUM = 1016,	// 11 bytes: NIC BPA number in ASCII
+	IPW_ORD_STAT_UCODE_DATE = 1017,	// 5 bytes: uCode date
+	IPW_ORD_SECURITY_NGOTIATION_RESULT = 1018,
+} ORDINALTABLE2;		// NS - means Not Supported by FW
+
+#define IPW_LAST_VARIABLE_LENGTH_ORDINAL   1018
+
+extern int ipw2100_get_ordinal(struct ipw2100_priv *, u32, void *, u32 *);
+extern int ipw2100_set_channel(struct ipw2100_priv *, u32, int);
+extern int ipw2100_set_port_type(struct ipw2100_priv *, u32, int);
+extern int ipw2100_set_mandatory_bssid(struct ipw2100_priv *, u8 *, int);
+extern int ipw2100_set_essid(struct ipw2100_priv *, char *, int);
+extern int ipw2100_set_rts_threshold(struct ipw2100_priv *, u32);
+extern int ipw2100_set_fragmentation_threshold(struct ipw2100_priv *, u32, int);
+extern int ipw2100_set_short_retry(struct ipw2100_priv *, u32);
+extern int ipw2100_set_long_retry(struct ipw2100_priv *, u32);
+extern int ipw2100_start_scan(struct ipw2100_priv *priv);
+
+#endif	/* _IPW2100_H */
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_frag.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_frag.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_frag.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_frag.c	2004-05-22 09:13:01.903974716 -0500
@@ -0,0 +1,297 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+#include <linux/802_11.h>
+#include "ipw2100.h"
+#include "ipw2100_frag.h"
+
+/* Get the msdu: real payload size. */ 
+inline u32 ipw2100_msdu_frag_threshold(struct ipw2100_priv *priv)
+{
+        return priv->frag_threshold - (ETH_ALEN + CRC_LENGTH);
+}
+
+
+#ifndef CONFIG_IPW2100_WEP
+static void defrag_timeout(unsigned long arg)
+{
+	struct defrag_info *info = (struct defrag_info *)arg;
+	
+	IPW2100_DEBUG_FRAG("Fragmentation timer freeing packet sequence.\n");
+	
+	if (info->skb) {
+		/* Pull this from the live fragment list */
+		list_del(&info->list);
+
+		dev_kfree_skb_irq(info->skb);
+		info->skb = NULL;
+		info->priv->num_of_defrag_rx--;
+		info->free_space = 0;
+
+		/* Add back to the free fragment list */
+		list_add_tail(&info->list, &info->priv->defrag_free_list);
+		
+	}
+}
+
+static struct defrag_info *defrag_alloc_slot(struct ipw2100_priv *priv)
+{
+	struct defrag_info *info;
+
+	if (list_empty(&priv->defrag_free_list))
+		return NULL;
+
+	info = list_entry(priv->defrag_free_list.next, struct defrag_info, list);
+
+	/* Pull from the free fragment list */
+	list_del(priv->defrag_free_list.next);
+
+	/* Add to the live fragment list */
+	list_add_tail(&info->list, &priv->defrag_list);
+	
+	priv->num_of_defrag_rx++;
+
+	return info;
+}
+
+
+static struct defrag_info *defrag_match_info(
+	struct ipw2100_priv *priv, struct ipw2100_802_11_header *hdr, 
+	u32 seq_num, u32 frag_num)
+{
+	struct list_head *element;
+	struct defrag_info *info = NULL;
+
+	for (element = priv->defrag_list.next;
+	     element != &priv->defrag_list;
+	     element = element->next) {
+		info = list_entry(element, struct defrag_info, list);
+		if ((info->seq_num == seq_num) && 
+		    (!memcmp(info->skb->data, hdr->address1, ETH_ALEN)) &&
+		    (!memcmp(info->skb->data + ETH_ALEN, 
+			    hdr->address3, ETH_ALEN)) && 
+		    (info->num_of_frags == frag_num))
+			return info;
+	}
+
+	return NULL;
+}
+
+static void defrag_first(struct ipw2100_priv *priv, struct ipw2100_hw_packet *packet, u32 frame_size, u32 seq_num)
+{
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+	struct defrag_info *info = NULL;
+		
+	IPW2100_DEBUG_FRAG("First fragment, seq_num: %X\n", seq_num);
+	
+	info = defrag_alloc_slot(priv);
+
+	if (info==NULL) {
+		IPW2100_DEBUG_FRAG("No valid slot found for fragmented "
+				 "packet, dropped\n");
+		priv->wstats.discard.fragment++;	
+		dev_kfree_skb_irq(packet->skb);
+		return;
+	}
+	
+	info->skb = packet->skb;
+	
+	skb_put(info->skb, frame_size - IPW_802_11_PAYLOAD_OFFSET);
+	
+	memcpy(skb_push(info->skb, ETH_ALEN), &hdr->address3, ETH_ALEN);
+	memcpy(skb_push(info->skb, ETH_ALEN), &hdr->address1, ETH_ALEN);
+	
+	info->seq_num = seq_num;
+	info->num_of_frags = 1;
+	info->free_space = info->skb->end - info->skb->head;
+	
+	init_timer(&info->defrag_timer);
+	info->defrag_timer.expires = jiffies + priv->defrag_timeout;
+	info->defrag_timer.data = (unsigned long)info;
+	info->defrag_timer.function = defrag_timeout;
+	add_timer(&info->defrag_timer);
+} 
+
+
+static struct sk_buff *defrag_cont(struct ipw2100_priv *priv, 
+				   struct ipw2100_hw_packet *packet, 
+				   u32 frame_size, u32 seq_num, u32 frag_num)
+{
+	struct defrag_info *info = NULL;
+    	u32 length;	
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+	struct sk_buff *skb = NULL;
+	
+	IPW2100_DEBUG_FRAG("Non-first fragment, seq_num: %X frag_num: %X\n",
+			   seq_num, frag_num);
+
+	length = frame_size - IPW_802_11_PAYLOAD_OFFSET + 
+			sizeof(struct ieee_802_11_snap_header);
+
+	info = defrag_match_info(priv, hdr, seq_num, frag_num);
+	
+	if (info != NULL) {
+		IPW2100_DEBUG_FRAG("Found matched defrag_info\n");
+
+		if (info->free_space < length) {
+			printk(KERN_WARNING "ipw2100"
+			       ": AP sending fragment overrun.  Dropping "
+			       "%d frames.\n", info->num_of_frags);
+			priv->wstats.discard.fragment++;	
+
+			/* For consistent cleanup, we just force a timeout
+			 * expiration */
+			del_timer_sync(&info->defrag_timer);
+			defrag_timeout((unsigned long)info);
+
+		} else {
+
+			info->num_of_frags++;
+			mod_timer(&info->defrag_timer, 
+				  jiffies + priv->defrag_timeout);
+			
+			skb_push(packet->skb, 
+				 sizeof(struct ieee_802_11_snap_header));
+			memcpy(skb_put(info->skb, length), packet->skb->data, 
+			       length);
+		
+			if ((*hdr).flags == 0) {
+				
+				IPW2100_DEBUG_FRAG("Last fragment received\n");
+				
+				del_timer_sync(&info->defrag_timer);
+				
+				
+				/* Pull this from the live fragment list */
+				list_del(&info->list);
+
+				skb = info->skb;
+				info->skb = NULL;
+				priv->num_of_defrag_rx--;
+				info->free_space = 0;
+
+				/* Add back to the free fragment list */
+				list_add_tail(&info->list, 
+					      &info->priv->defrag_free_list);
+			}
+		}
+	} else {
+		IPW2100_DEBUG_FRAG("Cannot match this fragment, dropped!\n");
+		priv->wstats.discard.fragment++;	
+	}
+
+	dev_kfree_skb_irq(packet->skb);
+
+	return skb;
+} 
+
+struct sk_buff *ipw2100_defrag_rx(struct ipw2100_priv *priv, 
+				  struct ipw2100_hw_packet *packet, 
+				  u32 frame_size)
+{
+	struct sk_buff *skb = NULL;
+
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+
+	u32 seq_num = SEQUENCE_NUMBER(hdr);
+	u32 frag_num = FRAGMENT_NUMBER(hdr);
+
+	if (frag_num == 0)
+		defrag_first(priv, packet, frame_size, seq_num);
+	else 
+		skb = defrag_cont(priv, packet, frame_size, seq_num, frag_num);
+
+	return skb;
+} 
+
+
+int ipw2100_defrag_alloc(struct ipw2100_priv *priv)
+{
+	priv->defrag_pool = (struct defrag_info *)kmalloc(
+		MAX_DEFRAG_RX * sizeof(struct defrag_info), 
+		GFP_KERNEL);
+	if (!priv->defrag_pool)
+		return -ENOMEM;
+
+	memset(priv->defrag_pool, 0, MAX_DEFRAG_RX * 
+	       sizeof(struct defrag_info));
+
+	return 0;
+}
+
+void ipw2100_defrag_free(struct ipw2100_priv *priv)
+{
+	struct defrag_info *info;
+	struct list_head *element;
+
+	if (!priv->defrag_pool)
+		return;
+
+	for (element = priv->defrag_list.next;
+	     element != &priv->defrag_list;
+	     element = element->next) {
+		info = list_entry(element, struct defrag_info, list);
+		if (info->skb) {
+			del_timer_sync(&info->defrag_timer);
+			dev_kfree_skb(info->skb);
+			info->skb = NULL;
+		}
+		priv->num_of_defrag_rx--;
+		if (priv->num_of_defrag_rx < 0) {
+			IPW2100_DEBUG_FRAG("Bad Rx count!\n");
+			break;
+		}
+	}
+
+	kfree(priv->defrag_pool);
+	priv->defrag_pool = NULL;
+}
+
+void ipw2100_defrag_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	INIT_LIST_HEAD(&priv->defrag_free_list);
+	INIT_LIST_HEAD(&priv->defrag_list);
+
+	priv->num_of_defrag_rx = 0;
+	priv->defrag_timeout = DEFAULT_DEFRAG_TIMEOUT;
+		
+	for(i = 0; i < MAX_DEFRAG_RX; i++) {
+		priv->defrag_pool[i].priv = priv;
+
+		/* Free any stale SKBs */
+		if (priv->defrag_pool[i].skb) {
+			dev_kfree_skb(priv->defrag_pool[i].skb);
+			priv->defrag_pool[i].skb = NULL;
+		}
+
+		list_add_tail(&priv->defrag_pool[i].list, 
+			      &priv->defrag_free_list);
+	}
+}
+#endif
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_frag.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_frag.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_frag.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_frag.h	2004-05-22 09:13:01.904974567 -0500
@@ -0,0 +1,77 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_FRAG_H
+#define _IPW2100_FRAG_H
+
+#define DEFAULT_FRAG_THRESHOLD 2342U
+#define MIN_FRAG_THRESHOLD     256U
+#define	MAX_FRAG_THRESHOLD     2342U
+
+
+#ifndef CONFIG_IPW2100_WEP
+
+#define IS_ESS(priv)     (priv->port_type == BSS)
+#define IS_IBSS(priv)    (priv->port_type == IBSS)
+
+enum {
+        WSE_UNICAST,
+        WSE_MULTICAST,
+        WSE_BROADCAST
+};
+
+#define ETH_IS_BROADCAST(addr)  (addr[0] == 0xff && addr[1] == 0xff     \
+                                 && addr[2] == 0xff && addr[3] == 0xff  \
+                                 && addr[4] == 0xff && addr[5] == 0xff)
+
+#define ETH_IS_MULTICAST(addr)  (addr[0] & 0x01)
+
+#define FRAGMENT_NUMBER_FIELD_MASK				0x000F
+#define SEQUENCE_NUMBER_FIELD_MASK				0xFFF0
+#define SEQUENCE_NUMBER_FIELD_SHIFT				4
+
+#define FRAGMENT_NUMBER(header) ((header->seq_ctrl & \
+        FRAGMENT_NUMBER_FIELD_MASK))
+#define SEQUENCE_NUMBER(header) ((header->seq_ctrl & \
+        SEQUENCE_NUMBER_FIELD_MASK)>>SEQUENCE_NUMBER_FIELD_SHIFT)
+
+#define IS_FRAGMENT(header) (((*header).flags == 1) || \
+                            (FRAGMENT_NUMBER(header) > 0))
+
+#define MAX_DEFRAG_TIMEOUT	0xFFFFFFFF	
+#define MIN_DEFRAG_TIMEOUT	0x1
+#define DEFAULT_DEFRAG_TIMEOUT	0x200
+struct sk_buff *ipw2100_defrag_rx(struct ipw2100_priv *priv, 
+				  struct ipw2100_hw_packet *packet, 
+				  u32 frame_size);
+int ipw2100_defrag_alloc(struct ipw2100_priv *);
+void ipw2100_defrag_free(struct ipw2100_priv *);
+void ipw2100_defrag_initialize(struct ipw2100_priv *priv);
+#endif
+
+u32 ipw2100_msdu_frag_threshold(struct ipw2100_priv *);
+
+#endif
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_fw.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_fw.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_fw.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_fw.c	2004-05-22 09:13:01.907974118 -0500
@@ -0,0 +1,656 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+/*******************************************************************************
+
+  Changes
+
+  0.33 Luc Saillard
+       Added support for using firmware hotplug vs. a custom binary loader.
+
+  Portions of ipw2100_mod_firmware_load, ipw2100_do_mod_firmware_load, and 
+  ipw2100_fw_load are loosely based on drivers/sound/sound_firmware.c 
+  available in the 2.4.25 kernel sources, and are copyright (c) Alan Cox
+
+*******************************************************************************/
+
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#ifndef CONFIG_IPW2100_LEGACY_FW_LOAD
+#include <linux/firmware.h>
+#endif
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#define __KERNEL_SYSCALLS__
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/unistd.h>
+
+#include "ipw2100.h"
+#include "ipw2100_hw.h"
+#include "ipw2100_fw.h"
+
+#define IPW2100_FW_VERSION 1
+
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+/* Module paramter for path to the firmware*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+static char firmware[255] = {[0 ... 254] = 0};
+MODULE_PARM(firmware, "1-254s");
+
+#else /* LINUX_VERSION_CODE < 2.6.0 */
+
+#include <linux/moduleparam.h>
+static char *firmware = NULL;
+module_param(firmware, charp, 0);
+
+#endif /* LINUX_VERSION_CODE < 2.6.0 */
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+
+/*
+
+BINARY FIRMWARE HEADER FORMAT
+
+offset      length   desc
+0           4        version
+4           4        fw_len
+8           4        uc_len
+C           fw_len   firmware data
+12 + fw_len uc_len   microcode data
+
+*/
+
+struct ipw2100_fw_header {
+	int version;
+	unsigned int fw_size;
+	unsigned int uc_size;
+} __attribute__ ((packed));
+
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+/*
+ * 
+ * The following was originally based on the mod_firmware_load in
+ * drivers/sound/sound_firmware.c.  Primary changes revolved around 
+ * making it work for firmware images > 128k and to support having
+ * both a firmware and microcode image in the file loaded.
+ *
+ */
+static void ipw2100_fw_free(struct ipw2100_fw *fw)
+{
+	struct ipw2100_fw_chunk *c;
+	struct list_head *e;
+
+	while (!list_empty(&fw->fw.chunk_list)) {
+		e = fw->fw.chunk_list.next;
+		c = list_entry(e, struct ipw2100_fw_chunk, list);
+		list_del(e);
+		vfree(c->buf);
+		vfree(c);
+	}
+
+	while (!list_empty(&fw->uc.chunk_list)) {
+		e = fw->uc.chunk_list.next;
+		c = list_entry(e, struct ipw2100_fw_chunk, list);
+		list_del(e);
+		vfree(c->buf);
+		vfree(c);
+	}
+}
+
+
+static int ipw2100_fw_load(int fd, struct ipw2100_fw_chunk_set *cs, long size)
+{
+	struct ipw2100_fw_chunk *c;
+	int i = 0;
+	
+	/* Break firmware image into chunks of 128k */
+	cs->size = size;
+	cs->chunks = cs->size >> 17;
+	
+	if (cs->size & 0x1FFFF)
+		cs->chunks++;
+	
+	IPW2100_DEBUG_FW("Loading %ld bytes from %u chunks\n",
+			 cs->size, cs->chunks);
+	
+	/* Load the chunks */
+	while (size > 0) {
+		i++;
+		
+		c = (struct ipw2100_fw_chunk *)vmalloc(
+			sizeof(struct ipw2100_fw_chunk));
+		if (c == NULL) {
+			printk(KERN_INFO "Out of memory loading firmware "
+			       "chunk %d.\n", i);
+			goto fail;
+		}
+		c->pos = 0;
+		
+		if (size >= 0x20000)
+			c->len = 0x20000;
+		else
+			c->len = size;
+		
+		c->buf = (unsigned char *)vmalloc(c->len);
+		if (c->buf == NULL) {
+			printk(KERN_INFO "Out of memory loading firmware "
+			       "chunk %d.\n", i);
+			goto fail;
+			
+		}
+		if (read(fd, c->buf, c->len) != c->len) {
+			printk(KERN_INFO "Failed to read chunk firmware "
+			       "chunk %d.\n", i);
+			goto fail;
+		}
+		
+		list_add_tail(&c->list, &cs->chunk_list);
+		
+		IPW2100_DEBUG_FW("Chunk %d loaded: %lu bytes\n",
+				 i, c->len);
+		size -= c->len;
+	}
+	
+	return 0;
+	
+ fail:
+	return 1;
+}
+
+static int errno;
+static int ipw2100_do_mod_firmware_load(const char *fn, struct ipw2100_fw *fw)
+{
+	int fd;
+	long l;
+	struct ipw2100_fw_header h;
+
+	/* Make sure the lists are init'd so that error paths can safely walk
+        * them to free potentially allocated storage */
+	INIT_LIST_HEAD(&fw->fw.chunk_list);
+	INIT_LIST_HEAD(&fw->uc.chunk_list);
+	
+	fd = open(fn, 0, 0);
+	if (fd == -1) {
+		printk(KERN_INFO "Unable to load '%s'.\n", fn);
+		return 1;
+	}
+	l = lseek(fd, 0L, 2);
+	lseek(fd, 0L, 0);
+	
+	IPW2100_DEBUG_FW("Loading %ld bytes for firmware '%s'\n", l, fn);
+	
+	if (read(fd, (char *)&h, sizeof(h)) != sizeof(h)) {
+		printk(KERN_INFO "Failed to read '%s'.\n", fn);
+		goto fail;
+	}
+	
+	if (h.version != IPW2100_FW_VERSION) {
+		printk(KERN_WARNING "Firmware image not compatible "
+		       "(detected version id of %u). "
+		       "See Documentation/networking/README.ipw2100\n",
+		       h.version);
+		goto fail;
+	}
+	
+	fw->version = h.version;
+
+	if (ipw2100_fw_load(fd, &fw->fw, h.fw_size))
+		goto fail;
+
+	if (ipw2100_fw_load(fd, &fw->uc, h.uc_size))
+		goto fail;
+
+	close(fd);
+	return 0;
+
+ fail:
+	ipw2100_fw_free(fw);
+	close(fd);
+	return 1;
+}
+
+
+static int ipw2100_mod_firmware_load(const char *fn, struct ipw2100_fw *fw)
+{
+	int r;
+	mm_segment_t fs = get_fs();
+	set_fs(get_ds());
+	r = ipw2100_do_mod_firmware_load(fn, fw);
+	set_fs(fs);
+	return r;
+}
+
+static inline struct list_head *ipw2100_fw_read(
+	struct list_head *e, struct ipw2100_fw_chunk_set *cs,
+	unsigned char *data, size_t len)
+{
+	struct ipw2100_fw_chunk *c = list_entry(e, struct ipw2100_fw_chunk, 
+						list);
+	unsigned int avail = c->len - c->pos;
+	if (avail <= len) {
+		struct ipw2100_fw_chunk *tmp;
+
+		memcpy(data, c->buf + c->pos, avail);
+		list_del(e);
+
+		IPW2100_DEBUG_INFO("advancing to next chunk...\n");
+
+		e = cs->chunk_list.next;
+		tmp = list_entry(e, struct ipw2100_fw_chunk, list);
+
+		if (avail != len) {
+			memcpy(data + avail, 
+			       tmp->buf + tmp->pos, 
+			       len - avail);
+			tmp->pos += len - avail;
+		}
+
+		vfree(c->buf);
+		vfree(c);
+
+		return e;
+	} 
+
+	memcpy(data, c->buf + c->pos, len);
+	c->pos += len;
+
+	return e;
+}
+
+static inline struct list_head *ipw2100_fw_readw(
+	struct list_head *e, struct ipw2100_fw_chunk_set *cs, 
+	unsigned short *data)
+{
+	return ipw2100_fw_read(e, cs, (unsigned char *)data, sizeof(*data));
+}
+
+static inline struct list_head *ipw2100_fw_readl(
+	struct list_head *e, struct ipw2100_fw_chunk_set *cs,
+	unsigned int *data)
+{
+	return ipw2100_fw_read(e, cs, (unsigned char *)data, sizeof(*data));
+}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+static int ipw2100_mod_firmware_load(struct ipw2100_fw *fw)
+{
+	struct ipw2100_fw_header *h = 
+		(struct ipw2100_fw_header *)fw->fw_entry->data;
+
+	if (h->version != IPW2100_FW_VERSION) {
+		printk(KERN_WARNING "Firmware image not compatible "
+		       "(detected version id of %u). "
+		       "See Documentation/networking/README.ipw2100\n",
+		       h->version);
+		return 1;
+	}
+
+	fw->version = h->version;
+	fw->fw.data = fw->fw_entry->data + sizeof(struct ipw2100_fw_header);
+	fw->fw.size = h->fw_size;
+	fw->uc.data = fw->fw.data + h->fw_size;
+	fw->uc.size = h->uc_size;
+
+	return 0;
+}
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+
+int ipw2100_get_firmware(struct ipw2100_priv *priv, struct ipw2100_fw *fw)
+{
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	char *fw_name;
+	int err = 0;
+
+	printk(KERN_DEBUG "%s: Using legacy firmware load.\n",
+	       priv->ndev->name);
+
+	if (!firmware || firmware[0] == '\0') 
+		fw_name = "/etc/firmware/ipw2100-1.0.fw";
+	else 
+		fw_name = firmware;
+
+	err = ipw2100_mod_firmware_load(fw_name, fw);
+	if (err) {
+		printk(KERN_ERR "%s: Firmware not available. "
+		       "See Documentation/networking/README.ipw2100\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+	int rc;
+
+	printk(KERN_DEBUG "%s: Using hotplug firmware load.\n",
+	       priv->ndev->name);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	rc = request_firmware(&fw->fw_entry, "ipw2100-1.0.fw",
+			      pci_name(priv->pdev));
+#else
+	rc = request_firmware(&fw->fw_entry, "ipw2100-1.0.fw",
+			      &priv->pdev->dev);
+#endif /* LINUX_VERSION_CODE */
+
+	if (rc < 0) {
+		printk(KERN_ERR
+		       "%s: Firmware not available or load failed\n",
+		       priv->ndev->name);
+		return rc;
+	}
+	IPW2100_DEBUG_INFO("firmware data %p size %d", fw->fw_entry->data,
+			   fw->fw_entry->size);
+
+	ipw2100_mod_firmware_load(fw);
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	return 0;
+}
+
+void ipw2100_release_firmware(struct ipw2100_priv *priv,
+			      struct ipw2100_fw *fw)
+{
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+	ipw2100_fw_free(fw);
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	if (fw->fw_entry)
+		release_firmware(fw->fw_entry);
+	fw->fw_entry = NULL;
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+}
+
+
+int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max)
+{
+	char ver[MAX_FW_VERSION_LEN];
+	u32 len = MAX_FW_VERSION_LEN;
+	u32 tmp;
+	int i;
+	/* firmware version is an ascii string (max len of 14) */
+	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_FW_VER_NUM,
+				ver, &len)) 
+		return -EIO;
+	tmp = max;
+	if (len >= max)
+		len = max - 1;
+	for (i = 0; i < len; i++)
+		buf[i] = ver[i];
+	buf[i] = '\0';
+	return tmp;
+}
+
+int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max)
+{
+	u32 ver;
+	u32 len = sizeof(ver);
+	/* microcode version is a 32 bit integer */
+	if (ipw2100_get_ordinal(priv, IPW_ORD_UCODE_VERSION,
+				&ver, &len))
+		return -EIO;
+	return snprintf(buf, max, "%08X", ver);
+}
+
+/* 
+ * On exit, the firmware will have been freed from the fw list 
+ */
+int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)
+{
+	/* firmware is constructed of N contiguous entries, each entry is
+	 * structured as:
+	 * 
+	 * offset    sie         desc
+	 * 0         4           address to write to
+	 * 4         2           length of data run
+         * 6         length      data
+	 */
+	unsigned int addr;
+	unsigned short len;
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	unsigned char data[32];
+	
+	struct ipw2100_fw_chunk_set *cs = &fw->fw;
+	struct list_head *e = cs->chunk_list.next;
+
+	while (cs->size > 0) {
+		e = ipw2100_fw_readl(e, cs, &addr);
+		cs->size -= sizeof(addr);
+
+		e = ipw2100_fw_readw(e, cs, &len);
+		cs->size -= sizeof(len);
+
+		if (len > 32) {
+			printk(KERN_ERR 
+			       "Invalid firmware run-length of %d bytes\n",
+			       len);
+			return -EINVAL;
+		}
+
+		e = ipw2100_fw_read(e, cs, data, len);
+		cs->size -= len;
+
+		write_nic_memory(priv->ndev, addr, len, data);
+	}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	const unsigned char *firmware_data = fw->fw.data;
+	unsigned int firmware_data_left = fw->fw.size;
+
+	while (firmware_data_left > 0) {
+	   	addr = *(u32 *)(firmware_data);
+		firmware_data      += 4;
+		firmware_data_left -= 4;
+
+	   	len = *(u16 *)(firmware_data);
+		firmware_data      += 2;
+		firmware_data_left -= 2;
+
+		if (len > 32) {
+			printk(KERN_ERR
+			       "Invalid firmware run-length of %d bytes\n",
+			       len);
+			return -EINVAL;
+		}
+
+		write_nic_memory(priv->ndev, addr, len, firmware_data);
+		firmware_data      += len;
+		firmware_data_left -= len;
+	}
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	return 0;
+}
+
+struct symbol_alive_response {
+	u8 cmd_id;
+	u8 seq_num;
+	u8 ucode_rev;
+	u8 eeprom_valid;
+	u16 valid_flags;
+	u8 IEEE_addr[6];
+	u16 flags;
+	u16 pcb_rev;
+	u16 clock_settle_time;	// 1us LSB
+	u16 powerup_settle_time;	// 1us LSB
+	u16 hop_settle_time;	// 1us LSB
+	u8 date[3];		// month, day, year
+	u8 time[2];		// hours, minutes
+	u8 ucode_valid;
+};
+
+int ipw2100_ucode_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)
+{
+	struct net_device *dev = priv->ndev;
+
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+	struct ipw2100_fw_chunk_set *cs = &fw->uc;
+	struct list_head *e = cs->chunk_list.next;
+	unsigned short uc_data;
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	const unsigned char *microcode_data = fw->uc.data;
+	unsigned int microcode_data_left = fw->uc.size;
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	struct symbol_alive_response response;
+	int i, j;
+	u8 data;
+
+	/* Symbol control */
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x703);
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x707);
+
+	/* HW config */
+	write_nic_byte(dev, 0x210014, 0x72);	/* fifo width =16 */
+	write_nic_byte(dev, 0x210014, 0x72);	/* fifo width =16 */
+
+	/* EN_CS_ACCESS bit to reset control store pointer */
+	write_nic_byte(dev, 0x210000, 0x40);
+	write_nic_byte(dev, 0x210000, 0x0);
+	write_nic_byte(dev, 0x210000, 0x40);
+
+	/* copy microcode from buffer into Symbol */
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+
+	while (cs->size > 0) {
+
+		e = ipw2100_fw_readw(e, cs, &uc_data);
+		cs->size -= sizeof(uc_data);
+		write_nic_byte(dev, 0x210010, uc_data & 0xFF);
+		write_nic_byte(dev, 0x210010, (uc_data >> 8) & 0xFF);
+
+	}
+
+#else /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	while (microcode_data_left > 0) {
+
+		write_nic_byte(dev, 0x210010, *microcode_data++);
+		write_nic_byte(dev, 0x210010, *microcode_data++);
+		microcode_data_left -= 2;
+
+	}
+
+#endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
+
+	/* EN_CS_ACCESS bit to reset the control store pointer */
+	write_nic_byte(dev, 0x210000, 0x0);
+
+	/* Enable System (Reg 0)
+	 * first enable causes a garbage in RX FIFO */
+	write_nic_byte(dev, 0x210000, 0x0);
+	write_nic_byte(dev, 0x210000, 0x80);
+
+	/* Reset External Baseband Reg */
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x703);
+	write_nic_word(dev, IPW2100_CONTROL_REG, 0x707);
+
+	/* HW Config (Reg 5) */
+	write_nic_byte(dev, 0x210014, 0x72);	// fifo width =16
+	write_nic_byte(dev, 0x210014, 0x72);	// fifo width =16
+
+	/* Enable System (Reg 0)
+	 * second enable should be OK 
+	 */
+	write_nic_byte(dev, 0x210000, 0x0);	// clear enable system
+	write_nic_byte(dev, 0x210000, 0x80);	// set enable system
+
+	/* check Symbol is enabled - upped this from 5 as it wasn't always
+	 * catching the update */
+	for (i = 0; i < 10; i++) {
+		udelay(10);
+
+		/* check Dino is enabled bit */
+		read_nic_byte(dev, 0x210000, &data);
+		if (data & 0x1)
+			break;
+	}
+
+	if (i == 10) {
+		printk(KERN_ERR "%s: Error initializing Symbol\n",
+		       dev->name);
+		return -EIO;
+	}
+
+	/* Get Symbol alive response */
+	for (i = 0; i < 10; i++) {
+		/* Read alive response structure */
+		for (j = 0; 
+		     j < (sizeof(struct symbol_alive_response) >> 1); 
+		     j++)
+			read_nic_word(dev, 0x210004,
+				      ((u16 *)&response) + j);
+
+		if ((response.cmd_id == 1) &&
+		    (response.ucode_valid == 0x1))
+			break;
+		udelay(10);
+	}
+
+	if (i == 10) {
+		printk(KERN_ERR "%s: No response from Symbol - hw not alive\n",
+		       dev->name);
+		return -EIO;
+	}
+
+	return 0;
+}
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_fw.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_fw.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_fw.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_fw.h	2004-05-22 09:13:01.914973073 -0500
@@ -0,0 +1,83 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_FW_H
+#define _IPW2100_FW_H
+
+#include <linux/netdevice.h>
+
+#define IPW_HOST_FW_SHARED_AREA0 	0x0002f200
+#define IPW_HOST_FW_SHARED_AREA0_END 	0x0002f510	// 0x310 bytes
+
+#define IPW_HOST_FW_SHARED_AREA1 	0x0002f610
+#define IPW_HOST_FW_SHARED_AREA1_END 	0x0002f630	// 0x20 bytes
+
+#define IPW_HOST_FW_SHARED_AREA2 	0x0002fa00
+#define IPW_HOST_FW_SHARED_AREA2_END 	0x0002fa20	// 0x20 bytes
+
+#define IPW_HOST_FW_SHARED_AREA3 	0x0002fc00
+#define IPW_HOST_FW_SHARED_AREA3_END 	0x0002fc10	// 0x10 bytes
+
+#define IPW_HOST_FW_INTERRUPT_AREA 	0x0002ff80
+#define IPW_HOST_FW_INTERRUPT_AREA_END 	0x00030000	// 0x80 bytes
+
+struct ipw2100_fw_chunk {
+	unsigned char *buf;
+	long len;
+	long pos;
+	struct list_head list;
+};
+
+struct ipw2100_fw_chunk_set {
+#ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	struct list_head chunk_list;
+	unsigned int chunks;
+#else
+   	const void *data;
+#endif
+	unsigned long size;
+};
+
+struct ipw2100_fw {
+	int version;
+	struct ipw2100_fw_chunk_set fw;
+	struct ipw2100_fw_chunk_set uc;
+#ifndef CONFIG_IPW2100_LEGACY_FW_LOAD
+	const struct firmware *fw_entry;
+#endif
+};
+
+int ipw2100_get_firmware(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+void ipw2100_release_firmware(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+int ipw2100_ucode_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw);
+
+#define MAX_FW_VERSION_LEN 14
+
+int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max);
+int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max);
+
+#endif	/* _IPW2100_FW_H */
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_hw.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_hw.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_hw.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_hw.h	2004-05-22 09:13:01.922971878 -0500
@@ -0,0 +1,205 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef _IPW2100_HW_H
+#define _IPW2100_HW_H
+
+#include <linux/netdevice.h>
+#include <asm/io.h>
+
+#include "ipw2100.h"
+
+static inline void read_register(struct net_device *dev, u32 reg, u32 *val) 
+{
+	*val = readl(dev->base_addr + reg);
+	IPW2100_DEBUG_IO("r: 0x%08X => 0x%08X\n", reg, *val);
+}
+
+static inline void write_register(struct net_device *dev, u32 reg, u32 val) 
+{
+	writel(val, dev->base_addr + reg);
+	IPW2100_DEBUG_IO("w: 0x%08X <= 0x%08X\n", reg, val);
+}
+
+static inline void read_register_word(struct net_device *dev, u32 reg, u16 *val)
+{
+	*val = readw(dev->base_addr + reg);
+	IPW2100_DEBUG_IO("r: 0x%08X => %04X\n", reg, *val);
+}
+
+static inline void read_register_byte(struct net_device *dev, u32 reg, u8 *val)
+{
+	*val = readb(dev->base_addr + reg);
+	IPW2100_DEBUG_IO("r: 0x%08X => %02X\n", reg, *val);
+}
+
+static inline void write_register_word(struct net_device *dev, u32 reg, u16 val)
+{
+	writew(val, dev->base_addr + reg);
+	IPW2100_DEBUG_IO("w: 0x%08X <= %04X\n", reg, val);
+}
+
+
+static inline void write_register_byte(struct net_device *dev, u32 reg, u8 val)
+{
+	writeb(val, dev->base_addr + reg);
+	IPW2100_DEBUG_IO("w: 0x%08X =< %02X\n", reg, val);
+}
+
+static inline void read_nic_dword(struct net_device *dev, u32 addr, u32 *val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	read_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_dword(struct net_device *dev, u32 addr, u32 val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void read_nic_word(struct net_device *dev, u32 addr, u16 *val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	read_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_word(struct net_device *dev, u32 addr, u16 val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	write_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void read_nic_byte(struct net_device *dev, u32 addr, u8 *val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	read_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_byte(struct net_device *dev, u32 addr, u8 val)
+{
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+	write_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);
+}
+
+static inline void write_nic_auto_inc_address(struct net_device *dev, u32 addr)
+{
+	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,
+		       addr & IPW_REG_INDIRECT_ADDR_MASK);
+}
+
+static inline void write_nic_dword_auto_inc(struct net_device *dev, u32 val)
+{
+	write_register(dev, IPW_REG_AUTOINCREMENT_DATA, val);
+}
+
+static inline void write_nic_memory(struct net_device *dev, u32 addr, u32 len,
+				    const u8 *buf)
+{
+	u32 aligned_addr;
+	u32 aligned_len;
+	u32 dif_len;
+	u32 i;
+
+	/* read first nibble byte by byte */
+	aligned_addr = addr & (~0x3);
+	dif_len = addr - aligned_addr;
+	if (dif_len) {
+		/* Start reading at aligned_addr + dif_len */
+		write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, 
+			       aligned_addr);
+		for (i = dif_len; i < 4; i++, buf++)
+			write_register_byte(
+				dev, IPW_REG_INDIRECT_ACCESS_DATA + i, 
+				*buf);
+		
+		len -= dif_len;
+		aligned_addr += 4;
+	}
+
+	/* read DWs through autoincrement registers */
+	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,
+		       aligned_addr);
+	aligned_len = len & (~0x3);
+	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)
+		write_register(
+			dev, IPW_REG_AUTOINCREMENT_DATA, *(u32 *)buf);
+	
+	/* copy the last nibble */
+	dif_len = len - aligned_len;
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);
+	for (i = 0; i < dif_len; i++, buf++)
+		write_register_byte(
+			dev, IPW_REG_INDIRECT_ACCESS_DATA + i, *buf);
+}
+
+static inline void read_nic_memory(struct net_device *dev, u32 addr, u32 len,
+				   u8 *buf)
+{
+	u32 aligned_addr;
+	u32 aligned_len;
+	u32 dif_len;
+	u32 i;
+
+	/* read first nibble byte by byte */
+	aligned_addr = addr & (~0x3);
+	dif_len = addr - aligned_addr;
+	if (dif_len) {
+		/* Start reading at aligned_addr + dif_len */
+		write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, 
+			       aligned_addr);
+		for (i = dif_len; i < 4; i++, buf++)
+			read_register_byte(
+				dev, IPW_REG_INDIRECT_ACCESS_DATA + i, buf);
+		
+		len -= dif_len;
+		aligned_addr += 4;
+	}
+
+	/* read DWs through autoincrement registers */
+	write_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS,
+		       aligned_addr);
+	aligned_len = len & (~0x3);
+	for (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)
+		read_register(dev, IPW_REG_AUTOINCREMENT_DATA,
+			      (u32 *)buf);
+	
+	/* copy the last nibble */
+	dif_len = len - aligned_len;
+	write_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,
+		       aligned_addr);
+	for (i = 0; i < dif_len; i++, buf++)
+		read_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA +
+				   i, buf);
+}
+
+#endif	/* _IPW2100_HW_H */
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_main.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_main.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_main.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_main.c	2004-05-22 09:13:02.018957535 -0500
@@ -0,0 +1,6166 @@
+/******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+/*
+
+ Initial driver on which this is based was developed by Janusz Gorycki, 
+ Maciej Urbaniak, and Maciej Sosnowski.
+
+
+Theory of Operation
+
+Tx - Commands and Data
+
+Firmware and host share a circular queue of Transmit Buffer Descriptors (TBDs)
+Each TBD contains a pointer to the physical (dma_addr_t) address of data being
+sent to the firmware as well as the length of the data.
+
+The host writes to the TBD queue at the WRITE index.  The WRITE index points
+to the _next_ packet to be written and is advanced when after the TBD has been
+filled.
+
+The firmware pulls from the TBD queue at the READ index.  The READ index points
+to the currently being read entry, and is advanced once the firmware is
+done with a packet.
+
+When data is sent to the firmware, the first TBD is used to indicate to the
+firmware if a Command or Data is being sent.  If it is Command, all of the 
+command information is contained within the physical address referred to by the
+TBD.  If it is Data, the first TBD indicates the type of data packet, number
+of fragments, etc.  The next TBD then referrs to the actual packet location.
+
+The Tx flow cycle is as follows:
+
+1) ipw2100_tx() is called by kernel with SKB to transmit
+2) Packet is move from the tx_free_list and appended to the transmit pending 
+   list (tx_pend_list)
+3) work is scheduled to move pending packets into the shared circular queue.
+4) when placing packet in the circular queue, the incoming SKB is DMA mapped
+   to a physical address.  That address is entered into a TBD.  Two TBDs are
+   filled out.  The first indicating a data packet, the second referring to the
+   actual payload data.
+5) the packet is removed from tx_pend_list and placed on the end of the 
+   firmware pending list (fw_pend_list)
+6) firmware is notified that the WRITE index has 
+7) Once the firmware has processed the TBD, INTA is triggered.  
+8) For each Tx interrupt received from the firmware, the READ index is checked
+   to see which TBDs are done being processed.
+9) For each TBD that has been processed, the ISR pulls the oldest packet 
+   from the fw_pend_list.  
+10)The packet structure contained in the fw_pend_list is then used
+   to unmap the DMA address and to free the SKB originally passed to the driver
+   from the kernel.
+11)The packet structure is placed onto the tx_free_list
+
+The above steps are the same for commands, only the msg_free_list/msg_pend_list
+are used instead of tx_free_list/tx_pend_list
+
+...
+
+Critical Sections / Locking :
+
+There are two locks utilized.  The first is the low level lock (priv->low_lock)
+that protects the following:
+
+- Access to the Tx/Rx queue lists via priv->low_lock.  The lists are as follows:
+
+  tx_free_list : Holds pre-allocated Tx buffers.
+    TAIL modified in __ipw2100_tx_process()
+    HEAD modified in ipw2100_tx()
+
+  tx_pend_list : Holds used Tx buffers waiting to go into the TBD ring 
+    TAIL modified ipw2100_tx()
+    HEAD modified by X__ipw2100_tx_send_data()
+
+  msg_free_list : Holds pre-allocated Msg (Command) buffers
+    TAIL modified in __ipw2100_tx_process()
+    HEAD modified in ipw2100_hw_seond_command()
+
+  msg_pend_list : Holds used Msg buffers waiting to go into the TBD ring
+    TAIL modified in ipw2100_hw_send_command()
+    HEAD modified in X__ipw2100_tx_send_commands()
+
+  The flow of data on the TX side is as follows:
+
+  MSG_FREE_LIST + COMMAND => MSG_PEND_LIST => TBD => MSG_FREE_LIST
+  TX_FREE_LIST + DATA => TX_PEND_LIST => TBD => TX_FREE_LIST
+
+  The methods that work on the TBD ring are protected via priv->low_lock.
+
+- The internal data state of the device itself
+- Access to the firmware read/write indexes for the BD queues
+  and associated logic
+
+...
+
+TODO
+
+- Deprecate the proc filesystem code (how to cleanly support 2.4 and 2.6 in
+  one driver base?)  ethtool_ops ?
+-   
+
+...
+
+Files:
+  ipw2100_fw.c/h   Defines the interface and implementation for 
+                   loading and unloading the firmware and microcode 
+		   onto the NIC MAC.  The code in these files will be 
+		   rewritten in the coming weeks to use a dynamic 
+		   loading approach.
+
+  ipw2100_hw.h     Inline functions for read/writing to the NIC.
+
+  ipw2100_main.c/h This file - defines modules entry points, ISR, 
+                   wireless extension, etc.
+
+  ipw2100_wx.c/h   Defines wireless extension handlers.	
+
+
+*/
+
+#include <linux/802_11.h>
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/if_arp.h>
+#include <linux/in6.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#include <linux/sched.h>
+#endif
+
+#ifndef IRQ_NONE
+typedef void irqreturn_t;
+#define IRQ_NONE 
+#define IRQ_HANDLED 
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(x) kfree(x)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/* Some 2.4 kernels configured with different schedulers do not have the
+ * __wake_up_sync function.  As such, we need to switch the 
+ * wake_up_interruptible_sync's accordingly */
+#  ifndef wake_up_sync
+/* Some versions don't define wake_up_sync but do define 
+ * wake_up_interruptible_sync.  We can't just check for
+ * the later since sometimes it is defined as an actual function
+ * and not a #define--in these cases, wake_up_sync is not defined */
+#    ifdef wake_up_interruptible_sync
+#      undef wake_up_interruptible_sync
+#    endif
+#  define wake_up_interruptible_sync wake_up_interruptible
+#  endif
+#endif
+
+#define IPW2100_MAIN
+#include "ipw2100.h"
+#include "ipw2100_hw.h"
+#include "ipw2100_fw.h"
+#include "ipw2100_wx.h"
+#include "ipwversion.h"
+
+#define DRV_NAME	"ipw2100"
+#define DRV_VERSION	IPW2100_VERSION
+#define DRV_DESCRIPTION	"Intel(R) PRO/Wireless 2100 Network Driver"
+#define DRV_COPYRIGHT	"Copyright(c) 2003-2004 Intel Corporation"
+
+static int debug = -1;
+
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR(DRV_COPYRIGHT);
+MODULE_LICENSE("GPL");
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+MODULE_PARM(debug, "i");
+
+static char if_name[IFNAMSIZ] = {[0 ... IFNAMSIZ - 1] = 0};
+MODULE_PARM(if_name, "1-" __MODULE_STRING(IFNAMSIZ - 1) "s");
+
+#else /* LINUX_VERSION_CODE < 2.6.0 */
+
+#include <linux/moduleparam.h>
+module_param(debug, int, 0);
+static char *if_name = NULL;
+module_param(if_name, charp, 0);
+
+#endif /* LINUX_VERSION_CODE < 2.6.0 */
+
+unsigned long ipw2100_debug_level = IPW2100_DL_UNINIT; /* Unset */
+
+const char *port_type_str[] = { 
+	"managed", "adhoc", "monitor"
+};
+
+#ifdef CONFIG_IPW2100_DEBUG
+const char *command_types[] = {
+	"undefined",
+	"unused", /* HOST_ATTENTION */ 
+	"HOST_COMPLETE",
+	"unused", /* SLEEP */
+	"unused", /* HOST_POWER_DOWN */
+	"unused", 
+	"SYSTEM_CONFIG",
+	"unused", /* SET_IMR */
+	"SSID",
+	"MANDATORY_BSSID",
+	"AUTHENTICATION_TYPE",
+	"ADAPTER_ADDRESS",
+	"PORT_TYPE",
+	"INTERNATIONAL_MODE",
+	"CHANNEL",
+	"RTS_THRESHOLD",
+	"POWER_MODE",
+	"TX_RATES",
+	"BASIC_TX_RATES",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"unused",
+	"ADD_MULTICAST",
+	"CLEAR_ALL_MULTICAST",
+	"BEACON_INTERVAL",
+	"ATIM_WINDOW",
+	"CLEAR_STATISTICS",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"TX_POWER_INDEX",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"undefined",
+	"BROADCAST_SCAN",
+	"CARD_DISABLE",
+	"PREFERRED_BSSID",
+	"SET_SCAN_OPTIONS",
+	"SCAN_DWELL_TIME",
+	"SWEEP_TABLE",
+	"AP_OR_STATION_TABLE",
+	"GROUP_ORDINALS",
+	"SHORT_RETRY_LIMIT",
+	"LONG_RETRY_LIMIT",
+	"unused", /* SAVE_CALIBRATION */
+	"unused", /* RESTORE_CALIBRATION */
+	"undefined",
+	"undefined",
+	"undefined",
+	"HOST_PRE_POWER_DOWN",
+	"unused", /* HOST_INTERRUPT_COALESCING */
+	"undefined",
+	"CARD_DISABLE_PHY_OFF",
+	"MSDU_TX_RATES"
+	"undefined",
+	"undefined",
+	"SET_STATION_STAT_BITS",
+	"CLEAR_STATIONS_STAT_BITS",
+	"LEAP_ROGUE_MODE",
+	"SET_SECURITY_INFORMATION",
+	"DISASSOCIATION_BSSID",
+	"SET_WPA_ASS_IE"
+};
+#endif
+
+
+/* Pre-decl until we get the code solid and then we can clean it up */
+static void X__ipw2100_tx_send_commands(struct ipw2100_priv *priv);
+static void X__ipw2100_tx_send_data(struct ipw2100_priv *priv);
+static int ipw2100_adapter_setup(struct ipw2100_priv *priv);
+
+static void ipw2100_queues_initialize(struct ipw2100_priv *priv);
+static void ipw2100_queues_free(struct ipw2100_priv *priv);
+static int ipw2100_queues_allocate(struct ipw2100_priv *priv);
+
+static int ipw2100_proc_init(void);
+static void ipw2100_proc_cleanup(void);
+static void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv);
+static int ipw2100_proc_dev_init(struct ipw2100_priv *priv);
+
+static inline int ipw2100_hw_is_adapter_in_system(struct net_device *dev)
+{
+	return (dev->base_addr && 
+		(readl(dev->base_addr + IPW_REG_DOA_DEBUG_AREA_START)
+		 == IPW_DATA_DOA_DEBUG_VALUE));
+}
+
+int ipw2100_get_ordinal(struct ipw2100_priv *priv, u32 ord, void *val, 
+			       u32 *len)
+{
+	struct ipw2100_ordinals *ordinals = &priv->ordinals;
+	u32 addr;
+	u32 field_info;
+	u16 field_len;
+	u16 field_count;
+	u32 total_length;
+
+	if (ordinals->table1_addr == 0) {
+		printk(KERN_WARNING DRV_NAME ": attempt to use fw ordinals "
+		       "before they have been loaded.\n");
+		return -EINVAL;
+	}
+
+	if (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {
+		if (*len < IPW_ORD_TAB_1_ENTRY_SIZE) {
+			*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+
+			printk(KERN_WARNING DRV_NAME 
+			       ": ordinal buffer length too small, need %d\n",
+			       IPW_ORD_TAB_1_ENTRY_SIZE);
+
+			return -EINVAL;
+		}
+
+		read_nic_dword(priv->ndev, ordinals->table1_addr + (ord << 2), 
+			       &addr);
+		read_nic_dword(priv->ndev, addr, val);
+
+		*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+		
+		return 0;
+	} 
+	
+	if (IS_ORDINAL_TABLE_TWO(ordinals, ord)) {
+
+		ord -= IPW_START_ORD_TAB_2;
+		
+		/* get the address of statistic */
+		read_nic_dword(priv->ndev, ordinals->table2_addr + (ord << 3), 
+			       &addr);
+		
+		/* get the second DW of statistics ; 
+		 * two 16-bit words - first is length, second is count */
+		read_nic_dword(priv->ndev, 
+			       ordinals->table2_addr + (ord << 3) + sizeof(u32),
+			       &field_info);
+		
+		/* get each entry length */
+		field_len = *((u16 *)&field_info);
+		
+		/* get number of entries */
+		field_count = *(((u16 *)&field_info) + 1);
+		
+		/* abort if no enought memory */
+		total_length = field_len * field_count;
+		if (total_length > *len) {
+			*len = total_length;
+			return -EINVAL;
+		}
+		
+		*len = total_length;
+		if (!total_length)
+			return 0;
+		
+		/* read the ordinal data from the SRAM */
+		read_nic_memory(priv->ndev, addr, total_length, val);
+		
+		return 0;
+	}
+
+	printk(KERN_WARNING DRV_NAME ": ordinal %d neither in table 1 nor "
+	       "in table 2\n", ord);
+
+	return -EINVAL;
+}
+
+static int ipw2100_set_ordinal(struct ipw2100_priv *priv, u32 ord, u32 *val, 
+			       u32 *len)
+{
+	struct ipw2100_ordinals *ordinals = &priv->ordinals;
+	u32 addr;
+
+	if (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {
+		if (*len != IPW_ORD_TAB_1_ENTRY_SIZE) {
+			*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+			IPW2100_DEBUG_INFO("wrong size\n");
+			return -EINVAL;
+		}
+
+		read_nic_dword(priv->ndev, ordinals->table1_addr + (ord << 2), 
+			       &addr);
+
+		write_nic_dword(priv->ndev, addr, *val);
+
+		*len = IPW_ORD_TAB_1_ENTRY_SIZE;
+
+		return 0;
+	} 
+
+	IPW2100_DEBUG_INFO("wrong table\n");
+	if (IS_ORDINAL_TABLE_TWO(ordinals, ord)) 
+		return -EINVAL;
+
+	return -EINVAL;
+}
+
+/*
+ * 1. check if message in progress, ret EBUSY if so
+ * 2. issue command
+ * 3. wait for command to complete; timeout in 3s
+ */
+static int ipw2100_hw_send_command(struct ipw2100_priv *priv,
+				   struct host_command * cmd) 
+{
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	unsigned long flags;
+	int err = 0;
+
+	IPW2100_DEBUG_INFO("enter - '%s' (%d)\n",
+	       command_types[cmd->host_command],
+	       cmd->host_command);
+	
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	if (priv->fatal_error) {
+		IPW2100_DEBUG_INFO("Attempt to send command while hardware "
+				   "in fatal error condition.");
+		err = -EIO;
+		goto fail_unlock;
+	}
+
+	if (priv->stopped) {
+		IPW2100_DEBUG_INFO("Attempt to send command while hardware "
+				   "is not running.");
+		err = -EIO;
+		goto fail_unlock;
+	}
+
+	if (priv->message_sending) {
+		IPW2100_DEBUG_INFO("Attempt to send command while hardware "
+				   "another command is pending.");
+		err = -EBUSY;
+		goto fail_unlock;
+	}
+
+	if (list_empty(&priv->msg_free_list)) {
+		IPW2100_DEBUG_INFO("no available msg buffers\n");
+		goto fail_unlock;
+	}
+
+	priv->message_sending = 1;
+	priv->messages_sent++;
+
+	element = priv->msg_free_list.next;
+
+	packet = list_entry(element, struct ipw2100_hw_packet, list);
+	packet->jiffy_start = jiffies;
+
+	/* initialize the firmware command packet */
+	packet->cmd->host_command_reg = cmd->host_command;
+	packet->cmd->host_command_reg1 = cmd->host_command1;
+	packet->cmd->host_command_len_reg = cmd->host_command_length;
+	packet->cmd->sequence = cmd->host_command_sequence;
+
+	memcpy(packet->cmd->host_command_params_reg,
+	       cmd->host_command_parameters,
+	       sizeof(packet->cmd->host_command_params_reg));
+
+	list_del(element);
+	list_add_tail(element, &priv->msg_pend_list);
+
+	X__ipw2100_tx_send_commands(priv);
+	X__ipw2100_tx_send_data(priv);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	/*
+	 * We must wait for this command to complete before another
+	 * command can be sent...  but if we wait more than 3 seconds
+	 * then there is a problem.
+	 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = interruptible_sleep_on_timeout(&priv->wait_command_queue, 3 * HZ);
+#else
+	err = wait_event_interruptible_timeout(
+		priv->wait_command_queue, !priv->message_sending, 3 * HZ);
+#endif
+	if (err == 0) {
+		printk(KERN_WARNING 
+		       "%s: ipw2100_hw_send_command timed out.\n",
+		       priv->ndev->name);
+		priv->fatal_error = 1;
+		priv->message_sending = 0;
+		return -EIO;
+	}
+
+	if (priv->fatal_error) {
+		printk(KERN_WARNING "%s: firmware fatal error\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+
+	IPW2100_DEBUG_INFO("exit - command %d\n", cmd->host_command);
+
+	return 0;
+
+ fail_unlock:
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	return err;
+}
+
+
+/*
+ * Verify the values and data access of the hardware
+ * No locks needed or used.  No functions called.
+ */
+static int ipw2100_verify(struct ipw2100_priv *priv)
+{
+	u32 data1, data2;
+	u32 address;
+
+	u32 val1 = 0x76543210;
+	u32 val2 = 0xFEDCBA98;
+
+	/* Domain 0 check - all values should be DOA_DEBUG */
+	for (address = IPW_REG_DOA_DEBUG_AREA_START;
+	     address < IPW_REG_DOA_DEBUG_AREA_END;
+	     address += sizeof(u32)) {
+		read_register(priv->ndev, address, &data1);
+		if (data1 != IPW_DATA_DOA_DEBUG_VALUE)
+			return -EIO;
+	}
+
+	/* Domain 1 check - use arbitrary read/write compare  */
+	for (address = 0; address < 5; address++) {
+		/* The memory area is not used now */
+		write_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x32, 
+			       val1);
+		write_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x36, 
+			       val2);
+		read_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x32, 
+			      &data1);
+		read_register(priv->ndev, IPW_REG_DOMAIN_1_OFFSET + 0x36, 
+			      &data2);
+		if (val1 == data1 && val2 == data2)
+			return 0;
+	}
+
+	return -EIO;
+}
+
+/*
+ * 
+ * Loop until the CARD_DISABLED bit is the same value as the
+ * supplied parameter
+ *
+ * TODO: See if it would be more efficient to do a wait/wake
+ *       cycle and have the completion event trigger the wakeup
+ * 
+ */
+static int ipw2100_wait_for_card_state(struct ipw2100_priv *priv, int disabled)
+{
+	int i;
+	u32 card_disabled;
+	u32 len = sizeof(card_disabled);
+	int err;
+	
+	for (i = 0; i <= IPW_CARD_DISABLE_COMPLETE_WAIT * 1000; i += 50) {
+		err = ipw2100_get_ordinal(priv, IPW_ORD_CARD_DISABLED, 
+					  &card_disabled, &len);
+		if (err) {
+			IPW2100_DEBUG_INFO("query failed.\n");
+			break;
+		}
+
+		/* We'll break out if either the HW state says it is
+		 * in the state we want, or if HOST_COMPLETE command
+		 * finishes */
+		if (card_disabled == disabled ||
+		    priv->disabled == disabled) {
+			priv->disabled = disabled;
+			return 0;
+		}
+
+		udelay(50);
+	}
+
+	if (i >= IPW_CARD_DISABLE_COMPLETE_WAIT * 1000) {
+		IPW2100_DEBUG_INFO("ipw2100_wait_for_card_state to %s state "
+				   "timed out\n", 
+				   disabled ? "DISABLED" : "ENABLED");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+
+/*********************************************************************
+    Procedure   :   sw_reset_and_clock
+    Purpose     :   Asserts s/w reset, asserts clock initialization 
+                    and waits for clock stabilization
+ ********************************************************************/
+static int sw_reset_and_clock(struct ipw2100_priv *priv)
+{
+	int i;
+	u32 r;
+
+	// assert s/w reset
+	write_register(priv->ndev, IPW_REG_RESET_REG, 
+		       IPW_AUX_HOST_RESET_REG_SW_RESET);
+
+	// wait for clock stabilization
+	for (i = 0; i < 1000; i++) {
+		udelay(IPW_WAIT_RESET_ARC_COMPLETE_DELAY);
+
+		// check clock ready bit
+		read_register(priv->ndev, IPW_REG_RESET_REG, &r);
+		if (r & IPW_AUX_HOST_RESET_REG_PRINCETON_RESET)
+			break;
+	}
+
+	if (i == 1000)
+		return -EIO;	// TODO: better error value
+
+	/* set "initialization complete" bit to move adapter to 
+	 * D0 state */
+	write_register(priv->ndev, IPW_REG_GP_CNTRL,
+		       IPW_AUX_HOST_GP_CNTRL_BIT_INIT_DONE);
+
+	/* wait for clock stabilization */
+	for (i = 0; i < 10000; i++) {
+		udelay(IPW_WAIT_CLOCK_STABILIZATION_DELAY * 4);
+
+		/* check clock ready bit */
+		read_register(priv->ndev, IPW_REG_GP_CNTRL, &r);
+		if (r & IPW_AUX_HOST_GP_CNTRL_BIT_CLOCK_READY)
+			break;
+	}
+
+	if (i == 10000)
+		return -EIO;	/* TODO: better error value */
+
+//#if CONFIG_IPW2100_D0ENABLED
+	/* set D0 standby bit */
+	read_register(priv->ndev, IPW_REG_GP_CNTRL, &r);
+	write_register(priv->ndev, IPW_REG_GP_CNTRL,
+		       r | IPW_AUX_HOST_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);
+//#endif
+
+	return 0;
+}
+
+/*********************************************************************
+    Procedure   :   ipw2100_ipw2100_download_firmware
+    Purpose     :   Initiaze adapter after power on.
+                    The sequence is:
+                    1. assert s/w reset first!
+                    2. awake clocks & wait for clock stabilization
+                    3. hold ARC (don't ask me why...)
+                    4. load Dino ucode and reset/clock init again
+                    5. zero-out shared mem
+                    6. download f/w
+ *******************************************************************/
+static int ipw2100_download_firmware(struct ipw2100_priv *priv)
+{
+	u32 address;
+	int err;
+
+	/* Fetch the firmware and microcode */
+	struct ipw2100_fw fw;
+	
+	if (priv->fatal_error) {
+		printk(KERN_ERR "%s: ipw2100_download_firmware called after "
+		       "fatal error %d.  Interface must be brought down.\n",
+		       priv->ndev->name, priv->fatal_error);
+		return -EINVAL;
+	}
+
+	err = ipw2100_get_firmware(priv, &fw);
+	if (err) {
+		printk(KERN_ERR "%s: ipw2100_get_firmware failed: %d\n",
+		       priv->ndev->name, err);
+		priv->fatal_error = 101;
+		return err;
+	}
+	priv->firmware_version = fw.version;
+
+	/* s/w reset and clock stabilization */
+	err = sw_reset_and_clock(priv);
+	if (err) {
+		printk(KERN_ERR "%s: sw_reset_and_clock failed: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	err = ipw2100_verify(priv);
+	if (err) {
+		printk(KERN_ERR "%s: ipw2100_verify failed: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	/* Hold ARC */
+	write_nic_dword(priv->ndev,
+			IPW_INTERNAL_REGISTER_HALT_AND_RESET,
+			0x80000000);
+
+	/* allow ARC to run */
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+
+	/* load microcode */
+	err = ipw2100_ucode_download(priv, &fw);
+	if (err) {
+		printk(KERN_ERR "%s: Error loading microcode: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	/* release ARC */
+	write_nic_dword(priv->ndev,
+			IPW_INTERNAL_REGISTER_HALT_AND_RESET,
+			0x00000000);
+
+	/* s/w reset and clock stabilization (again!!!) */
+	err = sw_reset_and_clock(priv);
+	if (err) {
+		printk(KERN_ERR "%s: sw_reset_and_clock failed: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+
+	/* load f/w */
+	err = ipw2100_fw_download(priv, &fw);
+	if (err) {
+		printk(KERN_ERR "%s: Error loading firmware: %d\n",
+		       priv->ndev->name, err);
+		goto fail;
+	}
+	
+	/* free any storage allocated for firmware image */
+	ipw2100_release_firmware(priv, &fw);
+
+	/* zero out Domain 1 area indirectly (Si requirement) */
+	for (address = IPW_HOST_FW_SHARED_AREA0; 
+	     address < IPW_HOST_FW_SHARED_AREA0_END; address += 4) 
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_SHARED_AREA1; 
+	     address < IPW_HOST_FW_SHARED_AREA1_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_SHARED_AREA2; 
+	     address < IPW_HOST_FW_SHARED_AREA2_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_SHARED_AREA3; 
+	     address < IPW_HOST_FW_SHARED_AREA3_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+	for (address = IPW_HOST_FW_INTERRUPT_AREA; 
+	     address < IPW_HOST_FW_INTERRUPT_AREA_END; address += 4)
+		write_nic_dword(priv->ndev, address, 0);
+
+	return 0;
+
+ fail:
+	ipw2100_release_firmware(priv, &fw);
+	return err;
+}
+
+static inline void ipw2100_hw_disable_interrupt(struct ipw2100_priv *priv)
+{
+	write_register(priv->ndev, IPW_REG_INTA_MASK, 0x0);
+}
+
+static inline void ipw2100_hw_enable_interrupt(struct ipw2100_priv *priv)
+{
+	write_register(priv->ndev, IPW_REG_INTA_MASK, IPW_INTERRUPT_MASK);
+}
+
+static void ipw2100_initialize_ordinals(struct ipw2100_priv *priv)
+{
+	struct ipw2100_ordinals *ord = &priv->ordinals;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_1,
+		      &ord->table1_addr);
+
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_2,
+		      &ord->table2_addr);
+
+	read_nic_dword(priv->ndev, ord->table1_addr, &ord->table1_size);
+	read_nic_dword(priv->ndev, ord->table2_addr, &ord->table2_size);
+
+	ord->table2_size &= 0x0000FFFF;
+
+	IPW2100_DEBUG_INFO("table 1 size: %d\n", ord->table1_size);
+	IPW2100_DEBUG_INFO("table 2 size: %d\n", ord->table2_size);
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static inline void ipw2100_hw_set_gpio(struct ipw2100_priv *priv)
+{
+	u32 reg = 0;
+	/*
+	 * Set GPIO 3 writable by FW; GPIO 1 writable 
+	 * by driver and enable clock
+	 */
+	reg = (IPW_BIT_GPIO_GPIO3_MASK | IPW_BIT_GPIO_GPIO1_ENABLE |
+	       IPW_BIT_GPIO_LED_OFF);
+	write_register(priv->ndev, IPW_REG_GPIO, reg);
+}
+
+static inline int ipw2100_get_rf_switch(struct ipw2100_priv *priv)
+{
+#define MAX_RF_KILL_CHECKS 5
+#define RF_KILL_CHECK_DELAY 40
+#define RF_KILL_CHECK_THRESHOLD 3
+	
+	unsigned short value = 0;
+	u32 reg = 0;
+	int i;
+	
+	if (!(priv->hw_features & HW_FEATURE_RFKILL)) 
+		return 0;
+
+	for (i = 0; i < MAX_RF_KILL_CHECKS; i++) {
+		udelay(RF_KILL_CHECK_DELAY);
+		read_register(priv->ndev, IPW_REG_GPIO, &reg);
+		value = (value << 1) | ((reg & IPW_BIT_GPIO_RF_KILL) ? 0 : 1);
+	}
+
+	return (value == 0);
+}
+
+static int ipw2100_get_hw_features(struct ipw2100_priv *priv)
+{
+	u32 addr, len;
+	u32 val;
+
+	/* 
+	 * EEPROM_SRAM_DB_START_ADDRESS using ordinal in ordinal table 1
+	 */
+	len = sizeof(addr);
+	if (ipw2100_get_ordinal(
+		    priv, IPW_ORD_EEPROM_SRAM_DB_BLOCK_START_ADDRESS,
+		    &addr, &len)) {
+		printk(KERN_INFO "failed querying ordinals at line %d\n", 
+		       __LINE__);
+		return -EIO;
+	}
+
+	IPW2100_DEBUG_INFO("EEPROM address: %08X\n", addr);
+ 
+	/*
+	 * EEPROM version is the byte at offset 0xfd in firmware
+	 * We read 4 bytes, then shift out the byte we actually want */ 
+	read_nic_dword(priv->ndev, addr + 0xFC, &val);
+	priv->eeprom_version = (val >> 24) & 0xFF;
+	IPW2100_DEBUG_INFO("EEPROM version: %d\n", priv->eeprom_version);
+
+        /*
+	 *  HW RF Kill enable is bit 0 in byte at offset 0x21 in firmware
+	 *
+	 *  notice that the EEPROM bit is reverse polarity, i.e.
+	 *     bit = 0  signifies HW RF kill switch is supported
+	 *     bit = 1  signifies HW RF kill switch is NOT supported
+	 */
+	read_nic_dword(priv->ndev, addr + 0x20, &val);
+	if (!((val >> 24) & 0x01))
+		priv->hw_features |= HW_FEATURE_RFKILL;
+
+	IPW2100_DEBUG_INFO("HW RF Kill: %ssupported.\n",
+			   (priv->hw_features & HW_FEATURE_RFKILL) ?
+			   "" : "not ");
+
+	return 0;
+}
+
+static int ipw2100_beacons_allocate(struct ipw2100_priv *priv)
+{
+	if (priv->beacons)
+		return 0;
+
+	IPW2100_DEBUG_SCAN("Allocating %d beacon slots.\n", 
+			   MAX_BEACON_COUNT);
+
+	priv->beacons = (struct ipw2100_beacon *)kmalloc(
+		MAX_BEACON_COUNT * sizeof(struct ipw2100_beacon),
+		GFP_KERNEL);
+	if (!priv->beacons) {
+		printk(KERN_WARNING DRV_NAME 
+		       ": Out of memory allocating beacons\n");
+		return -ENOMEM;
+	}
+
+	memset(priv->beacons, 0, 
+	       MAX_BEACON_COUNT * sizeof(struct ipw2100_beacon));
+
+	return 0;
+}
+
+static void ipw2100_beacons_free(struct ipw2100_priv *priv)
+{
+	if (!priv->beacons)
+		return;
+	kfree(priv->beacons);
+	priv->beacons = NULL;
+}
+
+static void ipw2100_beacons_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	INIT_LIST_HEAD(&priv->beacon_free_list);
+	INIT_LIST_HEAD(&priv->beacon_list);
+	for (i = 0; i < MAX_BEACON_COUNT; i++) 
+		list_add_tail(&priv->beacons[i].list, &priv->beacon_free_list);
+}
+
+/*
+ * Start firmware execution after power on and intialization
+ * The sequence is:
+ *  1. Release ARC
+ *  2. Wait for f/w initialization completes;
+ */
+static int ipw2100_start_adapter(struct ipw2100_priv *priv)
+{
+#define IPW_WAIT_FW_INIT_COMPLETE_DELAY (40 * HZ / 1000)
+	int i;
+	u32 r;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (!priv->stopped)
+		return 0;
+
+	/*
+	 * Initialize the hw - drive adapter to DO state by setting 
+	 * init_done bit. Wait for clk_ready bit and Download 
+	 * fw & dino ucode
+	 */
+	if (ipw2100_download_firmware(priv)) {
+		printk(KERN_ERR "%s: Failed to power on the adapter.\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+	
+	/* Clear the Tx, Rx and Msg queues and the r/w indexes
+	 * in the firmware RBD and TBD ring queue */
+	ipw2100_queues_initialize(priv);
+	ipw2100_beacons_initialize(priv);
+
+#ifndef CONFIG_IPW2100_WEP
+	ipw2100_defrag_initialize(priv);
+#endif
+		
+	ipw2100_hw_set_gpio(priv);
+
+	/* Release ARC - clear reset bit */
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+
+	/* wait for f/w intialization complete */
+	i = 5000;
+	do {
+  		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(IPW_WAIT_FW_INIT_COMPLETE_DELAY);
+
+		read_register(priv->ndev, IPW_REG_INTA, &r);
+
+		/* check "init done" bit */
+		if (r & IPW2100_INTA_FW_INIT_DONE) {
+			/* reset "init done" bit */
+			write_register(priv->ndev, IPW_REG_INTA,
+				       IPW2100_INTA_FW_INIT_DONE);
+			break;
+		}
+
+		/* check error conditions : we check these after the firmware
+		 * check so that if there is an error, the interrupt handler
+		 * will see it and the adapter will be reset */
+		if (r & 
+		    (IPW2100_INTA_FATAL_ERROR | IPW2100_INTA_PARITY_ERROR)) {
+			/* clear error conditions */
+			write_register(priv->ndev, IPW_REG_INTA,
+				       IPW2100_INTA_FATAL_ERROR |
+				       IPW2100_INTA_PARITY_ERROR);
+		}
+
+
+	} while (i--);
+
+	/* Start firmware hang check timer */
+	if (priv->stop_hang_check) {
+		priv->stop_hang_check = 0;
+		priv->hang_check_timer.expires = jiffies + 2 * HZ;
+		add_timer(&priv->hang_check_timer);
+	}
+	
+	if (!i) {
+		printk(KERN_WARNING "%s: Firmware did not initialized.\n",
+		       priv->ndev->name);
+		return -EIO;
+	}
+
+	/* allow firmware to write to GPIO1 & GPIO3 */
+	read_register(priv->ndev, IPW_REG_GPIO, &r);
+
+	r |= (IPW_BIT_GPIO_GPIO1_MASK | IPW_BIT_GPIO_GPIO3_MASK);
+
+	write_register(priv->ndev, IPW_REG_GPIO, r);
+
+	priv->stopped = 0;
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static inline void ipw2100_reset_sw(struct ipw2100_priv *priv)
+{
+	/* Forget whatever we know about any associated SSIDs... */
+	memset(priv->ctx->ssid, 0, sizeof(priv->ctx->ssid));
+	priv->ctx->port_type = BSS;
+	priv->ctx->channel = 1;
+	
+	ipw2100_hw_set_gpio(priv);
+
+	/* SW Reset the adapter */
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+}
+
+/* NOTE: Our interrupt is disabled when this method is called */
+static int ipw2100_power_cycle_adapter(struct ipw2100_priv *priv)
+{
+	u32 reg;
+	int i;
+
+	IPW2100_DEBUG_INFO("Power cycling the hardware.\n");
+
+	write_register(priv->ndev, IPW_REG_RESET_REG, 0);
+
+	ipw2100_hw_set_gpio(priv);
+
+	/* Step 1. Stop Master Assert */
+	write_nic_dword(priv->ndev, IPW_REG_RESET_REG, 
+			IPW_AUX_HOST_RESET_REG_STOP_MASTER);    
+	
+	/* Step 2. Wait for stop Master Assert 
+	 *         (not more then 50us, otherwise ret error */
+	i = 5;
+	do {
+		udelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);
+		read_register(priv->ndev, IPW_REG_RESET_REG, &reg);
+		
+		if (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)
+			break;
+	}  while(i--);
+
+	priv->reset_pending = 0;
+
+	if (!i) {
+		IPW2100_DEBUG_INFO("exit - waited too long for master assert "
+		       "stop\n");
+		return -EIO;
+	}
+
+	write_register(priv->ndev, IPW_REG_RESET_REG, 
+		       IPW_AUX_HOST_RESET_REG_SW_RESET);
+
+	
+	/* Reset any fatal_error conditions */
+	priv->fatal_error = 0;
+
+	/* At this point, the adapter is now stopped and disabled */
+	priv->stopped = 1;
+	priv->disabled = 1;
+
+	return 0;
+}
+
+/*
+ * Send the CARD_DISABLE_PHY_OFF comamnd to the card to disable it
+ *
+ * After disabling, if the card was associated, a STATUS_ASSN_LOST will be sent.
+ *
+ * STATUS_CARD_DISABLE_NOTIFICATION will be sent regardless of
+ * if STATUS_ASSN_LOST is sent.
+ */
+static int ipw2100_hw_phy_off(struct ipw2100_priv *priv)
+{
+
+#define HW_PHY_OFF_LOOP_DELAY (HZ / 5000)
+
+	struct host_command cmd = {
+		.host_command = CARD_DISABLE_PHY_OFF,
+		.host_command_sequence = 0,
+		.host_command_length = 0,
+	};
+	int err, i;
+	u32 val1, val2;
+
+	if (priv->phy_off == 1)
+		return 0;
+
+	IPW2100_DEBUG_FW_COMMAND("CARD_DISABLE_PHY_OFF\n");
+
+	/* Turn off the radio */
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) 
+		return err;
+
+	for (i = 0; i < 2500; i++) {
+		read_nic_dword(priv->ndev, IPW2100_CONTROL_REG, &val1);
+		read_nic_dword(priv->ndev, IPW2100_COMMAND, &val2);
+
+		if ((val1 & IPW2100_CONTROL_PHY_OFF) &&
+		    (val2 & IPW2100_COMMAND_PHY_OFF)) {
+			priv->phy_off = 1;
+			return 0;
+		}
+		
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HW_PHY_OFF_LOOP_DELAY);
+	}
+
+	return -EIO;
+}
+
+
+static int ipw2100_enable_adapter(struct ipw2100_priv *priv)
+{	
+	struct host_command cmd = {
+		.host_command = HOST_COMPLETE,
+		.host_command_sequence = 0,
+		.host_command_length = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("HOST_COMPLETE\n");
+	
+	if (!priv->disabled) 
+		return 0;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) {
+		IPW2100_DEBUG_INFO("Failed to send HOST_COMPLETE command\n");
+		return err;
+	}
+
+	err = ipw2100_wait_for_card_state(priv, STATE_ENABLED);
+	if (err) {
+		printk(KERN_WARNING 
+		       "%s: card not responding to init command.\n",
+		       priv->ndev->name);
+		return err;
+	}
+
+	IPW2100_DEBUG_INFO("TODO: implement scan state machine\n");
+
+	return 0;
+}
+
+static int ipw2100_hw_stop_adapter(struct ipw2100_priv *priv)
+{
+#define HW_POWER_DOWN_DELAY (HZ / 10)
+
+	struct host_command cmd = {
+		.host_command = HOST_PRE_POWER_DOWN,
+		.host_command_sequence = 0,
+		.host_command_length = 0,
+	};
+	int err, i;
+	u32 reg;
+
+	if (priv->stopped)
+		return 0;
+
+	/* We can only shut down the card if the firmware is operational.  So,
+	 * if we haven't reset since a fatal_error, then we can not send the
+	 * shutdown commands. */
+	if (priv->fatal_error) {
+		/* First, make sure the adapter is enabled so that the PHY_OFF 
+		 * command can shut it down */
+		ipw2100_enable_adapter(priv);
+
+		err = ipw2100_hw_phy_off(priv);
+		if (err) 
+			IPW2100_DEBUG_WARNING("Error disabling radio %d\n", err);
+		
+		/*
+		 * If in D0-standby mode going directly to D3 may cause a
+		 * PCI bus violation.  Therefore we must change out of the D0 
+		 * state.
+		 *
+		 * Sending the PREPARE_FOR_POWER_DOWN will restrict the 
+		 * hardware from going into standby mode and will transition 
+		 * out of D0-standy if it is already in that state.
+		 * 
+		 * STATUS_PREPARE_POWER_DOWN_COMPLETE will be sent by the
+		 * driver upon completion.  Once received, the driver can 
+		 * proceed to the D3 state.
+		 *
+		 * Prepare for power down command to fw.  This command would 
+		 * take HW out of D0-standby and prepare it for D3 state.
+		 * 
+		 * Currently FW does not support event notification for this 
+		 * event. Therefore, skip waiting for it.  Just wait a fixed 
+		 * 100ms
+		 */
+		IPW2100_DEBUG_FW_COMMAND("HOST_PRE_POWER_DOWN\n");
+		
+		err = ipw2100_hw_send_command(priv, &cmd);
+		if (err) 
+			printk(KERN_WARNING 
+			       "%s: Power down command failed: Error %d\n",
+			       priv->ndev->name, err);
+		else {
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(HW_POWER_DOWN_DELAY);
+		}
+	}
+	
+	priv->disabled = 1;
+
+	/*
+	 * Set GPIO 3 writable by FW; GPIO 1 writable 
+	 * by driver and enable clock
+	 */
+	ipw2100_hw_set_gpio(priv);
+
+	/*
+	 * Power down adapter.  Sequence:
+	 * 1. Stop master assert (RESET_REG[9]=1)
+	 * 2. Wait for stop master (RESET_REG[8]==1)
+	 * 3. S/w reset assert (RESET_REG[7] = 1)
+	 */
+
+	/* Stop master assert */
+	write_register(priv->ndev, IPW_REG_RESET_REG,
+		       IPW_AUX_HOST_RESET_REG_STOP_MASTER);
+
+	/* wait stop master not more than 50 usec. 
+	 * Otherwise return error. */
+	for (i = 5; i > 0; i--) {
+		udelay(10);
+
+		/* Check master stop bit */
+		read_register(priv->ndev, IPW_REG_RESET_REG, &reg);
+
+		if (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)
+			break;
+	}
+
+	if (i == 0) 
+		printk(KERN_WARNING DRV_NAME 
+		       ": %s: Could now power down adapter.\n", 
+		       priv->ndev->name);
+
+	/* assert s/w reset */
+	write_register(priv->ndev, IPW_REG_RESET_REG,
+		       IPW_AUX_HOST_RESET_REG_SW_RESET);
+
+	priv->stopped = 1;
+
+	return 0;
+}
+
+
+static int ipw2100_disable_adapter(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = CARD_DISABLE,
+		.host_command_sequence = 0,
+		.host_command_length = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("CARD_DISABLE\n");
+
+	if (priv->disabled) 
+		return 0;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) {
+		IPW2100_DEBUG_WARNING("exit - failed to send CARD_DISABLE "
+				      "command\n");
+		return err;
+	}
+
+	err = ipw2100_wait_for_card_state(priv, STATE_DISABLED);
+	if (err) {
+		IPW2100_DEBUG_WARNING("exit - card failed to change to "
+				      "DISABLED\n");
+		return err;
+	}
+
+	IPW2100_DEBUG_INFO("TODO: implement scan state machine\n");
+
+
+	return 0;
+}
+
+
+static int ipw2100_up(struct ipw2100_priv *priv)
+{
+	unsigned long flags;
+	int rc = 0;
+	u32 lock;
+	u32 ord_len = sizeof(lock);
+
+	/* If the interrupt is enabled, turn it off... */
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (priv->irq_enabled) {
+		ipw2100_hw_disable_interrupt(priv);
+		priv->irq_enabled = 0;
+	}
+
+	/* Reset any fatal_error conditions */
+	priv->fatal_error = 0;
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	if (priv->been_powered || priv->reset_pending) {
+		/* Power cycle the card ... */
+		if (ipw2100_power_cycle_adapter(priv)) {
+			printk(KERN_WARNING DRV_NAME 
+			       ": Could not cycle adapter.\n");
+			rc = 1;
+			goto exit;
+		}
+	} else 
+		priv->been_powered = 1;
+
+	/* Load the firmeware, start the clocks, etc. */
+	if (ipw2100_start_adapter(priv)) {
+	       	printk(KERN_ERR "%s: Failed to start the firmware.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+	ipw2100_initialize_ordinals(priv);
+	
+	/* Determine capabilities of this particular HW configuration */
+	if (ipw2100_get_hw_features(priv)) {
+		printk(KERN_ERR "%s: Failed to determine HW features.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+	lock = LOCK_NONE;
+	if (ipw2100_set_ordinal(priv, IPW_ORD_PERS_DB_LOCK, &lock, &ord_len)) {
+		printk(KERN_ERR "%s: Failed to clear ordinal lock.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+	/* Turn on the interrupt so that commands can be processed */
+	ipw2100_hw_enable_interrupt(priv);
+	priv->irq_enabled = 1;
+	
+	/* Send all of the commands that must be sent prior to 
+	 * HOST_COMPLETE */
+	if (ipw2100_adapter_setup(priv)) {
+		printk(KERN_ERR "%s: Failed to start the card.\n", 
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+	
+        /* Enable the adapter - sends HOST_COMPLETE */
+	if (ipw2100_enable_adapter(priv)) {
+		printk(KERN_ERR "%s: failed in call to enable adapter.\n",
+		       priv->ndev->name);
+		rc = 1;
+		goto exit;
+	}
+
+	/* Start a scan . . . */
+	ipw2100_start_scan(priv);
+
+ exit:
+	return rc;
+}
+
+
+static void ipw2100_down(struct ipw2100_priv *priv)
+{
+	unsigned long flags;
+
+	/* Kill the RF switch timer */
+	if (!priv->stop_rf_check) {
+		priv->stop_rf_check = 1;
+		del_timer_sync(&priv->rf_switch_timer);
+	}
+	
+	/* Kill the firmare hang check timer */
+	if (!priv->stop_hang_check) {
+		priv->stop_hang_check = 1;
+		del_timer_sync(&priv->hang_check_timer);
+	}
+
+	/* Make sure the interrupt is on so that FW commands will be 
+	 * processed correctly */
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (!priv->irq_enabled) {
+		ipw2100_hw_enable_interrupt(priv);
+		priv->irq_enabled = 1;
+	}
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+	
+	if (ipw2100_hw_stop_adapter(priv)) 
+		printk(KERN_ERR "%s: Error stopping adapter.\n", 
+		       priv->ndev->name);
+	
+	/* Do not disable the interrupt until _after_ we disable
+	 * the adaptor.  Otherwise the CARD_DISABLE command will never
+	 * be ack'd by the firmware */
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (priv->irq_enabled) {
+		ipw2100_hw_disable_interrupt(priv);
+		priv->irq_enabled = 0;
+	}
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+}
+
+static void ipw2100_reset_adapter(struct ipw2100_priv *priv)
+{
+	printk(KERN_INFO DRV_NAME ": %s: Restarting adapter.\n", 
+	       priv->ndev->name);
+
+	priv->resets++;
+	priv->connected = 0;
+	
+	/* Force a power cycle even if interface hasn't been opened
+	 * yet */
+	priv->reset_pending = 1;
+	memset(priv->key_table, 0, sizeof(priv->key_table));
+	memset(priv->key_size, 0, sizeof(priv->key_size));
+	priv->key_current = 0;
+	priv->authentication = 0;
+
+	ipw2100_up(priv);
+
+}
+
+
+static void isr_indicate_associated(struct ipw2100_priv *priv, u32 status)
+{
+
+#define MAC_ASSOCIATION_READ_DELAY (HZ)
+	int ret;
+	int len;
+	char essid[IW_ESSID_MAX_SIZE + 1];
+	u32 txrate;
+	u32 chan;
+	char *txratename;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/*
+	 * TBD: BSSID is usually 00:00:00:00:00:00 here and not
+	 *      an actual MAC of the AP. Seems like FW sets this
+	 *      address too late. Read it later and expose through 
+	 *      /proc or schedule a later task to query and update
+	 */
+#if 0
+	len = ETH_ALEN;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, 
+				  &priv->ctx->bssid,  &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+#endif
+
+	memset(essid, 0, IW_ESSID_MAX_SIZE + 1);
+
+	len = IW_ESSID_MAX_SIZE;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID, 
+				  essid, &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+
+	len = sizeof(u32);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, 
+				  &txrate, &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+
+	len = sizeof(u32);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &len);
+	if (ret) {
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+		return;
+	}
+
+	switch (txrate) {
+	case TX_RATE_1_MBIT:
+		txratename = "1Mbps";
+		break;
+	case TX_RATE_2_MBIT:
+		txratename = "2Mbsp";
+		break;
+	case TX_RATE_5_5_MBIT:
+		txratename = "5.5Mbps";
+		break;
+	case TX_RATE_11_MBIT:
+		txratename = "11Mbps";
+		break;
+	default:
+		txratename = "unknown rate";
+		break;
+	}
+
+	printk(KERN_INFO DRV_NAME 
+	       ": Associated with '%s' at %s, channel %d\n",
+	       essid, txratename, chan);
+
+	/* now we copy read ssid into dev */
+	memcpy(priv->ctx->ssid, essid, IW_ESSID_MAX_SIZE);
+	priv->ctx->channel = chan;
+
+	priv->connected = 1;
+	netif_carrier_on(priv->ndev);
+	netif_wake_queue(priv->ndev);
+}
+
+static void isr_indicate_association_lost(struct ipw2100_priv *priv, u32 status)
+{
+#if 0
+	struct host_command cmd = {
+		.host_command = BROADCAST_SCAN,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+	};
+#endif
+
+	printk(KERN_DEBUG "%s: Association lost.\n", priv->ndev->name);
+
+	IPW2100_DEBUG_INFO("TODO: only scan if scanning enabled and "
+	       "radio is on\n");
+
+	IPW2100_DEBUG_INFO("TODO: Move broadcast_scan initiation to scheduled "
+	       "work\n");
+
+#if 0
+	ipw2100_hw_send_command(priv, &cmd);
+#endif
+
+	priv->connected = 0;
+	netif_carrier_off(priv->ndev);
+	netif_stop_queue(priv->ndev);
+}
+
+static void isr_indicate_rf_kill(struct ipw2100_priv *priv, u32 status)
+{
+	IPW2100_DEBUG_RF_KILL("RF Kill state changed to radio OFF.\n");
+
+	/* RF_KILL is now enabled (else we wouldn't be here) */
+	priv->rf_kill = 1;
+
+	/* If not already running, we now fire up a timer that will poll
+	 * the state of the RF switch on the hardware so we can re-enable
+	 * the firmware if the switch is enabled */
+	if (priv->stop_rf_check) {
+		priv->stop_rf_check = 0;
+		priv->rf_switch_timer.expires = jiffies + HZ;
+		add_timer(&priv->rf_switch_timer);
+	}
+}
+
+static void isr_scan_complete(struct ipw2100_priv *priv, u32 status)
+{
+	IPW2100_DEBUG_SCAN("scan complete\n");
+}
+
+#ifdef CONFIG_IPW2100_DEBUG
+#define IPW2100_HANDLER(v, f) { v, f, # v }
+struct ipw2100_status_indicator {
+	int status;
+	void (*cb)(struct ipw2100_priv *priv, u32 status);
+	char *name;
+};
+#else
+#define IPW2100_HANDLER(v, f) { v, f }
+struct ipw2100_status_indicator {
+	int status;
+	void (*cb)(struct ipw2100_priv *priv, u32 status);
+};
+#endif /* CONFIG_IPW2100_DEBUG */
+
+const struct ipw2100_status_indicator status_handlers[] = {
+	IPW2100_HANDLER(STATUS_INIT_COMPLETE, 0),
+	IPW2100_HANDLER(STATUS_COUNTRY_FOUND, 0),
+	IPW2100_HANDLER(STATUS_ASSOCIATED, isr_indicate_associated),
+	IPW2100_HANDLER(STATUS_ASSN_LOST, isr_indicate_association_lost),
+	IPW2100_HANDLER(STATUS_ASSN_CHANGED, 0),
+	IPW2100_HANDLER(STATUS_SCAN_COMPLETE, isr_scan_complete),
+	IPW2100_HANDLER(STATUS_ENTERED_PSP, 0),
+	IPW2100_HANDLER(STATUS_WAKEN_FROM_PSP, 0),
+	IPW2100_HANDLER(STATUS_RF_KILL_SWITCH, isr_indicate_rf_kill),
+	IPW2100_HANDLER(STATUS_CARD_DISABLE_COMPLETE, 0),
+	IPW2100_HANDLER(STATUS_PREP_PWR_DOWN_COMPLETE, 0),
+	IPW2100_HANDLER(STATUS_SCANNING, 0),
+	IPW2100_HANDLER(-1, 0)
+};
+
+static void isr_status_change(struct ipw2100_priv *priv, int status)
+{
+	int i;
+
+	for (i = 0; status_handlers[i].status != -1; i++) {
+		if (status == status_handlers[i].status) {
+			IPW2100_DEBUG_STATUS("Status change: %s\n", 
+					     status_handlers[i].name);
+			if (status_handlers[i].cb)
+				status_handlers[i].cb(priv, status);
+			priv->wstats.status = status;
+			return;
+		}
+	}
+
+	IPW2100_DEBUG_STATUS("unknown status received: %04x\n", status);
+}
+
+static void isr_indicate_host_notification(struct ipw2100_priv *priv,
+					   struct ipw2100_notification * hdr)
+{
+
+#ifdef CONFIG_IPW2100_DEBUG
+
+	char *notif;
+
+	switch (hdr->hnhdr_subtype) {
+	case TYPE_SWEEP_ORD:
+		notif = "TYPE_SWEEP_ORD";
+		break;
+	case TYPE_IBSS_STTN_ORD:
+		notif = "TYPE_IBSS_STTN_ORD";
+		break;
+	case TYPE_BSS_AP_ORD:
+		notif = "TYPE_BSS_AP_ORD";
+		break;
+	case TYPE_CALIBRATION_DATA:
+		notif = "TYPE_CALIBRATION_DATA";
+		break;
+	case TYPE_RAW_BEACON_ENTRY:
+		notif = "TYPE_RAW_BEACON_ENTRY";
+		break;
+	case TYPE_ROGUE_AP_DATA:
+		notif = "TYPE_ROGUE_AP_DATA";
+		break;
+	case TYPE_ASSOCIATION_REQUEST:
+		notif = "TYPE_ASSOCIATION_REQUEST";
+		break;
+	case TYPE_REASSOCIATION_REQUEST:
+		notif = "TYPE_REASSOCIATION_REQUEST";
+		break;
+	default:
+		notif = "*UNKNOWN*";
+		break;
+	}
+
+	IPW2100_DEBUG_INFO("received %s host notification, size %d\n",
+	     notif, hdr->hnhdr_size);
+#endif
+}
+
+
+
+static void isr_rx_complete_command(
+	struct ipw2100_priv *priv,
+	struct ipw2100_cmd_header *cmd)
+{
+#ifdef CONFIG_IPW2100_DEBUG
+	if (cmd->host_command_reg < sizeof(command_types) / 
+	    sizeof(*command_types)) {
+		IPW2100_DEBUG_RX("Command '%s (%d)' completed\n",
+				 command_types[cmd->host_command_reg],
+				 cmd->host_command_reg);
+	}
+#endif
+	if (cmd->host_command_reg == HOST_COMPLETE) {
+		priv->disabled = 0;
+	}
+	if (cmd->host_command_reg == CARD_DISABLE) {
+		priv->disabled = 1;
+	}
+	if (cmd->host_command_reg == CARD_DISABLE_PHY_OFF) {
+		priv->phy_off = 1;
+	}
+
+	priv->message_sending = 0;
+
+	wake_up_interruptible_sync(&priv->wait_command_queue);
+
+#ifdef CONFIG_IPW2100_DEBUG
+	IPW2100_DEBUG_INFO("received command status:\n");
+	IPW2100_DEBUG_INFO("    CMD    = %d\n", cmd->host_command_reg);
+	IPW2100_DEBUG_INFO("    CMD1   = %08x\n", cmd->host_command_reg1);
+	IPW2100_DEBUG_INFO("    SEQ    = %d\n", cmd->sequence);
+	IPW2100_DEBUG_INFO("    STATUS = %d\n", cmd->cmd_status_reg);
+#endif
+
+}
+
+static  void isr_handle_ctl_packet(
+	struct ipw2100_priv *priv, 
+	struct ipw2100_802_11_header *header,
+	struct ipw2100_status *status)
+{
+	IPW2100_DEBUG_RX("Ignoring control frame.\n");
+}
+
+static inline void isr_beacon_add(
+	struct ipw2100_priv *priv,
+	struct ipw2100_802_11_probe_response *new_beacon,
+	s8 rssi)
+{
+	struct list_head *element;
+	struct ipw2100_beacon *beacon;
+	struct ipw2100_802_11_info_element *info_element;
+
+	element = priv->beacon_free_list.next;
+	
+	beacon = list_entry(element, struct ipw2100_beacon, list);
+	
+	/* Pull out fixed field data */
+	memcpy(beacon->bssid, new_beacon->header.address3, ETH_ALEN);
+	beacon->capability = new_beacon->capability;
+	beacon->rssi = rssi;
+	
+	/* First info element is the SSID */
+	info_element = &new_beacon->info_element;
+	if (info_element->id != MFIE_TYPE_SSID) {
+		printk(KERN_INFO DRV_NAME ": invalid MFIE type for SSID.\n");
+		IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+				   info_element->id);
+		return;
+	}
+	beacon->ssid_len = min(info_element->len, SSID_LENGTH);
+	memcpy(beacon->ssid, info_element->data, beacon->ssid_len);
+
+	/* Second info element is the RATES */
+	info_element = (struct ipw2100_802_11_info_element *)
+		&info_element->data[info_element->len];
+	if (info_element->id != MFIE_TYPE_RATES) {
+		printk(KERN_INFO DRV_NAME ": invalid MFIE type for RATES.\n");
+		IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+				   info_element->id);
+		return;
+	}
+	beacon->rates_len = min(info_element->len, MAX_RATES_LENGTH);
+	memcpy(beacon->rates, info_element->data, beacon->rates_len);
+
+	/* Third info element is either FH or DS, based on BSS capability */
+	info_element = (struct ipw2100_802_11_info_element *)
+		&info_element->data[info_element->len];
+	if (beacon->capability & SSID_CAPABILITY_BSS) {
+		/* BSS - Direct Sequence */
+		if (info_element->id != MFIE_TYPE_DS_SET) {
+			printk(KERN_INFO DRV_NAME 
+			       ": invalid MFIE type for DIRECT SEQUENCE.\n");
+			IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+					   info_element->id);
+			return;
+		}
+		
+		beacon->channel = info_element->data[0];
+	} else if (beacon->capability & SSID_CAPABILITY_IBSS) {
+		/* IBSS - Frequency Hop */
+		if (info_element->id != MFIE_TYPE_FH_SET) {
+			printk(KERN_INFO DRV_NAME 
+			       ": invalid MFIE type for FREQ HOP.\n");
+			IPW2100_DEBUG_SCAN("exit - ivalid MFIE type : %d\n",
+					   info_element->id);
+			return;
+		}
+	} else {
+		/* Invalid ESS/IBSS capability! */
+		printk(KERN_INFO DRV_NAME
+		       ": Invalid ESS/IBSS capability (both 0).\n");
+		IPW2100_DEBUG_SCAN("exit - invalid ESS/IBSS capability: %1X\n",
+				   beacon->capability & 0x3);
+		return;
+	}
+
+	/* For now, we ignore the optional CF and IBSS parameter sets */
+
+	list_del(element);
+
+	IPW2100_DEBUG_SCAN("adding '%s' to beacon list.\n", beacon->ssid);
+	
+	list_add_tail(&beacon->list, &priv->beacon_list);
+}
+
+static void isr_process_probe_response(
+	struct ipw2100_priv *priv,
+	struct ipw2100_802_11_probe_response *new_beacon,
+	s8 rssi)
+{
+	struct ipw2100_802_11_info_element *ssid_info;
+	struct list_head *element;
+	struct ipw2100_beacon *beacon;
+	u8 ssid_len;
+
+	IPW2100_DEBUG_MANAGEMENT(
+		"\n"
+		"Time Stamp 1    : %08X\n"
+		"Time Stamp 2    : %08X\n"
+		"Beacon Interval : %04X\n"
+		"Capabilities    : %c%c%c%c%c%c%c000000000\n",
+		new_beacon->time_stamp[0],
+		new_beacon->time_stamp[1],
+		new_beacon->beacon_interval,
+		(new_beacon->capability & 1) ? '1' : '0',
+		(new_beacon->capability & 2) ? '1' : '0',
+		(new_beacon->capability & 4) ? '1' : '0',
+		(new_beacon->capability & 8) ? '1' : '0',
+		(new_beacon->capability & 10) ? '1' : '0',
+		(new_beacon->capability & 20) ? '1' : '0',
+		(new_beacon->capability & 40) ? '1' : '0');
+
+	ssid_info = &new_beacon->info_element;
+	if (ssid_info->id != MFIE_TYPE_SSID) {
+		printk(KERN_INFO DRV_NAME ": invalid MFIE type for SSID.\n");
+		IPW2100_DEBUG_SCAN("exit - invalid MFIE type for SSID: %d\n",
+				   ssid_info->id);
+		return;
+	}
+
+	ssid_len = min(ssid_info->len, SSID_LENGTH);
+
+	IPW2100_DEBUG_SCAN("enter\n");
+
+	for (element = priv->beacon_list.next;
+	     element != &priv->beacon_list;
+	     element = element->next) {
+		beacon = list_entry(element, struct ipw2100_beacon, list);
+		if (!memcmp(beacon->bssid, new_beacon->header.address3, 
+			    ETH_ALEN) &&
+		    !memcmp(beacon->ssid, ssid_info->data, ssid_len))
+			return;
+	}
+
+	if (list_empty(&priv->beacon_free_list)) {
+		IPW2100_DEBUG_SCAN("TODO: Expire oldest beacon to add new.\n");
+		printk(KERN_WARNING DRV_NAME ": Beacon free list is empty.\n");
+	} else 
+		isr_beacon_add(priv, new_beacon, rssi);
+
+	IPW2100_DEBUG_SCAN("exit\n");
+}
+	
+static void isr_handle_mgt_packet(
+	struct ipw2100_priv *priv, 
+	struct ipw2100_802_11_header *header,
+	struct ipw2100_status *status)
+{
+	char *msg = "UNKNOWN";
+	
+	switch (header->sub_type) {
+	case ASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE:
+		msg = "ASSOCIATION RESPONSE";
+		break;
+	case REASSOCIATION_RESPONSE_802_11_PACKET_SUBTYPE:
+		msg = "REASSOCIATION RESPONSE";
+		break;
+	case PROBE_RESPONSE_802_11_PACKET_SUBTYPE:
+		msg = "PROBE RESPONSE";
+		IPW2100_DEBUG_SCAN("Probe response\n");
+		isr_process_probe_response(
+			priv, (struct ipw2100_802_11_probe_response *)header,
+			status->rssi);
+		break;
+
+	case BEACON_802_11_PACKET_SUBTYPE:
+		msg = "BEACON";
+		break;
+	default:
+		printk(KERN_DEBUG "%s: Unknown management packet: %d\n",
+		       priv->ndev->name, header->sub_type);
+		break;
+	}
+
+	IPW2100_DEBUG_RX("received %s(%d)\n", msg, header->sub_type);
+}
+
+
+
+#ifdef CONFIG_IPW2100_DEBUG
+const char *frame_types[] = {
+	"COMMAND_STATUS_VAL",
+	"STATUS_CHANGE_VAL",
+	"P80211_DATA_VAL",
+	"P8023_DATA_VAL",
+	"HOST_NOTIFICATION_VAL"
+};
+#endif
+
+
+const char snap_bridge[] = {
+	0xAA, 0xAA, 0x03, 0x00, 0x00, 0xF8
+};
+
+const char snap_tunnel[] = {
+	0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00
+};
+
+
+static inline struct ipw2100_hw_packet *ipw2100_alloc_skb(
+	struct ipw2100_priv *priv,
+	struct ipw2100_hw_packet *packet)
+{
+	packet->skb = dev_alloc_skb(sizeof(struct ipw2100_rx_packet));
+	
+	if (!packet->skb)
+		return NULL;
+
+	packet->rxp = (struct ipw2100_rx_packet *)packet->skb->data;
+	packet->dma_addr = pci_map_single(priv->pdev, packet->skb->data,
+					  sizeof(struct ipw2100_rx_packet),
+					  PCI_DMA_FROMDEVICE);
+	/* NOTE: pci_map_single does not return an error code, and 0 is a valid
+	 *       dma_addr */
+	
+#ifndef CONFIG_IPW2100_WEP
+	skb_reserve(packet->skb, IPW_802_11_PAYLOAD_OFFSET);
+#endif /* CONFIG_IPW2100_WEP */
+
+	return packet;
+}
+
+
+/*
+ *
+ * 0) Disconnect the SKB from the firmware (just unmap)
+ * 1) Pack the ETH header into the SKB
+ * 2) Pass the SKB to the network stack
+ *
+ * When packet is provided by the firmware, it contains the following:
+ * 
+ * .  ipw2100_802_11_header
+ * .  ieee_802_11_snap_header
+ * .  payload <= sbk->data was already set to here in ipw2100_alloc_skb
+ *
+ * The size of the constructed ethernet 
+ *
+ */
+static inline int isr_rx(struct ipw2100_priv *priv, int i)
+{
+	struct ipw2100_status *status = &priv->status_queue.drv[i];
+	struct ipw2100_hw_packet *packet = &priv->rx_buffers[i];
+#ifndef CONFIG_IPW2100_WEP
+	struct ipw2100_802_11_header *hdr = &packet->rxp->header;
+	struct sk_buff *skb = NULL;
+#else /* CONFIG_IPW2100_WEP */
+	struct ieee80211_rx_stats stats = {
+		.signal = status->rssi,
+		.noise = IPW2100_RSSI_TO_DBM,
+		.rate = 0,
+		.mac_time = jiffies,
+	};
+#endif /* CONFIG_IPW2100_WEP */
+	unsigned int payload_len;
+	
+	payload_len = status->frame_size - IPW_802_11_PAYLOAD_OFFSET + 
+		ETH_ALEN * 2;
+
+	pci_unmap_single(priv->pdev,
+			 packet->dma_addr,
+			 sizeof(struct ipw2100_rx_packet),
+			 PCI_DMA_FROMDEVICE);
+	
+	if (payload_len > IPW_MAX_802_11_PAYLOAD_LENGTH) {
+		printk(KERN_INFO 
+		       "%s: Packet payload too large (%u) - dropping:\n"
+		       "status packet = \n"
+		       "   bd index      = %d\n"
+		       "   frame_size    = %u\n"
+		       "   status_fields = 0x%04X\n"
+		       "   flags         = 0x%02X\n"
+		       "   rssi          = 0x%02X\n"
+		       "Scheduling firmware restart.\n",
+		       priv->ndev->name, payload_len, i,
+		       status->frame_size, status->status_fields,
+		       status->flags, status->rssi);
+
+		priv->fatal_error = 1;
+		priv->stats.rx_errors++;
+		if (!priv->reset_pending) {
+			priv->reset_pending = 1;
+			schedule_work(&priv->reset_work);
+		}
+		wake_up_interruptible_sync(&priv->wait_command_queue);
+
+		return 0;
+	}
+	
+#ifdef CONFIG_IPW2100_WEP
+	skb_put(packet->skb, status->frame_size);
+	return ieee80211_rx(&priv->ieee, packet->skb, &stats);
+
+#else /* CONFIG_IPW2100_WEP */
+
+#ifdef CONFIG_IPW2100_DEBUG
+	if (status->flags & IPW_STATUS_FLAG_DECRYPTED)
+		IPW2100_DEBUG_WEP("Received decrypted packet.\n");
+	if (status->flags & IPW_STATUS_FLAG_WEP_ENCRYPTED)
+		IPW2100_DEBUG_WEP("Received WEP encrypted packet.\n");
+#endif /* CONFIG_IPW2100_DEBUG */
+	/*
+	 * This is the older legacy code that will go away once we fully
+	 * transition to the new WEP code and generic 802.11 stack.
+	 */
+	if (!IS_FRAGMENT(hdr)) {
+		skb = packet->skb;
+		
+		/*
+		 * Build header (two ethernet addresses)
+		 * NOTE: These are in reverse order (since they are pushed)
+		 */
+		memcpy(skb_push(skb, ETH_ALEN), &hdr->address3, ETH_ALEN);
+		memcpy(skb_push(skb, ETH_ALEN), &hdr->address1, ETH_ALEN);
+		
+		/* Advance SKB buffer to include the data DMA'd by the
+		 * firmware */
+		skb_put(skb, payload_len);
+	} else {
+		IPW2100_DEBUG_RX("fragment Rx: %d bytes\n", status->frame_size);
+		skb = ipw2100_defrag_rx(priv, packet, status->frame_size);
+	}
+	
+	priv->ndev->last_rx = jiffies;
+	
+	/* If this was a fragment, then an SKB may not be finished */
+	if (skb) {
+		skb->dev = priv->ndev;
+		skb->protocol = eth_type_trans(skb, priv->ndev);
+		skb->ip_summed = CHECKSUM_NONE;
+		
+		IPW2100_DEBUG_RX("protocol from eth_type_trans=%04x\n",
+				 skb->protocol);
+		
+		priv->stats.rx_packets++;
+		priv->stats.rx_bytes += skb->len;
+		
+		netif_rx(skb);
+	}
+	
+	return 1;
+	
+#endif /* CONFIG_IPW2100_WEP */
+}
+ 
+/*
+ * ipw2100 interrupts are disabled at this point, and the ISR
+ * is the only code that calls this method.  So, we do not need
+ * to play with any locks.  
+ *
+ * RX Queue works as follows:
+ * 
+ * Read index - firmware places packet in entry identified by the 
+ *              Read index and advances Read index.  In this manner, 
+ *              Read index will always point to the next packet to 
+ *              be filled--but not yet valid.
+ *
+ * Write index - driver fills this entry with an unused RBD entry.
+ *               This entry has not filled by the firmware yet.
+ *
+ * In between the W and R indexes are the RBDs that have been received
+ * but not yet processed.  
+ *
+ * The process of handling packets will start at WRITE + 1 and advance
+ * until it reaches the READ index.  
+ *
+ * The WRITE index is cached in the variable 'priv->rx_queue.next'.
+ *
+ */
+static inline void __ipw2100_rx_process(struct ipw2100_priv *priv)
+{
+	struct ipw2100_bd_queue *rxq = &priv->rx_queue;
+	struct ipw2100_status_queue *sq = &priv->status_queue;
+	struct ipw2100_hw_packet *packet;
+	u16 frame_type;
+	u32 frame_size;
+	u32 r, w, i, s;//, j;
+	int handled;
+	struct ipw2100_rx_packet *u;
+	
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_RX_READ_INDEX, &r);
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, &w);
+	
+	if (r >= rxq->entries) {
+		IPW2100_DEBUG_RX("exit - bad read index\n");
+		return;
+	}
+
+	i = (rxq->next + 1) % rxq->entries;
+	s = i;
+	while (i != r) {
+		/* IPW2100_DEBUG_RX("r = %d : w = %d : processing = %d\n",
+		   r, rxq->next, i); */
+		
+		packet = &priv->rx_buffers[i];
+
+		/* Sync the DMA for the STATUS buffer so CPU is sure to get 
+		 * the correct values */
+		pci_dma_sync_single(
+			priv->pdev, 
+			sq->nic + sizeof(struct ipw2100_status) * i,
+			sizeof(struct ipw2100_status),
+			PCI_DMA_FROMDEVICE);
+
+		/* Sync the DMA for the RX buffer so CPU is sure to get 
+		 * the correct values */
+		pci_dma_sync_single(priv->pdev, packet->dma_addr,
+				    sizeof(struct ipw2100_rx_packet),
+				    PCI_DMA_FROMDEVICE);
+		
+		/* !!!!TEST!!!! This is to see if forcing a HW buffer flush
+		 * can fix the C2->C3 data corruption problem */
+		__asm__ __volatile__ ("lock; addl $0,0(%%esp)": : :"memory");
+
+		u = packet->rxp;
+		frame_type = sq->drv[i].status_fields & STATUS_TYPE_MASK;
+		frame_size = sq->drv[i].frame_size;
+		
+		IPW2100_DEBUG_RX("%s: '%s' frame type received (%d).\n",
+				 priv->ndev->name, frame_types[frame_type],
+				 frame_size);
+
+		handled = 0;
+		switch (frame_type) {
+		case COMMAND_STATUS_VAL:
+			if (frame_size == sizeof(u->command))
+			    isr_rx_complete_command(priv, &u->command);
+			break;
+
+		case STATUS_CHANGE_VAL:
+			if (frame_size == sizeof(u->status))
+				isr_status_change(priv, u->status);
+			break;
+
+		case P80211_DATA_VAL:
+		case P8023_DATA_VAL:
+			if (frame_size < sizeof(u->header))
+				break;
+
+			switch (u->header.type) {
+			case MANAGMENT_802_11_PACKET_TYPE:
+				isr_handle_mgt_packet(priv, &u->header,
+						      &sq->drv[i]);
+				break;
+				
+			case CONTROL_802_11_PACKET_TYPE:
+				isr_handle_ctl_packet(priv, &u->header,
+						      &sq->drv[i]);
+				break;
+				
+			case DATA_802_11_PACKET_TYPE:
+				/* We only process data packets if the interface
+				 * is open */
+				if (!priv->open) {
+					priv->wstats.discard.misc++;
+					IPW2100_DEBUG_RX(
+						"Dropping packet while "
+						"interface is not up.\n");
+					break;
+				}
+
+				handled = isr_rx(priv, i);
+				if (handled) 
+					break;
+				
+                                /* Remap the DMA address */
+				packet->dma_addr = pci_map_single(
+					priv->pdev, 
+					packet->skb->data,
+					sizeof(struct ipw2100_rx_packet),
+					PCI_DMA_FROMDEVICE);
+				
+				/* Update the RDB entry */
+				rxq->drv[i].host_addr = packet->dma_addr;
+				
+				break;
+				
+			default:
+				priv->wstats.discard.misc++;
+				IPW2100_DEBUG_RX("received unknown packet "
+						 "type, dropping...\n");
+				break;
+			}
+			break;
+
+		case HOST_NOTIFICATION_VAL:
+			if (frame_size >= sizeof(u->notification))
+			    isr_indicate_host_notification(priv, 
+							   &u->notification);
+			break;
+
+		default:
+			priv->wstats.discard.misc++;
+			IPW2100_DEBUG_WARNING(
+				"received unknown frame type: %d, "
+				"ignoring...\n", frame_type);
+			break;
+		}
+
+		if (handled) {
+			/* packet was sent; the function that sent it will
+			 * unmap and disconnect from this RDB.  We must 
+			 * allocate a new SKB and attach it. */
+			packet = ipw2100_alloc_skb(priv, packet);
+			if (!packet) {
+				printk(KERN_WARNING 
+				      "Unable to allocate SKB onto RBD ring - "
+				      "disabling adapter.\n");
+				/* TODO: schedule adapter shutdown */
+				IPW2100_DEBUG_INFO("TODO: Shutdown adapter...\n");
+				break;
+			}
+
+			/* Update the RBD to refer to the new region */
+			rxq->drv[i].host_addr = packet->dma_addr;
+		}
+		
+		/* clear status field associated with this RBD */
+		rxq->drv[i].status.field = 0;
+
+		i = (i + 1) % rxq->entries;
+	}
+
+	if (i != s) {
+		/* backtrack one entry, wrapping to end if at 0 */
+		rxq->next = (i ? i : rxq->entries) - 1;
+	
+		write_register(priv->ndev,
+			       IPW_MEM_HOST_SHARED_RX_WRITE_INDEX,
+			       rxq->next);
+	}
+}
+
+
+/*
+ * __ipw2100_tx_process
+ *
+ * This routine will determine whether the next packet on
+ * the fw_pend_list has been processed by the firmware yet.
+ *
+ * If not, then it does nothing and returns.
+ *
+ * If so, then it removes the item from the fw_pend_list, frees
+ * any associated storage, and places the item back on the
+ * free list of its source (either msg_free_list or tx_free_list)
+ *
+ * TX Queue works as follows:
+ * 
+ * Read index - points to the next TBD that the firmware will 
+ *              process.  The firmware will read the data, and once
+ *              done processing, it will advance the Read index.
+ *
+ * Write index - driver fills this entry with an constructed TBD 
+ *               entry.  The Write index is not advanced until the
+ *               packet has been configured.
+ *
+ * In between the W and R indexes are the TBDs that have NOT been 
+ * processed.  Lagging behind the R index are packets that have
+ * been processed but have not been freed by the driver.
+ *
+ * In order to free old storage, an internal index will be maintained
+ * that points to the next packet to be freed.  When all used
+ * packets have been freed, the oldest index will be the same as the
+ * firmware's read index.
+ *
+ * The OLDEST index is cached in the variable 'priv->tx_queue.oldest'
+ *
+ * Because the TBD structure can not contain arbitrary data, the
+ * driver must keep an internal queue of cached allocations such that
+ * it can put that data back into the tx_free_list and msg_free_list
+ * for use by future command and data packets.
+ *
+ */
+static inline int __ipw2100_tx_process(struct ipw2100_priv *priv)
+{
+	struct ipw2100_bd_queue *txq = &priv->tx_queue;
+        struct ipw2100_bd *tbd;
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	int descriptors_used;
+	int e, i;
+	u32 r, w, frag_num = 0;
+
+	if (list_empty(&priv->fw_pend_list)) {
+		return 0;
+	}
+	
+	element = priv->fw_pend_list.next;
+
+	packet = list_entry(element, struct ipw2100_hw_packet, list);
+        tbd = &txq->drv[packet->index];
+
+	/* Determine how many TBD entries must be finished... */
+	switch (packet->type) {
+	case COMMAND:
+		/* COMMAND uses only one slot; don't advance */
+		descriptors_used = 1;
+		e = txq->oldest;
+		break;
+
+	case DATA:
+		/* DATA uses two slots; advance and loop position. */
+		descriptors_used = tbd->num_fragments;
+                frag_num = tbd->num_fragments - 1;
+		e = txq->oldest + frag_num;
+		e %= txq->entries;
+		break;
+
+	default:
+		IPW2100_DEBUG_WARNING("%s: Bad fw_pend_list entry!\n", 
+				   priv->ndev->name);
+		return 0;
+	}
+
+	/* if the last TBD is not done by NIC yet, then packet is
+	 * not ready to be released. 
+	 * 
+	 */
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(0), 
+		      &r);
+	read_register(priv->ndev, IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0), 
+		      &w);
+	if (w != txq->next) 
+		printk(KERN_WARNING "%s: write index mismatch\n", 
+		       priv->ndev->name);
+
+        /*
+	 * txq->next is the index of the last packet written txq->oldest is 
+	 * the index of the r is the index of the next packet to be read by 
+	 * firmware
+	 */
+
+
+	/* 
+	 * Quick graphic to help you visualize the following
+	 * if / else statement
+	 * 
+	 * ===>|                     s---->|===============
+	 *                               e>|
+	 * | a | b | c | d | e | f | g | h | i | j | k | l 
+	 *       r---->|
+	 *               w
+	 *
+	 * w - updated by driver
+	 * r - updated by firmware
+	 * s - start of oldest BD entry (txq->oldest)
+	 * e - end of oldest BD entry
+	 *
+	 */
+	if (!((r <= w && (e < r || e >= w)) ||
+	      (e < r && e >= w))) { 
+		IPW2100_DEBUG_TX("exit - no processed packets ready to "
+				 "release.\n");
+		return 0;
+	}
+
+	list_del(element);
+
+#ifdef CONFIG_IPW2100_DEBUG
+	{
+		int i;
+		i = (txq->oldest + 1) % txq->entries;
+		IPW2100_DEBUG_TX(
+			"TX%d V=%p P=%p T=%p L=%d\n", i,
+			&txq->drv[i],
+			(void*)txq->nic + i * sizeof(struct ipw2100_bd),
+			(void*)txq->drv[i].host_addr,
+			txq->drv[i].buf_length);
+		
+		if (packet->type == DATA) {
+			i = (i + 1) % txq->entries;
+			
+			IPW2100_DEBUG_TX(
+				"TX%d V=%p P=%p T=%p L=%d\n", i,
+				&txq->drv[i],
+				(void*)txq->nic + i * sizeof(struct ipw2100_bd),
+				(void*)txq->drv[i].host_addr,
+				txq->drv[i].buf_length);
+		}
+	}
+#endif
+ 
+	switch (packet->type) {
+	case DATA:
+		if (txq->drv[txq->oldest].status.txType != 0) 
+			printk(KERN_WARNING "%s: Queue mismatch.  "
+			       "Expecting DATA TBD but pulled "
+			       "something else: ids %d=%d.\n", 
+			       priv->ndev->name, txq->oldest, packet->index);
+		
+		/* DATA packet; we have to free the SKB */
+		if (packet->skb) {
+			priv->stats.tx_packets++;
+			priv->stats.tx_bytes += packet->skb->len;
+                        for (i = 0; i < frag_num; i++) {
+                                tbd = &txq->drv[(packet->index + 1 + i) \
+                                                % txq->entries];
+                                IPW2100_DEBUG_TX(
+					"TX%d P=%08x L=%d\n",
+					(packet->index +1 +i) % txq->entries,
+					tbd->host_addr, tbd->buf_length);
+                                pci_unmap_single(priv->pdev,
+                                                 tbd->host_addr,
+                                                 tbd->buf_length,
+                                                 PCI_DMA_TODEVICE);
+                        }
+
+			dev_kfree_skb_irq(packet->skb);
+			packet->skb = NULL;
+		} else 
+			printk(KERN_WARNING "%s: Bad state.  SKB is NULL!\n",
+			       priv->ndev->name);
+
+		list_add_tail(element, &priv->tx_free_list);
+
+		/* We have a free slot in the Tx queue, so wake up the
+		 * transmit layer if it is stopped. */
+		if (netif_queue_stopped(priv->ndev))
+			netif_wake_queue(priv->ndev);
+		break;
+
+	case COMMAND:
+		if (txq->drv[txq->oldest].status.txType != 1) 
+			printk(KERN_WARNING "%s: Queue mismatch.  "
+			       "Expecting COMMAND TBD but pulled "
+			       "something else: ids %d=%d.\n", 
+			       priv->ndev->name, txq->oldest, packet->index);
+
+#ifdef CONFIG_IPW2100_DEBUG
+		if (packet->cmd->host_command_reg <
+		    sizeof(command_types) / sizeof(*command_types)) 
+			IPW2100_DEBUG_TX(
+				"Command '%s (%d)' processed: %d.\n",
+				command_types[packet->cmd->host_command_reg],
+				packet->cmd->host_command_reg,
+				packet->cmd->cmd_status_reg);
+#endif
+
+		list_add_tail(element, &priv->msg_free_list);
+		break;
+	}
+        
+	/* advance oldest used TBD pointer to start of next entry */
+	txq->oldest = (e + 1) % txq->entries;
+	/* increase available TBDs number */
+	txq->available += descriptors_used;
+
+	IPW2100_DEBUG_TX("packet latency (send to process)  %ld jiffies\n",
+			 jiffies - packet->jiffy_start);
+	
+	return (!list_empty(&priv->fw_pend_list));
+}
+
+
+static inline void __ipw2100_tx_complete(struct ipw2100_priv *priv)
+{
+	int i = 0;
+
+	while (__ipw2100_tx_process(priv) && i < 200) i++;
+
+	if (i == 200) {
+		printk(KERN_WARNING 
+		       "%s: Driver is running slow (%d iters).\n",
+		       priv->ndev->name, i);
+	}
+}
+
+
+static void X__ipw2100_tx_send_commands(struct ipw2100_priv *priv)
+{
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	struct ipw2100_bd_queue *txq = &priv->tx_queue;
+	struct ipw2100_bd *tbd;
+	int next = txq->next;
+
+	while (!list_empty(&priv->msg_pend_list)) {
+		/* if there isn't enough space in TBD queue, then
+		 * don't stuff a new one in. 
+		 * NOTE: 3 are needed as a command will take one,
+		 *       and there is a minimum of 2 that must be
+		 *       maintained between the r and w indexes
+		 */
+		if (txq->available <= 3) {
+			IPW2100_DEBUG_TX("no room in tx_queue\n");
+			break;
+		}
+
+		element = priv->msg_pend_list.next;
+		list_del(element);
+
+		packet = list_entry(element, 
+				    struct ipw2100_hw_packet, list);
+		
+		IPW2100_DEBUG_TX("using TBD at virt=%p, phys=%p\n",
+				 &txq->drv[txq->next],
+				 (void*)(txq->nic + txq->next * 
+					 sizeof(struct ipw2100_bd)));
+
+		packet->index = txq->next;
+
+		tbd = &txq->drv[txq->next];
+
+		/* initialize TBD */
+		tbd->host_addr = packet->cmd_phys;
+		tbd->buf_length = sizeof(struct ipw2100_cmd_header);
+		/* not marking number of fragments causes problems 
+		 * with f/w debug version */
+		tbd->num_fragments = 1;
+		tbd->status.field =
+			IPW_BD_STATUS_TX_FRAME_COMMAND |
+			IPW_BD_STATUS_TX_INTERRUPT_ENABLE;
+
+		/* update TBD queue counters */
+		txq->next++;
+		txq->next %= txq->entries;
+		txq->available--;
+
+		list_add_tail(element, &priv->fw_pend_list);
+	}
+
+	if (txq->next != next) {
+		/* kick off the DMA by notifying firmware the 
+		 * write index has moved; make sure TBD stores are sync'd */
+		wmb();
+		write_register(priv->ndev, 
+			       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0),
+			       txq->next);
+	}
+}
+
+
+/*
+ * X__ipw2100_tx_send_data
+ *
+ */
+static void X__ipw2100_tx_send_data(struct ipw2100_priv *priv)
+{
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+	struct ipw2100_bd_queue *txq = &priv->tx_queue;
+	struct ipw2100_bd *tbd;
+	int next = txq->next;
+        u32 frag_num, msdu_frag_threshold, frag_last_size, frag_size;
+        int i = 0;
+
+	while (!list_empty(&priv->tx_pend_list)) {
+		/* if there isn't enough space in TBD queue, then
+		 * don't stuff a new one in. 
+		 * NOTE: 4 are needed as a data will take two,
+		 *       and there is a minimum of 2 that must be
+		 *       maintained between the r and w indexes
+		 */
+		if (txq->available <= 4) {
+			IPW2100_DEBUG_TX("no room in tx_queue\n");
+			break;
+		}
+		
+		element = priv->tx_pend_list.next;
+                packet = list_entry(element, struct ipw2100_hw_packet, list);
+
+		/* Determine final fragment size and number of fragments */
+                msdu_frag_threshold = ipw2100_msdu_frag_threshold(priv);
+                frag_num = packet->skb->len / msdu_frag_threshold;
+                frag_last_size = packet->skb->len % msdu_frag_threshold;
+		if (frag_last_size)
+			frag_num++;
+		else
+			frag_last_size = msdu_frag_threshold;
+
+                if (txq->available <= 3 + frag_num) {
+                        IPW2100_DEBUG_TX("no room in tx_queue for "
+					 "fragments \n");
+                        break;
+                }
+
+		list_del(element);
+
+		tbd = &txq->drv[txq->next];
+
+		packet->index = txq->next;
+
+		tbd->host_addr = packet->data_phys;
+		tbd->buf_length = sizeof(struct ipw2100_data_header);
+		tbd->num_fragments = 1 + frag_num; /* TX header, and data */
+		tbd->status.field =
+			IPW_BD_STATUS_TX_FRAME_802_3 |
+			IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;
+		txq->next++;
+		txq->next %= txq->entries;
+
+		frag_size = msdu_frag_threshold;
+		IPW2100_DEBUG_TX(
+			"data header tbd skb->len:%d TX%d P=%08x L=%d\n", 
+			packet->skb->len, packet->index, tbd->host_addr, 
+			tbd->buf_length);
+#ifdef CONFIG_IPW2100_DEBUG		
+		if (frag_num > 1) 
+			IPW2100_DEBUG_FRAG("fragment Tx: %d frames\n", 
+					   frag_num);
+#endif
+
+                for (i = 0; i < frag_num; i++) {
+		        tbd = &txq->drv[txq->next];
+			txq->next++;
+			txq->next %= txq->entries;
+
+			/* If this is the last fragment, then set the final
+			 * fragmentation size accordingly, and turn on
+			 * interrupt firing */
+			if (i == frag_num - 1) {
+				frag_size = frag_last_size;
+				tbd->status.field = 
+					IPW_BD_STATUS_TX_FRAME_802_3 |
+					IPW_BD_STATUS_TX_INTERRUPT_ENABLE;
+			} else
+				tbd->status.field =
+					IPW_BD_STATUS_TX_FRAME_802_3 |
+					IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;
+			
+			tbd->buf_length = frag_size;
+ 
+                        tbd->host_addr = pci_map_single(
+				priv->pdev, 
+				packet->skb->data + i * msdu_frag_threshold,
+				frag_size, PCI_DMA_TODEVICE);
+			/* NOTE: pci_map_single does not return an error code, 
+			 *       and 0 is a valid dma_addr */
+
+			IPW2100_DEBUG_TX(
+				"data frag tbd TX%d P=%08x L=%d\n", 
+				txq->next == 0 ? txq->entries -1 : 
+				txq->next - 1,
+				tbd->host_addr, tbd->buf_length);
+
+			pci_dma_sync_single(priv->pdev,
+                                            tbd->host_addr,
+                                            tbd->buf_length,
+                                            PCI_DMA_TODEVICE);
+
+                }
+		
+		txq->available -= 1 + frag_num;
+
+		list_add_tail(element, &priv->fw_pend_list);
+	}
+
+	if (txq->next != next) {
+		/* A packet was handed to the hardware, so update the 
+		 * watchdog */
+		priv->ndev->trans_start = jiffies;
+
+		/* kick off the DMA by notifying firmware the 
+		 * write index has moved; make sure TBD stores are sync'd */
+		write_register(priv->ndev, 
+			       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0),
+			       txq->next);
+	}
+        return;
+}
+
+static void ipw2100_irq_tasklet(struct ipw2100_priv *priv)
+{
+	struct net_device *dev = priv->ndev;
+	unsigned long flags;
+	u32 inta, tmp;
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+	ipw2100_hw_disable_interrupt(priv);
+
+	read_register(dev, IPW_REG_INTA, &inta);
+			 
+	IPW2100_DEBUG_ISR("enter - INTA: 0x%08lX\n", 
+			  (unsigned long)inta & IPW_INTERRUPT_MASK);
+
+	priv->in_isr++;
+	priv->interrupts++;
+
+	/* We do not loop and keep polling for more interrupts as this
+	 * is frowned upon and doesn't play nicely with other potentially
+	 * chained IRQs */
+	IPW2100_DEBUG_ISR("INTA: 0x%08lX\n", 
+			  (unsigned long)inta & IPW_INTERRUPT_MASK);
+
+	if (inta & IPW2100_INTA_FATAL_ERROR) {
+		printk(KERN_WARNING DRV_NAME 
+		       ": Fatal interrupt. Scheduling firmware restart.\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_FATAL_ERROR);
+		/* Wake up any sleeping jobs */
+		priv->fatal_error = 1;
+		if (!priv->reset_pending) {
+			priv->reset_pending = 1;
+			schedule_work(&priv->reset_work);
+		}
+		wake_up_interruptible_sync(&priv->wait_command_queue);
+	}
+	
+	if (inta & IPW2100_INTA_PARITY_ERROR) {
+		IPW2100_DEBUG_ERROR("***** PARITY ERROR INTERRUPT !!!! \n");
+		write_register(
+			dev, IPW_REG_INTA, 
+			IPW2100_INTA_PARITY_ERROR);
+	}
+
+	if (inta & IPW2100_INTA_RX_TRANSFER) {
+		IPW2100_DEBUG_ISR("RX interrupt\n");
+
+		priv->rx_interrupts++;
+
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_RX_TRANSFER);
+		
+		__ipw2100_rx_process(priv);
+		__ipw2100_tx_complete(priv);
+	}
+	
+	if (inta & IPW2100_INTA_TX_TRANSFER) {
+		IPW2100_DEBUG_ISR("TX interrupt\n");
+
+		priv->tx_interrupts++;
+		
+		write_register(dev, IPW_REG_INTA,
+			       IPW2100_INTA_TX_TRANSFER);
+		
+		__ipw2100_tx_complete(priv);
+		X__ipw2100_tx_send_commands(priv);
+		X__ipw2100_tx_send_data(priv);
+	}
+	
+	if (inta & IPW2100_INTA_TX_COMPLETE) {
+		IPW2100_DEBUG_ISR("TX complete\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_TX_COMPLETE);
+		
+		__ipw2100_tx_complete(priv);
+	}
+	
+	if (inta & IPW2100_INTA_EVENT_INTERRUPT) {
+		/* ipw2100_handle_event(dev); */
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_EVENT_INTERRUPT);
+	}
+	
+	if (inta & IPW2100_INTA_FW_INIT_DONE) {
+		IPW2100_DEBUG_ISR("FW init done interrupt\n");
+		
+		read_register(dev, IPW_REG_INTA, &tmp);
+		if (tmp & (IPW2100_INTA_FATAL_ERROR |
+			   IPW2100_INTA_PARITY_ERROR)) {
+			write_register(
+				dev, IPW_REG_INTA,
+				IPW2100_INTA_FATAL_ERROR |
+				IPW2100_INTA_PARITY_ERROR);
+		}
+		
+		write_register(dev, IPW_REG_INTA,
+			       IPW2100_INTA_FW_INIT_DONE);
+	}
+	
+	if (inta & IPW2100_INTA_STATUS_CHANGE) {
+		IPW2100_DEBUG_ISR("Status change interrupt\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_STATUS_CHANGE);
+	}
+	
+	if (inta & IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE) {
+		IPW2100_DEBUG_ISR("slave host mode interrupt\n");
+		write_register(
+			dev, IPW_REG_INTA,
+			IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE);
+	}
+	
+	priv->in_isr--;
+	ipw2100_hw_enable_interrupt(priv);
+	priv->irq_enabled = 1;
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	IPW2100_DEBUG_ISR("exit\n");
+}
+
+
+static irqreturn_t ipw2100_interrupt(int irq, void *dev_id, 
+				     struct pt_regs *regs)
+{
+	struct net_device *dev = (struct net_device *) dev_id;
+	struct ipw2100_priv *priv = dev->priv;
+	u32 inta, inta_mask;
+
+	if (!dev)
+		return IRQ_NONE;
+
+	read_register(dev, IPW_REG_INTA_MASK, &inta_mask);
+	read_register(dev, IPW_REG_INTA, &inta);
+	inta &= IPW_INTERRUPT_MASK;
+
+	if (!(inta & inta_mask)) {
+		/* Shared interrupt */
+		return IRQ_NONE;
+	}
+
+	if (inta == 0xFFFFFFFF) {
+		/* Hardware disappeared */
+		return IRQ_HANDLED;
+	}
+
+	/* We disable the hardware interrupt here just to prevent unneeded
+	 * calls to be made.  We disable this again within the actual
+	 * work tasklet, so if another part of the code re-enables the
+	 * interrupt, that is fine */
+	ipw2100_hw_disable_interrupt(priv);
+
+	tasklet_schedule(&priv->irq_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * ipw2100_tx_prepare
+ *
+ * called by ipw2100_tx
+ * locks must be held prior to calling
+ * ret: 1 failure (skb not stored) 0 success
+ */
+static u8 P802_1H_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0xf8 };
+static u8 RFC1042_OUI[P80211_OUI_LEN] = { 0x00, 0x00, 0x00 };
+
+#define STR_12c "%02X%02X%02X%02X-%02X%02X%02X%02X-%02X%02X%02X%02X"
+#define VAR_12c(x) ((u8*)x)[0],((u8*)x)[1],((u8*)x)[2],((u8*)x)[3],\
+ ((u8*)x)[4],((u8*)x)[5],((u8*)x)[6],((u8*)x)[7], \
+ ((u8*)x)[8],((u8*)x)[9],((u8*)x)[10],((u8*)x)[11] 
+
+static void ipw2100_tx_prepare(struct ipw2100_priv *priv, struct sk_buff *skb)
+{
+	struct list_head *element;
+	struct ipw2100_data_header *header;
+	struct ipw2100_hw_packet *packet;
+	struct ieee_802_11_snap_header *snap;
+	u16 *type;
+	u8 *oui;
+#ifdef CONFIG_IPW2100_WEP
+	int olen;
+	struct sk_buff *wep_skb;
+#endif
+
+	element = priv->tx_free_list.next;
+
+	packet = list_entry(element, struct ipw2100_hw_packet, list);
+	header = packet->data;
+
+	header->host_command_reg = SEND;
+	header->host_command_reg1 = 0;
+	header->encrypted = 0;
+	header->needs_encryption = 0;
+	header->fragment_size = 0;
+	memcpy(header->dst_addr, skb->data, ETH_ALEN);
+	memcpy(header->src_addr, skb->data + ETH_ALEN, ETH_ALEN);
+
+	/* An ethhdr is 14 bytes:
+	   struct ethhdr {
+	   unsigned char h_dest[ETH_ALEN];
+	   unsigned char h_source[ETH_ALEN];
+	   unsigned short h_proto;
+	   } 
+
+	   A snap header is 6 bytes:
+	   struct ieee_802_11_snap_header {
+	   u8 dsap;
+	   u8 ssap;
+	   u8 ctrl;
+	   u8 oui[3];
+	   }
+	   
+	   Since we retain the h_proto, this only gives us 6 bytes of extra 
+	   space--not enough to hold the IV and ICV for a wep packet.  So, we
+	   have to re-allocate a new SKB if WEP is enabled.
+	*/
+
+#ifdef CONFIG_IPW2100_WEP
+	/* If we are connected and under shared authentication, then allocate
+	 * and encrypt */
+	if (priv->connected && 
+	    priv->authentication == AUTH_SHARED &&
+	    priv->ieee.crypt &&
+	    priv->ieee.crypt->ops->encrypt) {
+		wep_skb = dev_alloc_skb(
+			skb->len - sizeof(struct ethhdr) + 
+			sizeof(struct ieee_802_11_snap_header) +
+			2 + /* Type field ARP or IP */ +
+			8 /* IV and ICV */);
+		if (wep_skb == NULL) {
+			printk(KERN_WARNING "%s: Could not allocate SKB for "
+			       "WEP encryption.  Dropping packet.\n",
+			       priv->ndev->name);
+			dev_kfree_skb(skb);
+			priv->stats.rx_errors++;
+			return;
+		}
+
+		/* To encrypt, frame format is:
+		 * IV (4 bytes), clear payload (including SNAP header), 
+		 * ICV (4 bytes) */
+
+		/* Put space at the start of wep_skb for the IV */
+		skb_put(wep_skb, 4);
+		
+		/* Set up the SNAP header */
+		/* Pull the incoming SKB data ptr past the ethernet header */
+		skb_pull(skb, sizeof(struct ethhdr) - 2);
+
+		type = (u16 *) skb->data;
+		if (ntohs(*type) == 0x8137 || ntohs(*type) == 0x80f3)
+			oui = P802_1H_OUI;
+		else
+			oui = RFC1042_OUI;
+		
+		/* Put the SNAP into wep_skb */
+		snap = (struct ieee_802_11_snap_header *)skb_put(
+			wep_skb, sizeof(*snap));
+		snap->dsap = 0xaa;
+		snap->ssap = 0xaa;
+		snap->ctrl = 0x03;
+		memcpy(snap->oui, oui, P80211_OUI_LEN);
+
+		/* For now, the Host AP encryption system performs WEP
+		 * encrypt in place--this means we need to copy the non
+		 * encrypted data into the new SKB vs. having Host AP
+		 * transform the encrypted data across buffers */
+
+		/* Copy the h_proto (Type) and unencrypted payload into the 
+		 * wep_skb */
+		memcpy(skb_put(wep_skb, skb->len), skb->data, skb->len);
+		
+		/* Advance wep_skb storage to hold the ICV */
+		skb_put(wep_skb, 4);
+
+		/* We're done with the original SKB... so let it be free... */
+		dev_kfree_skb(skb);
+
+		/* Encrypt the frame */
+/*		printk(KERN_INFO "%s: Before encrypt: " STR_12c "\n",
+		priv->ieee.dev->name, VAR_12c(wep_skb->data));*/
+		atomic_inc(&priv->ieee.crypt->refcnt);
+		olen = priv->ieee.crypt->ops->encrypt(
+			wep_skb->data, wep_skb->len - 8, 
+			priv->ieee.crypt->priv);
+		atomic_dec(&priv->ieee.crypt->refcnt);
+/*		printk(KERN_INFO "%s: After encrypt : " STR_12c "\n",
+		priv->ieee.dev->name, VAR_12c(wep_skb->data));*/
+		if (olen != wep_skb->len) {
+			printk(KERN_INFO "%s: Encryption failed: %d vs. %d.\n",
+			       priv->ndev->name, olen, wep_skb->len);
+			dev_kfree_skb(wep_skb);
+			return;
+		}
+
+		header->encrypted = 1;
+		skb = wep_skb;
+	} else {
+#endif
+		/* Put a SNAP header where the ethernet header used to be 
+		 * and update skb->data pointer - we don't use the original 
+		 * ethernet header anyway
+		 *
+		 * An assumption is that SNAP header is smaller than 
+		 * ethernet header.  Silently drop. */
+		if (skb->len < sizeof(struct ethhdr) - 2) {
+			printk(KERN_WARNING "%s: skb too small for snap "
+			       "header.\n", priv->ndev->name);
+			return;
+		}
+		
+		/* move data pointer forward to the h_proto field 
+		 * (after h_dest and h_source MAC addresses) then back the size 
+		 * of a SNAP header */
+		skb_pull(skb, sizeof(struct ethhdr) - 2);
+		
+		type = (u16 *) skb->data;
+		if (ntohs(*type) == 0x8137 || ntohs(*type) == 0x80f3)
+			oui = P802_1H_OUI;
+		else
+			oui = RFC1042_OUI;
+		
+		skb_push(skb, sizeof(struct ieee_802_11_snap_header));
+		
+		snap = (struct ieee_802_11_snap_header *)skb->data;
+		snap->dsap = 0xaa;
+		snap->ssap = 0xaa;
+		snap->ctrl = 0x03;
+		memcpy(snap->oui, oui, P80211_OUI_LEN);	
+#ifdef CONFIG_IPW2100_WEP	
+	}
+#endif
+	
+	packet->jiffy_start = jiffies;
+	packet->skb = skb;
+	
+	list_del(element);
+	list_add_tail(element, &priv->tx_pend_list);
+	
+	X__ipw2100_tx_send_data(priv);
+}
+
+
+
+
+
+static int ipw2100_msg_allocate(struct ipw2100_priv *priv)
+{
+	int i, j, err = -EINVAL;
+	void *v;
+	dma_addr_t p;
+	     
+	priv->msg_buffers = (struct ipw2100_hw_packet *)kmalloc(
+		IPW_COMMAND_POOL_SIZE * sizeof(struct ipw2100_hw_packet), 
+		GFP_KERNEL);
+	if (!priv->msg_buffers) {
+		printk(KERN_ERR "%s: PCI alloc failed for msg "
+		       "buffers.\n", priv->ndev->name);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {
+		v = pci_alloc_consistent(
+			priv->pdev,
+			sizeof(struct ipw2100_cmd_header), 
+			&p);
+		if (!v) {
+			printk(KERN_ERR 
+			       "%s: PCI alloc failed for msg "
+			       "buffers.\n",
+			       priv->ndev->name);
+			err = -ENOMEM;
+			break;
+		} 
+
+		memset(v, 0, sizeof(struct ipw2100_cmd_header));
+		
+		priv->msg_buffers[i].type = COMMAND;
+		priv->msg_buffers[i].cmd = 
+			(struct ipw2100_cmd_header*)v;
+		priv->msg_buffers[i].cmd_phys = p;
+	}
+
+	if (i == IPW_COMMAND_POOL_SIZE)
+		return 0;
+
+	for (j = 0; j < i; j++) {
+		pci_free_consistent(
+			priv->pdev,
+			sizeof(struct ipw2100_cmd_header), 
+			priv->msg_buffers[j].cmd,
+			priv->msg_buffers[j].cmd_phys);
+	}
+	
+	kfree(priv->msg_buffers);
+	priv->msg_buffers = NULL;
+
+	return err;
+}
+
+static int ipw2100_msg_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	INIT_LIST_HEAD(&priv->msg_free_list);
+	INIT_LIST_HEAD(&priv->msg_pend_list);
+
+	for (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) 
+		list_add_tail(&priv->msg_buffers[i].list, &priv->msg_free_list);
+
+	return 0;
+}
+
+static void ipw2100_msg_free(struct ipw2100_priv *priv)
+{
+	int i;
+
+	if (!priv->msg_buffers) 
+		return;
+
+	for (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {
+		pci_free_consistent(priv->pdev,
+				    sizeof(struct ipw2100_cmd_header),
+				    priv->msg_buffers[i].cmd,
+				    priv->msg_buffers[i].cmd_phys);
+	}
+	
+	kfree(priv->msg_buffers);
+	priv->msg_buffers = NULL;
+}
+
+static struct proc_dir_entry *ipw2100_proc = NULL;
+
+static int proc_get_pci(char *page, char **start,
+		       off_t offset, int count,
+		       int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+	struct pci_dev *pdev = priv->pdev;
+	int i, j, len;
+	u32 val;
+
+	
+	len = 0;
+
+	len += snprintf(page + len, count - len, "PCI Configuration Data\n");
+	
+	for (i = 0; i < 16; i++) {
+		len += snprintf(page + len, count - len, "[%08X] ", i * 16);
+		for (j = 0; j < 16; j += 4) {
+			pci_read_config_dword(pdev, i * 16 + j, &val); 
+			len += snprintf(page + len, count - len, "%08X ", val);
+		}
+		len += snprintf(page + len, count - len, "\n");
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+#define IPW2100_REG(x) { IPW_ ##x, #x }
+const struct {
+	u32 addr;
+	const char *name;
+} hw_data[] = {
+	IPW2100_REG(REG_GP_CNTRL),
+	IPW2100_REG(REG_GPIO),
+	IPW2100_REG(REG_INTA),
+	IPW2100_REG(REG_INTA_MASK),
+	IPW2100_REG(REG_RESET_REG),
+};
+#define IPW2100_NIC(x, s) { x, #x, s }
+const struct {
+	u32 addr;
+	const char *name;
+	size_t size;
+} nic_data[] = {
+	IPW2100_NIC(IPW2100_CONTROL_REG, 2),
+	IPW2100_NIC(0x210014, 1),
+	IPW2100_NIC(0x210000, 1),
+};
+#define IPW2100_ORD(x, d) { IPW_ORD_ ##x, #x, d }
+const struct {
+	u8 index;
+	const char *name;
+	const char *desc;
+} ord_data[] = {
+	IPW2100_ORD(STAT_TX_HOST_REQUESTS, "requested Host Tx's (MSDU)"),
+	IPW2100_ORD(STAT_TX_HOST_COMPLETE, "successful Host Tx's (MSDU)"),
+	IPW2100_ORD(STAT_TX_DIR_DATA,	   "successful Directed Tx's (MSDU)"),
+	IPW2100_ORD(STAT_TX_DIR_DATA1,	   "successful Directed Tx's (MSDU) @ 1MB"),
+	IPW2100_ORD(STAT_TX_DIR_DATA2,	   "successful Directed Tx's (MSDU) @ 2MB"),
+	IPW2100_ORD(STAT_TX_DIR_DATA5_5,   "successful Directed Tx's (MSDU) @ 5_5MB"),
+	IPW2100_ORD(STAT_TX_DIR_DATA11,	   "successful Directed Tx's (MSDU) @ 11MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA1,   "successful Non_Directed Tx's (MSDU) @ 1MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA2,   "successful Non_Directed Tx's (MSDU) @ 2MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA5_5, "successful Non_Directed Tx's (MSDU) @ 5.5MB"),
+	IPW2100_ORD(STAT_TX_NODIR_DATA11,  "successful Non_Directed Tx's (MSDU) @ 11MB"),
+	IPW2100_ORD(STAT_NULL_DATA,	   "successful NULL data Tx's"),
+	IPW2100_ORD(STAT_TX_RTS,	   "successful Tx RTS"),
+	IPW2100_ORD(STAT_TX_CTS,	   "successful Tx CTS"),         
+	IPW2100_ORD(STAT_TX_ACK,	   "successful Tx ACK"),
+	IPW2100_ORD(STAT_TX_ASSN,	   "successful Association Tx's"),               
+	IPW2100_ORD(STAT_TX_ASSN_RESP,	   "successful Association response Tx's"),   
+	IPW2100_ORD(STAT_TX_REASSN,	   "successful Reassociation Tx's"),           
+	IPW2100_ORD(STAT_TX_REASSN_RESP,   "successful Reassociation response Tx's"),
+	IPW2100_ORD(STAT_TX_PROBE,	   "probes successfully transmitted"), 
+	IPW2100_ORD(STAT_TX_PROBE_RESP,	   "probe responses successfully transmitted"),                
+	IPW2100_ORD(STAT_TX_BEACON,	   "tx beacon"),             
+	IPW2100_ORD(STAT_TX_ATIM,	   "Tx ATIM"),            
+	IPW2100_ORD(STAT_TX_DISASSN,	   "successful Disassociation TX"),           
+	IPW2100_ORD(STAT_TX_AUTH,	   "successful Authentication Tx"),                 
+	IPW2100_ORD(STAT_TX_DEAUTH,	   "successful Deauthentication TX"),                
+	IPW2100_ORD(STAT_TX_TOTAL_BYTES,   "Total successful Tx data bytes"),
+	IPW2100_ORD(STAT_TX_RETRIES,       "Tx retries"),
+	IPW2100_ORD(STAT_TX_RETRY1,        "Tx retries at 1MBPS"),
+	IPW2100_ORD(STAT_TX_RETRY2,        "Tx retries at 2MBPS"),
+	IPW2100_ORD(STAT_TX_RETRY5_5,	   "Tx retries at 5.5MBPS"),
+	IPW2100_ORD(STAT_TX_RETRY11,	   "Tx retries at 11MBPS"),
+	IPW2100_ORD(STAT_TX_FAILURES,	   "Tx Failures"),
+	IPW2100_ORD(STAT_TX_MAX_TRIES_IN_HOP,"times max tries in a hop failed"),
+	IPW2100_ORD(STAT_TX_DISASSN_FAIL,	"times disassociation failed"),
+	IPW2100_ORD(STAT_TX_ERR_CTS,         "missed/bad CTS frames"),
+	IPW2100_ORD(STAT_TX_ERR_ACK,	"tx err due to acks"),
+	IPW2100_ORD(STAT_RX_HOST,	"packets passed to host"),
+	IPW2100_ORD(STAT_RX_DIR_DATA,	"directed packets"),                
+	IPW2100_ORD(STAT_RX_DIR_DATA1,	"directed packets at 1MB"),            
+	IPW2100_ORD(STAT_RX_DIR_DATA2,	"directed packets at 2MB"),           
+	IPW2100_ORD(STAT_RX_DIR_DATA5_5,	"directed packets at 5.5MB"),            
+	IPW2100_ORD(STAT_RX_DIR_DATA11,	"directed packets at 11MB"),            
+	IPW2100_ORD(STAT_RX_NODIR_DATA,"nondirected packets"),        
+	IPW2100_ORD(STAT_RX_NODIR_DATA1,	"nondirected packets at 1MB"),            
+	IPW2100_ORD(STAT_RX_NODIR_DATA2,	"nondirected packets at 2MB"),           
+	IPW2100_ORD(STAT_RX_NODIR_DATA5_5,	"nondirected packets at 5.5MB"),            
+	IPW2100_ORD(STAT_RX_NODIR_DATA11,	"nondirected packets at 11MB"),            
+	IPW2100_ORD(STAT_RX_NULL_DATA,	"null data rx's"),            
+	IPW2100_ORD(STAT_RX_RTS,	"Rx RTS"),                
+	IPW2100_ORD(STAT_RX_CTS,	"Rx CTS"),                
+	IPW2100_ORD(STAT_RX_ACK,	"Rx ACK"),                
+	IPW2100_ORD(STAT_RX_CFEND,	"Rx CF End"),                
+	IPW2100_ORD(STAT_RX_CFEND_ACK,	"Rx CF End + CF Ack"),             
+	IPW2100_ORD(STAT_RX_ASSN,	"Association Rx's"),                    
+	IPW2100_ORD(STAT_RX_ASSN_RESP,	"Association response Rx's"),            
+	IPW2100_ORD(STAT_RX_REASSN,	"Reassociation Rx's"),            
+	IPW2100_ORD(STAT_RX_REASSN_RESP,	"Reassociation response Rx's"),            
+	IPW2100_ORD(STAT_RX_PROBE,	"probe Rx's"),                
+	IPW2100_ORD(STAT_RX_PROBE_RESP,	"probe response Rx's"),            
+	IPW2100_ORD(STAT_RX_BEACON,	"Rx beacon"),            
+	IPW2100_ORD(STAT_RX_ATIM,	"Rx ATIM"),                    
+	IPW2100_ORD(STAT_RX_DISASSN,	"disassociation Rx"),            
+	IPW2100_ORD(STAT_RX_AUTH,	"authentication Rx"),                    
+	IPW2100_ORD(STAT_RX_DEAUTH,	"deauthentication Rx"),            
+	IPW2100_ORD(STAT_RX_TOTAL_BYTES,"Total rx data bytes received"),
+	IPW2100_ORD(STAT_RX_ERR_CRC,	 "packets with Rx CRC error"),
+	IPW2100_ORD(STAT_RX_ERR_CRC1,	 "Rx CRC errors at 1MB"),
+	IPW2100_ORD(STAT_RX_ERR_CRC2,	 "Rx CRC errors at 2MB"),
+	IPW2100_ORD(STAT_RX_ERR_CRC5_5,	 "Rx CRC errors at 5.5MB"),
+	IPW2100_ORD(STAT_RX_ERR_CRC11,	 "Rx CRC errors at 11MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE1, "duplicate rx packets at 1MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE2,	 "duplicate rx packets at 2MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE5_5,	 "duplicate rx packets at 5.5MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE11,	 "duplicate rx packets at 11MB"),
+	IPW2100_ORD(STAT_RX_DUPLICATE, "duplicate rx packets"),            
+	IPW2100_ORD(PERS_DB_LOCK,	"locking fw permanent  db"),
+	IPW2100_ORD(PERS_DB_SIZE,	"size of fw permanent  db"),           
+	IPW2100_ORD(PERS_DB_ADDR,	"address of fw permanent  db"),           
+	IPW2100_ORD(STAT_RX_INVALID_PROTOCOL,	"rx frames with invalid protocol"),        
+	IPW2100_ORD(SYS_BOOT_TIME,	"Boot time"),
+	IPW2100_ORD(STAT_RX_NO_BUFFER,	"rx frames rejected due to no buffer"), 
+	IPW2100_ORD(STAT_RX_MISSING_FRAG,	"rx frames dropped due to missing fragment"),            
+	IPW2100_ORD(STAT_RX_ORPHAN_FRAG,	"rx frames dropped due to non-sequential fragment"),        
+	IPW2100_ORD(STAT_RX_ORPHAN_FRAME,	"rx frames dropped due to unmatched 1st frame"),            
+	IPW2100_ORD(STAT_RX_FRAG_AGEOUT,	"rx frames dropped due to uncompleted frame"),        
+	IPW2100_ORD(STAT_RX_ICV_ERRORS,	"ICV errors during decryption"),        
+	IPW2100_ORD(STAT_PSP_SUSPENSION,"times adapter suspended"),        
+	IPW2100_ORD(STAT_PSP_BCN_TIMEOUT,	"beacon timeout"),           
+	IPW2100_ORD(STAT_PSP_POLL_TIMEOUT,	"poll response timeouts"),       
+	IPW2100_ORD(STAT_PSP_NONDIR_TIMEOUT, "timeouts waiting for last {broad,multi}cast pkt"),
+	IPW2100_ORD(STAT_PSP_RX_DTIMS,	"PSP DTIMs received"),
+	IPW2100_ORD(STAT_PSP_RX_TIMS,	"PSP TIMs received"),
+	IPW2100_ORD(STAT_PSP_STATION_ID,"PSP Station ID"),
+	IPW2100_ORD(LAST_ASSN_TIME,	"RTC time of last association"),               
+	IPW2100_ORD(STAT_PERCENT_MISSED_BCNS,"current calculation of % missed beacons"),       
+	IPW2100_ORD(STAT_PERCENT_RETRIES,"current calculation of % missed tx retries"),            
+	IPW2100_ORD(ASSOCIATED_AP_PTR,	"0 if not associated, else pointer to AP table entry"),
+	IPW2100_ORD(AVAILABLE_AP_CNT,	"AP's decsribed in the AP table"),
+	IPW2100_ORD(AP_LIST_PTR,	"Ptr to list of available APs"),
+	IPW2100_ORD(STAT_AP_ASSNS,	"associations"),
+	IPW2100_ORD(STAT_ASSN_FAIL,	"association failures"),       
+	IPW2100_ORD(STAT_ASSN_RESP_FAIL,"failures due to response fail"),       
+	IPW2100_ORD(STAT_FULL_SCANS,	"full scans"),
+	IPW2100_ORD(CARD_DISABLED,	"Card Disabled"),
+	IPW2100_ORD(STAT_ROAM_INHIBIT,	"times roaming was inhibited due to activity"),       
+	IPW2100_ORD(RSSI_AT_ASSN,	"RSSI of associated AP at time of association"),           
+	IPW2100_ORD(STAT_ASSN_CAUSE1,	"reassociation: no probe response or TX on hop"),
+	IPW2100_ORD(STAT_ASSN_CAUSE2,	"reassociation: poor tx/rx quality"),            
+	IPW2100_ORD(STAT_ASSN_CAUSE3,	"reassociation: tx/rx quality (excessive AP load"),
+	IPW2100_ORD(STAT_ASSN_CAUSE4,	"reassociation: AP RSSI level"),
+	IPW2100_ORD(STAT_ASSN_CAUSE5,	"reassociations due to load leveling"),            
+	IPW2100_ORD(STAT_AUTH_FAIL,	"times authentication failed"),        
+	IPW2100_ORD(STAT_AUTH_RESP_FAIL,"times authentication response failed"),       
+	IPW2100_ORD(STATION_TABLE_CNT,	"entries in association table"),        
+	IPW2100_ORD(RSSI_AVG_CURR,	"Current avg RSSI"),
+	IPW2100_ORD(POWER_MGMT_MODE,	"Power mode - 0=CAM, 1=PSP"),       
+	IPW2100_ORD(COUNTRY_CODE,	"IEEE country code as recv'd from beacon"),
+	IPW2100_ORD(COUNTRY_CHANNELS,	"channels suported by country"),           
+	IPW2100_ORD(RESET_CNT,	"adapter resets (warm)"),       
+	IPW2100_ORD(BEACON_INTERVAL,	"Beacon interval"),       
+	IPW2100_ORD(ANTENNA_DIVERSITY,	"TRUE if antenna diversity is disabled"),       
+	IPW2100_ORD(DTIM_PERIOD,	"beacon intervals between DTIMs"),       
+	IPW2100_ORD(OUR_FREQ,	"current radio freq lower digits - channel ID"),
+	IPW2100_ORD(RTC_TIME,	"current RTC time"),           
+	IPW2100_ORD(PORT_TYPE,	"operating mode"),       
+	IPW2100_ORD(CURRENT_TX_RATE,	"current tx rate"),
+	IPW2100_ORD(SUPPORTED_RATES,	"supported tx rates"),       
+	IPW2100_ORD(ATIM_WINDOW,	"current ATIM Window"),
+	IPW2100_ORD(BASIC_RATES,	"basic tx rates"),       
+	IPW2100_ORD(NIC_HIGHEST_RATE,	"NIC highest tx rate"),
+	IPW2100_ORD(AP_HIGHEST_RATE,	"AP highest tx rate"),
+	IPW2100_ORD(CAPABILITIES,	"Management frame capability field"),
+	IPW2100_ORD(AUTH_TYPE,	"Type of authentication"),       
+	IPW2100_ORD(RADIO_TYPE,	"Adapter card platform type"),       
+	IPW2100_ORD(RTS_THRESHOLD,	"Min packet length for RTS handshaking"),       
+	IPW2100_ORD(INT_MODE,	"International mode"),           
+	IPW2100_ORD(FRAGMENTATION_THRESHOLD,	"protocol frag threshold"),       
+	IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_START_ADDRESS,	"EEPROM offset in SRAM"),
+	IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_SIZE,	"EEPROM size in SRAM"),
+	IPW2100_ORD(EEPROM_SKU_CAPABILITY,	"EEPROM SKU Capability"),
+	IPW2100_ORD(EEPROM_IBSS_11B_CHANNELS,	"EEPROM IBSS 11b channel set"),       
+	IPW2100_ORD(MAC_VERSION,	"MAC Version"),       
+	IPW2100_ORD(MAC_REVISION,	"MAC Revision"),       
+	IPW2100_ORD(RADIO_VERSION,	"Radio Version"),       
+	IPW2100_ORD(NIC_MANF_DATE_TIME,	"MANF Date/Time STAMP"),
+	IPW2100_ORD(UCODE_VERSION,	"Ucode Version"),       
+};
+
+
+static int proc_get_registers(char *page, char **start,
+		       off_t offset, int count,
+		       int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	int i;
+	int len = 0;
+	u32 val = 0;
+
+	len += snprintf(page + len, count - len, 
+			"%30s [Address ] : Hex\n", "Register");
+	
+	for (i = 0; 
+	     i < (sizeof(hw_data) / sizeof(*hw_data)); 
+	     i++) {
+		read_register(dev, hw_data[i].addr, &val);
+
+		len += snprintf(page + len, count - len, 
+				"%30s [%08X] : %08X\n",
+				hw_data[i].name, hw_data[i].addr,
+				val);
+	}
+
+	*eof = 1;
+	return len;
+}
+
+
+static int proc_get_hw(char *page, char **start,
+		       off_t offset, int count,
+		       int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	int i;
+	int len = 0;
+
+	len += snprintf(page + len, count - len, 
+			"%30s [Address ] : Hex\n", "NIC entry");
+	
+	for (i = 0; 
+	     i < (sizeof(nic_data) / sizeof(*nic_data)); 
+	     i++) {
+		u8 tmp8;
+		u16 tmp16;
+		u32 tmp32;
+		
+		switch (nic_data[i].size) {
+		case 1:
+			read_nic_byte(dev, nic_data[i].addr, &tmp8);
+			len += snprintf(page + len, count - len, 
+					"%30s [%08X] : %02X\n",
+					nic_data[i].name, nic_data[i].addr,
+					tmp8);
+			break;
+		case 2:
+			read_nic_word(dev, nic_data[i].addr, &tmp16);
+			len += snprintf(page + len, count - len, 
+					"%30s [%08X] : %04X\n",
+					nic_data[i].name, nic_data[i].addr,
+					tmp16);
+			break;
+		case 4:
+			read_nic_dword(dev, nic_data[i].addr, &tmp32);
+			len += snprintf(page + len, count - len, 
+					"%30s [%08X] : %08X\n",
+					nic_data[i].name, nic_data[i].addr,
+					tmp32);
+			break;
+		}
+	}
+	*eof = 1;
+	return len;
+}
+
+
+static int proc_get_ordinals(char *page, char **start,
+			     off_t offset, int count,
+			     int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+	u32 val_len;
+	u32 val = 0;
+	static int loop = 0;
+
+	if (offset == 0)
+		loop = 0;
+
+	/* If we've reached EOF or the user is cutting is short, then
+	 * restart the counter and return 0 bytes */
+	if (loop >= (sizeof(ord_data) / sizeof(*ord_data))) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && 
+	       len < 2048 && 
+	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+		
+		val_len = sizeof(u32);
+
+		if (ipw2100_get_ordinal(priv, ord_data[loop].index, &val, 
+					&val_len)) 
+			len += snprintf(page + len, count - len,
+					"[0x%02X] = ERROR    %s\n",
+					ord_data[loop].index,
+					ord_data[loop].desc);
+		else
+			len += snprintf(page + len, count - len,
+					"[0x%02X] = 0x%08X %s\n",
+					ord_data[loop].index, 
+					val, ord_data[loop].desc);
+
+		loop++;
+	}
+	
+	/* see comment in fs/proc/generic.c proc_file_read */
+	if (len) 
+		*start = (char*)len; 
+	else
+		*eof = 1;
+
+	return len;
+}
+
+static int proc_get_version(char *page, char **start,
+			    off_t offset, int count,
+			    int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+	int len = 0;
+	char tmp[MAX_FW_VERSION_LEN];
+
+	len += snprintf(page + len, count - len, 
+			"hardware    : 0x%04X\n", 
+			priv->pdev->subsystem_device);
+
+#ifdef CONFIG_IPW2100_WEP
+	len += snprintf(page + len, count - len, 
+			"driver      : " DRV_VERSION " [WEP]\n");
+#else
+	len += snprintf(page + len, count - len, 
+			"driver      : " DRV_VERSION "\n");
+#endif
+
+	len += snprintf(page + len, count - len,
+			"build date  : " __DATE__ "\n");
+
+	len += snprintf(page + len, count - len,
+			"build time  : " __TIME__ "\n");
+
+	len += snprintf(page + len, count - len,
+			"eeprom      : %d\n", priv->eeprom_version);
+	err = ipw2100_get_ucodeversion(priv, tmp, sizeof(tmp));
+	if (err < 0) 
+		len += snprintf(page + len, count - len,
+				"ucode       : error\n");
+	else 
+		len += snprintf(page + len, count - len,
+				"ucode       : %s\n", tmp);
+	err = ipw2100_get_fwversion(priv, tmp, sizeof(tmp));
+	if (err < 0) 
+		len += snprintf(page + len, count - len,
+				"firmware    : error\n");
+	else 
+		len += snprintf(page + len, count - len,
+				"firmware    : %s\n", tmp);
+
+	len += snprintf(page + len, count - len,
+			"firmware img: %d\n", priv->firmware_version);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_stats(char *page, char **start,
+			  off_t offset, int count,
+			  int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+
+	len += snprintf(page + len, count - len,
+			"interrupts: %d {tx: %d, rx: %d, other: %d}\n", 
+			priv->interrupts, priv->tx_interrupts,
+			priv->rx_interrupts,
+			priv->interrupts - 
+			(priv->tx_interrupts + priv->rx_interrupts));
+	len += snprintf(page + len, count - len,
+			"firmware resets: %d\n", priv->resets);
+	len += snprintf(page + len, count - len,
+			"firmware hangs: %d\n", priv->hangs);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_internals(char *page, char **start,
+			      off_t offset, int count,
+			      int *eof, void *data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+
+#define DUMP_VAR(x,y) \
+        len += snprintf(page + len, count - len, \
+			# x ": %" # y "\n", priv-> x)
+
+	DUMP_VAR(reset_pending, d);
+	DUMP_VAR(stopped, d);
+	DUMP_VAR(disabled, d);
+	DUMP_VAR(phy_off, d);
+	DUMP_VAR(connected, d);
+	DUMP_VAR(been_powered, d);
+	DUMP_VAR(fatal_error, d);
+	DUMP_VAR(rf_kill, d);
+	DUMP_VAR(stop_hang_check, d);
+	DUMP_VAR(stop_rf_check, d);
+	DUMP_VAR(message_sending, d);
+	DUMP_VAR(messages_sent, d);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_bssinfo(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	int ret;
+	int length;
+	char essid[IW_ESSID_MAX_SIZE + 1];
+	u8 bssid[ETH_ALEN];
+	u32 chan = 0;
+
+	memset(essid, 0, sizeof(essid));
+	memset(bssid, 0, sizeof(bssid));
+
+	length = IW_ESSID_MAX_SIZE;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID, essid, &length);
+	if (ret) 
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+
+	length = sizeof(bssid);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,
+				  bssid, &length);
+	if (ret)
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+
+	length = sizeof(u32);
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &length);
+	if (ret) 
+		IPW2100_DEBUG_INFO("failed querying ordinals at line %d\n", 
+				   __LINE__);
+
+	len += snprintf(page + len, count - len, "ESSID: %s\n", essid);
+	len += snprintf(page + len, count - len,
+			"BSSID:   %02x:%02x:%02x:%02x:%02x:%02x\n",
+			bssid[0], bssid[1], bssid[2],
+			bssid[3], bssid[4], bssid[5]);
+	len += snprintf(page + len, count - len, "Channel: %d\n", chan);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_get_txqueue(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	u32 tbdr_r, tbdr_w;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	read_register(dev, IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(0),
+		      &tbdr_r);
+	read_register(dev, IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0),
+		      &tbdr_w);
+
+	IPW2100_DEBUG_INFO("after register read\n");
+
+	len += snprintf(page, count,
+			"Tx Queue\nnic:\n\tread  index=%d\n\twrite index=%d\n",
+			tbdr_r, tbdr_w);
+	len += snprintf(page + len, count - len,
+			"drv:\n\tread index=%d\n\twrite index=%d\n",
+			priv->tx_queue.oldest,
+			priv->tx_queue.next);
+	*eof = 1;
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return len;
+}
+
+static int proc_get_rxqueue(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	u32 rbdr_r, rbdr_w;
+	struct net_device *dev = (struct net_device *)data;
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	read_register(dev, IPW_MEM_HOST_SHARED_RX_READ_INDEX, &rbdr_r);
+	read_register(dev, IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, &rbdr_w);
+
+	IPW2100_DEBUG_INFO("after register read\n");
+
+	len += snprintf(page, count,
+			"Rx Queue\nnic:\n\tread  index=%d\n\twrite index=%d\n",
+			rbdr_r, rbdr_w);
+	len += snprintf(page + len, count - len,
+			"drv:\n\tread  index=NOT USED\n\twrite index=%d\n",
+			priv->rx_queue.next);
+
+	*eof = 1;
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return len;
+}
+
+
+#ifdef CONFIG_IPW2100_DEBUG
+static int proc_get_debug_level(char *page, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	int len = 0;
+	int i;
+	len += snprintf(page + len, count - len, 
+			"%-25s\tHex        SET Decimal\n",
+			"Description");
+	for (i = 0; i < sizeof(ipw2100_debug_levels) / 
+		     sizeof(struct ipw2100_dl); i++) {
+		len += snprintf(
+			page + len, count - len, "%-25s\t0x%08lX [%c] %lu\n",
+			ipw2100_debug_levels[i].name,
+			ipw2100_debug_levels[i].value,
+			(ipw2100_debug_level & ipw2100_debug_levels[i].value) ?
+			'*' : ' ',
+			ipw2100_debug_levels[i].value);
+	}
+	
+	len += snprintf(page + len, count - len, 
+			"debug_level = 0x%08lX (* = enabled)\n", 
+			ipw2100_debug_level);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_set_debug_level(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	char buf[] = "0x00000000";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+	unsigned long val;
+	char *p = buf;
+	int i;
+
+	if (copy_from_user(buf, buffer, len)) {
+		IPW2100_DEBUG_INFO("can't copy data from userspace\n");
+		return count;	
+	} else
+		buf[len] = 0;
+
+	if (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {
+	  p++;
+ 	  if (p[0] == 'x' || p[0] == 'X')
+	    p++;
+	  val = simple_strtoul(p, &p, 16);
+	} else
+	  val = simple_strtoul(p, &p, 10);
+	if (p == buf) 
+		printk(KERN_INFO DRV_NAME ": %s is not in hex [0x] or "
+		       "decimal form.\n", buf);
+	else {
+		printk(KERN_INFO DRV_NAME ": Debug level set to 0x%08lX\n", 
+		       val);
+		ipw2100_debug_level = val;
+
+		for (i = 0; i < sizeof(ipw2100_debug_levels) / 
+			     sizeof(struct ipw2100_dl); i++) {
+			if ((ipw2100_debug_level & 
+			     ipw2100_debug_levels[i].value) ==
+			    ipw2100_debug_levels[i].value)
+				printk(KERN_INFO DRV_NAME 
+				       ": tracing enabled for %-25s (%08lX).\n",
+				       ipw2100_debug_levels[i].name,
+				       ipw2100_debug_levels[i].value);
+		}
+	}
+
+	return count;
+}
+#endif /* CONFIG_IPW2100_DEBUG */
+
+static int proc_get_fatal_error(char *page, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	struct net_device *dev = data;
+	struct ipw2100_priv *priv = dev->priv;
+	int len = 0;
+
+	len += snprintf(page + len, count - len,
+			"fatal error: %d\n", priv->fatal_error);
+	
+	if (priv->fatal_error)
+		len += snprintf(page + len, count - len,
+				"`echo 0 > fatal_error` to clear\n");
+		
+	*eof = 1;
+	return len;
+}
+
+static int proc_set_fatal_error(struct file *file, const char *buffer,
+				unsigned long count, void *data)
+{
+	struct net_device *dev = data;
+	struct ipw2100_priv *priv = dev->priv;
+	priv->fatal_error = 0;
+	return count;
+}
+
+static int proc_get_cardmem(char *page,
+			    char **start,
+			    off_t offset,
+			    int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	u32 d;
+
+	read_nic_dword(dev, priv->proc_cardmemaddr, &d);
+
+	len += snprintf(page, count,
+			"cardmem addr[0x%08x] = 0x%08x (%d)\n",
+			priv->proc_cardmemaddr, d, d);
+
+	*eof = 1;
+	return len;
+}
+
+static int proc_set_cardmemaddr(struct file *file, const char
+				*buffer,
+				unsigned long count, void *data)
+{
+	char buff[] = "00000000";
+	unsigned long len =
+	    (sizeof(buff) - 1) > count ? count : sizeof(buff) - 1;
+	u32 val;
+	char *p;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (copy_from_user(buff, buffer, len)) {
+		IPW2100_DEBUG_INFO("can't copy data from userspace\n");
+                /* stupid? yes, but how do I signal an error here? */
+		return count;	
+	} else
+		buff[len] = 0;
+
+	val = simple_strtoul(buff, &p, 16);
+	if (p == buff) {
+		IPW2100_DEBUG_INFO("user supplied invalid address value, *p=%c\n",
+		       *p);
+	} else {
+		struct net_device *dev = (struct net_device *) data;
+		struct ipw2100_priv *priv = dev->priv;
+		
+		IPW2100_DEBUG_INFO("dev=0x%p\n", dev);
+		
+		priv->proc_cardmemaddr = val;
+		IPW2100_DEBUG_INFO("set mem addr = 0x%08x\n", val);
+	}
+	
+	IPW2100_DEBUG_INFO("exit\n");
+	return count;
+}
+
+static int proc_get_state(char *page,
+			  char **start,
+			  off_t offset,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	struct net_device *dev = (struct net_device *) data;
+	struct ipw2100_priv *priv = dev->priv;
+	
+	if (priv->hw_features & HW_FEATURE_RFKILL) 
+		len += snprintf(page, count, "Radio is %s by RF switch\n",
+				ipw2100_get_rf_switch(priv) ? 
+				"disabled" : "enabled");
+	else
+		len += snprintf(page, count, 
+				"Your hardware does not have an RF switch\n");
+	
+	*eof = 1;
+	return len;
+}
+
+
+int ipw2100_proc_dev_init(struct ipw2100_priv *priv)
+{
+	struct proc_dir_entry *e;
+
+	IPW2100_DEBUG_INFO("enter %s\n", priv->ndev->name);
+
+	priv->dir_dev = create_proc_entry(priv->ndev->name, 
+					  S_IFDIR | S_IRUGO | S_IXUGO, 
+					  ipw2100_proc);
+	if (!priv->dir_dev) {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/net/ipw2100/%s\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("hw", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_hw, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/hw\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_registers, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/registers\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("ordinals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_ordinals, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/ordinals\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("pci", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_pci, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/pci\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("version", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_version, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/version\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("stats", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_stats, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/stats\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("internals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_internals, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/internals\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("txqueue", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_txqueue, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/txqueue\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("rxqueue", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_rxqueue, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/rxqueue\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("bssinfo", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_bssinfo, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/bssinfo\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("cardmem", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_cardmem;
+		e->write_proc = proc_set_cardmemaddr;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/cardmem\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("fatal_error", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_fatal_error;
+		e->write_proc = proc_set_fatal_error;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/fatal_error\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("state", S_IFREG | S_IRUGO,
+			      priv->dir_dev, proc_get_state, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/state\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	IPW2100_DEBUG_INFO("exit %s\n", priv->ndev->name);
+
+	return 0;
+
+      fail:
+	ipw2100_proc_dev_cleanup(priv);
+	IPW2100_DEBUG_INFO("exit on fail %s\n", priv->ndev->name);
+
+	return -ENOMEM;
+}
+
+void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv)
+{
+	IPW2100_DEBUG_INFO("enter %s\n", priv->ndev->name);
+
+	if (priv->dir_dev) {
+		remove_proc_entry("stats", priv->dir_dev);
+		remove_proc_entry("internals", priv->dir_dev);
+		remove_proc_entry("txqueue", priv->dir_dev);
+		remove_proc_entry("rxqueue", priv->dir_dev);
+		remove_proc_entry("cardmem", priv->dir_dev);
+		remove_proc_entry("bssinfo", priv->dir_dev);
+		remove_proc_entry("state", priv->dir_dev);
+		remove_proc_entry("version", priv->dir_dev);
+		remove_proc_entry("hw", priv->dir_dev);
+		remove_proc_entry("registers", priv->dir_dev);
+		remove_proc_entry("ordinals", priv->dir_dev);
+		remove_proc_entry("pci", priv->dir_dev);
+		remove_proc_entry("fatal_error", priv->dir_dev);
+		remove_proc_entry(priv->ndev->name, ipw2100_proc);
+		priv->dir_dev = NULL;
+	}
+
+	IPW2100_DEBUG_INFO("exit %s\n", priv->ndev->name);
+}
+
+int ipw2100_proc_init(void)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	ipw2100_proc = create_proc_entry(DRV_NAME, S_IFDIR, proc_net);
+	if (ipw2100_proc == NULL) {
+		printk(KERN_ERR
+		       "Unable to initialise /proc/net/ipw2100.\n");
+		goto fail;
+	}
+
+#ifdef CONFIG_IPW2100_DEBUG
+	{
+		struct proc_dir_entry *e;
+		e = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR, 
+				      ipw2100_proc);
+		if (e) {
+			e->read_proc = proc_get_debug_level;
+			e->write_proc = proc_set_debug_level;
+			e->data = NULL;
+		} else {
+			printk(KERN_ERR
+			       "Unable to initialize "
+			       "/proc/net/ipw2100/debug_level\n");
+			goto fail;
+		}
+	}
+#endif /* CONFIG_IPW2100_DEBUG */
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+
+ fail:
+	ipw2100_proc_cleanup();
+	IPW2100_DEBUG_INFO("exit on fail\n");
+	
+	return -ENOMEM;
+}
+
+void ipw2100_proc_cleanup(void)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (ipw2100_proc) {
+#ifdef CONFIG_IPW2100_DEBUG
+		remove_proc_entry("debug_level", ipw2100_proc);
+#endif
+		remove_proc_entry(DRV_NAME, proc_net);
+		ipw2100_proc = NULL;
+	}
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+
+#define RX_QUEUE_LENGTH 256
+#define TX_QUEUE_LENGTH 256
+#define HW_QUEUE_LENGTH 256
+
+#define TX_PENDED_QUEUE_LENGTH (TX_QUEUE_LENGTH / NUMBER_OF_BD_PER_DATA_PACKET)
+
+
+static int status_queue_allocate(struct ipw2100_priv *priv, int entries)
+{
+	struct ipw2100_status_queue *q = &priv->status_queue;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	q->size = entries * sizeof(struct ipw2100_status);
+	q->drv = (struct ipw2100_status *)pci_alloc_consistent(
+		priv->pdev, q->size, &q->nic);
+	if (!q->drv) {
+		printk(KERN_WARNING 
+		       "Can not allocate status queue.\n");
+		return -ENOMEM;
+	}
+
+	memset(q->drv, 0, q->size);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static void status_queue_free(struct ipw2100_priv *priv)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (priv->status_queue.drv)
+		pci_free_consistent(
+			priv->pdev, priv->status_queue.size, 
+			priv->status_queue.drv, priv->status_queue.nic);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static int bd_queue_allocate(struct ipw2100_priv *priv,
+			     struct ipw2100_bd_queue *q, int entries)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	memset(q, 0, sizeof(struct ipw2100_bd_queue));
+
+	q->entries = entries;
+	q->size = entries * sizeof(struct ipw2100_bd);
+	q->drv = pci_alloc_consistent(priv->pdev, q->size, &q->nic);
+	if (!q->drv) {
+		IPW2100_DEBUG_INFO("can't allocate shared memory for "
+		       "buffer descriptors\n");
+		return -ENOMEM;
+	}
+	memset(q->drv, 0, q->size);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static void bd_queue_free(struct ipw2100_priv *priv,
+			  struct ipw2100_bd_queue *q)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (!q)
+		return;
+
+	if (q->drv)
+		pci_free_consistent(priv->pdev,
+				    q->size, q->drv, q->nic);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static void bd_queue_initialize(
+	struct ipw2100_priv *priv, struct ipw2100_bd_queue * q,
+	u32 base, u32 size, u32 r, u32 w)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	IPW2100_DEBUG_INFO("initializing bd queue at virt=%p, phys=%08x\n", q->drv, q->nic);
+
+	write_register(priv->ndev, base, q->nic);
+	write_register(priv->ndev, size, q->entries);
+	write_register(priv->ndev, r, q->oldest);
+	write_register(priv->ndev, w, q->next);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static int ipw2100_tx_allocate(struct ipw2100_priv *priv)
+{
+	int i, j, err = -EINVAL;
+	void *v;
+	dma_addr_t p;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	err = bd_queue_allocate(priv, &priv->tx_queue, TX_QUEUE_LENGTH);
+	if (err) {
+		printk(KERN_ERR "%s: failed bd_queue_allocate\n",
+		       priv->ndev->name);
+		return err;
+	}
+
+	priv->tx_buffers = (struct ipw2100_hw_packet *)kmalloc(
+		TX_PENDED_QUEUE_LENGTH * sizeof(struct ipw2100_hw_packet), 
+		GFP_KERNEL);
+	if (!priv->tx_buffers) {
+		printk(KERN_ERR "%s: alloc failed form tx buffers.\n",
+		       priv->ndev->name);
+		bd_queue_free(priv, &priv->tx_queue);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {
+		v = pci_alloc_consistent(
+			priv->pdev, sizeof(struct ipw2100_data_header), &p);
+		if (!v) {
+			printk(KERN_ERR "%s: PCI alloc failed for tx "
+			       "buffers.\n", priv->ndev->name);
+			err = -ENOMEM;
+			break;
+		}
+
+		priv->tx_buffers[i].type = DATA;
+		priv->tx_buffers[i].data = (struct ipw2100_data_header*)v;
+		priv->tx_buffers[i].data_phys = p;
+		priv->tx_buffers[i].skb = NULL;
+	}
+	
+	if (i == TX_PENDED_QUEUE_LENGTH)
+		return 0;
+
+	for (j = 0; j < i; j++) {
+		pci_free_consistent(
+			priv->pdev,
+			sizeof(struct ipw2100_data_header), 
+			priv->tx_buffers[j].data,
+			priv->tx_buffers[j].data_phys);
+	}
+	
+	kfree(priv->tx_buffers);
+	priv->tx_buffers = NULL;
+
+	return err;
+}
+
+static void ipw2100_tx_initialize(struct ipw2100_priv *priv)
+{
+	int i;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/*
+	 * reinitialize packet info lists
+	 */
+	INIT_LIST_HEAD(&priv->fw_pend_list);
+
+	/* 
+	 * reinitialize lists
+	 */
+	INIT_LIST_HEAD(&priv->tx_pend_list);
+	INIT_LIST_HEAD(&priv->tx_free_list);
+	for (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {
+		/* We simply drop any SKBs that have been queued for
+		 * transmit */
+		if (priv->tx_buffers[i].skb != NULL) {
+			dev_kfree_skb(priv->tx_buffers[i].skb);
+			priv->tx_buffers[i].skb = NULL;
+		}
+		list_add_tail(&priv->tx_buffers[i].list, &priv->tx_free_list);
+	}
+
+	priv->tx_queue.oldest = 0;
+	priv->tx_queue.available = priv->tx_queue.entries;
+	priv->tx_queue.next = 0;
+	
+	bd_queue_initialize(priv, &priv->tx_queue,
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_BASE(0),
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_SIZE(0),
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX(0),
+			    IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX(0));
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+}
+
+static void ipw2100_tx_free(struct ipw2100_priv *priv)
+{
+	int i;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	bd_queue_free(priv, &priv->tx_queue);
+
+	if (!priv->tx_buffers)
+		return;
+
+	for (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {
+		if (priv->tx_buffers[i].skb != NULL) {
+			pci_unmap_single(
+				priv->pdev,
+				priv->tx_buffers[i].skb_phys,
+				priv->tx_buffers[i].skb->len,
+				PCI_DMA_TODEVICE);
+			dev_kfree_skb(priv->tx_buffers[i].skb);
+			priv->tx_buffers[i].skb = NULL;
+		}
+		
+		if (priv->tx_buffers[i].data)
+			pci_free_consistent(
+				priv->pdev,
+				sizeof(struct ipw2100_data_header),
+				priv->tx_buffers[i].data,
+				priv->tx_buffers[i].data_phys);
+	}
+	
+	kfree(priv->tx_buffers);
+	priv->tx_buffers = NULL;
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+
+
+static int ipw2100_rx_allocate(struct ipw2100_priv *priv)
+{
+	int i, j, err = -EINVAL;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	err = bd_queue_allocate(priv, &priv->rx_queue, RX_QUEUE_LENGTH);
+	if (err) {
+		IPW2100_DEBUG_INFO("failed bd_queue_allocate\n");
+		return err;
+	}
+
+	err = status_queue_allocate(priv, RX_QUEUE_LENGTH);
+	if (err) {
+		IPW2100_DEBUG_INFO("failed status_queue_allocate\n");
+		bd_queue_free(priv, &priv->rx_queue);
+		return err;
+	}
+
+	/*
+	 * allocate packets
+	 */
+	priv->rx_buffers = (struct ipw2100_hw_packet *)
+	    kmalloc(RX_QUEUE_LENGTH * sizeof(struct ipw2100_hw_packet), 
+		    GFP_KERNEL);
+	if (!priv->rx_buffers) {
+		IPW2100_DEBUG_INFO("can't allocate rx packet buffer table\n");
+
+		bd_queue_free(priv, &priv->rx_queue);
+
+		status_queue_free(priv);
+
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < RX_QUEUE_LENGTH; i++) {
+		struct ipw2100_hw_packet *packet;
+
+		packet = ipw2100_alloc_skb(priv, &priv->rx_buffers[i]);
+		if (!packet) {
+			err = -ENOMEM;
+			break;
+		}
+
+		/* The BD holds the cache aligned address */
+		priv->rx_queue.drv[i].host_addr = packet->dma_addr;
+		priv->rx_queue.drv[i].buf_length = IPW_RX_NIC_BUFFER_LENGTH;
+		priv->status_queue.drv[i].status_fields = 0;
+	}
+
+	if (i == RX_QUEUE_LENGTH) 
+		return 0;
+
+	for (j = 0; j < i; j++) {
+		pci_unmap_single(priv->pdev, priv->rx_buffers[j].dma_addr,
+				 sizeof(struct ipw2100_rx_packet),
+				 PCI_DMA_FROMDEVICE);
+		dev_kfree_skb(priv->rx_buffers[j].skb);
+	}
+	
+	kfree(priv->rx_buffers);
+	priv->rx_buffers = NULL;
+
+	bd_queue_free(priv, &priv->rx_queue);
+
+	status_queue_free(priv);
+
+	return err;
+}
+
+static void ipw2100_rx_initialize(struct ipw2100_priv *priv)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	priv->rx_queue.oldest = 0;
+	priv->rx_queue.available = priv->rx_queue.entries - 1;
+	priv->rx_queue.next = priv->rx_queue.entries - 1;
+
+	bd_queue_initialize(priv, &priv->rx_queue,
+			    IPW_MEM_HOST_SHARED_RX_BD_BASE,
+			    IPW_MEM_HOST_SHARED_RX_BD_SIZE,
+			    IPW_MEM_HOST_SHARED_RX_READ_INDEX,
+			    IPW_MEM_HOST_SHARED_RX_WRITE_INDEX);
+
+	/* set up the status queue */
+	write_register(priv->ndev, IPW_MEM_HOST_SHARED_RX_STATUS_BASE,
+		       priv->status_queue.nic);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static void ipw2100_rx_free(struct ipw2100_priv *priv)
+{
+	int i;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	bd_queue_free(priv, &priv->rx_queue);
+	status_queue_free(priv);
+
+	if (!priv->rx_buffers)
+		return;
+
+	for (i = 0; i < RX_QUEUE_LENGTH; i++) {
+		if (priv->rx_buffers[i].rxp) {
+			pci_unmap_single(priv->pdev, 
+					 priv->rx_buffers[i].dma_addr,
+					 sizeof(struct ipw2100_rx_packet),
+					 PCI_DMA_FROMDEVICE);
+			dev_kfree_skb(priv->rx_buffers[i].skb);
+		}
+	}
+	
+	kfree(priv->rx_buffers);
+	priv->rx_buffers = NULL;
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+static int ipw2100_read_mac_address(struct ipw2100_priv *priv)
+{
+	u32 length = ETH_ALEN;
+	u8 mac[ETH_ALEN];
+
+	int err;
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ADAPTER_MAC, 
+				  mac, &length);
+	if (err) {
+		IPW2100_DEBUG_INFO("MAC address read failed\n");
+		return -EIO;
+	}
+	IPW2100_DEBUG_INFO("card MAC is %02X:%02X:%02X:%02X:%02X:%02X\n",
+	       mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+	memcpy(priv->ndev->dev_addr, mac, ETH_ALEN);
+
+	return 0;
+}
+
+/********************************************************************
+ *
+ * Firmware Commands
+ *
+ ********************************************************************/
+int ipw2100_start_scan(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = BROADCAST_SCAN,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/* Not clearing here; doing so makes iwlist always return nothing... 
+	 *
+	 * We should modify the table logic to use aging tables vs. clearing 
+	 * the table on each scan start.
+	 */
+	IPW2100_DEBUG_SCAN("starting scan\n");
+	err =  ipw2100_hw_send_command(priv, &cmd);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return err;
+}
+
+int ipw2100_set_mac_address(struct ipw2100_priv *priv, int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = ADAPTER_ADDRESS,
+		.host_command_sequence = 0,
+		.host_command_length = ETH_ALEN
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+	memcpy(cmd.host_command_parameters, priv->ndev->dev_addr, ETH_ALEN);
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return err;
+}
+
+int ipw2100_set_port_type(struct ipw2100_priv *priv, u32 port_type, 
+				 int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = PORT_TYPE,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(u32),
+		.host_command_parameters[0] = port_type
+	};
+	int err;
+
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	/* send cmd to firmware */
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	/* store if successful */
+	if (!err) 
+		priv->ctx->port_type = port_type;
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+
+int ipw2100_set_channel(struct ipw2100_priv *priv, u32 channel, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = CHANNEL,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(channel),
+		.host_command_parameters[0] = channel
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("CHANNEL: %d\n", channel);
+
+	/* If not BSS then we don't support channel selection */
+	if (priv->ctx->port_type != IBSS) 
+		return 0;
+
+	if ((priv->ctx->channel < REG_MIN_CHANNEL) ||
+	    (priv->ctx->channel > REG_MAX_CHANNEL)) 
+		return -EINVAL;
+		
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+	
+		
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) {
+		IPW2100_DEBUG_INFO
+			("Failed to set channel to %d",
+			 channel);
+		return err;
+	}
+	
+	priv->ctx->channel = channel;
+	
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	return 0;
+}
+
+static int ipw2100_system_config(struct ipw2100_priv *priv, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = SYSTEM_CONFIG,
+		.host_command_sequence = 0,
+		.host_command_length = 12,
+	};
+	int err;
+
+	/* Set system configuration */
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	cmd.host_command_parameters[0] = CFG_BSS_MASK;
+
+	/* l1b only */
+	/*cmd.host_command_parameters[0] |= DIVERSITY_ANTENNA_A;*/
+
+	/* long preamble - workaround for a faulty 802.11b radio */
+	cmd.host_command_parameters[0] |= CFG_PREAMBLE_LEN;
+	cmd.host_command_parameters[0] |= CFG_802_1x_ENABLE;
+
+	cmd.host_command_parameters[1] = REG_CHANNEL_MASK;
+
+	cmd.host_command_parameters[2] = 0;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err)
+		return err;
+
+	cmd.host_command = ADD_MULTICAST;
+	cmd.host_command_sequence = 0;
+	cmd.host_command_length = 0;
+
+	ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	return 0;
+}
+
+int ipw2100_set_tx_rates(struct ipw2100_priv *priv, u32 rate, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = BASIC_TX_RATES,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = rate & TX_RATE_MASK
+	};
+	int err;
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	/* Set BASIC TX Rate */
+	ipw2100_hw_send_command(priv, &cmd);
+
+	/* Set TX Rate */
+	cmd.host_command = TX_RATES;
+	ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	return 0;
+}
+
+int ipw2100_set_power_mode(struct ipw2100_priv *priv, 
+			   int power_level)
+{
+	struct host_command cmd = {
+		.host_command = POWER_MODE,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = power_level
+	};
+	int err;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err)
+		return err;
+
+#ifdef CONFIG_IPW2100_TX_POWER
+	if (priv->port_type == IBSS && 
+	    priv->adhoc_power != DFTL_IBSS_TX_POWER) {
+		/* Set beacon interval */
+		cmd.host_command = TX_POWER_INDEX;
+		cmd.host_command_parameters[0] = (u32)priv->adhoc_power;
+
+		err = ipw2100_hw_send_command(priv, &cmd);
+		if (err)
+			return err;
+	}
+#endif
+
+	return 0;
+}
+
+
+int ipw2100_set_rts_threshold(struct ipw2100_priv *priv, u32 threshold)
+{
+	struct host_command cmd = {
+		.host_command = RTS_THRESHOLD,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = threshold
+	};
+	int err;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) 
+		return err;
+
+	priv->rts_threshold = threshold;
+
+	return 0;
+}
+
+int ipw2100_set_fragmentation_threshold(struct ipw2100_priv *priv,
+					u32 threshold, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = FRAG_THRESHOLD,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = 0,
+	};
+	int err;
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	if (threshold == 0) 
+		threshold = DEFAULT_FRAG_THRESHOLD;
+	else {
+		threshold = max(threshold, MIN_FRAG_THRESHOLD);
+		threshold = min(threshold, MAX_FRAG_THRESHOLD);
+	}
+
+	cmd.host_command_parameters[0] = threshold;
+
+	IPW2100_DEBUG_FW_COMMAND("FRAG_THRESHOLD: %u\n", threshold);
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batchmode)
+		ipw2100_enable_adapter(priv);
+
+	if (!err)
+		priv->frag_threshold = threshold;
+
+	return err;
+}
+
+int ipw2100_set_short_retry(struct ipw2100_priv *priv, u32 retry)
+{
+	struct host_command cmd = {
+		.host_command = SHORT_RETRY_LIMIT,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = retry
+	};
+	int err;
+	
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err)
+		return err;
+
+	priv->short_retry_limit = retry;
+
+	return 0;
+}
+
+int ipw2100_set_long_retry(struct ipw2100_priv *priv, u32 retry)
+{
+	struct host_command cmd = {
+		.host_command = LONG_RETRY_LIMIT,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = retry
+	};
+	int err;
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (err) 
+		return err;
+
+	priv->long_retry_limit = retry;
+
+	return 0;
+}
+
+
+int ipw2100_set_mandatory_bssid(struct ipw2100_priv *priv, u8 *bssid, 
+				int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = MANDATORY_BSSID,
+		.host_command_sequence = 0,
+		.host_command_length = (bssid == NULL) ? 0 : ETH_ALEN 
+	};
+	int err;
+
+#ifdef CONFIG_IPW2100_DEBUG
+	if (bssid != NULL)
+		IPW2100_DEBUG_FW_COMMAND(
+			"MANDATORY_BSSID: %02X:%02X:%02X:%02X:%02X:%02X\n",
+			bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], 
+			bssid[5]);
+	else
+		IPW2100_DEBUG_FW_COMMAND("MANDATORY_BSSID: <clear>\n");
+#endif
+	/* if BSSID is empty then we disable mandatory bssid mode */
+	if (bssid != NULL)
+		memcpy((u8 *)cmd.host_command_parameters, bssid, ETH_ALEN);
+	
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) 
+			return err;
+	}
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	
+	if (!batchmode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+#if 0
+static int ipw2100_disassociate_bssid(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = DISASSOCIATION_BSSID,
+		.host_command_sequence = 0,
+		.host_command_length = ETH_ALEN
+	};
+	int err;
+	int len;
+
+	IPW2100_DEBUG_FW_COMMAND("DISASSOCIATION_BSSID\n");
+
+	len = ETH_ALEN;
+	ret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, 
+				  &priv->ctx->bssid,  &len);
+	memcpy(cmd.host_command_parameters, priv->ctx->bssid, ETH_ALEN);
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	return err;
+}
+#endif
+		
+int ipw2100_set_essid(struct ipw2100_priv *priv, char *essid, int batchmode)
+{
+	int ssid_length = strnlen(essid, IW_ESSID_MAX_SIZE);
+	struct host_command cmd = {
+		.host_command = SSID,
+		.host_command_sequence = 0,
+		.host_command_length = ssid_length
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("SSID: %s\n", essid);
+	
+	if (memcmp(priv->ctx->ssid, essid, ssid_length) == 0)
+		return 0;
+
+	if (ssid_length) 
+		strncpy((char*)cmd.host_command_parameters, 
+			essid, ssid_length);
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err)
+			return err;
+	}
+
+	ipw2100_start_scan(priv);
+		
+	/* NOTE:  We always send the SSID command even if the provided ESSID is
+	 * the same as what we currently think is set. */
+	
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (!err) {
+		memset(priv->ctx->ssid, 0, IW_ESSID_MAX_SIZE);
+		memcpy(priv->ctx->ssid, essid, ssid_length);
+		
+	}
+
+	if (!batchmode) {
+		if (ipw2100_enable_adapter(priv)) 
+			err = -EIO;
+	}
+
+	return err;
+}
+
+
+struct security_info_params {
+	u32 allowed_ciphers;
+	u16 version;
+	u8 auth_mode;
+	u8 replay_counters_number;
+	u8 unicast_using_group;
+} __attribute__ ((packed));
+
+int ipw2100_set_security_information(struct ipw2100_priv *priv, 
+				     int auth_shared, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = SET_SECURITY_INFORMATION,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(struct security_info_params)
+	};
+	struct security_info_params *security = 
+		(struct security_info_params *)&cmd.host_command_parameters;
+	int err;
+	memset(security, 0, sizeof(*security));
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/* All encryption/decryption is handled in the driver itself and no
+	 * longer in the firmware, so set the firmware to not do anything and
+	 * just provide all packets to the driver 
+	 *
+	 * NOTE: This is the case for everything except AP authentication */
+	security->auth_mode = auth_shared ? AUTH_SHARED : AUTH_OPEN;
+	if (security->auth_mode == AUTH_OPEN) 
+		security->allowed_ciphers = NONE_CIPHER;
+	else if (security->auth_mode == AUTH_SHARED) 
+		security->allowed_ciphers = WEP40_CIPHER | WEP104_CIPHER;
+	security->replay_counters_number = 0;
+
+	if (!batchmode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err)
+			return err;
+	}
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+	if (!err)
+		priv->authentication = security->auth_mode;
+		
+	if (!batchmode) {
+		err = ipw2100_enable_adapter(priv);
+	}
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return err;
+}
+
+int ipw2100_set_ibss_beacon_interval(struct ipw2100_priv *priv, 
+				     u32 interval, int batchmode)
+{
+	struct host_command cmd = {
+		.host_command = BEACON_INTERVAL,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = interval
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	if (priv->port_type == IBSS) {
+		if (!batchmode) {
+			err = ipw2100_disable_adapter(priv);
+			if (err)
+				return err;
+		}
+		
+		ipw2100_hw_send_command(priv, &cmd);
+		
+		if (!batchmode) {
+			err = ipw2100_enable_adapter(priv);
+			if (err)
+				return err;
+		}
+	}
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+int ipw2100_set_scan_options(struct ipw2100_priv *priv)
+{
+	struct host_command cmd = {
+		.host_command = SET_SCAN_OPTIONS,
+		.host_command_sequence = 0,
+		.host_command_length = 8,
+		.host_command_parameters[0] = 0,
+		.host_command_parameters[1] = 0
+	};
+	int err;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	IPW2100_DEBUG_SCAN("setting scan options\n");
+
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return err;
+}
+
+
+void ipw2100_queues_initialize(struct ipw2100_priv *priv)
+{
+	ipw2100_tx_initialize(priv);
+	ipw2100_rx_initialize(priv);
+	ipw2100_msg_initialize(priv);
+}
+
+void ipw2100_queues_free(struct ipw2100_priv *priv)
+{
+	ipw2100_tx_free(priv);
+	ipw2100_rx_free(priv);
+	ipw2100_msg_free(priv);
+}
+
+int ipw2100_queues_allocate(struct ipw2100_priv *priv)
+{
+	int err;
+	err = ipw2100_tx_allocate(priv);
+	if (err)
+		goto fail;
+
+	err = ipw2100_rx_allocate(priv);
+	if (err)
+		goto fail;
+	
+	err = ipw2100_msg_allocate(priv);
+	if (err)
+		goto fail;
+
+	return 0;
+
+ fail:
+	ipw2100_rx_free(priv);
+	ipw2100_msg_free(priv);
+	return -ENOMEM;
+}
+
+static int ipw2100_adapter_setup(struct ipw2100_priv *priv)
+{
+	int err;
+	int batchmode = 1;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	err = ipw2100_disable_adapter(priv);
+	if (err)
+		return err;
+
+	err = ipw2100_read_mac_address(priv);
+	if (err)
+		return -EIO;
+
+	err = ipw2100_set_mac_address(priv, batchmode);
+	if (err)
+		return err;
+	
+	err = ipw2100_set_port_type(priv, BSS, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_channel(priv, priv->ctx->channel, batchmode);
+	if (err)
+		return err;
+
+	err  = ipw2100_system_config(priv, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_tx_rates(priv, 0xFFFFFFFF, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);
+	if (err)
+		return err;
+
+	err = ipw2100_set_rts_threshold(priv, priv->rts_threshold);
+	if (err)
+		return err;
+
+	err = ipw2100_set_mandatory_bssid(priv, NULL, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_essid(priv, priv->ctx->ssid, batchmode);
+	if (err)
+		return err;
+
+	err = ipw2100_set_security_information(priv, AUTH_OPEN, batchmode);
+	if (err)
+		return err;
+
+	if (priv->ctx->port_type == IBSS) {
+		err = ipw2100_set_ibss_beacon_interval(
+			priv, priv->beacon_interval, batchmode);
+		if (err)
+			return err;
+	}
+
+	err = ipw2100_set_scan_options(priv);
+	if (err)
+		return err;
+
+	/*
+	 err = ipw2100_set_tx_power_mode(priv, ...);
+	 if (err) 
+	 return err;
+	*/
+	err = ipw2100_set_fragmentation_threshold(
+		priv, priv->frag_threshold, batchmode);
+	if (err) 
+		return err;
+	
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+
+/*************************************************************************
+ * 
+ * EXTERNALLY CALLED METHODS
+ *
+ *************************************************************************/
+
+/* This method is called by the network layer -- not to be confused with
+ * ipw2100_set_mac_address() declared above called by this driver (and this
+ * method as well) to talk to the firmware */
+static int ipw2100_set_address(struct net_device *dev, void *p)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct sockaddr *addr = p;
+	int err;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+
+	err = ipw2100_set_mac_address(priv, 0);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int ipw2100_open(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	unsigned long flags;
+
+	IPW2100_DEBUG_INFO("enter\n");
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_INC_USE_COUNT;
+#endif
+
+	/* TODO: We probably shouldn't start the queue until we receive
+	 * an association.  Likewise, for netif_carrier_on() . . .
+	 */
+	netif_start_queue(dev);
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+	priv->open = 1;
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return 0;
+}
+
+static int ipw2100_close(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	unsigned long flags;
+	struct list_head *element;
+	struct ipw2100_hw_packet *packet;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	netif_carrier_off(dev);
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	priv->open = 0;
+	
+	/* Flush the TX queue ... */
+	while (!list_empty(&priv->tx_pend_list)) {
+		element = priv->tx_pend_list.next;
+                packet = list_entry(element, struct ipw2100_hw_packet, list);
+		list_del(element);
+		dev_kfree_skb(packet->skb);
+		packet->skb = NULL;
+		list_add_tail(element, &priv->tx_free_list);
+	}
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	MOD_DEC_USE_COUNT;
+#endif
+
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+}
+
+static int ipw2100_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	unsigned long flags;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	if (!priv->connected) { 
+		/* TODO: check code to ensure that xmit disabled during
+		 * any call that results in priv->connected == false */
+		IPW2100_DEBUG_INFO("Can not transmit when not connected.\n");
+		priv->stats.tx_carrier_errors++;
+		goto fail_unlock;
+	}
+
+	if (list_empty(&priv->tx_free_list)) {
+		printk(KERN_WARNING "%s: No TX buffers available when awake.\n",
+		       priv->ndev->name);
+		goto fail_unlock;
+	}
+	
+	ipw2100_tx_prepare(priv, skb);
+
+	if (list_empty(&priv->tx_free_list))
+		netif_stop_queue(dev);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return 0;
+
+ fail_unlock:
+	IPW2100_DEBUG_INFO("exit - failed\n");
+	netif_stop_queue(dev);
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+	return 1;
+}
+
+
+/*
+ * TODO:  Fix this function... its just wrong
+ */
+static void ipw2100_tx_timeout(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_TX("enter (connected=%d)\n", priv->connected);
+
+	priv->stats.tx_errors++;
+
+	/* TODO: Make sure we shut off the network interface on 
+	 * disassociation */
+	printk(KERN_INFO "%s: TX timed out.  Scheduling firmware restart.\n",
+	       dev->name);
+	if (!priv->reset_pending) {
+		priv->reset_pending = 1;
+		schedule_work(&priv->reset_work);
+	}
+
+	IPW2100_DEBUG_TX("exit\n");
+}
+
+
+/*
+ * TODO: reimplement it so that it reads statistics
+ *       from the adapter using ordinal tables
+ *       instead of/in addition to collecting them
+ *       in the driver
+ */
+static struct net_device_stats *ipw2100_stats(struct net_device *dev)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv*)dev->priv;
+	return &priv->stats;
+}
+
+static int ipw2100_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu < ETH_ZLEN || new_mtu > ETH_DATA_LEN)
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+	return 0;
+}
+
+
+static int ipw2100_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	IPW2100_DEBUG_INFO("enter\n");
+
+	IPW2100_DEBUG_INFO("exit\n");
+	return -EOPNOTSUPP;
+}
+
+
+static u32 ipw2100_ethtool_get_link(struct net_device *dev)
+{
+    struct ipw2100_priv *priv = (struct ipw2100_priv*)dev->priv;
+    return priv->connected;
+}
+
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,23)
+static struct ethtool_ops ipw2100_ethtool_ops = {
+    .get_link        = ipw2100_ethtool_get_link,
+};
+#endif
+
+static void ipw2100_hang_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+	unsigned long flags;
+	u32 rtc = 0xa5a5a5a5;
+	u32 len = sizeof(rtc);
+	int restart = 0;
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	if (priv->fatal_error != 0) {
+		/* If fatal_error is set then we need to restart */
+		printk(KERN_INFO "%s: Hardware fatal error detected.\n",
+		       priv->ndev->name);
+
+		restart = 1;
+
+	} else if (ipw2100_get_ordinal(priv, IPW_ORD_RTC_TIME, &rtc, &len) ||
+		   (rtc == priv->last_rtc)) {
+		/* Check if firmware is hung */
+		printk(KERN_INFO "%s: Firmware RTC stalled.\n",
+		       priv->ndev->name);
+
+		restart = 1;
+
+	}
+
+	if (restart) {
+		/* Kill timer */
+		priv->stop_hang_check = 1;
+		
+		priv->hangs++;
+		
+		/* Restart the NIC */
+		if (!priv->reset_pending) {
+			printk(KERN_INFO "%s: Scheduling firmware restart.\n",
+			       priv->ndev->name);
+			
+			priv->reset_pending = 1;
+			schedule_work(&priv->reset_work);
+		} else
+			printk(KERN_INFO 
+			       "%s: Firmware restart already in progress.\n",
+			       priv->ndev->name);
+	} 
+
+	priv->last_rtc = rtc;
+
+	/* Check again in two seconds */
+	if (!priv->stop_hang_check)
+		mod_timer(&priv->hang_check_timer, jiffies + 2 * HZ);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+}
+
+
+static void ipw2100_rf_switch_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->low_lock, flags);
+	if (priv->rf_kill != ipw2100_get_rf_switch(priv)) {
+		/* Toggle the switch to match what the HW told us */
+		priv->rf_kill = !priv->rf_kill;
+		
+		printk(KERN_INFO "%s: RF Kill state changed to radio %s.\n",
+		       priv->ndev->name,
+		       priv->rf_kill ? "OFF" : "ON");
+		
+		if (priv->rf_kill) {
+			/* RF switch is ON; firmware will have killed the HW */
+			priv->rf_kill = 0;
+		} else {
+                        /* Kill timer; we don't need to poll for RF going
+			 * off since the firmware will tell us */
+			priv->stop_rf_check = 1;
+			
+			/* Restart the NIC */
+			if (!priv->reset_pending) {
+				printk(KERN_INFO 
+				       "%s: Scheduling firmware restart.\n",
+				       priv->ndev->name);
+				
+				priv->reset_pending = 1;
+				schedule_work(&priv->reset_work);
+			} else
+				printk(KERN_INFO 
+				       "%s: Firmware restart already in progress.\n",
+				       priv->ndev->name);
+		} 
+	} 
+	
+	/* Check again in one second */
+	if (!priv->stop_rf_check)
+		mod_timer(&priv->rf_switch_timer, jiffies + HZ);
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+}
+
+static void ipw2100_irq_tasklet(struct ipw2100_priv *priv);
+
+static struct net_device *ipw2100_alloc_device(
+	struct pci_dev *pdev,
+	char *base_addr, 
+	unsigned long mem_start,
+	unsigned long mem_len)
+{
+	struct ipw2100_priv *priv;
+	struct net_device *dev;
+
+	dev = alloc_etherdev(sizeof(struct ipw2100_priv));
+	if (!dev)
+		return NULL;
+
+	dev->type = ARPHRD_ETHER;
+	dev->open = ipw2100_open;
+	dev->stop = ipw2100_close;
+	dev->hard_start_xmit = ipw2100_tx;
+	dev->do_ioctl = ipw2100_ioctl;
+	dev->get_stats = ipw2100_stats;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,23)
+	dev->ethtool_ops = &ipw2100_ethtool_ops;
+#endif
+	dev->change_mtu = ipw2100_change_mtu;
+	dev->tx_timeout = ipw2100_tx_timeout;
+	dev->wireless_handlers = &ipw2100_wx_handler_def;
+	dev->get_wireless_stats = ipw2100_wx_wireless_stats;
+	dev->set_mac_address = ipw2100_set_address;
+	dev->watchdog_timeo = 3*HZ;
+	dev->irq = 0;
+
+	dev->base_addr = (unsigned long)base_addr;
+	dev->mem_start = mem_start;
+	dev->mem_end = dev->mem_start + mem_len - 1;
+	
+	if (!if_name || if_name[0] == '\0')
+                strncpy(dev->name, "eth%d", IFNAMSIZ - 1);
+        else 
+                strncpy(dev->name, if_name, IFNAMSIZ - 1);
+
+	/* NOTE: We don't use the wireless_handlers hook
+	 * in dev as the system will start throwing WX requests
+	 * to us before we're actually initialized and it just
+	 * ends up causing problems.  So, we just handle
+	 * the WX extensions through the ipw2100_ioctl interface */
+
+	priv = (struct ipw2100_priv*)dev->priv;
+	memset(priv, 0, sizeof(struct ipw2100_priv));
+
+	priv->ctx = &priv->active_ctx;
+	priv->pdev = pdev;
+	priv->ndev = dev;
+
+	/* memset() puts everything to 0, so we only have explicitely set
+	 * those values that need to be something else */
+	priv->disabled = 1;
+	priv->stopped = 1;
+
+	priv->ctx->port_type = BSS;
+	priv->ctx->channel = 1;
+
+	priv->beacon_interval = DEFAULT_BEACON_INTERVAL;
+	priv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;
+	priv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;
+	priv->rts_threshold = DEFAULT_RTS_THRESHOLD;
+	priv->frag_threshold = DEFAULT_FRAG_THRESHOLD;
+
+	priv->tx_power = 0;
+
+	strcpy(priv->nick, "ipw2100");
+
+
+	IPW2100_DEBUG_INFO("Port type set to %s\n", 
+			   port_type_str[priv->ctx->port_type]);
+
+	spin_lock_init(&priv->low_lock);
+
+	init_waitqueue_head(&priv->wait_command_queue);
+
+	priv->connected = 0;
+	netif_carrier_off(dev);
+
+#ifndef CONFIG_IPW2100_WEP
+	INIT_LIST_HEAD(&priv->defrag_free_list);
+	INIT_LIST_HEAD(&priv->defrag_list);
+#endif
+		       
+	INIT_LIST_HEAD(&priv->msg_free_list);
+	INIT_LIST_HEAD(&priv->msg_pend_list);
+
+	INIT_LIST_HEAD(&priv->tx_free_list);
+	INIT_LIST_HEAD(&priv->tx_pend_list);
+
+	INIT_LIST_HEAD(&priv->fw_pend_list);
+	
+	INIT_WORK(&priv->reset_work, (void (*)(void *))ipw2100_reset_adapter, 
+		  priv);
+
+	tasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))
+		     ipw2100_irq_tasklet, (unsigned long)priv);
+
+	/* NOTE:  We do not start the timer yet; we only run the timer if the
+	 *        the RF kill switch has been triggered */
+	init_timer(&priv->rf_switch_timer);
+	priv->rf_switch_timer.data = (unsigned long)priv;
+	priv->rf_switch_timer.function = ipw2100_rf_switch_check;
+	priv->stop_rf_check = 1;   /* Timer not running */
+
+	init_timer(&priv->hang_check_timer);
+	priv->hang_check_timer.data = (unsigned long)priv;
+	priv->hang_check_timer.function = ipw2100_hang_check;
+	priv->stop_hang_check = 1; /* Timer not running */
+	return dev;
+}
+
+
+#ifdef CONFIG_IPW2100_WEP
+
+#define IPW_PRIVACY_CAPABLE 0x0008
+
+static int ipw2100_set_wep_flags(struct ipw2100_priv *priv, u32 flags, 
+				 int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = WEP_FLAGS,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = flags,
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("WEP_FLAGS: flags = 0x%08X\n", flags);
+	
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	/* send cmd to firmware */
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+struct ipw2100_wep_key {
+	u8 idx;
+	u8 len;
+	u8 key[13];
+};
+
+static int ipw2100_set_key(struct ipw2100_priv *priv, 
+			   int idx, char *key, int len, int batch_mode)
+{
+	int keylen = len ? (len <= 5 ? 5 : 13) : 0;
+	struct host_command cmd = {
+		.host_command = WEP_KEY_INFO,
+		.host_command_sequence = 0,
+		.host_command_length = sizeof(struct ipw2100_wep_key),
+	};
+	struct ipw2100_wep_key *wep_key = (void*)cmd.host_command_parameters;
+	int err;
+	
+	IPW2100_DEBUG_FW_COMMAND("WEP_KEY_INFO: index = %d, len = %d/%d\n", idx,
+				 keylen, len);
+
+	/* NOTE: We don't check cached values in case the firmware was reset
+	 * or some other problem is occuring.  If the user is setting the key,
+	 * then we push the change */
+	
+	wep_key->idx = idx;
+	wep_key->len = keylen;
+
+	if (keylen) {
+		memcpy(wep_key->key, key, len);
+		memset(wep_key->key + len, 0, keylen - len);
+	}
+
+	printk(KERN_INFO "%s: idx: %d, len: %d key: %c%c%c%c%c\n",
+	       priv->ndev->name, wep_key->idx, wep_key->len,
+	       wep_key->key[0], 
+	       wep_key->key[1], 
+	       wep_key->key[2], 
+	       wep_key->key[3], 
+	       wep_key->key[4]);
+
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	err = ipw2100_set_wep_flags(priv, IPW_PRIVACY_CAPABLE, 1);
+	if (!err) {
+		/* send cmd to firmware */
+		err = ipw2100_hw_send_command(priv, &cmd);
+		
+		/* store if successful */
+		if (!err) {
+			memcpy(priv->key_table[idx], key, len);
+			priv->key_size[idx] = len;
+		}
+	}
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+static int ipw2100_set_key_index(struct ipw2100_priv *priv, 
+				 int idx, int batch_mode)
+{
+	struct host_command cmd = {
+		.host_command = WEP_KEY_INDEX,
+		.host_command_sequence = 0,
+		.host_command_length = 4,
+		.host_command_parameters[0] = idx,
+	};
+	int err;
+
+	IPW2100_DEBUG_FW_COMMAND("WEP_KEY_INDEX: index = %d\n", idx);
+	
+	if (idx < 0 || idx > 3)
+		return -EINVAL;
+
+	if (!batch_mode) {
+		err = ipw2100_disable_adapter(priv);
+		if (err) {
+			printk(KERN_ERR "%s: Could not disable adapter %d\n",
+			       priv->ndev->name, err);
+			return err;
+		}
+	}
+
+	/* send cmd to firmware */
+	err = ipw2100_hw_send_command(priv, &cmd);
+
+	/* store if successful */
+	if (!err) {
+		priv->key_current = idx;
+	}
+
+	if (!batch_mode) 
+		ipw2100_enable_adapter(priv);
+
+	return err;
+}
+
+static void shim__set_key(struct ieee80211_device *ieee, int idx, 
+			    char *key, int len)
+{
+	ipw2100_set_key(ieee->priv, idx, key, len, 1);
+}
+
+static void shim__set_key_idx(struct ieee80211_device *ieee, int idx)
+{
+	ipw2100_set_key_index(ieee->priv, idx, 0);
+}
+
+static void shim__set_wep_authentication(struct ieee80211_device *ieee, 
+					 int enable)
+{
+	ipw2100_set_security_information(ieee->priv, 
+					 enable ? AUTH_SHARED : AUTH_OPEN, 0);
+}
+
+static struct ieee80211_helper_functions ipw2100_ieee_callbacks = {
+	.set_key = shim__set_key,
+	.set_key_idx = shim__set_key_idx,
+	.set_wep_authentication = shim__set_wep_authentication,
+	.card_present = NULL,
+	.cor_sreset = NULL,
+	.dev_open = NULL,
+	.dev_close = NULL,
+	.genesis_reset = NULL,
+	.set_unencrypted_filter = NULL,
+	.hw_enable = NULL,
+	.hw_config = NULL,
+	.hw_reset = NULL,
+	.hw_shutdown = NULL,
+	.reset_port = NULL,
+	.tx = NULL,
+	.schedule_reset = NULL,
+	.tx_80211 = NULL
+};
+#endif
+
+#define PCI_DMA_32BIT   0x00000000ffffffffULL
+
+static int ipw2100_pci_init_one(struct pci_dev *pdev, 
+				const struct pci_device_id *ent)
+{
+	unsigned long mem_start, mem_len, mem_flags;
+	char *base_addr = NULL;
+	struct net_device *dev = NULL;
+	struct ipw2100_priv *priv = NULL;
+	int err = 0;
+	int registered = 0;
+	u32 val;
+
+	IPW2100_DEBUG_INFO("enter\n");
+
+	/* set up PCI mappings for device */
+	err = pci_enable_device(pdev);
+	if (err)
+		return err;
+
+	pci_set_master(pdev);
+
+	err = pci_set_dma_mask(pdev, PCI_DMA_32BIT);
+	if (err) {
+		IPW2100_DEBUG_INFO("failed pci_set_dma_mask!\n");
+		pci_disable_device(pdev);
+		return err;
+	}
+
+	pci_set_drvdata(pdev, NULL);
+
+	err = pci_request_regions(pdev, DRV_NAME);
+	if (err) {
+		pci_disable_device(pdev);
+		return err;
+	}
+	
+        /* We disable the RETRY_TIMEOUT register (0x41) to keep 
+	 * PCI Tx retries from interfering with C3 CPU state */
+	pci_read_config_dword(pdev, 0x40, &val); 
+	if ((val & 0x0000ff00) != 0) 
+		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
+
+	mem_start = pci_resource_start(pdev, 0);
+	mem_len = pci_resource_len(pdev, 0);
+	mem_flags = pci_resource_flags(pdev, 0);
+
+	if ((mem_flags & IORESOURCE_MEM) != IORESOURCE_MEM) {
+		IPW2100_DEBUG_INFO("weird - resource type is not memory\n");
+		err = -ENODEV;
+		goto fail;
+	}
+
+	base_addr = ioremap_nocache(mem_start, mem_len);
+	if (!base_addr) {
+		err = -EIO;
+		goto fail;
+	}
+
+	pci_set_power_state(pdev, 0);
+	pci_restore_state(pdev, NULL);
+
+	/* allocate and initialize our net_device */
+	dev = ipw2100_alloc_device(pdev, base_addr, mem_start, mem_len);
+	if (!dev) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	if (!ipw2100_hw_is_adapter_in_system(dev)) {
+		err = -ENODEV;
+		goto fail;
+	}
+
+	pci_set_drvdata(pdev, dev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+	SET_NETDEV_DEV(dev, &pdev->dev);
+#endif
+
+	priv = dev->priv;
+
+#ifdef CONFIG_IPW2100_WEP
+	ieee80211_init(&priv->ieee, dev, priv);
+	priv->ieee.func = &ipw2100_ieee_callbacks;
+#endif /* CONFIG_IPW2100_WEP */
+
+	/* begin initializing the hardware */
+	ipw2100_hw_disable_interrupt(priv);
+	priv->irq_enabled = 0;
+
+	/* Allocate and initialize the beacon list */
+	if (ipw2100_beacons_allocate(priv)) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	ipw2100_beacons_initialize(priv);
+
+	/* Allocate and initialize the Tx/Rx queues and lists */
+	if (ipw2100_queues_allocate(priv)) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	ipw2100_queues_initialize(priv);
+
+#ifndef CONFIG_IPW2100_WEP
+	/* Allocate and initialize the defrag buffers */
+	if (ipw2100_defrag_alloc(priv)) {
+		err = -ENOMEM;
+		goto fail;
+	}
+	ipw2100_defrag_initialize(priv);
+#endif
+
+	err = request_irq(pdev->irq,
+			  ipw2100_interrupt, SA_SHIRQ, 
+			  dev->name, dev);
+	if (err) {
+		printk(KERN_ERR
+		       "ipw2100: Error allocating IRQ %d.\n",
+		       pdev->irq);
+		err = -EBUSY;
+		goto fail;
+	}
+	dev->irq = pdev->irq;
+
+	IPW2100_DEBUG_INFO("Attempting to register device...\n");
+
+	err = register_netdev(dev);
+	if (err) {
+		err = -ENODEV;
+		goto fail;
+	}
+	registered = 1;
+
+	SET_MODULE_OWNER(dev);
+
+	printk(KERN_INFO "Detected ipw2100 PCI device at "
+	       "%s, dev: %s, mem: 0x%lX-0x%lX -> %p, irq: %d\n",
+	       pdev->slot_name, dev->name,
+	       dev->mem_start, dev->mem_end, base_addr, pdev->irq);
+
+	/* perform this after register_netdev so that dev->name is
+	 * set */
+	err = ipw2100_proc_dev_init(priv);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Failed to create /proc node\n",
+		       dev->name);
+		err = -EIO;
+		goto fail;
+	}
+
+	/* Bring up the HW */
+	if (ipw2100_up(dev->priv)) {
+		err = -EIO;
+		goto fail;
+	}
+		
+	IPW2100_DEBUG_INFO("exit\n");
+
+	return 0;
+	
+ fail:
+	if (dev) {
+		if (registered) 
+			unregister_netdev(dev);
+
+		if (dev->irq) {
+			free_irq(dev->irq, dev);
+		}
+
+		/* These are safe to call even if they weren't allocated */
+#ifndef CONFIG_IPW2100_WEP
+		ipw2100_defrag_free(priv);
+#endif
+		ipw2100_beacons_free(priv);
+		ipw2100_queues_free(priv);
+		ipw2100_proc_dev_cleanup(priv);
+
+		free_netdev(dev);
+		pci_set_drvdata(pdev, NULL);
+	}
+
+	if (base_addr) 
+		iounmap((char*)base_addr);
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+
+	return err;
+}
+
+static void __devexit ipw2100_pci_remove_one(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct ipw2100_priv *priv;
+
+	if (dev) {
+		priv = dev->priv;
+
+		/* Unregister the device first - this results in close() 
+		 * being called if the device is open.  If we free storage
+		 * first, then close() will crash. */
+		unregister_netdev(dev);
+
+#ifdef CONFIG_IPW2100_WEP
+		ieee80211_deinit(&priv->ieee);
+#endif /* CONFIG_IPW2100_WEP */
+
+		ipw2100_down(priv);
+
+ 		ipw2100_proc_dev_cleanup(priv);
+
+#ifndef CONFIG_IPW2100_WEP
+		ipw2100_defrag_free(priv);
+#endif
+		ipw2100_beacons_free(priv);
+		ipw2100_queues_free(priv);
+
+		if (dev->irq)
+			free_irq(dev->irq, dev);
+
+		if (dev->base_addr)
+			iounmap((unsigned char *)dev->base_addr);
+
+		free_netdev(dev);
+	}
+
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+
+	IPW2100_DEBUG_INFO("exit\n");
+}
+
+#ifdef CONFIG_PM
+
+static int ipw2100_suspend(struct pci_dev *pdev, u32 state)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct ipw2100_priv *priv = dev->priv;
+	
+	
+	netif_device_detach(dev);
+
+	if (netif_running(dev))
+		ipw2100_down(priv);
+	
+	pci_save_state(pdev, priv->pm_state);
+	pci_disable_device(pdev);       // needed?
+	pci_set_power_state(pdev, state);
+	
+	return 0;
+}
+
+
+static int ipw2100_resume(struct pci_dev *pdev)
+{
+	struct net_device *dev = pci_get_drvdata(pdev);
+	struct ipw2100_priv *priv = dev->priv;
+	u32 val;
+	
+	pci_set_power_state(pdev, 0);
+	pci_restore_state(pdev, priv->pm_state);
+	
+        /* Suspend/Resume resets the PCI configuration space, so we have to
+	 * re-disable the RETRY_TIMEOUT register (0x41) to keep 
+	 * PCI Tx retries from interfering with C3 CPU state */
+	pci_read_config_dword(pdev, 0x40, &val); 
+	if ((val & 0x0000ff00) != 0) 
+		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
+
+	if (netif_running(dev))
+		ipw2100_up(priv);
+	
+	netif_device_attach(dev);
+	
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+#define IPW2100_DEV_ID(x) { PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, x }
+
+static struct pci_device_id ipw2100_pci_id_table[] __devinitdata = {
+	IPW2100_DEV_ID(0x2520), /* IN 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2521), /* IN 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2524), /* IN 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2525), /* IN 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2526), /* IN 2100A mPCI Gen A3 */
+	IPW2100_DEV_ID(0x2522), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2523), /* IN 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2527), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2528), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2529), /* IN 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x252B), /* IN 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x252C), /* IN 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x252D), /* IN 2100 mPCI 3A */
+
+	IPW2100_DEV_ID(0x2550), /* IB 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2551), /* IB 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2553), /* IB 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2554), /* IB 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2555), /* IB 2100 mPCI 3B */
+
+	IPW2100_DEV_ID(0x2560), /* DE 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2562), /* DE 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2563), /* DE 2100A mPCI 3A */
+	IPW2100_DEV_ID(0x2561), /* DE 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2565), /* DE 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2566), /* DE 2100 mPCI 3A */
+	IPW2100_DEV_ID(0x2567), /* DE 2100 mPCI 3A */
+
+	IPW2100_DEV_ID(0x2570), /* GA 2100 mPCI 3B */
+
+	IPW2100_DEV_ID(0x2580), /* TO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2582), /* TO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2583), /* TO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2581), /* TO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2585), /* TO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2586), /* TO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2587), /* TO 2100 mPCI 3B */
+
+	IPW2100_DEV_ID(0x2590), /* SO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2592), /* SO 2100A mPCI 3B */
+	IPW2100_DEV_ID(0x2591), /* SO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2593), /* SO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2596), /* SO 2100 mPCI 3B */
+	IPW2100_DEV_ID(0x2598), /* SO 2100 mPCI 3B */
+	
+	IPW2100_DEV_ID(0x25A0), /* HP 2100 mPCI 3B */
+	{0,},
+};
+
+MODULE_DEVICE_TABLE(pci, ipw2100_pci_id_table);
+
+static struct pci_driver ipw2100_pci_driver = {
+	.name = DRV_NAME,
+	.id_table = ipw2100_pci_id_table,
+	.probe = ipw2100_pci_init_one,
+	.remove = __devexit_p(ipw2100_pci_remove_one),
+#ifdef CONFIG_PM
+	.suspend = ipw2100_suspend,
+	.resume = ipw2100_resume,
+#endif
+};
+
+/*
+ * module stuff
+ */
+
+static int __init ipw2100_init(void)
+{
+	int err;
+
+	printk(KERN_INFO DRV_NAME ": %s, %s\n", DRV_DESCRIPTION, DRV_VERSION);
+	printk(KERN_INFO DRV_NAME ": %s\n", DRV_COPYRIGHT);
+
+#ifdef CONFIG_IPW2100_WEP
+	printk(KERN_INFO DRV_NAME ": Compiled with WEP support.\n");
+#endif	       
+
+	/* If debug module parameter declared, set debug_level to that */
+	if (debug != -1) 
+		ipw2100_debug_level = debug;
+	else /* Otherwise, if ipw2100_debug_level has not been initialized, set
+	      * it to NONE */
+		if (ipw2100_debug_level & IPW2100_DL_UNINIT)
+			ipw2100_debug_level = IPW2100_DL_NONE;
+
+	ipw2100_proc_init();
+
+	err = pci_module_init(&ipw2100_pci_driver);
+	if (err)
+		ipw2100_proc_cleanup();
+
+	return err;
+}
+
+static void __exit ipw2100_exit(void)
+{
+	pci_unregister_driver(&ipw2100_pci_driver);
+
+	ipw2100_proc_cleanup();
+}
+
+module_init(ipw2100_init);
+module_exit(ipw2100_exit);
+
+/*
+         1         2         3         4         5         6         7
+12345678901234567890123456789012345678901234567890123456789012345678901234567890
+*/
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_wx.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_wx.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_wx.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_wx.c	2004-05-22 09:13:02.057951709 -0500
@@ -0,0 +1,1048 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+
+  Portions of this file are based on the sample_* files provided by Wireless
+  Extensions 0.26 package and copyright (c) 1997-2003 Jean Tourrilhes 
+  <jt@hpl.hp.com>
+
+  Portions of this file are based on the Host AP project, 
+  Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen
+    <jkmaline@cc.hut.fi>
+  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+
+/*******************************************************************************
+
+  Changes
+
+  0.40 Pedro Ramalhais 
+       Added support for available channel and rates to iwlist.  Code derived
+       from Host AP.
+  0.33 Luc Saillard
+       Added support for wireless stats (/proc/net/wireless)
+
+*******************************************************************************/
+
+/*
+ * This file defines the Wireless Extension handlers.  It does not
+ * define any methods of hardware manipulation and relies on the
+ * functions defined in ipw2100_main to provide the HW interaction.
+ * 
+ * The exception to this is the use of the ipw2100_get_ordinal() 
+ * function used to poll the hardware vs. making unecessary calls.
+ *
+ */
+#include <asm/uaccess.h>
+
+#include "ipw2100.h"
+#include "ipw2100_hw.h"
+#include "ipw2100_wx.h"
+#include "ieee80211.h"
+
+#if WIRELESS_EXT > 12
+
+const long ipw2100_frequencies[] = {  
+	2412, 2417, 2422, 2427, 
+	2432, 2437, 2442, 2447, 
+	2452, 2457, 2462, 2467, 
+	2472, 2484  
+};
+
+#define FREQ_COUNT (sizeof(ipw2100_frequencies) / sizeof(ipw2100_frequencies[0]))
+
+const long ipw2100_rates_11b[] = {
+	1000000,
+	2000000,
+	5500000,
+	11000000
+};
+
+#define RATE_COUNT (sizeof(ipw2100_rates_11b) / sizeof(ipw2100_rates_11b[0]))
+
+static int ipw2100_wx_get_name(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	strcpy(wrqu->name, "IEEE 802.11b");
+	IPW2100_DEBUG_WX("Name: %s\n", wrqu->name);
+	return 0;
+}
+
+
+static int ipw2100_wx_set_freq(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra) 
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_freq *fwrq = &wrqu->freq;
+	
+	/* we only set channel in adhoc mode */
+	if (priv->ctx->port_type != BSS) {
+		/* if setting by freq convert to channel */
+		if (fwrq->e == 1) {
+			if ((fwrq->m >= (int) 2.412e8 &&
+			     fwrq->m <= (int) 2.487e8)) {
+				int f = fwrq->m / 100000;
+				int c = 0;
+				
+				while ((c < REG_MAX_CHANNEL) &&
+				       (f != ipw2100_frequencies[c]))
+					c++;
+				
+				/* hack to fall through */
+				fwrq->e = 0;
+				fwrq->m = c + 1;
+			}
+		}
+
+		if (fwrq->e > 0 || fwrq->m > 1000) 
+			return -EOPNOTSUPP;
+		else /* set the channel */
+			return ipw2100_set_channel(priv, fwrq->m, 0);
+	}
+
+	IPW2100_DEBUG_WX("SET Freq/Channel -> %d \n", priv->ctx->channel);
+	return 0;
+}
+
+
+static int ipw2100_wx_get_freq(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_freq *fwrq = &wrqu->freq;
+	u32 chan;
+	u32 len = sizeof(u32);
+	int err;
+
+	/* feed crap if we are not associated */
+	if (priv->disabled || priv->ctx->ssid[0] == '\0') {
+		fwrq->m = 0;
+		fwrq->e = 0;
+		return 0;
+	}
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &len);
+	if (err) {
+		IPW2100_DEBUG_WX("failed querying ordinals.\n");
+		return err;
+	}
+
+	/* we keep it */
+	priv->ctx->channel = chan;
+
+#ifdef WEXT_USECHANNELS
+	/* return CHANNEL no if requested so */
+	fwrq->m = chan;
+	fwrq->e = 0;
+#else
+	/* otherwise return freq */
+	fwrq->m = ipw2100_frequencies[chan - 1] * 100000;
+	fwrq->e = 1;
+#endif	/* WEXT_USECHANNELS */
+
+	IPW2100_DEBUG_WX("GET Freq/Channel -> %d \n", fwrq->m);
+	return 0;
+}
+
+static int ipw2100_wx_set_mode(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	err = ipw2100_set_port_type(
+		priv, wrqu->mode == IW_MODE_ADHOC ? IBSS : BSS, 0);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET Mode -> %s \n",
+	       port_type_str[priv->ctx->port_type]);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_mode(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	switch (priv->ctx->port_type) {
+	case BSS:
+		wrqu->mode = IW_MODE_INFRA;
+		break;
+	case IBSS:
+		wrqu->mode = IW_MODE_ADHOC;
+		break;
+	default:
+		/*
+		wrqu->mode = IW_MODE_AUTO;
+		*/
+		wrqu->mode = IW_MODE_INFRA;
+	}
+
+	IPW2100_DEBUG_WX("GET Mode -> %s \n",
+	       port_type_str[priv->ctx->port_type]);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_range(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct iw_range *range = (struct iw_range *)extra;
+	u16 val;
+	int i;
+
+	wrqu->data.length = sizeof(*range);
+	memset(range, 0, sizeof(*range));
+
+	/* Let's try to keep this struct in the same order as in
+	 * linux/include/wireless.h
+	 */
+	
+	/* TODO: See what values we can set, and remove the ones we can't
+	 * set, or fill them with some default data.
+	 */
+
+	/* ~5 Mb/s real (802.11b) */
+	range->throughput = 5 * 1000 * 1000;     
+
+	// TODO: Not used in 802.11b?
+//	range->min_nwid;	/* Minimal NWID we are able to set */
+	// TOOD: Not used in 802.11b?
+//	range->max_nwid;	/* Maximal NWID we are able to set */
+
+//	range->old_num_channels;	/* Old Frequency (backward compat - moved lower ) */
+//	range->old_num_frequency;	/* Old Frequency (backward compat - moved lower ) */
+//	range->old_freq[6];		/* Filler to keep "version" at the same offset */
+
+//	range->sensitivity;	/* signal level threshold range */
+	
+	range->max_qual.qual = 100;
+	/* TODO: Find real max RSSI and stick here */
+	range->max_qual.level = 0;
+	range->max_qual.noise = IPW2100_RSSI_TO_DBM;
+	range->max_qual.updated = 7; /* Updated all three */
+
+	range->avg_qual.qual = 92; /* > 8% missed beacons is 'bad' */
+	/* TODO: Find real 'good' to 'bad' threshol value for RSSI */
+	range->avg_qual.level = 20 + IPW2100_RSSI_TO_DBM;
+	range->avg_qual.noise = 0;
+	range->avg_qual.updated = 7; /* Updated all three */
+
+	range->num_bitrates = RATE_COUNT;
+
+	for (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {
+		range->bitrate[i] = ipw2100_rates_11b[i];
+	}
+	
+//	range->min_rts = 0;	// FIXME: What about min_rts? and max_rts=DEFAULT below?
+	range->max_rts = DEFAULT_RTS_THRESHOLD;
+	range->min_frag = MIN_FRAG_THRESHOLD;
+	range->max_frag = MAX_FRAG_THRESHOLD;
+
+//	range->min_pmp;		/* Minimal PM period */
+//	range->max_pmp;		/* Maximal PM period */
+//	range->min_pmt;		/* Minimal PM timeout */
+//	range->max_pmt;		/* Maximal PM timeout */
+//	range->pmp_flags;	/* How to decode max/min PM period */
+//	range->pmt_flags;	/* How to decode max/min PM timeout */
+//	range->pm_capa;		/* What PM options are supported */
+
+//	range->encoding_size[IW_MAX_ENCODING_SIZES];	/* Different token sizes */
+//	range->num_encoding_sizes;			/* Number of entry in the list */
+//	range->max_encoding_tokens;			/* Max number of tokens */
+//	range->encoding_login_index;			/* token index for login token */
+
+//	range->txpower_capa;		/* What options are supported */
+//	range->num_txpower;		/* Number of entries in the list */
+//	range->txpower[IW_MAX_TXPOWER];	/* list, in bps */
+		
+	/* Set the Wireless Extension versions */
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 16;
+
+//	range->retry_capa;	/* What retry options are supported */
+//	range->retry_flags;	/* How to decode max/min retry limit */
+//	range->r_time_flags;	/* How to decode max/min retry life */
+//	range->min_retry;	/* Minimal number of retries */
+//	range->max_retry;	/* Maximal number of retries */
+//	range->min_r_time;	/* Minimal retry lifetime */
+//	range->max_r_time;	/* Maximal retry lifetime */
+											
+        range->num_channels = FREQ_COUNT;
+
+	val = 0;
+	for (i = 0; i < FREQ_COUNT; i++) {
+		// TODO: Include only legal frequencies for some countries
+//		if (local->channel_mask & (1 << i)) {
+			range->freq[val].i = i + 1;
+			range->freq[val].m = ipw2100_frequencies[i] * 100000;
+			range->freq[val].e = 1;
+			val++;
+//		}
+		if (val == IW_MAX_FREQUENCIES)
+		break;
+	}
+	range->num_frequency = val;
+
+	IPW2100_DEBUG_WX("GET Range\n");
+
+	return 0;
+}
+
+static int ipw2100_wx_set_wap(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	static const unsigned char any[] = {
+		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+	};
+	static const unsigned char off[] = {
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+
+	// sanity checks
+	if (wrqu->ap_addr.sa_family != ARPHRD_ETHER) 
+		return -EINVAL;
+
+	if (!memcmp(any, wrqu->ap_addr.sa_data, ETH_ALEN) ||
+	    !memcmp(off, wrqu->ap_addr.sa_data, ETH_ALEN)) {
+		/* we disable mandatory BSSID association */
+		IPW2100_DEBUG_WX("exit - disable mandatory BSSID\n");
+		return ipw2100_set_mandatory_bssid(priv, NULL, 0);
+	}
+
+	err = ipw2100_set_mandatory_bssid(
+		priv, wrqu->ap_addr.sa_data, 0);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET BSSID -> %02X:%02X:%02X:%02X:%02X:%02X\n",
+	       wrqu->ap_addr.sa_data[0] & 0xff,
+	       wrqu->ap_addr.sa_data[1] & 0xff,
+	       wrqu->ap_addr.sa_data[2] & 0xff,
+	       wrqu->ap_addr.sa_data[3] & 0xff,
+	       wrqu->ap_addr.sa_data[4] & 0xff, 
+	       wrqu->ap_addr.sa_data[5] & 0xff);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_wap(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int len = ETH_ALEN;
+
+	wrqu->ap_addr.sa_family = ARPHRD_ETHER;
+
+	/* Fetch from the hardware */
+	if (priv->disabled ||
+	    ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, 
+				&priv->ctx->bssid,  &len) ||
+	    priv->ctx->ssid[0] == '\0') {
+		memset(wrqu->ap_addr.sa_data, 0, ETH_ALEN);
+		return 0;
+	}
+
+	memcpy(wrqu->ap_addr.sa_data, &priv->ctx->bssid, ETH_ALEN);
+
+	IPW2100_DEBUG_WX("GET BSSID -> %02X:%02X:%02X:%02X:%02X:%02X\n",
+			 (u8)wrqu->ap_addr.sa_data[0],
+			 (u8)wrqu->ap_addr.sa_data[1],
+			 (u8)wrqu->ap_addr.sa_data[2],
+			 (u8)wrqu->ap_addr.sa_data[3],
+			 (u8)wrqu->ap_addr.sa_data[4],
+			 (u8)wrqu->ap_addr.sa_data[5]);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_essid(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+	
+	if (priv->disabled) {
+		IPW2100_DEBUG_WX("Caching ESSID: %s\n", extra);
+		strncpy(priv->ctx->ssid, extra, IW_ESSID_MAX_SIZE);
+		return 0;
+	}
+
+	err = ipw2100_set_essid(priv, extra, 0);
+	if (err) {
+		IPW2100_DEBUG_WX("SET SSID failed\n");
+		return err;
+	}
+
+	IPW2100_DEBUG_WX("exit\n");
+
+	return 0;
+}
+
+static int ipw2100_wx_get_essid(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	wrqu->data.length = strlen(priv->ctx->ssid) + 1;
+	memcpy(extra, priv->ctx->ssid, wrqu->data.length);
+	wrqu->data.flags = 1; /* active */
+
+	IPW2100_DEBUG_WX("GET ESSID -> %s\n", extra);
+	return 0;
+}
+
+static int ipw2100_wx_set_nick(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	if (wrqu->data.length > IW_ESSID_MAX_SIZE)
+		return -E2BIG;
+
+	wrqu->data.length = min((size_t)wrqu->data.length, sizeof(priv->nick));
+	memset(priv->nick, 0, sizeof(priv->nick));
+	memcpy(priv->nick, extra,  wrqu->data.length);
+
+	IPW2100_DEBUG_WX("SET Nickname -> %s \n", priv->nick);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_nick(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	
+	wrqu->data.length = strlen(priv->nick) + 1;
+	memcpy(extra, priv->nick, wrqu->data.length);
+	wrqu->data.flags = 1; /* active */
+	
+	IPW2100_DEBUG_WX("GET Nickname -> %s \n", extra);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_rate(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int val;
+	int len = sizeof(val);
+	int err;
+
+	if (priv->disabled || priv->ctx->ssid[0] == '\0') {
+		wrqu->bitrate.value = 0;
+		return 0;
+	}
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &val, &len);
+	if (err) {
+		IPW2100_DEBUG_WX("failed querying ordinals.\n");
+		return err;
+	}
+
+	switch (val & TX_RATE_MASK) {
+	case TX_RATE_1_MBIT:
+		wrqu->bitrate.value = 1000000;
+		break;
+	case TX_RATE_2_MBIT:
+		wrqu->bitrate.value = 2000000;
+		break;
+	case TX_RATE_5_5_MBIT:
+		wrqu->bitrate.value = 5500000;
+		break;
+	case TX_RATE_11_MBIT:
+		wrqu->bitrate.value = 11000000;
+		break;
+	default:
+		wrqu->bitrate.value = 0;
+	}
+
+	IPW2100_DEBUG_WX("GET Rate -> %d \n", wrqu->bitrate.value);
+	return 0;
+}
+
+static int ipw2100_wx_set_rts(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	if (wrqu->rts.value < 1 || 
+	    wrqu->rts.value > 2304 || 
+	    wrqu->rts.disabled)
+		return -EINVAL;
+
+	err = ipw2100_set_rts_threshold(priv, wrqu->rts.value);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET RTS Threshold -> %d \n", wrqu->rts.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_rts(struct net_device *dev, 
+			      struct iw_request_info *info, 
+			      union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int len = sizeof(wrqu->rts.value);
+	int err;
+
+	if (priv->disabled)
+		wrqu->rts.value = priv->rts_threshold;
+	else {
+		err = ipw2100_get_ordinal(priv, IPW_ORD_RTS_THRESHOLD, 
+					  &wrqu->rts.value, &len);
+		if (err) {
+			IPW2100_DEBUG_WX("query ordinal failed.\n");
+			return err;
+		}
+	}
+
+	wrqu->rts.fixed = 1; /* no auto select */
+	wrqu->rts.disabled = 0; /* can't be disabled */
+
+	IPW2100_DEBUG_WX("GET RTS Threshold -> %d \n", wrqu->rts.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_txpow(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	IPW2100_DEBUG_WX("TODO: Power management by wireless extension...\n");
+
+	IPW2100_DEBUG_WX("SET TX Power -> %d \n", wrqu->rts.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_txpow(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	wrqu->power.value = priv->tx_power;
+	wrqu->power.fixed = 1;
+	wrqu->power.flags = IW_TXPOW_DBM;
+	wrqu->power.disabled = 0;
+
+	IPW2100_DEBUG_WX("GET TX Power -> %d \n", wrqu->power.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_frag(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	if (wrqu->frag.value < MIN_FRAG_THRESHOLD ||
+	    wrqu->frag.value > MAX_FRAG_THRESHOLD)
+		return -EINVAL;
+
+	err = ipw2100_set_fragmentation_threshold(
+		priv, wrqu->frag.value & ~0x1, 0);
+	if (err) 
+		return err;
+
+	IPW2100_DEBUG_WX("SET Frag Threshold -> %d \n", 
+	       wrqu->frag.value & ~0x01);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_frag(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+/*	int len = sizeof(wrqu->frag.value);
+	int err;
+
+	err = ipw2100_get_ordinal(priv, IPW_ORD_FRAGMENTATION_THRESHOLD,
+				  &wrqu->frag.value, &len);
+*/
+	wrqu->frag.value = ipw2100_msdu_frag_threshold(priv);
+	wrqu->frag.fixed = 0;	/* no auto select */
+	wrqu->frag.disabled = 
+		(wrqu->frag.value == DEFAULT_FRAG_THRESHOLD);
+
+	IPW2100_DEBUG_WX("GET Frag Threshold -> %d \n", wrqu->frag.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_retry(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	int err;
+
+	if (wrqu->retry.flags & IW_RETRY_LIFETIME || 
+	    wrqu->retry.disabled)
+		return -EINVAL;
+
+	if (!wrqu->retry.flags & IW_RETRY_LIMIT)
+		return 0;
+
+	if (wrqu->retry.flags & IW_RETRY_MIN) {
+		err = ipw2100_set_short_retry(priv, wrqu->retry.value);
+		if (err)
+			return err;
+
+		IPW2100_DEBUG_WX("SET Short Retry Limit -> %d \n",
+		       wrqu->retry.value);
+
+		return 0;
+	} 
+
+	if (wrqu->retry.flags & IW_RETRY_MAX) {
+		err = ipw2100_set_long_retry(priv, wrqu->retry.value);
+		if (err)
+			return err;
+
+		IPW2100_DEBUG_WX("SET Long Retry Limit -> %d \n",
+		       wrqu->retry.value);
+
+		return 0;
+	}
+
+	err = ipw2100_set_short_retry(priv, wrqu->retry.value);
+	if (err)
+		return err;
+	err = ipw2100_set_long_retry(priv, wrqu->retry.value);
+	if (err)
+		return err;
+
+	IPW2100_DEBUG_WX("SET Both Retry Limits -> %d \n", wrqu->retry.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_get_retry(struct net_device *dev, 
+				struct iw_request_info *info, 
+				union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	wrqu->retry.disabled = 0; /* can't be disabled */
+
+	if ((wrqu->retry.flags & IW_RETRY_TYPE) == 
+	    IW_RETRY_LIFETIME) 
+		return -EINVAL;
+	
+	if (wrqu->retry.flags & IW_RETRY_MAX) {
+		wrqu->retry.flags = IW_RETRY_LIMIT & IW_RETRY_MAX;
+		wrqu->retry.value = priv->long_retry_limit;
+	} else {
+		wrqu->retry.flags =
+		    (priv->short_retry_limit !=
+		     priv->long_retry_limit) ?
+		    IW_RETRY_LIMIT & IW_RETRY_MIN : IW_RETRY_LIMIT;
+
+		wrqu->retry.value = priv->short_retry_limit;
+	}
+
+	IPW2100_DEBUG_WX("GET Retry -> %d \n", wrqu->retry.value);
+
+	return 0;
+}
+
+static int ipw2100_wx_set_scan(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+
+	IPW2100_DEBUG_WX("Initiating scan...\n");
+	if (ipw2100_start_scan(priv)) {
+		IPW2100_DEBUG_WX("Start scan failed.\n");
+
+		/* TODO: Mark a scan as pending so when hardware initialized
+		 *       a scan starts */
+	}
+
+	return 0;
+}
+
+/*
+ *
+ * Following logic based on the code in drivers/net/wireless/airo.c from 2.6.1
+ *
+ */
+static inline char *ipw2100_translate_scan(char *start, char *stop, 
+					   struct ipw2100_beacon *beacon)
+{
+	struct iw_event iwe;
+	int i;
+
+	/* First entry *MUST* be the AP MAC address */
+	iwe.cmd = SIOCGIWAP;
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER; 
+	memcpy(iwe.u.ap_addr.sa_data, beacon->bssid, ETH_ALEN);
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_ADDR_LEN);
+	
+	/* Remaining entries will be displayed in the order we provide them */
+
+	/* Add the ESSID */
+        iwe.u.data.length = beacon->ssid_len;
+        if (iwe.u.data.length > 32)
+		iwe.u.data.length = 32;
+        iwe.cmd = SIOCGIWESSID;
+        iwe.u.data.flags = 1;
+        start = iwe_stream_add_point(start, stop, &iwe, beacon->ssid);
+
+        /* Add mode */
+        iwe.cmd = SIOCGIWMODE;
+        if (beacon->capability & (SSID_CAPABILITY_BSS | SSID_CAPABILITY_IBSS)) {
+		if (beacon->capability & SSID_CAPABILITY_BSS)
+			iwe.u.mode = IW_MODE_MASTER;
+		else
+			iwe.u.mode = IW_MODE_ADHOC;
+
+		start = iwe_stream_add_event(start, stop, &iwe, IW_EV_UINT_LEN);
+	}
+	
+        /* Add frequency */
+	iwe.cmd = SIOCGIWFREQ;
+	iwe.u.freq.m = ipw2100_frequencies[beacon->channel - 1] * 100000;
+	iwe.u.freq.e = 1;
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add rates */
+	iwe.cmd = SIOCGIWRATE;
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+	for (i = 0; i < beacon->rates_len; i++) {
+		iwe.u.bitrate.value = (beacon->rates[i] & 0x7F) * 500000;
+		start = iwe_stream_add_event(start, stop, &iwe, 
+					     IW_EV_PARAM_LEN);
+	}
+
+	/* Add quality statistics */
+	iwe.cmd = IWEVQUAL;
+	iwe.u.qual.qual = beacon->rssi; /* For quality, we just use signal 
+					 * strength since there is nothing
+					 * else we can measure at this point */
+	iwe.u.qual.level = beacon->rssi + IPW2100_RSSI_TO_DBM;
+	iwe.u.qual.noise = IPW2100_RSSI_TO_DBM;
+	iwe.u.qual.updated = 7;	
+
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_QUAL_LEN);
+
+	/* Add encryption capability */
+	iwe.cmd = SIOCGIWENCODE;
+	if (beacon->capability & SSID_CAPABILITY_ENCRYPT)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	start = iwe_stream_add_point(start, stop, &iwe, beacon->ssid);
+
+	return start;
+}
+
+static int ipw2100_wx_get_scan(struct net_device *dev, 
+			       struct iw_request_info *info, 
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct list_head *element;
+	unsigned long flags;
+
+	char *ev = extra;
+	char *stop = ev + IW_SCAN_MAX_DATA;
+	int i;
+
+	IPW2100_DEBUG_WX("enter\n");
+	
+	spin_lock_irqsave(&priv->low_lock, flags);
+
+	for (element = priv->beacon_list.next, i = 0;
+	     element != &priv->beacon_list;
+	     element = element->next, i++) 
+		ev = ipw2100_translate_scan(
+			ev, stop, 
+			list_entry(element, struct ipw2100_beacon, list));
+
+	spin_unlock_irqrestore(&priv->low_lock, flags);
+
+	wrqu->data.length = ev -  extra;
+	wrqu->data.flags = 0;
+	
+	IPW2100_DEBUG_WX("exit: %d beacons returned.\n", i);
+
+	return 0;
+}
+
+
+#ifdef CONFIG_IPW2100_WEP
+/*
+ * Implementation based on code in hostap-driver v0.1.3 hostap_ioctl.c
+ */
+static int ipw2100_wx_set_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	return ieee80211_wx_set_encode(&priv->ieee, info, wrqu, key);
+}
+
+static int ipw2100_wx_get_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	return ieee80211_wx_get_encode(&priv->ieee, info, wrqu, key);
+}
+#else /* CONIFG_IPW2100_WEP */
+/*
+ * Implementation based on code in wireless tools sample_enc v0.26
+ */
+static int ipw2100_wx_set_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_point *erq = &(wrqu->encoding);
+	int index = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+	if (erq->length > 0) {
+		/* Check the size of the key */
+		if (erq->length > MAX_KEY_SIZE)
+			return(-EINVAL);
+
+		/* Check the index */
+		if ((index < 0) || (index >= MAX_KEYS))
+			index = priv->key_current;
+
+		/* Copy the key in the driver */
+		memcpy(priv->key_table[index], key, erq->length);
+		priv->key_size[index] = erq->length;
+		priv->key_on = 1;
+	} else {
+		/* Do we want to just set the current key ? */
+		if ((index >= 0) && (index < MAX_KEYS)) {
+			if (priv->key_size[index] > 0) {
+				priv->key_current = index;
+				priv->key_on = 1;
+			}
+			else
+				return(-EINVAL);
+		}
+	}
+
+	/* Read the flags */
+	if (erq->flags & IW_ENCODE_DISABLED)
+		priv->key_on = 0; /* disable encryption */
+	if (erq->flags & IW_ENCODE_RESTRICTED)
+		priv->key_open = 0; /* disable open mode */
+	if (erq->flags & IW_ENCODE_OPEN)
+		priv->key_open = 1; /* enable open mode */
+
+	return 0;
+}
+
+static int ipw2100_wx_get_encode(struct net_device *dev, 
+				 struct iw_request_info *info, 
+				 union iwreq_data *wrqu, char *key)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_point *erq = &(wrqu->encoding);
+	int index = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+	IPW2100_DEBUG_WX("TODO: Implement ipw2100_wx_set_encode()\n");
+
+	/* Set the flags */
+	erq->flags = 0;
+	if (priv->key_on == 0)
+		erq->flags |= IW_ENCODE_DISABLED;
+	if (priv->key_open == 0)
+		erq->flags |= IW_ENCODE_RESTRICTED;
+	else
+		erq->flags |= IW_ENCODE_OPEN;
+	
+	/* Which key do we want */
+	if ((index < 0) || (index >= MAX_KEYS))
+		index = priv->key_current;
+	erq->flags |= index + 1;
+	
+	/* Copy the key to the user buffer */
+	erq->length = priv->key_size[index];
+	memcpy(key, priv->key_table[index], priv->key_size[index]);
+
+	return 0;
+}
+#endif /* CONFIG_IPW2100_WEP */
+
+static iw_handler ipw2100_wx_handlers[] =
+{
+        NULL,                     /* SIOCSIWCOMMIT */
+        ipw2100_wx_get_name,      /* SIOCGIWNAME */
+        NULL,                     /* SIOCSIWNWID */
+        NULL,                     /* SIOCGIWNWID */
+        ipw2100_wx_set_freq,      /* SIOCSIWFREQ */
+        ipw2100_wx_get_freq,      /* SIOCGIWFREQ */
+        ipw2100_wx_set_mode,      /* SIOCSIWMODE */
+        ipw2100_wx_get_mode,      /* SIOCGIWMODE */
+        NULL,                     /* SIOCSIWSENS */
+        NULL,                     /* SIOCGIWSENS */
+        NULL,                     /* SIOCSIWRANGE */
+        ipw2100_wx_get_range,     /* SIOCGIWRANGE */
+        NULL,                     /* SIOCSIWPRIV */
+        NULL,                     /* SIOCGIWPRIV */
+        NULL,                     /* SIOCSIWSTATS */
+        NULL,                     /* SIOCGIWSTATS */
+        NULL,                     /* SIOCSIWSPY */
+        NULL,                     /* SIOCGIWSPY */
+        NULL,                     /* SIOCGIWTHRSPY */
+        NULL,                     /* SIOCWIWTHRSPY */
+        ipw2100_wx_set_wap,       /* SIOCSIWAP */
+        ipw2100_wx_get_wap,       /* SIOCGIWAP */
+        NULL,                     /* -- hole -- */
+        NULL,                     /* SIOCGIWAPLIST -- depricated */
+        ipw2100_wx_set_scan,      /* SIOCSIWSCAN */
+        ipw2100_wx_get_scan,      /* SIOCGIWSCAN */
+        ipw2100_wx_set_essid,     /* SIOCSIWESSID */
+        ipw2100_wx_get_essid,     /* SIOCGIWESSID */
+        ipw2100_wx_set_nick,      /* SIOCSIWNICKN */
+        ipw2100_wx_get_nick,      /* SIOCGIWNICKN */
+        NULL,                     /* -- hole -- */
+        NULL,                     /* -- hole -- */
+        NULL,                     /* SIOCSIWRATE */
+        ipw2100_wx_get_rate,      /* SIOCGIWRATE */
+        ipw2100_wx_set_rts,       /* SIOCSIWRTS */
+        ipw2100_wx_get_rts,       /* SIOCGIWRTS */
+        ipw2100_wx_set_frag,      /* SIOCSIWFRAG */
+        ipw2100_wx_get_frag,      /* SIOCGIWFRAG */
+        ipw2100_wx_set_txpow,     /* SIOCSIWTXPOW */
+        ipw2100_wx_get_txpow,     /* SIOCGIWTXPOW */
+        ipw2100_wx_set_retry,     /* SIOCSIWRETRY */
+        ipw2100_wx_get_retry,     /* SIOCGIWRETRY */
+        ipw2100_wx_set_encode,    /* SIOCSIWENCODE */
+        ipw2100_wx_get_encode,    /* SIOCGIWENCODE */
+        NULL,                     /* SIOCSIWPOWER */
+        NULL,                     /* SIOCGIWPOWER */
+};
+
+struct iw_handler_def ipw2100_wx_handler_def = 
+{
+	.num_standard = sizeof(ipw2100_wx_handlers) / sizeof(iw_handler),
+	.num_private = 0,
+	.num_private_args = 0,
+	.standard = ipw2100_wx_handlers,
+	.private = NULL,
+	.private_args = NULL,
+};
+
+/*
+ * Get wireless statistics.
+ * Called by /proc/net/wireless
+ */
+struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device * dev)
+{
+	struct ipw2100_priv *priv = dev->priv;
+	struct iw_statistics *wstats;
+	u32 ord_value, ord_len = sizeof(u32);
+
+	if (!priv)
+		return (struct iw_statistics *) NULL;
+
+	/* if hw is disabled, then ipw2100_get_ordinal() can't be called.
+	 * ipw2100_wx_wireless_stats seems to be called before fw is 
+	 * initialized. */
+	if (priv->disabled)
+		return (struct iw_statistics *) NULL;
+
+	wstats = &priv->wstats;
+
+
+        /* If we don't have a connection the quality is 0*/
+	if (!priv->connected) 
+		wstats->qual.qual = 0; 
+	else {
+		if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS,
+					&ord_value, &ord_len))
+			goto fail_get_ordinal;
+		wstats->qual.qual = 100 - ord_value;
+	}
+
+	if (ipw2100_get_ordinal(priv, IPW_ORD_RSSI_AVG_CURR, 
+				&ord_value, &ord_len))
+		goto fail_get_ordinal;
+	wstats->qual.level = ord_value + IPW2100_RSSI_TO_DBM;
+
+	wstats->qual.noise = IPW2100_RSSI_TO_DBM;
+	wstats->qual.updated = 7;	
+
+	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS, 
+				&ord_value, &ord_len))
+		goto fail_get_ordinal;
+        /* FIXME: this is percent and not a # */
+	wstats->miss.beacon = ord_value; 
+
+	if (ipw2100_get_ordinal(priv, IPW_ORD_STAT_TX_RETRIES, 
+				&ord_value, &ord_len))
+		goto fail_get_ordinal;
+	wstats->discard.retries = ord_value;
+
+	return wstats;
+
+ fail_get_ordinal:
+	IPW2100_DEBUG_WX("failed querying ordinals.\n");
+
+	return (struct iw_statistics *) NULL;
+}
+
+
+
+#endif /* WIRELESS_EXT > 12 */ 
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_wx.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_wx.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipw2100_wx.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipw2100_wx.h	2004-05-22 09:13:02.068950065 -0500
@@ -0,0 +1,46 @@
+/*******************************************************************************
+  
+  Copyright(c) 2003 - 2004 Intel Corporation. All rights reserved.
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Contact Information:
+  James P. Ketrenos <ipw2100-admin@linux.intel.com>
+  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
+
+*******************************************************************************/
+#ifndef __IPW2100_WX_H
+#define __IPW2100_WX_H
+
+#if WIRELESS_EXT > 12
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+
+#ifndef WIRELESS_SPY
+#define WIRELESS_SPY		// enable iwspy support
+#endif
+#include <net/iw_handler.h>	// new driver API
+
+#include "ipw2100.h"
+
+extern struct iw_handler_def ipw2100_wx_handler_def;
+extern struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device * dev);
+
+#endif /* WIRELESS_EXT */
+#endif /* __IPW2100_WX_H */
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/ipwversion.h linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipwversion.h
--- linux-2.6.6/drivers/net/wireless/ipw2100/ipwversion.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/ipwversion.h	2004-05-22 09:13:02.072949468 -0500
@@ -0,0 +1,6 @@
+
+#ifndef __IPWVERSION_h
+#define __IPWVERSION_h
+#define IPW2100_VERSION "0.40-pre"
+#endif
+
diff -urN linux-2.6.6/drivers/net/wireless/ipw2100/pbe5.c linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/pbe5.c
--- linux-2.6.6/drivers/net/wireless/ipw2100/pbe5.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/net/wireless/ipw2100/pbe5.c	2004-05-22 09:13:02.082947974 -0500
@@ -0,0 +1,195 @@
+/*******************************************************************************
+  
+  This program is free software; you can redistribute it and/or modify it 
+  under the terms of the GNU General Public License as published by the Free 
+  Software Foundation; either version 2 of the License, or (at your option) 
+  any later version.
+  
+  This program is distributed in the hope that it will be useful, but WITHOUT 
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
+  more details.
+  
+  You should have received a copy of the GNU General Public License along with
+  this program; if not, write to the Free Software Foundation, Inc., 59 
+  Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  
+  The full GNU General Public License is included in this distribution in the
+  file called LICENSE.
+  
+  Author:
+  Pedro Ramalhais <pmr09313@students.fct.unl.pt>
+  
+  Based on:
+  av5100.c from http://ipw2100.sourceforge.net/
+
+*******************************************************************************/
+
+#include <linux/compiler.h>
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/netdevice.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include "ipwversion.h"
+
+#define DRV_NAME		"pbe5"
+#define DRV_VERSION		"1.0-ipw" IPW2100_VERSION
+#define DRV_DESCRIPTION		"SW RF kill switch for Packard Bell EasyNote E5"
+#define DRV_AUTHOR		"Pedro Ramalhais"
+#define DRV_LICENSE		"GPL"
+
+static int radio = 1;
+MODULE_PARM(radio, "i");
+
+MODULE_DESCRIPTION(DRV_DESCRIPTION);
+MODULE_AUTHOR(DRV_AUTHOR);
+MODULE_LICENSE(DRV_LICENSE);
+
+/*
+ * NOTE: These values were obtained from disassembling the Icon.exe program
+ * installed in the Packard Bell EasyNote E5 laptop. The names were guessed,
+ * so don't rely on them.
+ */
+#define PBE5_PORT_TOGGLE	0x0b3
+#define PBE5_VALUE_TOGGLE_ON	0x01
+#define PBE5_VALUE_TOGGLE_OFF	0x00
+#define PBE5_PORT_APPLY		0x0b2
+#define PBE5_VALUE_APPLY	0xef
+
+// Some "booleans" =;-)
+#define PBE5_RADIO_OFF	0
+#define PBE5_RADIO_ON	1
+
+static int pbe5_radio_status = PBE5_RADIO_ON;
+
+unsigned char pbe5_get_radio(void)
+{
+	unsigned char val = 0x00;
+	
+	val = inb(PBE5_PORT_TOGGLE);
+	
+	return val;
+}
+
+static void pbe5_set_radio(int state_set)
+{
+	pbe5_radio_status = pbe5_get_radio();
+
+	if (pbe5_radio_status != state_set) {
+		// Set the radio toggle register
+		outb(PBE5_VALUE_TOGGLE_ON, PBE5_PORT_TOGGLE);
+		// Commit the radio toggle register value
+		outb(PBE5_VALUE_APPLY, PBE5_PORT_APPLY);
+		// Update the radio status
+		pbe5_radio_status = pbe5_get_radio();
+
+		printk(KERN_INFO DRV_NAME ": Radio turned %s\n",
+			(state_set  == PBE5_RADIO_ON) ? "ON" : "OFF");
+	} else {
+		printk(KERN_INFO DRV_NAME ": Radio already %s\n",
+			(state_set  == PBE5_RADIO_ON) ? "ON" : "OFF");
+	}
+}
+
+
+/*
+ * proc stuff
+ */
+static struct proc_dir_entry *dir_base = NULL;
+
+static int proc_set_radio(struct file *file, const char *buffer, 
+			  unsigned long count, void *data)
+{
+	pbe5_set_radio(buffer[0] == '0' ? PBE5_RADIO_OFF : PBE5_RADIO_ON);
+	
+	return count;
+}
+
+static int proc_get_radio(char *page, char **start, off_t offset,
+			  int count, int *eof, void *data)
+{
+	int len = 0;
+	
+	len += snprintf(page, count, DRV_NAME ": %d\n", 
+			pbe5_radio_status == PBE5_RADIO_OFF ? 0 : 1);
+	
+	*eof = 1;
+	return len;
+}
+
+
+static void pbe5_proc_cleanup(void)
+{
+	if (dir_base) {
+		remove_proc_entry("radio", dir_base);
+		remove_proc_entry(DRV_NAME, &proc_root);
+		dir_base = NULL;
+	}
+}
+
+
+static int pbe5_proc_init(void)
+{
+	struct proc_dir_entry *ent;
+	int err = 0;
+
+	dir_base = create_proc_entry(DRV_NAME, S_IFDIR, &proc_root);
+	if (dir_base == NULL) {
+		printk(KERN_ERR DRV_NAME ": Unable to initialise /proc/" 
+		       DRV_NAME "\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+
+	ent = create_proc_entry("radio", S_IFREG | S_IRUGO | S_IWUSR, 
+				dir_base);
+	if (ent) {
+		ent->read_proc = proc_get_radio;
+		ent->write_proc = proc_set_radio;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/" DRV_NAME "/radio\n");
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	return 0;
+
+ fail:
+	pbe5_proc_cleanup();
+	return err;
+}
+
+/*
+ * module stuff
+ */
+static int __init pbe5_init(void)
+{
+	pbe5_proc_init();
+
+	pbe5_set_radio((radio == 1) ? PBE5_RADIO_ON : PBE5_RADIO_OFF);
+	
+	return 0;
+}
+
+static void __exit pbe5_exit(void)
+{
+	pbe5_set_radio(PBE5_RADIO_OFF);
+
+	pbe5_proc_cleanup();
+}
+
+module_init(pbe5_init);
+module_exit(pbe5_exit);
+
+/*
+         1         2         3         4         5         6         7
+12345678901234567890123456789012345678901234567890123456789012345678901234567890
+*/
diff -urN linux-2.6.6/drivers/scsi/dpt/dpt_osdutil.h linux-2.6.6-gentoo1/drivers/scsi/dpt/dpt_osdutil.h
--- linux-2.6.6/drivers/scsi/dpt/dpt_osdutil.h	2004-05-09 21:33:20.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/scsi/dpt/dpt_osdutil.h	1969-12-31 18:00:00.000000000 -0600
@@ -1,358 +0,0 @@
-/*	BSDI osd_util.h,v 1.8 1998/06/03 19:14:58 karels Exp	*/
-
-/*
- * Copyright (c) 1996-1999 Distributed Processing Technology Corporation
- * All rights reserved.
- *
- * Redistribution and use in source form, with or without modification, are
- * permitted provided that redistributions of source code must retain the
- * above copyright notice, this list of conditions and the following disclaimer.
- *
- * This software is provided `as is' by Distributed Processing Technology and
- * any express or implied warranties, including, but not limited to, the
- * implied warranties of merchantability and fitness for a particular purpose,
- * are disclaimed. In no event shall Distributed Processing Technology be
- * liable for any direct, indirect, incidental, special, exemplary or
- * consequential damages (including, but not limited to, procurement of
- * substitute goods or services; loss of use, data, or profits; or business
- * interruptions) however caused and on any theory of liability, whether in
- * contract, strict liability, or tort (including negligence or otherwise)
- * arising in any way out of the use of this driver software, even if advised
- * of the possibility of such damage.
- *
- */
-
-#ifndef         __OSD_UTIL_H
-#define         __OSD_UTIL_H
-
-/*File - OSD_UTIL.H
- ****************************************************************************
- *
- *Description:
- *
- *      This file contains defines and function prototypes that are
- *operating system dependent.  The resources defined in this file
- *are not specific to any particular application.
- *
- *Copyright Distributed Processing Technology, Corp.
- *        140 Candace Dr.
- *        Maitland, Fl. 32751   USA
- *        Phone: (407) 830-5522  Fax: (407) 260-5366
- *        All Rights Reserved
- *
- *Author:       Doug Anderson
- *Date:         1/7/94
- *
- *Editors:
- *
- *Remarks:
- *
- *
- *****************************************************************************/
-
-
-/*Definitions - Defines & Constants ----------------------------------------- */
-
-/*----------------------------- */
-/* Operating system selections: */
-/*----------------------------- */
-
-/*#define               _DPT_MSDOS      */
-/*#define               _DPT_WIN_3X     */
-/*#define               _DPT_WIN_4X     */
-/*#define               _DPT_WIN_NT     */
-/*#define               _DPT_NETWARE    */
-/*#define               _DPT_OS2        */
-/*#define               _DPT_SCO        */
-/*#define               _DPT_UNIXWARE   */
-/*#define               _DPT_SOLARIS    */
-/*#define               _DPT_NEXTSTEP   */
-/*#define               _DPT_BANYAN     */
-
-/*-------------------------------- */
-/* Include the OS specific defines */
-/*-------------------------------- */
-
-/*#define       OS_SELECTION    From Above List */
-/*#define       SEMAPHORE_T     ??? */
-/*#define       DLL_HANDLE_T    ??? */
-
-#if (defined(KERNEL) && (defined(__FreeBSD__) || defined(__bsdi__)))
-# include        "i386/isa/dpt_osd_defs.h"
-#else
-# include        "osd_defs.h"
-#endif
-
-#ifndef DPT_UNALIGNED
-   #define      DPT_UNALIGNED
-#endif
-
-#ifndef DPT_EXPORT
-   #define      DPT_EXPORT
-#endif
-
-#ifndef DPT_IMPORT
-   #define      DPT_IMPORT
-#endif
-
-#ifndef DPT_RUNTIME_IMPORT
-   #define      DPT_RUNTIME_IMPORT  DPT_IMPORT
-#endif
-
-/*--------------------- */
-/* OS dependent defines */
-/*--------------------- */
-
-#if defined (_DPT_MSDOS) || defined (_DPT_WIN_3X)
-   #define      _DPT_16_BIT
-#else
-   #define      _DPT_32_BIT
-#endif
-
-#if defined (_DPT_SCO) || defined (_DPT_UNIXWARE) || defined (_DPT_SOLARIS) || defined (_DPT_AIX) || defined (SNI_MIPS) || defined (_DPT_BSDI) || defined (_DPT_FREE_BSD) || defined(_DPT_LINUX)
-   #define      _DPT_UNIX
-#endif
-
-#if defined (_DPT_WIN_3x) || defined (_DPT_WIN_4X) || defined (_DPT_WIN_NT) \
-	    || defined (_DPT_OS2)
-   #define      _DPT_DLL_SUPPORT
-#endif
-
-#if !defined (_DPT_MSDOS) && !defined (_DPT_WIN_3X) && !defined (_DPT_NETWARE)
-   #define      _DPT_PREEMPTIVE
-#endif
-
-#if !defined (_DPT_MSDOS) && !defined (_DPT_WIN_3X)
-   #define      _DPT_MULTI_THREADED
-#endif
-
-#if !defined (_DPT_MSDOS)
-   #define      _DPT_MULTI_TASKING
-#endif
-
-  /* These exist for platforms that   */
-  /* chunk when accessing mis-aligned */
-  /* data                             */
-#if defined (SNI_MIPS) || defined (_DPT_SOLARIS)
-   #if defined (_DPT_BIG_ENDIAN)
-	#if !defined (_DPT_STRICT_ALIGN)
-            #define _DPT_STRICT_ALIGN
-	#endif
-   #endif
-#endif
-
-  /* Determine if in C or C++ mode */
-#ifdef  __cplusplus
-   #define      _DPT_CPP
-#else
-   #define      _DPT_C
-#endif
-
-/*-------------------------------------------------------------------*/
-/* Under Solaris the compiler refuses to accept code like:           */
-/*   { {"DPT"}, 0, NULL .... },                                      */
-/* and complains about the {"DPT"} part by saying "cannot use { }    */
-/* to initialize char*".                                             */
-/*                                                                   */
-/* By defining these ugly macros we can get around this and also     */
-/* not have to copy and #ifdef large sections of code.  I know that  */
-/* these macros are *really* ugly, but they should help reduce       */
-/* maintenance in the long run.                                      */
-/*                                                                   */
-/*-------------------------------------------------------------------*/
-#if !defined (DPTSQO)
-   #if defined (_DPT_SOLARIS)
-      #define DPTSQO
-      #define DPTSQC
-   #else
-      #define DPTSQO {
-      #define DPTSQC }
-   #endif  /* solaris */
-#endif  /* DPTSQO */
-
-
-/*---------------------- */
-/* OS dependent typedefs */
-/*---------------------- */
-
-#if defined (_DPT_MSDOS) || defined (_DPT_SCO)
-   #define BYTE unsigned char
-   #define WORD unsigned short
-#endif
-
-#ifndef _DPT_TYPEDEFS
-   #define _DPT_TYPEDEFS
-   typedef unsigned char   uCHAR;
-   typedef unsigned short  uSHORT;
-   typedef unsigned int    uINT;
-   typedef unsigned long   uLONG;
-
-   typedef union {
-	 uCHAR        u8[4];
-	 uSHORT       u16[2];
-	 uLONG        u32;
-   } access_U;
-#endif
-
-#if !defined (NULL)
-   #define      NULL    0
-#endif
-
-
-/*Prototypes - function ----------------------------------------------------- */
-
-#ifdef  __cplusplus
-   extern "C" {         /* Declare all these functions as "C" functions */
-#endif
-
-/*------------------------ */
-/* Byte reversal functions */
-/*------------------------ */
-
-  /* Reverses the byte ordering of a 2 byte variable */
-#if (!defined(osdSwap2))
- uSHORT       osdSwap2(DPT_UNALIGNED uSHORT *);
-#endif  // !osdSwap2
-
-  /* Reverses the byte ordering of a 4 byte variable and shifts left 8 bits */
-#if (!defined(osdSwap3))
- uLONG        osdSwap3(DPT_UNALIGNED uLONG *);
-#endif  // !osdSwap3
-
-
-#ifdef  _DPT_NETWARE
-   #include "novpass.h" /* For DPT_Bswapl() prototype */
-	/* Inline the byte swap */
-   #ifdef __cplusplus
-	 inline uLONG osdSwap4(uLONG *inLong) {
-	 return *inLong = DPT_Bswapl(*inLong);
-	 }
-   #else
-	 #define osdSwap4(inLong)       DPT_Bswapl(inLong)
-   #endif  // cplusplus
-#else
-	/* Reverses the byte ordering of a 4 byte variable */
-# if (!defined(osdSwap4))
-   uLONG        osdSwap4(DPT_UNALIGNED uLONG *);
-# endif  // !osdSwap4
-
-  /* The following functions ALWAYS swap regardless of the *
-   * presence of DPT_BIG_ENDIAN                            */
-
-   uSHORT       trueSwap2(DPT_UNALIGNED uSHORT *);
-   uLONG        trueSwap4(DPT_UNALIGNED uLONG *);
-
-#endif  // netware
-
-
-/*-------------------------------------*
- * Network order swap functions        *
- *                                     *
- * These functions/macros will be used *
- * by the structure insert()/extract() *
- * functions.                          *
- *
- * We will enclose all structure       *
- * portability modifications inside    *
- * #ifdefs.  When we are ready, we     *
- * will #define DPT_PORTABLE to begin  *
- * using the modifications.            *
- *-------------------------------------*/
-uLONG	netSwap4(uLONG val);
-
-#if defined (_DPT_BIG_ENDIAN)
-
-// for big-endian we need to swap
-
-#ifndef NET_SWAP_2
-#define NET_SWAP_2(x) (((x) >> 8) | ((x) << 8))
-#endif  // NET_SWAP_2
-
-#ifndef NET_SWAP_4
-#define NET_SWAP_4(x) netSwap4((x))
-#endif  // NET_SWAP_4
-
-#else
-
-// for little-endian we don't need to do anything
-
-#ifndef NET_SWAP_2
-#define NET_SWAP_2(x) (x)
-#endif  // NET_SWAP_2
-
-#ifndef NET_SWAP_4
-#define NET_SWAP_4(x) (x)
-#endif  // NET_SWAP_4
-
-#endif  // big endian
-
-
-
-/*----------------------------------- */
-/* Run-time loadable module functions */
-/*----------------------------------- */
-
-  /* Loads the specified run-time loadable DLL */
-DLL_HANDLE_T    osdLoadModule(uCHAR *);
-  /* Unloads the specified run-time loadable DLL */
-uSHORT          osdUnloadModule(DLL_HANDLE_T);
-  /* Returns a pointer to a function inside a run-time loadable DLL */
-void *          osdGetFnAddr(DLL_HANDLE_T,uCHAR *);
-
-/*--------------------------------------- */
-/* Mutually exclusive semaphore functions */
-/*--------------------------------------- */
-
-  /* Create a named semaphore */
-SEMAPHORE_T     osdCreateNamedSemaphore(char *);
-  /* Create a mutually exlusive semaphore */
-SEMAPHORE_T     osdCreateSemaphore(void);
-	/* create an event semaphore */
-SEMAPHORE_T              osdCreateEventSemaphore(void);
-	/* create a named event semaphore */
-SEMAPHORE_T             osdCreateNamedEventSemaphore(char *);
-
-  /* Destroy the specified mutually exclusive semaphore object */
-uSHORT          osdDestroySemaphore(SEMAPHORE_T);
-  /* Request access to the specified mutually exclusive semaphore */
-uLONG           osdRequestSemaphore(SEMAPHORE_T,uLONG);
-  /* Release access to the specified mutually exclusive semaphore */
-uSHORT          osdReleaseSemaphore(SEMAPHORE_T);
-	/* wait for a event to happen */
-uLONG                            osdWaitForEventSemaphore(SEMAPHORE_T, uLONG);
-	/* signal an event */
-uLONG                            osdSignalEventSemaphore(SEMAPHORE_T);
-	/* reset the event */
-uLONG                            osdResetEventSemaphore(SEMAPHORE_T);
-
-/*----------------- */
-/* Thread functions */
-/*----------------- */
-
-  /* Releases control to the task switcher in non-preemptive */
-  /* multitasking operating systems. */
-void            osdSwitchThreads(void);
-
-  /* Starts a thread function */
-uLONG   osdStartThread(void *,void *);
-
-/* what is my thread id */
-uLONG osdGetThreadID(void);
-
-/* wakes up the specifed thread */
-void osdWakeThread(uLONG);
-
-/* osd sleep for x miliseconds */
-void osdSleep(uLONG);
-
-#define DPT_THREAD_PRIORITY_LOWEST 0x00
-#define DPT_THREAD_PRIORITY_NORMAL 0x01
-#define DPT_THREAD_PRIORITY_HIGHEST 0x02
-
-uCHAR osdSetThreadPriority(uLONG tid, uCHAR priority);
-
-#ifdef __cplusplus
-   }    /* end the xtern "C" declaration */
-#endif
-
-#endif  /* osd_util_h */
diff -urN linux-2.6.6/drivers/scsi/dpt/dpti_i2o-dev.h linux-2.6.6-gentoo1/drivers/scsi/dpt/dpti_i2o-dev.h
--- linux-2.6.6/drivers/scsi/dpt/dpti_i2o-dev.h	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/scsi/dpt/dpti_i2o-dev.h	2004-05-22 09:13:10.465695424 -0500
@@ -0,0 +1,395 @@
+/*
+ * I2O user space accessible structures/APIs
+ * 
+ * (c) Copyright 1999, 2000 Red Hat Software
+ *
+ * This program is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU General Public License 
+ * as published by the Free Software Foundation; either version 
+ * 2 of the License, or (at your option) any later version.  
+ * 
+ *************************************************************************
+ *
+ * This header file defines the I2O APIs that are available to both
+ * the kernel and user level applications.  Kernel specific structures
+ * are defined in i2o_osm. OSMs should include _only_ i2o_osm.h which
+ * automatically includs this file.
+ *
+ */
+
+#ifndef _I2O_DEV_H
+#define _I2O_DEV_H
+
+
+#include <linux/ioctl.h>
+
+/*
+ * I2O Control IOCTLs and structures
+ */
+#define I2O_MAGIC_NUMBER	'i'
+#define I2OGETIOPS		_IOR(I2O_MAGIC_NUMBER,0,u8[MAX_I2O_CONTROLLERS])
+#define I2OHRTGET		_IOWR(I2O_MAGIC_NUMBER,1,struct i2o_cmd_hrtlct)
+#define I2OLCTGET		_IOWR(I2O_MAGIC_NUMBER,2,struct i2o_cmd_hrtlct)
+#define I2OPARMSET		_IOWR(I2O_MAGIC_NUMBER,3,struct i2o_cmd_psetget)
+#define I2OPARMGET		_IOWR(I2O_MAGIC_NUMBER,4,struct i2o_cmd_psetget)
+#define I2OSWDL			_IOWR(I2O_MAGIC_NUMBER,5,struct i2o_sw_xfer)
+#define I2OSWUL			_IOWR(I2O_MAGIC_NUMBER,6,struct i2o_sw_xfer)
+#define I2OSWDEL		_IOWR(I2O_MAGIC_NUMBER,7,struct i2o_sw_xfer)
+#define I2OVALIDATE		_IOR(I2O_MAGIC_NUMBER,8,u32)
+#define I2OHTML			_IOWR(I2O_MAGIC_NUMBER,9,struct i2o_html)
+#define I2OEVTREG		_IOW(I2O_MAGIC_NUMBER,10,struct i2o_evt_id)
+#define I2OEVTGET		_IOR(I2O_MAGIC_NUMBER,11,struct i2o_evt_info)
+
+struct i2o_cmd_hrtlct
+{
+	unsigned int iop;	/* IOP unit number */
+	void *resbuf;		/* Buffer for result */
+	unsigned int *reslen;	/* Buffer length in bytes */
+};
+
+struct i2o_cmd_psetget
+{
+	unsigned int iop;	/* IOP unit number */
+	unsigned int tid;	/* Target device TID */
+	void *opbuf;		/* Operation List buffer */
+	unsigned int oplen;	/* Operation List buffer length in bytes */
+	void *resbuf;		/* Result List buffer */
+	unsigned int *reslen;	/* Result List buffer length in bytes */
+};
+
+struct i2o_sw_xfer
+{
+	unsigned int iop;	/* IOP unit number */
+	unsigned char flags;	/* Flags field */
+	unsigned char sw_type;	/* Software type */
+	unsigned int sw_id;	/* Software ID */
+	void *buf;		/* Pointer to software buffer */
+	unsigned int *swlen;	/* Length of software data */
+	unsigned int *maxfrag;	/* Maximum fragment count */
+        unsigned int *curfrag;	/* Current fragment count */
+};
+
+struct i2o_html
+{
+	unsigned int iop;	/* IOP unit number */
+	unsigned int tid;	/* Target device ID */
+	unsigned int page;	/* HTML page */
+	void *resbuf;		/* Buffer for reply HTML page */
+	unsigned int *reslen;	/* Length in bytes of reply buffer */
+	void *qbuf;		/* Pointer to HTTP query string */
+	unsigned int qlen;	/* Length in bytes of query string buffer */
+};
+
+#define I2O_EVT_Q_LEN 32
+
+struct i2o_evt_id
+{
+	unsigned int iop;
+	unsigned int tid;
+	unsigned int evt_mask;
+};
+
+/* Event data size = frame size - message header + evt indicator */
+#define I2O_EVT_DATA_SIZE 88
+
+struct i2o_evt_info
+{
+	struct i2o_evt_id id;
+	unsigned char evt_data[I2O_EVT_DATA_SIZE];
+ 	unsigned int data_size;
+};
+
+struct i2o_evt_get
+{
+	struct i2o_evt_info info;
+	int pending;
+	int lost;
+};
+
+
+/**************************************************************************
+ * HRT related constants and structures
+ **************************************************************************/
+#define I2O_BUS_LOCAL	0
+#define I2O_BUS_ISA	1
+#define I2O_BUS_EISA	2
+#define I2O_BUS_MCA	3
+#define I2O_BUS_PCI	4
+#define I2O_BUS_PCMCIA	5
+#define I2O_BUS_NUBUS	6
+#define I2O_BUS_CARDBUS	7
+#define I2O_BUS_UNKNOWN	0x80
+
+#ifndef __KERNEL__
+
+typedef unsigned char u8;
+typedef unsigned short u16;
+typedef unsigned int u32;
+
+#endif /* __KERNEL__ */
+
+typedef struct _i2o_pci_bus {
+	u8 PciFunctionNumber;
+	u8 PciDeviceNumber;
+	u8 PciBusNumber;
+	u8 reserved;
+	u16 PciVendorID;
+	u16 PciDeviceID;
+} i2o_pci_bus;
+
+typedef struct _i2o_local_bus {
+	u16 LbBaseIOPort;
+	u16 reserved;
+	u32 LbBaseMemoryAddress;
+} i2o_local_bus;
+
+typedef struct _i2o_isa_bus {
+	u16 IsaBaseIOPort;
+	u8 CSN;
+	u8 reserved;
+	u32 IsaBaseMemoryAddress;
+} i2o_isa_bus;
+
+typedef struct _i2o_eisa_bus_info {
+	u16 EisaBaseIOPort;
+	u8 reserved;
+	u8 EisaSlotNumber;
+	u32 EisaBaseMemoryAddress;
+} i2o_eisa_bus;
+
+typedef struct _i2o_mca_bus {
+	u16 McaBaseIOPort;
+	u8 reserved;
+	u8 McaSlotNumber;
+	u32 McaBaseMemoryAddress;
+} i2o_mca_bus;
+
+typedef struct _i2o_other_bus {
+	u16 BaseIOPort;
+	u16 reserved;
+	u32 BaseMemoryAddress;
+} i2o_other_bus;
+
+typedef struct _i2o_hrt_entry {
+	u32 adapter_id;
+	u32 parent_tid:12;
+	u32 state:4;
+	u32 bus_num:8;
+	u32 bus_type:8;
+	union {
+		i2o_pci_bus pci_bus;
+		i2o_local_bus local_bus;
+		i2o_isa_bus isa_bus;
+		i2o_eisa_bus eisa_bus;
+		i2o_mca_bus mca_bus;
+		i2o_other_bus other_bus;
+	} bus;
+} i2o_hrt_entry;
+
+typedef struct _i2o_hrt {
+	u16 num_entries;
+	u8 entry_len;
+	u8 hrt_version;
+	u32 change_ind;
+	i2o_hrt_entry hrt_entry[1];
+} i2o_hrt;
+
+typedef struct _i2o_lct_entry {
+	u32 entry_size:16;
+	u32 tid:12;
+	u32 reserved:4;
+	u32 change_ind;
+	u32 device_flags;
+	u32 class_id:12;
+	u32 version:4;
+	u32 vendor_id:16;
+	u32 sub_class;
+	u32 user_tid:12;
+	u32 parent_tid:12;
+	u32 bios_info:8;
+	u8 identity_tag[8];
+	u32 event_capabilities;
+} i2o_lct_entry;
+
+typedef struct _i2o_lct {
+	u32 table_size:16;
+	u32 boot_tid:12;
+	u32 lct_ver:4;
+	u32 iop_flags;
+	u32 change_ind;
+	i2o_lct_entry lct_entry[1];
+} i2o_lct;
+
+typedef struct _i2o_status_block {
+	u16 org_id;
+	u16 reserved;
+	u16 iop_id:12;
+	u16 reserved1:4;
+	u16 host_unit_id;
+	u16 segment_number:12;
+	u16 i2o_version:4;
+	u8 iop_state;
+	u8 msg_type;
+	u16 inbound_frame_size;
+	u8 init_code;	
+	u8 reserved2;
+	u32 max_inbound_frames;
+	u32 cur_inbound_frames;
+	u32 max_outbound_frames;
+	char product_id[24];	
+	u32 expected_lct_size;
+	u32 iop_capabilities;
+	u32 desired_mem_size;
+	u32 current_mem_size;
+	u32 current_mem_base;
+	u32 desired_io_size;
+	u32 current_io_size;
+	u32 current_io_base;
+	u32 reserved3:24;
+	u32 cmd_status:8;
+} i2o_status_block;
+ 
+/* Event indicator mask flags */
+#define I2O_EVT_IND_STATE_CHANGE		0x80000000
+#define I2O_EVT_IND_GENERAL_WARNING		0x40000000
+#define I2O_EVT_IND_CONFIGURATION_FLAG		0x20000000
+#define I2O_EVT_IND_LOCK_RELEASE		0x10000000
+#define I2O_EVT_IND_CAPABILITY_CHANGE		0x08000000
+#define I2O_EVT_IND_DEVICE_RESET		0x04000000
+#define I2O_EVT_IND_EVT_MASK_MODIFIED		0x02000000
+#define I2O_EVT_IND_FIELD_MODIFIED		0x01000000
+#define I2O_EVT_IND_VENDOR_EVT			0x00800000
+#define I2O_EVT_IND_DEVICE_STATE		0x00400000
+
+/* Executive event indicitors */
+#define I2O_EVT_IND_EXEC_RESOURCE_LIMITS	0x00000001
+#define I2O_EVT_IND_EXEC_CONNECTION_FAIL	0x00000002
+#define I2O_EVT_IND_EXEC_ADAPTER_FAULT		0x00000004
+#define I2O_EVT_IND_EXEC_POWER_FAIL		0x00000008
+#define I2O_EVT_IND_EXEC_RESET_PENDING		0x00000010
+#define I2O_EVT_IND_EXEC_RESET_IMMINENT		0x00000020
+#define I2O_EVT_IND_EXEC_HW_FAIL		0x00000040
+#define I2O_EVT_IND_EXEC_XCT_CHANGE		0x00000080
+#define I2O_EVT_IND_EXEC_NEW_LCT_ENTRY		0x00000100
+#define I2O_EVT_IND_EXEC_MODIFIED_LCT		0x00000200
+#define I2O_EVT_IND_EXEC_DDM_AVAILABILITY	0x00000400
+
+/* Random Block Storage Event Indicators */
+#define I2O_EVT_IND_BSA_VOLUME_LOAD		0x00000001
+#define I2O_EVT_IND_BSA_VOLUME_UNLOAD		0x00000002
+#define I2O_EVT_IND_BSA_VOLUME_UNLOAD_REQ	0x00000004
+#define I2O_EVT_IND_BSA_CAPACITY_CHANGE		0x00000008
+#define I2O_EVT_IND_BSA_SCSI_SMART		0x00000010
+
+/* Event data for generic events */
+#define I2O_EVT_STATE_CHANGE_NORMAL		0x00
+#define I2O_EVT_STATE_CHANGE_SUSPENDED		0x01
+#define I2O_EVT_STATE_CHANGE_RESTART		0x02
+#define I2O_EVT_STATE_CHANGE_NA_RECOVER		0x03
+#define I2O_EVT_STATE_CHANGE_NA_NO_RECOVER	0x04
+#define I2O_EVT_STATE_CHANGE_QUIESCE_REQUEST	0x05
+#define I2O_EVT_STATE_CHANGE_FAILED		0x10
+#define I2O_EVT_STATE_CHANGE_FAULTED		0x11
+
+#define I2O_EVT_GEN_WARNING_NORMAL		0x00
+#define I2O_EVT_GEN_WARNING_ERROR_THRESHOLD	0x01
+#define I2O_EVT_GEN_WARNING_MEDIA_FAULT		0x02
+
+#define I2O_EVT_CAPABILITY_OTHER		0x01
+#define I2O_EVT_CAPABILITY_CHANGED		0x02
+
+#define I2O_EVT_SENSOR_STATE_CHANGED		0x01
+
+/*
+ *	I2O classes / subclasses
+ */
+
+/*  Class ID and Code Assignments
+ *  (LCT.ClassID.Version field)
+ */
+#define    I2O_CLASS_VERSION_10                        0x00
+#define    I2O_CLASS_VERSION_11                        0x01
+
+/*  Class code names
+ *  (from v1.5 Table 6-1 Class Code Assignments.)
+ */
+ 
+#define    I2O_CLASS_EXECUTIVE                         0x000
+#define    I2O_CLASS_DDM                               0x001
+#define    I2O_CLASS_RANDOM_BLOCK_STORAGE              0x010
+#define    I2O_CLASS_SEQUENTIAL_STORAGE                0x011
+#define    I2O_CLASS_LAN                               0x020
+#define    I2O_CLASS_WAN                               0x030
+#define    I2O_CLASS_FIBRE_CHANNEL_PORT                0x040
+#define    I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL          0x041
+#define    I2O_CLASS_SCSI_PERIPHERAL                   0x051
+#define    I2O_CLASS_ATE_PORT                          0x060
+#define    I2O_CLASS_ATE_PERIPHERAL                    0x061
+#define    I2O_CLASS_FLOPPY_CONTROLLER                 0x070
+#define    I2O_CLASS_FLOPPY_DEVICE                     0x071
+#define    I2O_CLASS_BUS_ADAPTER_PORT                  0x080
+#define    I2O_CLASS_PEER_TRANSPORT_AGENT              0x090
+#define    I2O_CLASS_PEER_TRANSPORT                    0x091
+
+/* 
+ *  Rest of 0x092 - 0x09f reserved for peer-to-peer classes
+ */
+ 
+#define    I2O_CLASS_MATCH_ANYCLASS                    0xffffffff
+
+/* 
+ *  Subclasses
+ */
+
+#define    I2O_SUBCLASS_i960                           0x001
+#define    I2O_SUBCLASS_HDM                            0x020
+#define    I2O_SUBCLASS_ISM                            0x021
+ 
+/* Operation functions */
+
+#define I2O_PARAMS_FIELD_GET	0x0001
+#define I2O_PARAMS_LIST_GET	0x0002
+#define I2O_PARAMS_MORE_GET	0x0003
+#define I2O_PARAMS_SIZE_GET	0x0004
+#define I2O_PARAMS_TABLE_GET	0x0005
+#define I2O_PARAMS_FIELD_SET	0x0006
+#define I2O_PARAMS_LIST_SET	0x0007
+#define I2O_PARAMS_ROW_ADD	0x0008
+#define I2O_PARAMS_ROW_DELETE	0x0009
+#define I2O_PARAMS_TABLE_CLEAR	0x000A
+
+/*
+ * I2O serial number conventions / formats 
+ * (circa v1.5)
+ */
+
+#define    I2O_SNFORMAT_UNKNOWN                        0
+#define    I2O_SNFORMAT_BINARY                         1
+#define    I2O_SNFORMAT_ASCII                          2
+#define    I2O_SNFORMAT_UNICODE                        3
+#define    I2O_SNFORMAT_LAN48_MAC                      4
+#define    I2O_SNFORMAT_WAN                            5
+
+/* 
+ * Plus new in v2.0 (Yellowstone pdf doc)
+ */
+
+#define    I2O_SNFORMAT_LAN64_MAC                      6
+#define    I2O_SNFORMAT_DDM                            7
+#define    I2O_SNFORMAT_IEEE_REG64                     8
+#define    I2O_SNFORMAT_IEEE_REG128                    9
+#define    I2O_SNFORMAT_UNKNOWN2                       0xff
+
+/*
+ *	I2O Get Status State values 
+ */
+
+#define	ADAPTER_STATE_INITIALIZING		0x01
+#define	ADAPTER_STATE_RESET			0x02
+#define	ADAPTER_STATE_HOLD			0x04
+#define 	ADAPTER_STATE_READY			0x05
+#define	ADAPTER_STATE_OPERATIONAL		0x08
+#define	ADAPTER_STATE_FAILED			0x10
+#define	ADAPTER_STATE_FAULTED			0x11
+	
+#endif /* _I2O_DEV_H */
diff -urN linux-2.6.6/drivers/scsi/dpt/dpti_i2o.h linux-2.6.6-gentoo1/drivers/scsi/dpt/dpti_i2o.h
--- linux-2.6.6/drivers/scsi/dpt/dpti_i2o.h	2004-05-09 21:32:29.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/scsi/dpt/dpti_i2o.h	2004-05-22 09:13:10.483692734 -0500
@@ -1,6 +1,5 @@
-#ifndef _SCSI_I2O_H
-#define _SCSI_I2O_H
-
+#ifndef _I2O_H
+#define _I2O_H
 /* I2O kernel space accessible structures/APIs
  *
  * (c) Copyright 1999, 2000 Red Hat Software
@@ -19,10 +18,9 @@
 
 #ifdef __KERNEL__       /* This file to be included by kernel only */
 
-#include <linux/i2o-dev.h>
+#include "dpti_i2o-dev.h"
 
 #include <asm/semaphore.h> /* Needed for MUTEX init macros */
-#include <linux/version.h>
 #include <linux/config.h>
 #include <linux/notifier.h>
 #include <asm/atomic.h>
@@ -44,10 +42,16 @@
 
 #define I2O_MAX_MANAGERS	4
 
+#include <asm/semaphore.h> /* Needed for MUTEX init macros */
+
 /*
  *	I2O Interface Objects
  */
 
+#include <linux/config.h>
+#include <linux/notifier.h>
+#include <asm/atomic.h>
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
 
 #define DECLARE_MUTEX(name) struct semaphore name=MUTEX
@@ -456,4 +460,4 @@
 
 #endif /* __KERNEL__ */
 
-#endif /* _SCSI_I2O_H */
+#endif /* _I2O_H */
diff -urN linux-2.6.6/drivers/scsi/dpt/dpti_ioctl.h linux-2.6.6-gentoo1/drivers/scsi/dpt/dpti_ioctl.h
--- linux-2.6.6/drivers/scsi/dpt/dpti_ioctl.h	2004-05-09 21:32:29.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/scsi/dpt/dpti_ioctl.h	2004-05-22 09:13:10.494691091 -0500
@@ -3,10 +3,10 @@
                              -------------------
     begin                : Thu Sep 7 2000
     copyright            : (C) 2001 by Adaptec
-    email                : deanna_bonds@adaptec.com
+    email                : Mark_Salyzyn@adaptec.com
+    original author      : doug_anderson@adaptec.com & deanna_bonds@adaptec.com
 
-    See Documentation/scsi/dpti.txt for history, notes, license info
-    and credits
+    See README.dpti for history, notes, license info, and credits
  ***************************************************************************/
 
 /***************************************************************************
diff -urN linux-2.6.6/drivers/scsi/dpt/dptsig.h linux-2.6.6-gentoo1/drivers/scsi/dpt/dptsig.h
--- linux-2.6.6/drivers/scsi/dpt/dptsig.h	2004-05-09 21:33:19.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/scsi/dpt/dptsig.h	2004-05-22 09:13:10.518687505 -0500
@@ -1,7 +1,8 @@
 /*	BSDI dptsig.h,v 1.7 1998/06/03 19:15:00 karels Exp	*/
 
 /*
- * Copyright (c) 1996-1999 Distributed Processing Technology Corporation
+ * Copyright (c) 1996-2000 Distributed Processing Technology Corporation
+ * Copyright (c) 2000-2001 Adaptec Corporation.
  * All rights reserved.
  *
  * Redistribution and use in source form, with or without modification, are
@@ -92,6 +93,7 @@
 #define PROC_INTEL      0x00    /* Intel 80x86 */
 #define PROC_MOTOROLA   0x01    /* Motorola 68K */
 #define PROC_MIPS4000   0x02    /* MIPS RISC 4000 */
+#define PROC_MIPS       PROC_MIPS4000 /* MIPS RISC */
 #define PROC_ALPHA      0x03    /* DEC Alpha */
 #define PROC_POWERPC    0x04    /* IBM Power PC */
 #define PROC_i960       0x05    /* Intel i960 */
@@ -108,10 +110,14 @@
 #define PROC_486        0x08    /* Intel 80486 */
 #define PROC_PENTIUM    0x10    /* Intel 586 aka P5 aka Pentium */
 #define PROC_SEXIUM	0x20	/* Intel 686 aka P6 aka Pentium Pro or MMX */
+#define PROC_ITANIUM    0x40    /* Intel Itanium 64 bit */
 
 /* PROC_i960: */
-#define PROC_960RX      0x01    /* Intel 80960RC/RD */
+#define PROC_960RX      0x01    /* Intel 80960RP/RD */
 #define PROC_960HX      0x02    /* Intel 80960HA/HD/HT */
+#define PROC_960RN      0x03    /* Intel 80960RN/RM */
+#define PROC_960RS      0x04    /* Intel 80960RS */
+#define PROC_80303      0x05    /* Intel 80303 (ZION) */
 
 /* PROC_MOTOROLA: */
 #define PROC_68000      0x01    /* Motorola 68000 */
@@ -125,8 +131,9 @@
 #define PROC_PPC603		0x02	/* PowerPC 603 */
 #define PROC_PPC604		0x04	/* PowerPC 604 */
 
-/* PROC_MIPS4000: */
+/* PROC_MIPS */
 #define PROC_R4000      0x01    /* MIPS R4000 */
+#define PROC_RM7000     0x02    /* MIPS RM7000 */
 
 /* Filetype - sigBYTE dsFiletype;       DISTINCT VALUES */
 /* ------------------------------------------------------------------ */
@@ -147,6 +154,7 @@
 #define FT_LIBRARY      14      /* Storage Manager Real-Mode Calls */
 #define FT_RESOURCE 	15 	/* Storage Manager Resource File */
 #define FT_MODEM_DB  	16  	/* Storage Manager Modem Database */
+#define FT_DMI          17      /* DMI component interface */
 
 /* Filetype flags - sigBYTE dsFiletypeFlags;    FLAG BITS */
 /* ------------------------------------------------------------------ */
@@ -170,6 +178,7 @@
 #define OEM_OLIVETTI    5       /* Olivetti */
 #define OEM_SNI         6       /* Siemens/Nixdorf */
 #define OEM_SUN         7       /* SUN Microsystems */
+#define OEM_ADAPTEC     8       /* Adaptec */
 
 /* Operating System  - sigLONG dsOS;    FLAG BITS */
 /* ------------------------------------------------------------------ */
@@ -202,6 +211,8 @@
 #define OS_SINIX_N      0x04000000 /* SNI SINIX-N			*/
 #define OS_PLAN9	0x08000000 /* ATT Plan 9			*/
 #define OS_TSX		0x10000000 /* SNH TSX-32			*/
+#define OS_WINDOWS_98   0x20000000 /* Microsoft Windows '98     */
+#define OS_NW5x                 0x40000000 /* Novell Netware 5x */
 
 #define OS_OTHER        0x80000000 /* Other				*/
 
@@ -284,6 +295,93 @@
 #define REQ_ENGINE      0x10    /* Requires a DPT Engine to be loaded   */
 #define REQ_COMM_ENG    0x20    /* Requires a DPT Communications Engine */
 
+/* ------------------------------------------------------------------   */
+/* Requirements - sigWORD dsFirmware;         FLAG BITS                 */
+/* ------------------------------------------------------------------   */
+#define dsFirmware dsApplication
+#define FW_DNLDSIZE16_OLD       0x0000    /* 0..3 DownLoader Size 16K - TO SUPPORT OLD IMAGES */
+#define FW_DNLDSIZE16k    0x0000    /* 0..3 DownLoader Size 16k             */
+#define FW_DNLDSIZE16     0x0001    /* 0..3 DownLoader Size 16K         */
+#define FW_DNLDSIZE32     0x0002    /* 0..3 DownLoader Size 32K         */
+#define FW_DNLDSIZE64     0x0004    /* 0..3 DownLoader Size 64K         */
+#define FW_DNLDSIZE0      0x000f    /* 0..3 DownLoader Size 0K - NONE   */
+#define FW_DNLDSIZE_NONE        0x000F    /* 0..3 DownLoader Size - NONE      */
+
+                /* Code Offset is position of the code within the ROM CODE Segment */
+#define FW_DNLDR_TOP      0x0000        /* 12 DownLoader Position (0=Top, 1=Bottom) */
+#define FW_DNLDR_BTM      0x1000        /* 12 DownLoader Position (0=Top, 1=Bottom) Dominator */
+
+#define FW_LOAD_BTM               0x0000        /* 13 Code Offset (0=Btm, 1=Top) MIPS   */
+#define FW_LOAD_TOP               0x2000        /* 13 Code Offset (0=Btm, 1=Top) i960   */
+
+#define FW_SIG_VERSION1   0x0000    /* 15..14 Version Bits 0=Ver1               */
+#define FW_SIG_VERSION2   0x4000        /* 15..14 Version Bits 1=Ver2       */
+
+/*
+                                0..3   Downloader Size (Value * 16K)
+
+                                4
+                                5
+                                6
+                                7
+
+                                8
+                                9
+                                10
+                                11
+
+                                12              Downloader Position (0=Top of Image  1= Bottom of Image (Dominator) )
+                                13              Load Offset (0=BTM (MIPS) -- 1=TOP (960) )
+                                14..15  F/W Sig Version (0=Ver1)
+*/
+
+/* ------------------------------------------------------------------   */
+/* Sub System Vendor IDs - The PCI Sub system and vendor IDs for each   */
+/* Adaptec Raid controller                                              */
+/* ------------------------------------------------------------------   */
+#define PM1554U2_SUB_ID          0xC0011044
+#define PM1654U2_SUB_ID          0xC0021044
+#define PM1564U3_1_SUB_ID    0xC0031044
+#define PM1564U3_2_SUB_ID    0xC0041044
+#define PM1554U2_NOACPI_SUB_ID      0xC0051044
+#define PM2554U2_SUB_ID      0xC00A1044
+#define PM2654U2_SUB_ID      0xC00B1044
+#define PM2664U3_1_SUB_ID    0xC00C1044
+#define PM2664U3_2_SUB_ID    0xC00D1044
+#define PM2554U2_NOACPI_SUB_ID      0xC00E1044
+#define PM2654U2_NOACPI_SUB_ID      0xC00F1044
+#define PM3754U2_SUB_ID      0xC0141044
+#define PM3755U2B_SUB_ID     0xC0151044
+#define PM3755F_SUB_ID       0xC0161044
+#define PM3757U2_1_SUB_ID    0xC01E1044
+#define PM3757U2_2_SUB_ID    0xC01F1044
+#define PM3767U3_2_SUB_ID    0xC0201044
+#define PM3767U3_4_SUB_ID    0xC0211044
+#define PM2865U3_1_SUB_ID    0xC0281044
+#define PM2865U3_2_SUB_ID    0xC0291044
+#define PM2865F_SUB_ID       0xC02A1044
+#define ADPT2000S_1_SUB_ID       0xC03C1044
+#define ADPT2000S_2_SUB_ID       0xC03D1044
+#define ADPT2000F_SUB_ID         0xC03E1044
+#define ADPT3000S_1_SUB_ID       0xC0461044
+#define ADPT3000S_2_SUB_ID       0xC0471044
+#define ADPT3000F_SUB_ID         0xC0481044
+#define ADPT5000S_1_SUB_ID       0xC0501044
+#define ADPT5000S_2_SUB_ID       0xC0511044
+#define ADPT5000F_SUB_ID         0xC0521044
+#define ADPT1000UDMA_SUB_ID      0xC05A1044
+#define ADPT1000UDMA_DAC_SUB_ID  0xC05B1044
+#define ADPTI2O_DEVICE_ID        0xa501
+#define ADPTDOMINATOR_DEVICE_ID  0xa511
+#define ADPTDOMINATOR_SUB_ID_START   0xC0321044
+#define ADPTDOMINATOR_SUB_ID_END     0xC03b1044
+
+
+
+/* ------------------------------------------------------------------   */
+/* ------------------------------------------------------------------   */
+/* ------------------------------------------------------------------   */
+
 /*
  * You may adjust dsDescription_size with an override to a value less than
  * 50 so that the structure allocates less real space.
@@ -318,6 +416,35 @@
 /* 32 bytes minimum - with no description.  Put NULL at description[0] */
 /* 81 bytes maximum - with 49 character description plus NULL. */
 
+#if defined __bsdi__
+#ifndef PACK
+#define PACK __attribute__ ((packed))
+#endif
+typedef struct dpt_sig_Packed {
+    char    dsSignature[6] PACK;      /* ALWAYS "dPtSiG" */
+    sigBYTE dsSigVersion PACK;        /* signature version (currently 1) */
+    sigBYTE dsProcessorFamily PACK;   /* what type of processor */
+    sigBYTE dsProcessor PACK;         /* precise processor */
+    sigBYTE dsFiletype PACK;          /* type of file */
+    sigBYTE dsFiletypeFlags PACK;     /* flags to specify load type, etc. */
+    sigBYTE dsOEM PACK;               /* OEM file was created for */
+    sigLONG dsOS PACK;                /* which Operating systems */
+    sigWORD dsCapabilities PACK;      /* RAID levels, etc. */
+    sigWORD dsDeviceSupp PACK;        /* Types of SCSI devices supported */
+    sigWORD dsAdapterSupp PACK;       /* DPT adapter families supported */
+    sigWORD dsApplication PACK;       /* applications file is for */
+    sigBYTE dsRequirements PACK;      /* Other driver dependencies */
+    sigBYTE dsVersion PACK;           /* 1 */
+    sigBYTE dsRevision PACK;          /* 'J' */
+    sigBYTE dsSubRevision PACK;       /* '9'   ' ' if N/A */
+    sigBYTE dsMonth PACK;             /* creation month */
+    sigBYTE dsDay PACK;               /* creation day */
+    sigBYTE dsYear PACK;              /* creation year since 1980 (1993=13) */
+    /* description (NULL terminated) */
+    char  dsDescription[dsDescription_size] PACK;
+} dpt_sig_S_Packed;
+#define PACKED_SIG_SIZE sizeof(dpt_sig_S_Packed)
+#endif
 /* This line added at Roycroft's request */
 /* Microsoft's NT compiler gets confused if you do a pack and don't */
 /* restore it. */
diff -urN linux-2.6.6/drivers/scsi/dpt_i2o.c linux-2.6.6-gentoo1/drivers/scsi/dpt_i2o.c
--- linux-2.6.6/drivers/scsi/dpt_i2o.c	2004-05-09 21:33:13.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/scsi/dpt_i2o.c	2004-05-22 09:17:04.483728442 -0500
@@ -1,14 +1,15 @@
 /***************************************************************************
-                          dpti.c  -  description
+                          dpt_i2o.c  -  description
                              -------------------
     begin                : Thu Sep 7 2000
-    copyright            : (C) 2000 by Adaptec
-    email                : deanna_bonds@adaptec.com
+    copyright            : (C) 2000-2003 by Adaptec
+    email                : Mark_Salyzyn@adaptec.com
+    original author      : deanna_bonds@adaptec.com
 
-			   July 30, 2001 First version being submitted
+    			   July 30, 2001 First version being submitted
 			   for inclusion in the kernel.  V2.4
 
-    See Documentation/scsi/dpti.txt for history, notes, license info
+    See Documentation/scsi/dpti.txt for history, notes, license info,
     and credits
  ***************************************************************************/
 
@@ -24,19 +25,21 @@
 //#define DEBUG 1
 //#define UARTDELAY 1
 
-// On the real kernel ADDR32 should always be zero for 2.4. GFP_HIGH allocates
-// high pages. Keep the macro around because of the broken unmerged ia64 tree
-
-#define ADDR32 (0)
-
-#error Please convert me to Documentation/DMA-mapping.txt
-
 #include <linux/version.h>
+
 #include <linux/module.h>
 
-MODULE_AUTHOR("Deanna Bonds, with _lots_ of help from Mark Salyzyn");
+MODULE_AUTHOR("Deanna Bonds & Mark Salyzyn");
 MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+static char kernel_version[] = UTS_RELEASE;
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)) && (LINUX_VERSION_CODE != KERNEL_VERSION(2,4,13)) && (LINUX_VERSION_CODE != KERNEL_VERSION(2,4,9))
+# define dma_handle ptr
+#endif
+
 ////////////////////////////////////////////////////////////////
 
 #include <linux/ioctl.h>	/* For SCSI-Passthrough */
@@ -47,7 +50,12 @@
 #include <linux/config.h>	/* for CONFIG_PCI */
 #include <linux/pci.h>		/* for PCI support */
 #include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 #include <linux/blkdev.h>
+#else
+#include <linux/blk.h>
+#include <linux/tqueue.h>
+#endif
 #include <linux/delay.h>	/* for udelay */
 #include <linux/interrupt.h>
 #include <linux/kernel.h>	/* for printk */
@@ -62,14 +70,30 @@
 
 #include <asm/processor.h>	/* for boot_cpu_data */
 #include <asm/pgtable.h>
-#include <asm/io.h>		/* for virt_to_bus, etc. */
+#include <asm/io.h>
 
 #include "scsi.h"
 #include "hosts.h"
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,65))
+#include "sd.h"
+#endif
 
 #include "dpt/dptsig.h"
 #include "dpti.h"
 
+#if (defined(__x86_64__))
+# include <asm-x86_64/ioctl32.h>
+#endif
+
+#if LINUX_VERSION_CODE  <= KERNEL_VERSION(2,4,2)   
+static inline int pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask)
+{
+    dev->dma_mask = mask;
+
+    return 0;
+}
+#endif
+
 /*============================================================================
  * Create a binary signature - this is read by dptsig
  * Needed for our management apps
@@ -79,14 +103,16 @@
 	{'d', 'P', 't', 'S', 'i', 'G'}, SIG_VERSION,
 #ifdef __i386__
 	PROC_INTEL, PROC_386 | PROC_486 | PROC_PENTIUM | PROC_SEXIUM,
-#elif defined(__ia64__)
-	PROC_INTEL, PROC_IA64,
-#elif defined(__sparc__)
-	PROC_ULTRASPARC,
-#elif defined(__alpha__)
-	PROC_ALPHA ,
+#elif defined __ia64__
+	PROC_INTEL, PROC_ITANIUM,
+#elif defined __x86_64__
+	PROC_INTEL, PROC_SEXIUM,
+#elif defined __sparc__
+	PROC_ULTRASPARC, ~(sigBYTE)0U,
+#elif defined __alpha__
+	PROC_ALPHA, ~(sigBYTE)0U,
 #else
-	(-1),(-1)
+	~(sigBYTE)0U, ~(sigBYTE)0U,
 #endif
 	 FT_HBADRVR, 0, OEM_DPT, OS_LINUX, CAP_OVERLAP, DEV_ALL,
 	ADF_ALL_SC5, 0, 0, DPT_VERSION, DPT_REVISION, DPT_SUBREVISION,
@@ -101,9 +127,13 @@
  *============================================================================
  */
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+static struct semaphore adpt_configuration_lock = MUTEX;
+#else
 DECLARE_MUTEX(adpt_configuration_lock);
-
-static struct i2o_sys_tbl *sys_tbl = NULL;
+#endif
+static struct i2o_sys_tbl *sys_tbl_va = NULL;
+static dma_addr_t sys_tbl_pa;
 static int sys_tbl_ind = 0;
 static int sys_tbl_len = 0;
 
@@ -111,6 +141,15 @@
 static adpt_hba* hba_chain = NULL;
 static int hba_count = 0;
 
+// If this is driver is embedded in the kernel this define
+// should be moved to include/linux/proc_fs.h as an emumerated type
+#define PROC_SCSI_DPT_I2O  0
+struct proc_dir_entry proc_scsi_dptI2O = {
+	PROC_SCSI_DPT_I2O, 7, DPT_DRIVER,
+	S_IFDIR | S_IRUGO | S_IXUGO, 2,
+	0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+};
+
 static struct file_operations adpt_fops = {
 	.ioctl		= adpt_ioctl,
 	.open		= adpt_open,
@@ -149,9 +188,9 @@
 
 static u8 adpt_read_blink_led(adpt_hba* host)
 {
-	if(host->FwDebugBLEDflag_P != 0) {
-		if( readb(host->FwDebugBLEDflag_P) == 0xbc ){
-			return readb(host->FwDebugBLEDvalue_P);
+	if(host->bled_flag_addr_virt != 0) {
+		if( readb(host->bled_flag_addr_virt) == 0xbc ){
+			return readb(host->bled_value_addr_virt);
 		}
 	}
 	return 0;
@@ -178,10 +217,11 @@
 
 	PINFO("Detecting Adaptec I2O RAID controllers...\n");
 
-        /* search for all Adatpec I2O RAID cards */
-	while ((pDev = pci_find_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
-		if(pDev->device == PCI_DPT_DEVICE_ID ||
-		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
+        /* search for all Adaptec I2O RAID cards */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+	while ((pDev = pci_find_device( dptids[0].vendor, PCI_ANY_ID, pDev))) {
+		if(pDev->device == dptids[0].device ||
+		   pDev->device == dptids[1].device){
 			if(adpt_install_hba(sht, pDev) ){
 				PERROR("Could not Init an I2O RAID device\n");
 				PERROR("Will not try to detect others.\n");
@@ -189,6 +229,18 @@
 			}
 		}
 	}
+#else
+	while ((pDev = adpt_pci_find_device( dptids[0].vendor, pDev))) {
+		if(pDev->device == dptids[0].device ||
+		   pDev->device == dptids[1].device){
+			if(adpt_install_hba(sht, pDev) ){
+				PERROR("Could not Init an I2O RAID device\n");
+				PERROR("Will not try to detect others.\n");
+				return hba_count-1;
+			}
+		}
+	}
+#endif
 
 	/* In INIT state, Activate IOPs */
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
@@ -242,11 +294,23 @@
 		adpt_inquiry(pHba);
 	}
 
+#if 0
+printk (KERN_INFO"dpti: Register us with the SCSI system\n");
+#endif
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+#if 0
+printk (KERN_INFO"adpt_scsi_register(%p,%p)\n", pHba, sht);
+#endif
 		if( adpt_scsi_register(pHba,sht) < 0){
+#if 0
+printk (KERN_INFO"adpt_i2o_delete_hba(%p)\n", pHba);
+#endif
 			adpt_i2o_delete_hba(pHba);
 			continue;
 		}
+#if 0
+printk (KERN_INFO"registered\n");
+#endif
 		pHba->initialized = TRUE;
 		pHba->state &= ~DPTI_STATE_RESET;
 	}
@@ -254,10 +318,27 @@
 	// Register our control device node
 	// nodes will need to be created in /dev to access this
 	// the nodes can not be created from within the driver
+#if 0
+printk (KERN_INFO"dpti: Register us with the char device system\n");
+#endif
 	if (hba_count && register_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER, &adpt_fops)) {
 		adpt_i2o_sys_shutdown();
 		return 0;
 	}
+#	if (defined(__x86_64__))
+		register_ioctl32_conversion(DPT_SIGNATURE, sys_ioctl);
+		register_ioctl32_conversion(I2OUSRCMD, sys_ioctl);
+		register_ioctl32_conversion(DPT_CTRLINFO, sys_ioctl);
+		register_ioctl32_conversion(DPT_SYSINFO, sys_ioctl);
+		register_ioctl32_conversion(DPT_BLINKLED, sys_ioctl);
+		register_ioctl32_conversion(I2ORESETCMD, sys_ioctl);
+		register_ioctl32_conversion(I2ORESCANCMD, sys_ioctl);
+		register_ioctl32_conversion(DPT_TARGET_BUSY & 0xFFFF, sys_ioctl);
+		register_ioctl32_conversion(DPT_TARGET_BUSY, sys_ioctl);
+#	endif
+#if 0
+printk (KERN_INFO"dpti: %d adapters\n", hba_count);
+#endif
 	return hba_count;
 }
 
@@ -284,11 +365,12 @@
 	u32 len;
 	u32 reqlen;
 	u8* buf;
+	dma_addr_t addr;
 	u8  scb[16];
 	s32 rcode;
 
 	memset(msg, 0, sizeof(msg));
-	buf = (u8*)kmalloc(80,GFP_KERNEL|ADDR32);
+	buf = (u8*)pci_alloc_consistent(pHba->pDev, 80, &addr);
 	if(!buf){
 		printk(KERN_ERR"%s: Could not allocate buffer\n",pHba->name);
 		return;
@@ -301,18 +383,18 @@
 
 	reqlen = 14;		// SINGLE SGE
 	/* Stick the headers on */
-	msg[0] = reqlen<<16 | SGL_OFFSET_12;
-	msg[1] = (0xff<<24|HOST_TID<<12|ADAPTER_TID);
+	msg[0] = cpu_to_le32(reqlen<<16 | SGL_OFFSET_12);
+	msg[1] = cpu_to_le32(0xff<<24|HOST_TID<<12|ADAPTER_TID);
 	msg[2] = 0;
-	msg[3]  = 0;
+	msg[3] = 0;
 	// Adaptec/DPT Private stuff 
-	msg[4] = I2O_CMD_SCSI_EXEC|DPT_ORGANIZATION_ID<<16;
-	msg[5] = ADAPTER_TID | 1<<16 /* Interpret*/;
+	msg[4] = cpu_to_le32(I2O_CMD_SCSI_EXEC|DPT_ORGANIZATION_ID<<16);
+	msg[5] = cpu_to_le32(ADAPTER_TID | 1<<16) /* Interpret*/;
 	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
 	// I2O_SCB_FLAG_ENABLE_DISCONNECT | 
 	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 
 	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
-	msg[6] = scsidir|0x20a00000| 6 /* cmd len*/;
+	msg[6] = cpu_to_le32(scsidir|0x20a00000| 6) /* cmd len*/;
 
 	mptr=msg+7;
 
@@ -331,15 +413,28 @@
 	lenptr=mptr++;		/* Remember me - fill in when we know */
 
 	/* Now fill in the SGList and command */
-	*lenptr = len;
-	*mptr++ = 0xD0000000|direction|len;
-	*mptr++ = virt_to_bus(buf);
+	*lenptr = cpu_to_le32(len);
+	/* The following test gets optimized out if dma_addr_t is <= 32 bits */
+	if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support) && (((u64)addr >> 32) != 0) ) {
+		*mptr++ = cpu_to_le32((0x7C<<24)+(2<<16)+0x02); /* Enable 64 bit */
+		*mptr++ = cpu_to_le32(1 << PAGE_SHIFT);
+		*mptr++ = cpu_to_le32(0xD0000000|direction|len);
+		*mptr++ = cpu_to_le32(addr);
+		*mptr++ = cpu_to_le32((u64)addr >> 32);
+		reqlen += 3;
+		msg[0] = cpu_to_le32(reqlen<<16 | SGL_OFFSET_12);
+	} else {
+		*mptr++ = cpu_to_le32(0xD0000000|direction|len);
+		*mptr++ = cpu_to_le32(addr);
+	}
 
 	// Send it on it's way
 	rcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2, 120);
 	if (rcode != 0) {
 		sprintf(pHba->detail, "Adaptec I2O RAID");
 		printk(KERN_INFO "%s: Inquiry Error (%d)\n",pHba->name,rcode);
+		if (rcode != -ETIME && rcode != -EINTR)
+			pci_free_consistent(pHba->pDev, 80, buf, addr);
 	} else {
 		memset(pHba->detail, 0, sizeof(pHba->detail));
 		memcpy(&(pHba->detail), "Vendor: Adaptec ", 16);
@@ -348,28 +443,62 @@
 		memcpy(&(pHba->detail[40]), " FW: ", 4);
 		memcpy(&(pHba->detail[44]), (u8*) &buf[32], 4);
 		pHba->detail[48] = '\0';	/* precautionary */
+		pci_free_consistent(pHba->pDev, 80, buf, addr);
 	}
-	kfree(buf);
 	adpt_i2o_status_get(pHba);
 	return ;
 }
 
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 static int adpt_slave_configure(Scsi_Device * device)
 {
-	struct Scsi_Host *host = device->host;
-	adpt_hba* pHba;
+	struct Scsi_Host * host = device->host;
+	adpt_hba * pHba;
 
 	pHba = (adpt_hba *) host->hostdata[0];
 
 	if (host->can_queue && device->tagged_supported) {
 		scsi_adjust_queue_depth(device, MSG_SIMPLE_TAG,
-				host->can_queue - 1);
+			host->can_queue - 1);
 	} else {
 		scsi_adjust_queue_depth(device, 0, 1);
-	}
+        }
 	return 0;
 }
+#else
+static void adpt_select_queue_depths(struct Scsi_Host *host, Scsi_Device * devicelist)
+{
+	Scsi_Device *device;	/* scsi layer per device information */
+	adpt_hba* pHba;
+
+	pHba = (adpt_hba *) host->hostdata[0];
+
+	for (device = devicelist; device != NULL; device = device->next) {
+		if (device->host != host) {
+			continue;
+		}
+		if (host->can_queue) {
+			device->queue_depth =  host->can_queue - 1;
+		} else {
+			device->queue_depth = 1;
+		}
+	}
+}
+#endif
+#if 0
+void adpt_sleep(void)
+{
+	spinlock_t * was_locked = (spinlock_t *)NULL;
+	if (spin_is_locked(&io_request_lock)) {
+		was_locked = &io_request_lock;
+		spin_unlock_irq(was_locked);
+	}
+	scsi_sleep(1);
+	if (was_locked)
+		spin_lock_irq(was_locked);
+}
+#endif
 
 static int adpt_queue(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
 {
@@ -377,6 +506,10 @@
 	struct adpt_device* pDev = NULL;	/* dpt per device information */
 	ulong timeout = jiffies + (TMOUT_SCSI*HZ);
 
+#if 0
+printk (KERN_INFO"adpt_queue(%p,%p)\n", cmd, done);
+adpt_sleep();
+#endif
 	cmd->scsi_done = done;
 	/*
 	 * SCSI REQUEST_SENSE commands will be executed automatically by the 
@@ -411,8 +544,9 @@
 		return 1;
 	}
 
-	if(cmd->eh_state != SCSI_STATE_QUEUED){
-		// If we are not doing error recovery
+	if ((cmd->eh_state != SCSI_STATE_QUEUED)
+	 && (cmd->device->type == TYPE_DISK)) {
+		// If the controller is doing error recovery
 		mod_timer(&cmd->eh_timeout, timeout);
 	}
 
@@ -424,6 +558,10 @@
 		 * to the device structure.  This should be a TEST_UNIT_READY
 		 * command from scan_scsis_single.
 		 */
+#if 0
+printk (KERN_INFO"adpt_find_device(%p,%d,%d,%d)\n", pHba, cmd->device->channel, cmd->device->id, cmd->device->lun);
+adpt_sleep();
+#endif
 		if ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun)) == NULL) {
 			// TODO: if any luns are at this bus, scsi id then fake a TEST_UNIT_READY and INQUIRY response 
 			// with type 7F (for all luns less than the max for this bus,id) so the lun scan will continue.
@@ -431,8 +569,16 @@
 			cmd->scsi_done(cmd);
 			return 0;
 		}
+#if 0
+printk (KERN_INFO"pDev=%p\n", pDev);
+adpt_sleep();
+#endif
 		(struct adpt_device*)(cmd->device->hostdata) = pDev;
 	}
+#if 0
+printk (KERN_INFO"pDev->pScsi_dev=%p\n", cmd->device);
+adpt_sleep();
+#endif
 	pDev->pScsi_dev = cmd->device;
 
 	/*
@@ -445,12 +591,21 @@
 	return adpt_scsi_to_i2o(pHba, cmd, pDev);
 }
 
-static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,
-		sector_t capacity, int geom[])
+static int adpt_bios_param(
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+	struct scsi_device *sdev, struct block_device *dev, sector_t capacity,
+#else
+	Disk* disk, kdev_t dev,
+#endif
+	int geom[])
 {
 	int heads=-1;
 	int sectors=-1;
 	int cylinders=-1;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,65))
+	unsigned long capacity = disk->capacity;
+	Scsi_Device * sdev = disk->device;
+#endif
 
 	// *** First lets set the default geometry ****
 	
@@ -479,7 +634,12 @@
 		heads = 255;
 		sectors = 63;
 	}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+	sector_div(capacity, heads * sectors);
+	cylinders = (unsigned)capacity;
+#else
 	cylinders = capacity / (heads * sectors);
+#endif
 
 	// Special case if CDROM
 	if(sdev->type == 5) {  // CDROM
@@ -505,8 +665,15 @@
 	return (char *) (pHba->detail);
 }
 
-static int adpt_proc_info(struct Scsi_Host *host, char *buffer, char **start, off_t offset,
-		  int length, int inout)
+static int adpt_proc_info(
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+	struct Scsi_Host *host,
+#endif
+	char *buffer, char **start, off_t offset, int length,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,65))
+	int hostno,
+#endif
+	int inout)
 {
 	struct adpt_device* d;
 	int id;
@@ -515,6 +682,9 @@
 	int begin = 0;
 	int pos = 0;
 	adpt_hba* pHba;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,65))
+	struct Scsi_Host *host;
+#endif
 	int unit;
 
 	*start = buffer;
@@ -538,7 +708,12 @@
 	// Find HBA (host bus adapter) we are looking for
 	down(&adpt_configuration_lock);
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
-		if (pHba->host == host) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+		if (pHba->host == host)
+#else
+		if (pHba->host->host_no == hostno)
+#endif
+		{
 			break;	/* found adapter */
 		}
 	}
@@ -548,7 +723,11 @@
 	}
 	host = pHba->host;
 
-	len  = sprintf(buffer    , "Adaptec I2O RAID Driver Version: %s\n\n", DPT_I2O_VERSION);
+#	if (defined(DPT_I2O_DRIVER_BUILD))
+		len  = sprintf(buffer    , "Adaptec I2O RAID Driver Version: " DPT_I2O_VERSION "[%d]\n\n", DPT_I2O_DRIVER_BUILD);
+#	else
+		len  = sprintf(buffer    , "Adaptec I2O RAID Driver Version: " DPT_I2O_VERSION "\n\n");
+#	endif
 	len += sprintf(buffer+len, "%s\n", pHba->detail);
 	len += sprintf(buffer+len, "SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\n", 
 			pHba->host->host_no, pHba->name, host->irq);
@@ -575,8 +754,10 @@
 		for(id = 0; id < MAX_ID; id++) {
 			d = pHba->channel[chan].device[id];
 			while(d){
-				len += sprintf(buffer+len,"\t%-24.24s", d->pScsi_dev->vendor);
-				len += sprintf(buffer+len," Rev: %-8.8s\n", d->pScsi_dev->rev);
+				if (d->pScsi_dev) {
+					len += sprintf(buffer+len,"\t%-24.24s", d->pScsi_dev->vendor);
+					len += sprintf(buffer+len," Rev: %-8.8s\n", d->pScsi_dev->rev);
+				}
 				pos = begin + len;
 
 
@@ -589,10 +770,10 @@
 					begin = pos;
 				}
 
-				unit = d->pI2o_dev->lct_data.tid;
+				unit = le32_to_cpu(d->pI2o_dev->lct_data.tid);
 				len += sprintf(buffer+len, "\tTID=%d, (Channel=%d, Target=%d, Lun=%d)  (%s)\n\n",
 					       unit, (int)d->scsi_channel, (int)d->scsi_id, (int)d->scsi_lun,
-					       scsi_device_online(d->pScsi_dev)? "online":"offline"); 
+					       (d->pScsi_dev && d->pScsi_dev->online)? "online":"offline"); 
 				pos = begin + len;
 
 				/* CHECKPOINT */
@@ -654,11 +835,14 @@
 	}
 
 	memset(msg, 0, sizeof(msg));
-	msg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;
-	msg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;
+	msg[0] = cpu_to_le32(FIVE_WORD_MSG_SIZE|SGL_OFFSET_0);
+	msg[1] = cpu_to_le32(I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid);
 	msg[2] = 0;
-	msg[3]= 0; 
-	msg[4] = (u32)cmd;
+	msg[3] = 0; 
+	if (sizeof(cmd) > sizeof(u32))
+		msg[4] = (u32)cmd->serial_number;
+	else
+		msg[4] = (u32)(unsigned long)cmd; /* EVIL, not 64 bit safe, but faster */
 	if( (rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER)) != 0){
 		if(rcode == -EOPNOTSUPP ){
 			printk(KERN_INFO"%s: Abort cmd not supported\n",pHba->name);
@@ -691,8 +875,8 @@
 		return FAILED;
 	}
 	memset(msg, 0, sizeof(msg));
-	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
-	msg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);
+	msg[0] = cpu_to_le32(FOUR_WORD_MSG_SIZE|SGL_OFFSET_0);
+	msg[1] = cpu_to_le32(I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);
 	msg[2] = 0;
 	msg[3] = 0;
 
@@ -720,12 +904,14 @@
 {
 	adpt_hba* pHba;
 	u32 msg[4];
+	int channel;
 
+	channel = cmd->device->channel;
 	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
 	memset(msg, 0, sizeof(msg));
-	printk(KERN_WARNING"%s: Bus reset: SCSI Bus %d: tid: %d\n",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );
-	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
-	msg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);
+	printk(KERN_WARNING"%s: Bus reset: SCSI Bus %d: tid: %d\n",pHba->name, channel,pHba->channel[channel].tid );
+	msg[0] = cpu_to_le32(FOUR_WORD_MSG_SIZE|SGL_OFFSET_0);
+	msg[1] = cpu_to_le32(I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[channel].tid);
 	msg[2] = 0;
 	msg[3] = 0;
 	if(adpt_i2o_post_wait(pHba, (void*)msg,sizeof(msg), FOREVER) ){
@@ -742,8 +928,11 @@
 {
 	adpt_hba* pHba;
 	int rcode;
+	int channel;
+
+	channel = cmd->device->channel;
 	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
-	printk(KERN_WARNING"%s: Hba Reset: scsi id %d: tid: %d\n",pHba->name,cmd->device->channel,pHba->channel[cmd->device->channel].tid );
+	printk(KERN_WARNING"%s: Hba Reset: scsi id %d: tid: %d\n",pHba->name,channel,pHba->channel[channel].tid );
 	rcode =  adpt_hba_reset(pHba);
 	if(rcode == 0){
 		printk(KERN_WARNING"%s: HBA reset complete\n",pHba->name);
@@ -789,6 +978,8 @@
 		adpt_i2o_delete_hba(pHba);
 		return rcode;
 	}
+	adpt_inquiry(pHba);
+
 	pHba->state &= ~DPTI_STATE_RESET;
 
 	adpt_fail_posted_scbs(pHba);
@@ -862,12 +1053,13 @@
 	ulong base_addr1_phys = 0;
 	u32 hba_map0_area_size = 0;
 	u32 hba_map1_area_size = 0;
-	ulong base_addr_virt = 0;
-	ulong msg_addr_virt = 0;
+	char * base_addr_virt = 0;
+	char * msg_addr_virt = 0;
 
 	int raptorFlag = FALSE;
 	int i;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
 	if(pci_enable_device(pDev)) {
 		return -EINVAL;
 	}
@@ -894,14 +1086,75 @@
 	}
 
 
-	base_addr_virt = (ulong)ioremap(base_addr0_phys,hba_map0_area_size);
+#else  /* 2.2.* kernel method */
+	u16 command = 0;
+	u16 subdevice = 0;
+
+	// Read in the command register and make sure that the device is 
+	// enabled and set up for bus master                             
+	pci_read_config_word(pDev, PCI_COMMAND, &command);
+	if(((command & PCI_COMMAND_MEMORY) && !(command & PCI_COMMAND_MASTER))){
+		command |= PCI_COMMAND_MASTER;
+		pci_write_config_word(pDev, PCI_COMMAND, command);
+	}
+
+	pci_read_config_dword(pDev, PCI_BASE_ADDRESS_0,(u32*)&base_addr0_phys);
+	// To get the size of the memory space taken we have to write out
+	// 0xffffffff (32 bit) to the base register (PCI_BASE_ADDRESS_0)
+	// and then read it back. The lower 4 bits are ignored not needed.
+	// They contain address space flag (io or memory) 
+	// and memory type (32 1M 64)
+	// The Rest is used to determine the size of memory space
+	// used. All other upper bits will be set to ones. 
+	// If we take the negative of this number and add one
+	// it will give us the memory size. We must also write the original
+	// Base address back out to reset it up.
+	pci_write_config_dword(pDev, PCI_BASE_ADDRESS_0 , 0xffffffff);
+	pci_read_config_dword(pDev, PCI_BASE_ADDRESS_0 , &hba_map0_area_size);
+
+	// Restore the base address
+	pci_write_config_dword(pDev, PCI_BASE_ADDRESS_0 , (u32)base_addr0_phys);
+	(u32)base_addr0_phys &= PCI_BASE_ADDRESS_MEM_MASK;
+
+	// Take the negative, disreguard the bottem four bits and add 1
+	hba_map0_area_size &= PCI_BASE_ADDRESS_MEM_MASK;	// And out the lower 4 bits
+	hba_map0_area_size = ~hba_map0_area_size + 1;	// Take the negative and add 1
+
+	pci_read_config_word (pDev, PCI_SUBSYSTEM_ID, &subdevice);
+
+	if(pDev->device == PCI_DPT_DEVICE_ID){
+		// Raptor card with this device id  needs 4M
+		if(subdevice >= 0xc032 && subdevice <= 0xc03b){ 
+			hba_map0_area_size = 0x400000;
+		} else {
+			if(hba_map0_area_size > 0x100000) { // Only give 'em 1M
+				hba_map0_area_size = 0x100000;
+			}
+		}
+	} else {
+		//Use BAR1 in this config
+		pci_read_config_dword(pDev,PCI_BASE_ADDRESS_1, (u32*)&base_addr1_phys);
+		pci_write_config_dword(pDev,PCI_BASE_ADDRESS_1, 0xffffffff);
+		pci_read_config_dword(pDev,PCI_BASE_ADDRESS_1, &hba_map1_area_size);
+
+		//Restore the base address
+		pci_write_config_dword(pDev,PCI_BASE_ADDRESS_1, (u32)base_addr1_phys);
+		(u32)base_addr1_phys &= PCI_BASE_ADDRESS_MEM_MASK;
+		hba_map1_area_size &= PCI_BASE_ADDRESS_MEM_MASK;
+		hba_map1_area_size = ~hba_map1_area_size + 1;
+		
+		raptorFlag=TRUE;
+	}
+#endif
+
+	base_addr_virt = (char *)ioremap(base_addr0_phys,hba_map0_area_size);
 	if(base_addr_virt == 0) {
 		PERROR("dpti: adpt_config_hba: io remap failed\n");
 		return -EINVAL;
 	}
 
         if(raptorFlag == TRUE) {
-		msg_addr_virt = (ulong)ioremap(base_addr1_phys, hba_map1_area_size );
+		msg_addr_virt = (char *)ioremap(base_addr1_phys, hba_map1_area_size );
 		if(msg_addr_virt == 0) {
 			PERROR("dpti: adpt_config_hba: io remap failed on BAR1\n");
 			iounmap((void*)base_addr_virt);
@@ -949,32 +1202,31 @@
 	// Set up the Virtual Base Address of the I2O Device
 	pHba->base_addr_virt = base_addr_virt;
 	pHba->msg_addr_virt = msg_addr_virt;  
-	pHba->irq_mask = (ulong)(base_addr_virt+0x30);
-	pHba->post_port = (ulong)(base_addr_virt+0x40);
-	pHba->reply_port = (ulong)(base_addr_virt+0x44);
+	pHba->irq_mask = (u32 *)(base_addr_virt+0x30);
+	pHba->post_port = (u32 *)(base_addr_virt+0x40);
+	pHba->reply_port = (u32 *)(base_addr_virt+0x44);
 
-	pHba->hrt = NULL;
-	pHba->lct = NULL;
+	pHba->hrt_va = NULL;
+	pHba->lct_va = NULL;
 	pHba->lct_size = 0;
-	pHba->status_block = NULL;
+	pHba->status_block_va = NULL;
 	pHba->post_count = 0;
 	pHba->state = DPTI_STATE_RESET;
-	pHba->pDev = pDev;
 	pHba->devices = NULL;
 
 	// Initializing the spinlocks
 	spin_lock_init(&pHba->state_lock);
 
 	if(raptorFlag == 0){
-		printk(KERN_INFO"Adaptec I2O RAID controller %d at %lx size=%x irq=%d\n", 
+		printk(KERN_INFO"Adaptec I2O RAID controller %d at %p size=%x irq=%d\n", 
 			hba_count-1, base_addr_virt, hba_map0_area_size, pDev->irq);
 	} else {
 		printk(KERN_INFO"Adaptec I2O RAID controller %d irq=%d\n",hba_count-1, pDev->irq);
-		printk(KERN_INFO"     BAR0 %lx - size= %x\n",base_addr_virt,hba_map0_area_size);
-		printk(KERN_INFO"     BAR1 %lx - size= %x\n",msg_addr_virt,hba_map1_area_size);
+		printk(KERN_INFO"     BAR0 %p - size= %x\n",base_addr_virt,hba_map0_area_size);
+		printk(KERN_INFO"     BAR1 %p - size= %x\n",msg_addr_virt,hba_map1_area_size);
 	}
 
-	if (request_irq (pDev->irq, adpt_isr, SA_SHIRQ, pHba->name, pHba)) {
+	if (request_irq (pDev->irq, adpt_isr, SA_SHIRQ, pHba->name, (void *)pHba)) {
 		printk(KERN_ERR"%s: Couldn't register IRQ %d\n", pHba->name, pDev->irq);
 		adpt_i2o_delete_hba(pHba);
 		return -EINVAL;
@@ -1026,17 +1278,17 @@
 	if(pHba->msg_addr_virt != pHba->base_addr_virt){
 		iounmap((void*)pHba->msg_addr_virt);
 	}
-	if(pHba->hrt) {
-		kfree(pHba->hrt);
+	if(pHba->hrt_va) {
+		pci_free_consistent(pHba->pDev, le32_to_cpu(pHba->hrt_va->num_entries) * le32_to_cpu(pHba->hrt_va->entry_len) << 2, pHba->hrt_va, pHba->hrt_pa);
 	}
-	if(pHba->lct){
-		kfree(pHba->lct);
+	if(pHba->lct_va){
+		pci_free_consistent(pHba->pDev, pHba->lct_size, pHba->lct_va, pHba->lct_pa);
 	}
-	if(pHba->status_block) {
-		kfree(pHba->status_block);
+	if(pHba->status_block_va) {
+		pci_free_consistent(pHba->pDev, sizeof(i2o_status_block), pHba->status_block_va, pHba->status_block_pa);
 	}
-	if(pHba->reply_pool){
-		kfree(pHba->reply_pool);
+	if(pHba->reply_pool_va){
+		pci_free_consistent(pHba->pDev, pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, pHba->reply_pool_va, pHba->reply_pool_pa);
 	}
 
 	for(d = pHba->devices; d ; d = next){
@@ -1053,9 +1305,23 @@
 			}
 		}
 	}
-	kfree(pHba);
 
+	if (pHba->host != NULL) {
+		scsi_unregister(pHba->host);
+	}
+	kfree(pHba);
 	if(hba_count <= 0){
+#		if (defined(__x86_64__))
+			unregister_ioctl32_conversion(DPT_SIGNATURE);
+			unregister_ioctl32_conversion(I2OUSRCMD);
+			unregister_ioctl32_conversion(DPT_CTRLINFO);
+			unregister_ioctl32_conversion(DPT_SYSINFO);
+			unregister_ioctl32_conversion(DPT_BLINKLED);
+			unregister_ioctl32_conversion(I2ORESETCMD);
+			unregister_ioctl32_conversion(I2ORESCANCMD);
+			unregister_ioctl32_conversion(DPT_TARGET_BUSY & 0xFFFF);
+			unregister_ioctl32_conversion(DPT_TARGET_BUSY);
+#		endif
 		unregister_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER);   
 	}
 }
@@ -1065,7 +1331,11 @@
 {
 	int i;
 
-	printk(KERN_INFO"Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
+#	if (defined(DPT_I2O_DRIVER_BUILD))
+		printk(KERN_INFO"Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "[%d]\n", DPT_I2O_DRIVER_BUILD);
+#	else
+		printk(KERN_INFO"Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
+#	endif
 	for (i = 0; i < DPTI_MAX_HBA; i++) {
 		hbas[i] = NULL;
 	}
@@ -1083,7 +1353,7 @@
 
 	if(chan < 0 || chan >= MAX_CHANNEL)
 		return NULL;
-	
+
 	if( pHba->channel[chan].device == NULL){
 		printk(KERN_DEBUG"Adaptec I2O RAID: Trying to find device before they are allocated\n");
 		return NULL;
@@ -1135,7 +1405,7 @@
 	wait_data->next = adpt_post_wait_queue;
 	adpt_post_wait_queue = wait_data;
 	adpt_post_wait_id++;
-	adpt_post_wait_id &= 0x7fff;
+	adpt_post_wait_id = (adpt_post_wait_id & 0x7fff);
 	wait_data->id =  adpt_post_wait_id;
 	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
 
@@ -1144,28 +1414,85 @@
 
 	// this code is taken from kernel/sched.c:interruptible_sleep_on_timeout
 	wait.task = current;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+	write_lock_irqsave(&waitqueue_lock,flags);
+	__add_wait_queue(&adpt_wq_i2o_post, &wait);
+	write_unlock(&waitqueue_lock);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 	init_waitqueue_entry(&wait, current);
-	spin_lock_irqsave(&adpt_wq_i2o_post.lock, flags);
+	spin_lock_irqsave(&adpt_wq_i2o_post.lock,flags);
 	__add_wait_queue(&adpt_wq_i2o_post, &wait);
 	spin_unlock(&adpt_wq_i2o_post.lock);
+#else
+	init_waitqueue_entry(&wait, current);
+	wq_write_lock_irqsave(&adpt_wq_i2o_post.lock,flags);
+	__add_wait_queue(&adpt_wq_i2o_post, &wait);
+	wq_write_unlock(&adpt_wq_i2o_post.lock);
+#endif
 
 	msg[2] |= 0x80000000 | ((u32)wait_data->id);
 	timeout *= HZ;
 	if((status = adpt_i2o_post_this(pHba, msg, len)) == 0){
+		spinlock_t * was_locked = (spinlock_t *)NULL;
 		set_current_state(TASK_INTERRUPTIBLE);
-		spin_unlock_irq(pHba->host->host_lock);
-		if (!timeout)
+		/*
+		 *	We are called before the host & host lock has been
+		 * assigned, and may be called with, or without, the host lock
+		 * held. We need to free the lock, if held, before going
+		 * to sleep.
+		 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+		if ((pHba->host != NULL) /* Sad */
+		 && (spin_is_locked(pHba->host->host_lock))) {
+			was_locked = pHba->host->host_lock;
+			spin_unlock_irq(was_locked);
+		}
+#else
+		if (spin_is_locked(&io_request_lock)) {
+			was_locked = &io_request_lock;
+			spin_unlock_irq(was_locked);
+		}
+#endif
+		if(!timeout){
 			schedule();
-		else
-			schedule_timeout(timeout*HZ);
-		spin_lock_irq(pHba->host->host_lock);
+		} else {
+			timeout = schedule_timeout(timeout*HZ);
+			if (timeout == 0) {
+				// I/O issued, but cannot get result in
+				// specified time. Freeing resources is
+				// dangerous.
+				status = -ETIME;
+			}
+		}
+		if (was_locked)
+			spin_lock_irq(was_locked);
+		if (signal_pending(current)) {
+			printk("adpt_i2o_post_wait: interrupted\n");
+			status = -EINTR;
+		}
 	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+	write_lock_irq(&waitqueue_lock);
+	__remove_wait_queue(&adpt_wq_i2o_post, &wait);
+	write_unlock_irqrestore(&waitqueue_lock,flags);
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 	spin_lock_irq(&adpt_wq_i2o_post.lock);
 	__remove_wait_queue(&adpt_wq_i2o_post, &wait);
-	spin_unlock_irqrestore(&adpt_wq_i2o_post.lock, flags);
+	spin_unlock_irqrestore(&adpt_wq_i2o_post.lock,flags);
+#else
+	wq_write_lock_irq(&adpt_wq_i2o_post.lock);
+	__remove_wait_queue(&adpt_wq_i2o_post, &wait);
+	wq_write_unlock_irqrestore(&adpt_wq_i2o_post.lock,flags);
+#endif
+
+	wait_data->wq = 0;
+
+	if (status == -EINTR)
+		return status;
 
-	if(status == -ETIMEDOUT){
-		printk(KERN_INFO"dpti%d: POST WAIT TIMEOUT\n",pHba->unit);
+	if(status == -ETIMEDOUT || status == -ETIME) {
+		printk(KERN_INFO"dpti%d: POST WAIT FAILED (%d)\n",
+		  pHba->unit, status);
 		// We will have to free the wait_data memory during shutdown
 		return status;
 	}
@@ -1247,12 +1574,13 @@
 		if(p1->id == context) {
 			p1->status = status;
 			spin_unlock(&adpt_post_wait_lock);
-			wake_up_interruptible(p1->wq);
+			if (p1->wq)
+				wake_up_interruptible(p1->wq);
 			return;
 		}
 	}
 	spin_unlock(&adpt_post_wait_lock);
-        // If this happens we lose commands that probably really completed
+        // If this happens we loose commands that probably really completed
 	printk(KERN_DEBUG"dpti: Could Not find task %d in wait queue\n",context);
 	printk(KERN_DEBUG"      Tasks in wait queue:\n");
 	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
@@ -1265,6 +1593,8 @@
 {
 	u32 msg[8];
 	u8* status;
+	dma_addr_t addr;
+	u64 addr64;
 	u32 m = EMPTY_QUEUE ;
 	ulong timeout = jiffies + (TMOUT_IOPRESET*HZ);
 
@@ -1277,16 +1607,16 @@
 	do {
 		rmb();
 		m = readl(pHba->post_port);
-		if (m != EMPTY_QUEUE) {
+		if (m != cpu_to_le32(EMPTY_QUEUE)) {
 			break;
 		}
 		if(time_after(jiffies,timeout)){
 			printk(KERN_WARNING"Timeout waiting for message!\n");
 			return -ETIMEDOUT;
 		}
-	} while (m == EMPTY_QUEUE);
+	} while (m == cpu_to_le32(EMPTY_QUEUE));
 
-	status = (u8*)kmalloc(4, GFP_KERNEL|ADDR32);
+	status = (u8*)pci_alloc_consistent(pHba->pDev, 4, &addr);
 	if(status == NULL) {
 		adpt_send_nop(pHba, m);
 		printk(KERN_ERR"IOP reset failed - no free memory.\n");
@@ -1294,16 +1624,17 @@
 	}
 	memset(status,0,4);
 
-	msg[0]=EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0;
-	msg[1]=I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[0]=cpu_to_le32(EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0);
+	msg[1]=cpu_to_le32(I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID);
 	msg[2]=0;
 	msg[3]=0;
 	msg[4]=0;
 	msg[5]=0;
-	msg[6]=virt_to_bus(status);
-	msg[7]=0;     
+	addr64 = cpu_to_le64(addr);
+	msg[6]=(u32)addr64;
+	msg[7]=(u32)(addr64 >> 32);
 
-	memcpy_toio(pHba->msg_addr_virt+m, msg, sizeof(msg));
+	memcpy_toio(pHba->msg_addr_virt+le32_to_cpu(m), msg, sizeof(msg));
 	wmb();
 	writel(m, pHba->post_port);
 	wmb();
@@ -1311,40 +1642,47 @@
 	while(*status == 0){
 		if(time_after(jiffies,timeout)){
 			printk(KERN_WARNING"%s: IOP Reset Timeout\n",pHba->name);
-			kfree(status);
+			/* We loose 4 bytes of "status" here, but we cannot
+			   free these because controller may awake and corrupt
+			   those bytes at any time */
+			/* pci_free_consistent(pHba->pDev, 4, buf, addr); */
 			return -ETIMEDOUT;
 		}
 		rmb();
 	}
 
-	if(*status == 0x01 /*I2O_EXEC_IOP_RESET_IN_PROGRESS*/) {
+	if(*status == cpu_to_le32(0x01) /*I2O_EXEC_IOP_RESET_IN_PROGRESS*/) {
 		PDEBUG("%s: Reset in progress...\n", pHba->name);
 		// Here we wait for message frame to become available
 		// indicated that reset has finished
 		do {
 			rmb();
 			m = readl(pHba->post_port);
-			if (m != EMPTY_QUEUE) {
+			if (m != cpu_to_le32(EMPTY_QUEUE)) {
 				break;
 			}
 			if(time_after(jiffies,timeout)){
 				printk(KERN_ERR "%s:Timeout waiting for IOP Reset.\n",pHba->name);
+				/* We loose 4 bytes of "status" here, but we
+				   cannot free these because controller may
+				   awake and corrupt those bytes at any time */
+				/* pci_free_consistent(pHba->pDev, 4, buf, addr); */
 				return -ETIMEDOUT;
 			}
-		} while (m == EMPTY_QUEUE);
+		} while (m == cpu_to_le32(EMPTY_QUEUE));
 		// Flush the offset
 		adpt_send_nop(pHba, m);
 	}
 	adpt_i2o_status_get(pHba);
-	if(*status == 0x02 ||
-			pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
+	if(*status == cpu_to_le32(0x02) ||
+			pHba->status_block_va->iop_state != cpu_to_le32(ADAPTER_STATE_RESET)) {
 		printk(KERN_WARNING"%s: Reset reject, trying to clear\n",
 				pHba->name);
 	} else {
 		PDEBUG("%s: Reset completed.\n", pHba->name);
 	}
 
-	kfree(status);
+	pci_free_consistent(pHba->pDev, 4, status, addr);
 #ifdef UARTDELAY
 	// This delay is to allow someone attached to the card through the debug UART to 
 	// set up the dump levels that they want before the rest of the initialization sequence
@@ -1360,7 +1698,7 @@
 	int max;
 	int tid;
 	struct i2o_device *d;
-	i2o_lct *lct = pHba->lct;
+	i2o_lct *lct = pHba->lct_va;
 	u8 bus_no = 0;
 	s16 scsi_id;
 	s16 scsi_lun;
@@ -1377,7 +1715,7 @@
 	max /= 9;
 
 	for(i=0;i<max;i++) {
-		if( lct->lct_entry[i].user_tid != 0xfff){
+		if( lct->lct_entry[i].user_tid != cpu_to_le32(0xfff)){
 			/*
 			 * If we have hidden devices, we need to inform the upper layers about
 			 * the possible maximum id reference to handle device access when
@@ -1385,12 +1723,12 @@
 			 * allow us future access to devices that are currently hidden
 			 * behind arrays, hotspares or have not been configured (JBOD mode).
 			 */
-			if( lct->lct_entry[i].class_id != I2O_CLASS_RANDOM_BLOCK_STORAGE &&
-			    lct->lct_entry[i].class_id != I2O_CLASS_SCSI_PERIPHERAL &&
-			    lct->lct_entry[i].class_id != I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+			if( lct->lct_entry[i].class_id != cpu_to_le32(I2O_CLASS_RANDOM_BLOCK_STORAGE) &&
+			    lct->lct_entry[i].class_id != cpu_to_le32(I2O_CLASS_SCSI_PERIPHERAL) &&
+			    lct->lct_entry[i].class_id != cpu_to_le32(I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL) ){
 			    	continue;
 			}
-			tid = lct->lct_entry[i].tid;
+			tid = le32_to_cpu(lct->lct_entry[i].tid);
 			// I2O_DPT_DEVICE_INFO_GROUP_NO;
 			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
 				continue;
@@ -1402,7 +1740,7 @@
 				printk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);
 				continue;
 			}
-			if (scsi_id >= MAX_ID){
+			if(scsi_id > MAX_ID){
 				printk(KERN_WARNING"%s: SCSI ID %d out of range \n", pHba->name, bus_no);
 				continue;
 			}
@@ -1430,21 +1768,21 @@
 		memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
 
 		d->flags = 0;
-		tid = d->lct_data.tid;
+		tid = le32_to_cpu(d->lct_data.tid);
 		adpt_i2o_report_hba_unit(pHba, d);
 		adpt_i2o_install_device(pHba, d);
 	}
 	bus_no = 0;
 	for(d = pHba->devices; d ; d = d->next) {
-		if(d->lct_data.class_id  == I2O_CLASS_BUS_ADAPTER_PORT ||
-		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PORT){
-			tid = d->lct_data.tid;
+		if(d->lct_data.class_id  == cpu_to_le32(I2O_CLASS_BUS_ADAPTER_PORT) ||
+		   d->lct_data.class_id  == cpu_to_le32(I2O_CLASS_FIBRE_CHANNEL_PORT)){
+			tid = le32_to_cpu(d->lct_data.tid);
 			// TODO get the bus_no from hrt-but for now they are in order
 			//bus_no = 
 			if(bus_no > pHba->top_scsi_channel){
 				pHba->top_scsi_channel = bus_no;
 			}
-			pHba->channel[bus_no].type = d->lct_data.class_id;
+			pHba->channel[bus_no].type = le32_to_cpu(d->lct_data.class_id);
 			pHba->channel[bus_no].tid = tid;
 			if(adpt_i2o_query_scalar(pHba, tid, 0x0200, -1, buf, 28)>=0)
 			{
@@ -1462,11 +1800,11 @@
 
 	// Setup adpt_device table
 	for(d = pHba->devices; d ; d = d->next) {
-		if(d->lct_data.class_id  == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
-		   d->lct_data.class_id  == I2O_CLASS_SCSI_PERIPHERAL ||
-		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+		if(d->lct_data.class_id  == cpu_to_le32(I2O_CLASS_RANDOM_BLOCK_STORAGE) ||
+		   d->lct_data.class_id  == cpu_to_le32(I2O_CLASS_SCSI_PERIPHERAL) ||
+		   d->lct_data.class_id  == cpu_to_le32(I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL) ){
 
-			tid = d->lct_data.tid;
+			tid = le32_to_cpu(d->lct_data.tid);
 			scsi_id = -1;
 			// I2O_DPT_DEVICE_INFO_GROUP_NO;
 			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)>=0) {
@@ -1476,7 +1814,7 @@
 				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
 					continue;
 				}
-				if (scsi_id >= MAX_ID) {
+				if(scsi_id > MAX_ID){
 					continue;
 				}
 				if( pHba->channel[bus_no].device[scsi_id] == NULL){
@@ -1567,7 +1905,7 @@
 	}
 
 //	if(pHba->in_use){
-	//	up(&adpt_configuration_lock);
+//		up(&adpt_configuration_lock);
 //		return -EBUSY;
 //	}
 
@@ -1602,7 +1940,6 @@
 	return 0;
 }
 
-
 static int adpt_i2o_passthru(adpt_hba* pHba, u32* arg)
 {
 	u32 msg[MAX_MESSAGE_SIZE];
@@ -1611,13 +1948,14 @@
 	u32 reply_size = 0;
 	u32* user_msg = (u32*)arg;
 	u32* user_reply = NULL;
-	ulong sg_list[pHba->sg_tablesize];
+	void * sg_list[pHba->sg_tablesize];
 	u32 sg_offset = 0;
 	u32 sg_count = 0;
 	int sg_index = 0;
 	u32 i = 0;
 	u32 rcode = 0;
-	ulong p = 0;
+	void * p = 0;
+	dma_addr_t addr;
 	ulong flags = 0;
 
 	memset(&msg, 0, MAX_MESSAGE_SIZE*4);
@@ -1651,10 +1989,34 @@
 	memset(reply,0,REPLY_FRAME_SIZE*4);
 	sg_offset = (msg[0]>>4)&0xf;
 	msg[2] = 0x40000000; // IOCTL context
-	msg[3] = (u32)reply;
+	if (sizeof(reply) > sizeof(u32)) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+		spin_lock_irqsave(pHba->host->host_lock, flags);
+#else
+		spin_lock_irqsave(&io_request_lock, flags);
+#endif
+		for (i = 0; i < (sizeof(pHba->ioctl_reply_context) / sizeof(pHba->ioctl_reply_context[0])); ++i) {
+			if (pHba->ioctl_reply_context[i] == NULL) {
+				pHba->ioctl_reply_context[i] = reply;
+				break;
+			}
+		}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+		spin_unlock_irqrestore(pHba->host->host_lock, flags);
+#else
+		spin_unlock_irqrestore(&io_request_lock, flags);
+#endif
+		if (i >= (sizeof(pHba->ioctl_reply_context) / sizeof(pHba->ioctl_reply_context[0]))) {
+			kfree (reply);
+			printk(KERN_WARNING"%s: Too many outstanding ioctl commands\n",pHba->name);
+			return -EBUSY;
+		}
+		msg[3] = i;
+	} else
+		msg[3] = (u32)reply;	// EVIL, not 64 bit safe
 	memset(sg_list,0, sizeof(sg_list[0])*pHba->sg_tablesize);
 	if(sg_offset) {
-		// TODO 64bit fix
+		// TODO 64 bit fix ?
 		struct sg_simple_element *sg =  (struct sg_simple_element*) (msg+sg_offset);
 		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
 		if (sg_count > pHba->sg_tablesize){
@@ -1673,7 +2035,7 @@
 			}
 			sg_size = sg[i].flag_count & 0xffffff;      
 			/* Allocate memory for the transfer */
-			p = (ulong)kmalloc(sg_size, GFP_KERNEL|ADDR32);
+			p = pci_alloc_consistent(pHba->pDev, sg_size, &addr);
 			if(p == 0) {
 				printk(KERN_DEBUG"%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",
 						pHba->name,sg_size,i,sg_count);
@@ -1681,9 +2043,15 @@
 				goto cleanup;
 			}
 			sg_list[sg_index++] = p; // sglist indexed with input frame, not our internal frame.
+			if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support) && (((u64)addr >> 32) != 0) ) {
+				printk(KERN_DEBUG"%s: Could not allocate SG buffer in 32 space - size = %d buffer number %d of %d\n",
+						pHba->name,sg_size,i,sg_count);
+				rcode = -ENOMEM;
+				goto cleanup;
+			}
 			/* Copy in the user's SG buffer if necessary */
 			if(sg[i].flag_count & 0x04000000 /*I2O_SGL_FLAGS_DIR*/) {
-				// TODO 64bit fix
+				// TODO 64 bit fix?
 				if (copy_from_user((void*)p,(void*)sg[i].addr_bus, sg_size)) {
 					printk(KERN_DEBUG"%s: Could not copy SG buf %d FROM user\n",pHba->name,i);
 					rcode = -EFAULT;
@@ -1691,12 +2059,16 @@
 				}
 			}
 			//TODO 64bit fix
-			sg[i].addr_bus = (u32)virt_to_bus((void*)p);
+			sg[i].addr_bus = cpu_to_le32(addr);
 		}
 	}
 
 	do {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 		spin_lock_irqsave(pHba->host->host_lock, flags);
+#else
+		spin_lock_irqsave(&io_request_lock, flags);
+#endif
 		// This state stops any new commands from enterring the
 		// controller while processing the ioctl
 //		pHba->state |= DPTI_STATE_IOCTL;
@@ -1704,7 +2076,11 @@
 //		the queue empties and stops.  We need a way to restart the queue
 		rcode = adpt_i2o_post_wait(pHba, msg, size, FOREVER);
 //		pHba->state &= ~DPTI_STATE_IOCTL;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 		spin_unlock_irqrestore(pHba->host->host_lock, flags);
+#else
+		spin_unlock_irqrestore(&io_request_lock, flags);
+#endif
 	} while(rcode == -ETIMEDOUT);  
 
 	if(rcode){
@@ -1741,8 +2117,8 @@
 			if(! (sg[j].flag_count & 0x4000000 /*I2O_SGL_FLAGS_DIR*/)) {
 				sg_size = sg[j].flag_count & 0xffffff; 
 				// TODO 64bit fix
-				if (copy_to_user((void*)sg[j].addr_bus,(void*)sg_list[j], sg_size)) {
-					printk(KERN_WARNING"%s: Could not copy %lx TO user %x\n",pHba->name, sg_list[j], sg[j].addr_bus);
+				if (copy_to_user((void*)sg[j].addr_bus,sg_list[j], sg_size)) {
+					printk(KERN_WARNING"%s: Could not copy %p TO user %x\n",pHba->name, sg_list[j], sg[j].addr_bus);
 					rcode = -EFAULT;
 					goto cleanup;
 				}
@@ -1765,10 +2141,13 @@
 
 
 cleanup:
-	kfree (reply);
-	while(sg_index) {
-		if(sg_list[--sg_index]) {
-			kfree((void*)(sg_list[sg_index]));
+	if (rcode != -ETIME && rcode != -EINTR) {
+		struct sg_simple_element *sg =  (struct sg_simple_element*) (msg+sg_offset);
+		kfree (reply);
+		while(sg_index) {
+			if(sg_list[--sg_index]) {
+				pci_free_consistent(pHba->pDev, sg[sg_index].flag_count & 0xffffff, sg_list[sg_index], le32_to_cpu(sg[sg_index].addr_bus));
+			}
 		}
 	}
 	return rcode;
@@ -1796,11 +2175,11 @@
 
 #if defined __i386__ 
 	adpt_i386_info(&si);
-#elif defined (__ia64__)
+#elif defined __ia64__
 	adpt_ia64_info(&si);
-#elif defined(__sparc__)
+#elif defined __sparc__
 	adpt_sparc_info(&si);
-#elif defined (__alpha__)
+#elif defined __alpha__ 
 	adpt_alpha_info(&si);
 #else
 	si.processorType = 0xff ;
@@ -1819,7 +2198,7 @@
 	// This is all the info we need for now
 	// We will add more info as our new
 	// managmenent utility requires it
-	si->processorType = PROC_IA64;
+	si->processorType = PROC_ITANIUM;
 }
 #endif
 
@@ -1894,7 +2273,7 @@
 	}
 
 	while((volatile u32) pHba->state & DPTI_STATE_RESET ) {
-		set_task_state(current,TASK_UNINTERRUPTIBLE);
+		set_current_state(TASK_UNINTERRUPTIBLE);
 		schedule_timeout(2);
 
 	}
@@ -1942,13 +2321,51 @@
 		break;
 		}
 	case I2ORESETCMD:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 		spin_lock_irqsave(pHba->host->host_lock, flags);
+#else
+		spin_lock_irqsave(&io_request_lock, flags);
+#endif
 		adpt_hba_reset(pHba);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 		spin_unlock_irqrestore(pHba->host->host_lock, flags);
+#else
+		spin_unlock_irqrestore(&io_request_lock, flags);
+#endif
 		break;
 	case I2ORESCANCMD:
 		adpt_rescan(pHba);
 		break;
+	case DPT_TARGET_BUSY & 0xFFFF:
+	case DPT_TARGET_BUSY:
+	{
+		TARGET_BUSY_T busy;
+		struct adpt_device* d;
+
+		if (copy_from_user((void*)&busy, (void*)arg, sizeof(TARGET_BUSY_T))) {
+			return -EFAULT;
+		}
+
+		d = adpt_find_device(pHba, busy.channel, busy.id, busy.lun);
+		if(d == NULL){
+			return -ENODEV;
+		}
+		busy.isBusy = ((d->pScsi_dev)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+		 && (atomic_read(&d->pScsi_dev->access_count)
+		  || test_bit(SHOST_RECOVERY, &pHba->host->shost_state)));
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+		 && (d->pScsi_dev->device_busy /* Imperfect */
+		  || test_bit(SHOST_RECOVERY, &pHba->host->shost_state)));
+#else
+		 && (d->pScsi_dev->access_count
+		  || pHba->host->in_recovery));
+#endif
+		if (copy_to_user ((char*)arg, &busy, sizeof(busy))) {
+			return -EFAULT;
+		}
+		break;
+	}
 	default:
 		return -EINVAL;
 	}
@@ -1956,77 +2373,145 @@
 	return error;
 }
 
+static inline Scsi_Cmnd * adpt_cmd_from_context(adpt_hba * pHba, u32 context)
+{
+	Scsi_Cmnd * cmd;
 
-static void adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
+	if (context == 0)
+		return NULL;
+	if (sizeof(cmd) > sizeof(u32)) {
+		Scsi_Device * d;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+# if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+		shost_for_each_device(d, pHba->host) {
+# else
+		list_for_each_entry(d, &pHba->host->my_devices, siblings) {
+# endif
+			unsigned long flags;
+			spin_lock_irqsave(&d->list_lock, flags);
+			list_for_each_entry(cmd, &d->cmd_list, list) {
+				if (((u32)cmd->serial_number == context)
+				 || ((u32)cmd->serial_number_at_timeout == context)) {
+					spin_unlock_irqrestore(&d->list_lock, flags);
+					return cmd;
+				}
+			}
+			spin_unlock_irqrestore(&d->list_lock, flags);
+		}
+#else
+		d = pHba->host->host_queue;
+		while (d) {
+			for (cmd = d->device_queue; cmd ; cmd = cmd->next)
+				if (((u32)cmd->serial_number == context)
+				 || ((u32)cmd->serial_number_at_timeout == context))
+					return cmd;
+			d = d->next;
+		}
+#endif
+	} else
+		return (Scsi_Cmnd*)(unsigned long)context; /* 64 bit! */
+	return NULL;
+}
+
+static irqreturn_t adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
 {
 	Scsi_Cmnd* cmd;
 	adpt_hba* pHba = dev_id;
 	u32 m;
-	ulong reply;
+	u8 * reply = (u8 *)-1L;
 	u32 status=0;
 	u32 context;
 	ulong flags = 0;
 
 	if (pHba == NULL ){
 		printk(KERN_WARNING"adpt_isr: NULL dev_id\n");
-		return;
+		return IRQ_NONE;
 	}
-	spin_lock_irqsave(pHba->host->host_lock, flags);
-	while( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+	if (pHba->host != NULL) /* Sad */
+		spin_lock_irqsave(pHba->host->host_lock, flags);
+#else
+	spin_lock_irqsave(&io_request_lock, flags);
+#endif
+	while( readl(pHba->irq_mask) & cpu_to_le32(I2O_INTERRUPT_PENDING_B)) {
 		m = readl(pHba->reply_port);
-		if(m == EMPTY_QUEUE){
+		if(m == cpu_to_le32(EMPTY_QUEUE)){
 			// Try twice then give up
 			rmb();
 			m = readl(pHba->reply_port);
-			if(m == EMPTY_QUEUE){ 
+			if(m == cpu_to_le32(EMPTY_QUEUE)){ 
 				// This really should not happen
 				printk(KERN_ERR"dpti: Could not get reply frame\n");
 				goto out;
 			}
 		}
-		reply = (ulong)bus_to_virt(m);
+		if ((pHba->reply_pool_pa <= le32_to_cpu(m))
+		 && (le32_to_cpu(m) < (pHba->reply_pool_pa + (pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4)))) {
+			reply = ((u8 *)pHba->reply_pool_va) + (le32_to_cpu(m) - pHba->reply_pool_pa);
+		} else {
+			/* Ick, we should *never* be here */
+			printk(KERN_ERR"dpti: replay frame not from pool\n");
+			reply = (u8 *)bus_to_virt(le32_to_cpu(m));
+		}
 
-		if (readl(reply) & MSG_FAIL) {
+		if (readl(reply) & cpu_to_le32(MSG_FAIL)) {
 			u32 old_m = readl(reply+28); 
-			ulong msg;
+			char * msg;
 			u32 old_context;
 			PDEBUG("%s: Failed message\n",pHba->name);
-			if(old_m >= 0x100000){
+			if(le32_to_cpu(old_m) >= 0x100000){
 				printk(KERN_ERR"%s: Bad preserved MFA (%x)- dropping frame\n",pHba->name,old_m);
 				writel(m,pHba->reply_port);
 				continue;
 			}
 			// Transaction context is 0 in failed reply frame
-			msg = (ulong)(pHba->msg_addr_virt + old_m);
+			msg = pHba->msg_addr_virt + le32_to_cpu(old_m);
 			old_context = readl(msg+12);
 			writel(old_context, reply+12);
 			adpt_send_nop(pHba, old_m);
 		} 
 		context = readl(reply+8);
 		if(context & 0x40000000){ // IOCTL
-			ulong p = (ulong)(readl(reply+12));
+			u32 context = readl(reply+12);
+			void * p;
+			if (sizeof(reply) > sizeof(u32)) {
+				p = pHba->ioctl_reply_context[context];
+				pHba->ioctl_reply_context[context] = NULL;
+			} else
+				p = (void *)(unsigned long)(readl(reply+12));
 			if( p != 0) {
-				memcpy((void*)p, (void*)reply, REPLY_FRAME_SIZE * 4);
+				memcpy_fromio(p, (void*)reply, REPLY_FRAME_SIZE * 4);
 			}
 			// All IOCTLs will also be post wait
 		}
 		if(context & 0x80000000){ // Post wait message
-			status = readl(reply+16);
+			status = le32_to_cpu(readl(reply+16));
 			if(status  >> 24){
 				status &=  0xffff; /* Get detail status */
 			} else {
 				status = I2O_POST_WAIT_OK;
 			}
 			if(!(context & 0x40000000)) {
-				cmd = (Scsi_Cmnd*) readl(reply+12); 
+				cmd = adpt_cmd_from_context (pHba, readl(reply+12));
 				if(cmd != NULL) {
 					printk(KERN_WARNING"%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n", pHba->name, cmd, context);
 				}
 			}
 			adpt_i2o_post_wait_complete(context, status);
 		} else { // SCSI message
-			cmd = (Scsi_Cmnd*) readl(reply+12); 
+			cmd = adpt_cmd_from_context (pHba, readl(reply+12));
 			if(cmd != NULL){
+				if(cmd->use_sg)
+					pci_unmap_sg(pHba->pDev,
+					  (struct scatterlist *)cmd->buffer,
+					  cmd->use_sg,
+					  scsi_to_pci_dma_dir(cmd->sc_data_direction));
+				else if(cmd->request_bufflen)
+					pci_unmap_single(pHba->pDev,
+					  cmd->SCp.dma_handle,
+					  cmd->request_bufflen,
+					  scsi_to_pci_dma_dir(cmd->sc_data_direction));
+
 				if(cmd->serial_number != 0) { // If not timedout
 					adpt_i2o_to_scsi(reply, cmd);
 				}
@@ -2036,8 +2521,28 @@
 		wmb();
 		rmb();
 	}
-out:	spin_unlock_irqrestore(pHba->host->host_lock, flags);
+out:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+	if (pHba->host != NULL) /* Sad */
+		spin_unlock_irqrestore(pHba->host->host_lock, flags);
+#else
+	spin_unlock_irqrestore(&io_request_lock, flags);
+#endif
+	if (reply == (u8 *)-1) {
+		return IRQ_NONE;
+	}
+	return IRQ_HANDLED;
+
 }
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+/*
+ * dpti2oscsi2.c contains a table of scsi commands that is used to determine
+ * the data direction of the command.  It is used in dpt_scsi_to_i2o to speed
+ * up the building of the scsi message.
+ */
+#include "dpti2oscsi2.c"
+#endif
+
 
 static s32 adpt_scsi_to_i2o(adpt_hba* pHba, Scsi_Cmnd* cmd, struct adpt_device* d)
 {
@@ -2051,6 +2556,10 @@
 	u32 reqlen;
 	s32 rcode;
 
+#if 0
+printk (KERN_INFO"adpt_scsi_to_i2o(%p,%p,%p)\n", pHba, cmd, d);
+adpt_sleep();
+#endif
 	memset(msg, 0 , sizeof(msg));
 	len = cmd->request_bufflen;
 	direction = 0x00000000;	
@@ -2063,6 +2572,34 @@
 		 * Note:  Do not have to verify index is less than 0 since
 		 * cmd->cmnd[0] is an unsigned char
 		 */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+		if (cmd->cmnd[0] < DISKXFERTBLSIZE) {
+			switch (i2oscsi2diskxfer[cmd->cmnd[0]]) {
+			case DATAIN:
+				scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+				break;
+			case DATAOUT:
+				direction=0x04000000;	// SGL OUT
+				scsidir  =0x80000000;	// DATA OUT (iop-->dev)
+				break;
+			case NODATA:
+				break;
+			case NOSUPPORT:
+				scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+				// Assume In - and continue;
+				break;
+			default:
+				printk(KERN_WARNING"%s: scsi opcode 0x%x not supported.\n",
+				     pHba->name, cmd->cmnd[0]);
+				cmd->result = (DID_OK <<16) | (INITIATOR_ERROR << 8);
+				cmd->scsi_done(cmd);
+				return 	0;
+			}
+		} else {
+			printk(KERN_WARNING"%s: cmd->cmnd[0] = %d is greater than table size, which is %d\n",
+			     pHba->name, cmd->cmnd[0], DISKXFERTBLSIZE);
+		}
+#else
 		switch(cmd->sc_data_direction){
 		case SCSI_DATA_READ:
 			scsidir  =0x40000000;	// DATA IN  (iop<--dev)
@@ -2084,21 +2621,25 @@
 			cmd->scsi_done(cmd);
 			return 	0;
 		}
+#endif
 	}
 	// msg[0] is set later
 	// I2O_CMD_SCSI_EXEC
-	msg[1] = ((0xff<<24)|(HOST_TID<<12)|d->tid);
+	msg[1] = cpu_to_le32((0xff<<24)|(HOST_TID<<12)|d->tid);
 	msg[2] = 0;
-	msg[3] = (u32)cmd;	/* We want the SCSI control block back */
+	if (sizeof(cmd) > sizeof(u32))
+		msg[3] = (u32)cmd->serial_number;
+	else
+		msg[3] = (u32)(unsigned long)cmd;	/* EVIL 64 bit We want the SCSI control block back */
 	// Our cards use the transaction context as the tag for queueing
 	// Adaptec/DPT Private stuff 
-	msg[4] = I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16);
-	msg[5] = d->tid;
+	msg[4] = cpu_to_le32(I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16));
+	msg[5] = cpu_to_le32(d->tid);
 	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
 	// I2O_SCB_FLAG_ENABLE_DISCONNECT | 
 	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 
 	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
-	msg[6] = scsidir|0x20a00000|cmd->cmd_len;
+	msg[6] = cpu_to_le32(scsidir|0x20a00000|cmd->cmd_len);
 
 	mptr=msg+7;
 
@@ -2108,37 +2649,102 @@
 	mptr+=4;
 	lenptr=mptr++;		/* Remember me - fill in when we know */
 	reqlen = 14;		// SINGLE SGE
+	/* The following test gets optimized out if dma_addr_t is <= 32 bits */
+	if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support)) {
+		*mptr++ = cpu_to_le32((0x7C<<24)+(2<<16)+0x02); /* Enable 64 bit */
+		*mptr++ = cpu_to_le32(1 << PAGE_SHIFT);
+		reqlen += 2;
+	}
 	/* Now fill in the SGList and command */
 	if(cmd->use_sg) {
 		struct scatterlist *sg = (struct scatterlist *)cmd->request_buffer;
+		int sg_count = pci_map_sg(pHba->pDev, sg, cmd->use_sg,
+		  scsi_to_pci_dma_dir(cmd->sc_data_direction));
 		len = 0;
-		for(i = 0 ; i < cmd->use_sg; i++) {
-			*mptr++ = direction|0x10000000|sg->length;
-			len+=sg->length;
-			*mptr++ = virt_to_bus(sg->address);
-			sg++;
+		if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support)) {
+			for(i = 0 ; i < sg_count; i++) {
+				dma_addr_t addr;
+				*mptr++ = cpu_to_le32(direction|0x10000000|sg_dma_len(sg));
+				len+=sg_dma_len(sg);
+				addr = sg_dma_address(sg);
+				*mptr++ = cpu_to_le32(addr);
+				*mptr++ = cpu_to_le32((u64)addr >> 32);
+				sg++;
+			}
+			/* Make this an end of list */
+			mptr[-3] = cpu_to_le32(direction|0xD0000000|sg_dma_len(sg-1));
+#if 0
+reqlen = mptr - msg;
+*lenptr = cpu_to_le32(len);
+msg[0] = cpu_to_le32(reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0));
+printk(KERN_INFO"Message64=");
+{int i;
+for (i=0; i<reqlen; ++i)
+printk("%c%08x", (i?' ':'{'), msg[i]);
+}
+printk("}\n");
+adpt_sleep();
+#endif
+		} else {
+			for(i = 0 ; i < sg_count; i++) {
+				*mptr++ = cpu_to_le32(direction|0x10000000|sg_dma_len(sg));
+				len+=sg_dma_len(sg);
+				*mptr++ = cpu_to_le32(sg_dma_address(sg));
+				sg++;
+			}
+			/* Make this an end of list */
+			mptr[-2] = cpu_to_le32(direction|0xD0000000|sg_dma_len(sg-1));
+#if 0
+reqlen = mptr - msg;
+*lenptr = cpu_to_le32(len);
+msg[0] = cpu_to_le32(reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0));
+printk(KERN_INFO"Message32=");
+{int i;
+for (i=0; i<reqlen; ++i)
+printk("%c%08x", (i?' ':'{'), msg[i]);
+}
+printk("}\n");
+adpt_sleep();
+#endif
 		}
-		/* Make this an end of list */
-		mptr[-2] = direction|0xD0000000|(sg-1)->length;
 		reqlen = mptr - msg;
-		*lenptr = len;
+		*lenptr = cpu_to_le32(len);
 		
 		if(cmd->underflow && len != cmd->underflow){
 			printk(KERN_WARNING"Cmd len %08X Cmd underflow %08X\n",
 				len, cmd->underflow);
 		}
 	} else {
-		*lenptr = len = cmd->request_bufflen;
+		len = cmd->request_bufflen;
+
+		*lenptr = cpu_to_le32(len);
 		if(len == 0) {
 			reqlen = 12;
 		} else {
-			*mptr++ = 0xD0000000|direction|cmd->request_bufflen;
-			*mptr++ = virt_to_bus(cmd->request_buffer);
-		}
+			*mptr++ = cpu_to_le32(0xD0000000|direction|cmd->request_bufflen);
+			cmd->SCp.dma_handle = pci_map_single(pHba->pDev,
+			  cmd->request_buffer,
+			  len, scsi_to_pci_dma_dir(cmd->sc_data_direction));
+			*mptr++ = cpu_to_le32(cmd->SCp.dma_handle);
+			if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support)) {
+				*mptr++ = cpu_to_le32((u64)cmd->SCp.dma_handle >> 32);
+				++reqlen;
+			}
+		}
+#if 0
+msg[0] = cpu_to_le32(reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0));
+printk(KERN_INFO"Message=");
+{int i;
+for (i=0; i<reqlen; ++i)
+printk("%c%08x", (i?' ':'{'), msg[i]);
+}
+printk("}\n");
+adpt_sleep();
+#endif
 	}
 	
 	/* Stick the headers on */
-	msg[0] = reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0);
+	msg[0] = cpu_to_le32(reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0));
 	
 	// Send it on it's way
 	rcode = adpt_i2o_post_this(pHba, msg, reqlen<<2);
@@ -2161,6 +2767,21 @@
 	(adpt_hba*)(host->hostdata[0]) = pHba;
 	pHba->host = host;
 
+	/*
+	 *      Only enable PAE mode if the dma_addr_t is larger than
+	 * 32 bit addressing, and we have more than 32 bit addressing
+	 * worth of memory.
+	 */
+	if( (sizeof(dma_addr_t) > 4)
+	 && (num_physpages > (0xFFFFFFFFULL >> PAGE_SHIFT))) {
+		pHba->pae_support = 1;
+		pci_set_dma_mask(pHba->pDev, (dma_addr_t)0xFFFFFFFFFFFFFFFFULL);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,18)) && defined(CONFIG_HIGHMEM) && ((LINUX_VERSION_CODE != KERNEL_VERSION(2,4,19)) || defined(CONFIG_HIGHIO))
+#if 1
+		host->highmem_io = 1;
+#endif
+#endif
+	}
 	host->irq = pHba->pDev->irq;
 	/* no IO ports, so don't have to set host->io_port and 
 	 * host->n_io_port
@@ -2171,30 +2792,40 @@
 	host->max_id = 16;
 	host->max_lun = 256;
 	host->max_channel = pHba->top_scsi_channel + 1;
-	host->cmd_per_lun = 1;
-	host->unique_id = (uint) pHba;
+	host->cmd_per_lun = 256;
+	host->unique_id = (uint)(unsigned long)pHba; /* 64 bit */
 	host->sg_tablesize = pHba->sg_tablesize;
 	host->can_queue = pHba->post_fifo_size;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+	scsi_set_device(host, &pHba->pDev->dev);
+#else
+	scsi_set_pci_device(host, pHba->pDev);
+#endif
 
 	return 0;
 }
 
 
-static s32 adpt_i2o_to_scsi(ulong reply, Scsi_Cmnd* cmd)
+static s32 adpt_i2o_to_scsi(u8 * reply, Scsi_Cmnd* cmd)
 {
 	adpt_hba* pHba;
 	u32 hba_status;
 	u32 dev_status;
-	u32 reply_flags = readl(reply) & 0xff00; // Leave it shifted up 8 bits 
+	u32 reply_flags = le32_to_cpu(readl(reply)) & 0xff00; // Leave it shifted up 8 bits 
 	// I know this would look cleaner if I just read bytes
 	// but the model I have been using for all the rest of the
 	// io is in 4 byte words - so I keep that model
-	u16 detailed_status = readl(reply+16) &0xffff;
+	u16 detailed_status = le32_to_cpu(readl(reply+16)) &0xffff;
 	dev_status = (detailed_status & 0xff);
 	hba_status = detailed_status >> 8;
+//if (hba_status == 1) {
+// printk ("ReplyFrame=%08x %08x %08x %08x %08x %08x\n", le32_to_cpu(readl(reply)), le32_to_cpu(readl(reply+4)), le32_to_cpu(readl(reply+8)), le32_to_cpu(readl(reply+12)), le32_to_cpu(readl(reply+16)), le32_to_cpu(readl(reply+20)));
+//}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
 	// calculate resid for sg 
-	cmd->resid = cmd->request_bufflen - readl(reply+5);
+	cmd->resid = cmd->request_bufflen - le32_to_cpu(readl(reply+5));
+#endif
 
 	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
 
@@ -2205,7 +2836,7 @@
 		case I2O_SCSI_DSC_SUCCESS:
 			cmd->result = (DID_OK << 16);
 			// handle underflow
-			if(readl(reply+5) < cmd->underflow ) {
+			if(le32_to_cpu(readl(reply+5)) < cmd->underflow ) {
 				cmd->result = (DID_ERROR <<16);
 				printk(KERN_WARNING"%s: SCSI CMD underflow\n",pHba->name);
 			}
@@ -2220,7 +2851,9 @@
 		case I2O_SCSI_DSC_NO_ADAPTER:
 		case I2O_SCSI_DSC_RESOURCE_UNAVAILABLE:
 			printk(KERN_WARNING"%s: SCSI Timeout-Device (%d,%d,%d) hba status=0x%x, dev status=0x%x, cmd=0x%x\n",
-				pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun, hba_status, dev_status, cmd->cmnd[0]);
+				pHba->name,
+				(u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
+				hba_status, dev_status, cmd->cmnd[0]);
 			cmd->result = (DID_TIME_OUT << 16);
 			break;
 		case I2O_SCSI_DSC_ADAPTER_BUSY:
@@ -2260,7 +2893,8 @@
 		case I2O_SCSI_DSC_REQUEST_INVALID:
 		default:
 			printk(KERN_WARNING"%s: SCSI error %0x-Device(%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
-				pHba->name, detailed_status & I2O_SCSI_DSC_MASK, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
+				pHba->name, detailed_status & I2O_SCSI_DSC_MASK,
+				(u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
 			       hba_status, dev_status, cmd->cmnd[0]);
 			cmd->result = (DID_ERROR << 16);
 			break;
@@ -2272,13 +2906,14 @@
 			u32 len = sizeof(cmd->sense_buffer);
 			len = (len > 40) ?  40 : len;
 			// Copy over the sense data
-			memcpy(cmd->sense_buffer, (void*)(reply+28) , len);
+			memcpy_fromio(cmd->sense_buffer, (void*)(reply+28) , len);
 			if(cmd->sense_buffer[0] == 0x70 /* class 7 */ && 
 			   cmd->sense_buffer[2] == DATA_PROTECT ){
 				/* This is to handle an array failed */
 				cmd->result = (DID_TIME_OUT << 16);
 				printk(KERN_WARNING"%s: SCSI Data Protect-Device (%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
-					pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun, 
+					pHba->name,
+					(u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
 					hba_status, dev_status, cmd->cmnd[0]);
 
 			}
@@ -2290,7 +2925,8 @@
 		 */
 		cmd->result = (DID_TIME_OUT << 16);
 		printk(KERN_WARNING"%s: I2O MSG_FAIL - Device (%d,%d,%d) tid=%d, cmd=0x%x\n",
-			pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
+			pHba->name,
+			(u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
 			((struct adpt_device*)(cmd->device->hostdata))->tid, cmd->cmnd[0]);
 	}
 
@@ -2308,13 +2944,25 @@
 	s32 rcode;
 	ulong flags;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 	spin_lock_irqsave(pHba->host->host_lock, flags);
-	if ((rcode=adpt_i2o_lct_get(pHba)) < 0)
+#else
+	spin_lock_irqsave(&io_request_lock, flags);
+#endif
+	if ((rcode=adpt_i2o_lct_get(pHba)) < 0){
 		goto out;
-	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)
+	}
+
+	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){
 		goto out;
+	}
 	rcode = 0;
-out:	spin_unlock_irqrestore(pHba->host->host_lock, flags);
+out:
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+	spin_unlock_irqrestore(pHba->host->host_lock, flags);
+#else
+	spin_unlock_irqrestore(&io_request_lock, flags);
+#endif
 	return rcode;
 }
 
@@ -2325,7 +2973,7 @@
 	int max;
 	int tid;
 	struct i2o_device *d;
-	i2o_lct *lct = pHba->lct;
+	i2o_lct *lct = pHba->lct_va;
 	u8 bus_no = 0;
 	s16 scsi_id;
 	s16 scsi_lun;
@@ -2354,14 +3002,14 @@
 	printk(KERN_INFO "%s: LCT has %d entries.\n", pHba->name,max);
 	
 	for(i=0;i<max;i++) {
-		if( lct->lct_entry[i].user_tid != 0xfff){
+		if( lct->lct_entry[i].user_tid != cpu_to_le32(0xfff)){
 			continue;
 		}
 
-		if( lct->lct_entry[i].class_id == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
-		    lct->lct_entry[i].class_id == I2O_CLASS_SCSI_PERIPHERAL ||
-		    lct->lct_entry[i].class_id == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
-			tid = lct->lct_entry[i].tid;
+		if( lct->lct_entry[i].class_id == cpu_to_le32(I2O_CLASS_RANDOM_BLOCK_STORAGE) ||
+		    lct->lct_entry[i].class_id == cpu_to_le32(I2O_CLASS_SCSI_PERIPHERAL) ||
+		    lct->lct_entry[i].class_id == cpu_to_le32(I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL) ){
+			tid = le32_to_cpu(lct->lct_entry[i].tid);
 			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
 				printk(KERN_ERR"%s: Could not query device\n",pHba->name);
 				continue;
@@ -2415,7 +3063,7 @@
 					}
 				}
 				memset(pDev,0,sizeof(struct adpt_device));
-				pDev->tid = d->lct_data.tid;
+				pDev->tid = le32_to_cpu(d->lct_data.tid);
 				pDev->scsi_channel = bus_no;
 				pDev->scsi_id = scsi_id;
 				pDev->scsi_lun = scsi_lun;
@@ -2472,6 +3120,17 @@
 			printk(KERN_WARNING"%s: Device (%d,%d,%d) offline\n",pHba->name,pDev->scsi_channel,pDev->scsi_id,pDev->scsi_lun);
 			if (pDev->pScsi_dev) {
 				scsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)) && (LINUX_VERSION_CODE < KERNEL_VERSIO$
+                                if (atomic_read(&pDev->pScsi_dev->access_count)) {
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+                                if (pDev->pScsi_dev->device_busy) {
+#else
+                                if (pDev->pScsi_dev->access_count) {
+#endif
+#ifdef SCSI_LOG_ERROR_RECOVERY
+					 SCSI_LOG_ERROR_RECOVERY(1, printk ("%s:Rescan: Previously "
+								"mounted drive not found!\n",pHba->name));
+				}
 			}
 		}
 	}
@@ -2524,17 +3183,17 @@
 			}
 		}
 
-		if(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {
+		if(pHba->status_block_va->iop_state == cpu_to_le32(ADAPTER_STATE_FAULTED)) {
 			printk(KERN_CRIT "%s: hardware fault\n", pHba->name);
 			return -1;
 		}
 
-		if (pHba->status_block->iop_state == ADAPTER_STATE_READY ||
-		    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||
-		    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||
-		    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {
+		if (pHba->status_block_va->iop_state == cpu_to_le32(ADAPTER_STATE_READY) ||
+		    pHba->status_block_va->iop_state == cpu_to_le32(ADAPTER_STATE_OPERATIONAL) ||
+		    pHba->status_block_va->iop_state == cpu_to_le32(ADAPTER_STATE_HOLD) ||
+		    pHba->status_block_va->iop_state == cpu_to_le32(ADAPTER_STATE_FAILED)) {
 			adpt_i2o_reset_hba(pHba);			
-			if (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
+			if (adpt_i2o_status_get(pHba) < 0 || pHba->status_block_va->iop_state != cpu_to_le32(ADAPTER_STATE_RESET)) {
 				printk(KERN_ERR "%s: Failed to initialize.\n", pHba->name);
 				return -1;
 			}
@@ -2586,10 +3245,10 @@
 	u32 *msg;
 	ulong timeout = jiffies + 5*HZ;
 
-	while(m == EMPTY_QUEUE){
+	while(m == cpu_to_le32(EMPTY_QUEUE)){
 		rmb();
 		m = readl(pHba->post_port);
-		if(m != EMPTY_QUEUE){
+		if(m != cpu_to_le32(EMPTY_QUEUE)){
 			break;
 		}
 		if(time_after(jiffies,timeout)){
@@ -2597,9 +3256,9 @@
 			return 2;
 		}
 	}
-	msg = (u32*)(pHba->msg_addr_virt + m);
-	writel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);
-	writel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);
+	msg = (u32*)(pHba->msg_addr_virt + le32_to_cpu(m));
+	writel( cpu_to_le32(THREE_WORD_MSG_SIZE | SGL_OFFSET_0),&msg[0]);
+	writel( cpu_to_le32(I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0),&msg[1]);
 	writel( 0,&msg[2]);
 	wmb();
 
@@ -2611,17 +3270,16 @@
 static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 {
 	u8 *status;
+	dma_addr_t addr;
 	u32 *msg = NULL;
 	int i;
 	ulong timeout = jiffies + TMOUT_INITOUTBOUND*HZ;
-	u32* ptr;
-	u32 outbound_frame;  // This had to be a 32 bit address
 	u32 m;
 
 	do {
 		rmb();
 		m = readl(pHba->post_port);
-		if (m != EMPTY_QUEUE) {
+		if (m != cpu_to_le32(EMPTY_QUEUE)) {
 			break;
 		}
 
@@ -2629,27 +3287,34 @@
 			printk(KERN_WARNING"%s: Timeout waiting for message frame\n",pHba->name);
 			return -ETIMEDOUT;
 		}
-	} while(m == EMPTY_QUEUE);
+	} while(m == cpu_to_le32(EMPTY_QUEUE));
 
-	msg=(u32 *)(pHba->msg_addr_virt+m);
+	msg=(u32 *)(pHba->msg_addr_virt+le32_to_cpu(m));
 
-	status = kmalloc(4,GFP_KERNEL|ADDR32);
+	status = (u8*)pci_alloc_consistent(pHba->pDev, 4, &addr);
 	if (status==NULL) {
 		adpt_send_nop(pHba, m);
 		printk(KERN_WARNING"%s: IOP reset failed - no free memory.\n",
 			pHba->name);
 		return -ENOMEM;
 	}
+	if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support) && (((u64)addr >> 32) != 0) ) {
+		pci_free_consistent(pHba->pDev, 4, status, addr);
+		adpt_send_nop(pHba, m);
+		printk(KERN_WARNING"%s: IOP reset failed - no free memory.\n",
+			pHba->name);
+		return -ENOMEM;
+	}
 	memset(status, 0, 4);
 
-	writel(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6, &msg[0]);
-	writel(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID, &msg[1]);
+	writel( cpu_to_le32(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6), &msg[0]);
+	writel( cpu_to_le32(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID), &msg[1]);
 	writel(0, &msg[2]);
 	writel(0x0106, &msg[3]);	/* Transaction context */
-	writel(4096, &msg[4]);		/* Host page frame size */
-	writel((REPLY_FRAME_SIZE)<<16|0x80, &msg[5]);	/* Outbound msg frame size and Initcode */
-	writel(0xD0000004, &msg[6]);		/* Simple SG LE, EOB */
-	writel(virt_to_bus(status), &msg[7]);
+	writel( cpu_to_le32(4096), &msg[4]);		/* Host page frame size */
+	writel( cpu_to_le32((REPLY_FRAME_SIZE)<<16|0x80), &msg[5]);	/* Outbound msg frame size and Initcode */
+	writel( cpu_to_le32(0xD0000004), &msg[6]);		/* Simple SG LE, EOB */
+	writel( cpu_to_le32(addr), &msg[7]);
 
 	writel(m, pHba->post_port);
 	wmb();
@@ -2664,36 +3329,42 @@
 		rmb();
 		if(time_after(jiffies,timeout)){
 			printk(KERN_WARNING"%s: Timeout Initializing\n",pHba->name);
-			kfree((void*)status);
+			/* We loose 4 bytes of "status" here, but we
+			   cannot free these because controller may
+			   awake and corrupt those bytes at any time */
+			/* pci_free_consistent(pHba->pDev, 4, status, addr); */
 			return -ETIMEDOUT;
 		}
 	} while (1);
 
 	// If the command was successful, fill the fifo with our reply
 	// message packets
-	if(*status != 0x04 /*I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {
-		kfree((void*)status);
+	if(*status != le32_to_cpu(0x04) /*I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {
+		pci_free_consistent(pHba->pDev, 4, status, addr);
 		return -2;
 	}
-	kfree((void*)status);
+	pci_free_consistent(pHba->pDev, 4, status, addr);
 
-	if(pHba->reply_pool != NULL){
-		kfree(pHba->reply_pool);
+	if(pHba->reply_pool_va != NULL){
+		pci_free_consistent(pHba->pDev, pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, pHba->reply_pool_va, pHba->reply_pool_pa);
 	}
 
-	pHba->reply_pool = (u32*)kmalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
-	if(!pHba->reply_pool){
+	pHba->reply_pool_va = (u32*)pci_alloc_consistent(pHba->pDev, pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, &pHba->reply_pool_pa);
+	if(!pHba->reply_pool_va){
 		printk(KERN_ERR"%s: Could not allocate reply pool\n",pHba->name);
 		return -1;
 	}
-	memset(pHba->reply_pool, 0 , pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4);
+	if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support) && (((u64)pHba->reply_pool_pa >> 32) != 0) ) {
+		pci_free_consistent(pHba->pDev, pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, pHba->reply_pool_va, pHba->reply_pool_pa);
+		pHba->reply_pool_va = NULL;
+		printk(KERN_ERR"%s: Could not allocate reply pool in 32 bit space\n",pHba->name);
+		return -1;
+	}
+	memset(pHba->reply_pool_va, 0 , pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4);
 
-	ptr = pHba->reply_pool;
 	for(i = 0; i < pHba->reply_fifo_size; i++) {
-		outbound_frame = (u32)virt_to_bus(ptr);
-		writel(outbound_frame, pHba->reply_port);
+		writel(cpu_to_le32(pHba->reply_pool_pa + (i * REPLY_FRAME_SIZE * 4)), pHba->reply_port);
 		wmb();
-		ptr +=  REPLY_FRAME_SIZE;
 	}
 	adpt_i2o_status_get(pHba);
 	return 0;
@@ -2717,26 +3388,26 @@
 	u32 m;
 	u32 *msg;
 	u8 *status_block=NULL;
-	ulong status_block_bus;
+	u64 status_block_pa;
 
-	if(pHba->status_block == NULL) {
-		pHba->status_block = (i2o_status_block*)
-			kmalloc(sizeof(i2o_status_block),GFP_KERNEL|ADDR32);
-		if(pHba->status_block == NULL) {
+	if(pHba->status_block_va == NULL) {
+		pHba->status_block_va = (i2o_status_block*)
+		  pci_alloc_consistent(pHba->pDev, sizeof(i2o_status_block),
+		    &pHba->status_block_pa);
+		if(pHba->status_block_va == NULL) {
 			printk(KERN_ERR
 			"dpti%d: Get Status Block failed; Out of memory. \n", 
 			pHba->unit);
 			return -ENOMEM;
 		}
 	}
-	memset(pHba->status_block, 0, sizeof(i2o_status_block));
-	status_block = (u8*)(pHba->status_block);
-	status_block_bus = virt_to_bus(pHba->status_block);
+	memset(pHba->status_block_va, 0, sizeof(i2o_status_block));
+	status_block = (u8*)(pHba->status_block_va);
 	timeout = jiffies+TMOUT_GETSTATUS*HZ;
 	do {
 		rmb();
 		m = readl(pHba->post_port);
-		if (m != EMPTY_QUEUE) {
+		if (m != cpu_to_le32(EMPTY_QUEUE)) {
 			break;
 		}
 		if(time_after(jiffies,timeout)){
@@ -2744,20 +3415,21 @@
 					pHba->name);
 			return -ETIMEDOUT;
 		}
-	} while(m==EMPTY_QUEUE);
+	} while(m==cpu_to_le32(EMPTY_QUEUE));
 
 	
-	msg=(u32*)(pHba->msg_addr_virt+m);
+	msg=(u32*)(pHba->msg_addr_virt+le32_to_cpu(m));
 
-	writel(NINE_WORD_MSG_SIZE|SGL_OFFSET_0, &msg[0]);
-	writel(I2O_CMD_STATUS_GET<<24|HOST_TID<<12|ADAPTER_TID, &msg[1]);
-	writel(1, &msg[2]);
+	writel( cpu_to_le32(NINE_WORD_MSG_SIZE|SGL_OFFSET_0), &msg[0]);
+	writel( cpu_to_le32(I2O_CMD_STATUS_GET<<24|HOST_TID<<12|ADAPTER_TID), &msg[1]);
+	writel( cpu_to_le32(1), &msg[2]);
 	writel(0, &msg[3]);
 	writel(0, &msg[4]);
 	writel(0, &msg[5]);
-	writel(((u32)status_block_bus)&0xffffffff, &msg[6]);
-	writel(0, &msg[7]);
-	writel(sizeof(i2o_status_block), &msg[8]); // 88 bytes
+	status_block_pa = cpu_to_le64(pHba->status_block_pa);
+	writel( (u32)status_block_pa, &msg[6]);
+	writel( (u32)(status_block_pa >> 32), &msg[7]);
+	writel( cpu_to_le32(sizeof(i2o_status_block)), &msg[8]); // 88 bytes
 
 	//post message
 	writel(m, pHba->post_port);
@@ -2773,18 +3445,25 @@
 	}
 
 	// Set up our number of outbound and inbound messages
-	pHba->post_fifo_size = pHba->status_block->max_inbound_frames;
+	pHba->post_fifo_size = le32_to_cpu(pHba->status_block_va->max_inbound_frames);
 	if (pHba->post_fifo_size > MAX_TO_IOP_MESSAGES) {
 		pHba->post_fifo_size = MAX_TO_IOP_MESSAGES;
 	}
 
-	pHba->reply_fifo_size = pHba->status_block->max_outbound_frames;
+	pHba->reply_fifo_size = le32_to_cpu(pHba->status_block_va->max_outbound_frames);
 	if (pHba->reply_fifo_size > MAX_FROM_IOP_MESSAGES) {
 		pHba->reply_fifo_size = MAX_FROM_IOP_MESSAGES;
 	}
 
 	// Calculate the Scatter Gather list size
-	pHba->sg_tablesize = (pHba->status_block->inbound_frame_size * 4 -40)/ sizeof(struct sg_simple_element);
+	pHba->sg_tablesize = (le32_to_cpu(pHba->status_block_va->inbound_frame_size) * 4 - 12 * sizeof(u32))/ sizeof(struct sg_simple_element);
+	if( (sizeof(dma_addr_t) > 4)
+	 && (num_physpages > (0xFFFFFFFFULL >> PAGE_SHIFT))) {
+		pHba->sg_tablesize
+		  = (le32_to_cpu(pHba->status_block_va->inbound_frame_size) * 4
+		  - 14 * sizeof(u32))
+		  / (sizeof(struct sg_simple_element) + sizeof(u32));
+	}
 	if (pHba->sg_tablesize > SG_LIST_ELEMENTS) {
 		pHba->sg_tablesize = SG_LIST_ELEMENTS;
 	}
@@ -2792,7 +3471,7 @@
 
 #ifdef DEBUG
 	printk("dpti%d: State = ",pHba->unit);
-	switch(pHba->status_block->iop_state) {
+	switch(le32_to_cpu(pHba->status_block_va->iop_state)) {
 		case 0x01:
 			printk("INIT\n");
 			break;
@@ -2815,7 +3494,7 @@
 			printk("FAULTED\n");
 			break;
 		default:
-			printk("%x (unknown!!)\n",pHba->status_block->iop_state);
+			printk("%x (unknown!!)\n",le32_to_cpu(pHba->status_block_va->iop_state));
 	}
 #endif
 	return 0;
@@ -2830,28 +3509,35 @@
 	int ret;
 	u32 buf[16];
 
-	if ((pHba->lct_size == 0) || (pHba->lct == NULL)){
-		pHba->lct_size = pHba->status_block->expected_lct_size;
+	if ((pHba->lct_size == 0) || (pHba->lct_va == NULL)){
+		pHba->lct_size = le32_to_cpu(pHba->status_block_va->expected_lct_size);
 	}
 	do {
-		if (pHba->lct == NULL) {
-			pHba->lct = kmalloc(pHba->lct_size, GFP_KERNEL|ADDR32);
-			if(pHba->lct == NULL) {
+		if (pHba->lct_va == NULL) {
+			pHba->lct_va = pci_alloc_consistent(pHba->pDev, pHba->lct_size, &pHba->lct_pa);
+			if(pHba->lct_va == NULL) {
 				printk(KERN_CRIT "%s: Lct Get failed. Out of memory.\n",
 					pHba->name);
 				return -ENOMEM;
 			}
+			if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support) && (((u64)pHba->lct_pa >> 32) != 0) ) {
+				pci_free_consistent(pHba->pDev, pHba->lct_size, pHba->lct_va, pHba->lct_pa);
+				pHba->lct_va = NULL;
+				printk(KERN_CRIT "%s: Lct Get failed. Out of 32 bit memory.\n",
+					pHba->name);
+				return -ENOMEM;
+			}
 		}
-		memset(pHba->lct, 0, pHba->lct_size);
+		memset(pHba->lct_va, 0, pHba->lct_size);
 
-		msg[0] = EIGHT_WORD_MSG_SIZE|SGL_OFFSET_6;
-		msg[1] = I2O_CMD_LCT_NOTIFY<<24 | HOST_TID<<12 | ADAPTER_TID;
+		msg[0] = cpu_to_le32(EIGHT_WORD_MSG_SIZE|SGL_OFFSET_6);
+		msg[1] = cpu_to_le32(I2O_CMD_LCT_NOTIFY<<24 | HOST_TID<<12 | ADAPTER_TID);
 		msg[2] = 0;
 		msg[3] = 0;
 		msg[4] = 0xFFFFFFFF;	/* All devices */
 		msg[5] = 0x00000000;	/* Report now */
-		msg[6] = 0xD0000000|pHba->lct_size;
-		msg[7] = virt_to_bus(pHba->lct);
+		msg[6] = cpu_to_le32(0xD0000000|pHba->lct_size);
+		msg[7] = cpu_to_le32(pHba->lct_pa);
 
 		if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 360))) {
 			printk(KERN_ERR "%s: LCT Get failed (status=%#10x.\n", 
@@ -2860,26 +3546,29 @@
 			return ret;
 		}
 
-		if ((pHba->lct->table_size << 2) > pHba->lct_size) {
-			pHba->lct_size = pHba->lct->table_size << 2;
-			kfree(pHba->lct);
-			pHba->lct = NULL;
+		ret = le32_to_cpu(pHba->lct_va->table_size) << 2;
+		if (ret > pHba->lct_size) {
+			pci_free_consistent(pHba->pDev, pHba->lct_size, pHba->lct_va, pHba->lct_pa);
+			pHba->lct_size = ret;
+			pHba->lct_va = NULL;
 		}
-	} while (pHba->lct == NULL);
+	} while (pHba->lct_va == NULL);
 
 	PDEBUG("%s: Hardware resource table read.\n", pHba->name);
 
 
 	// I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO;
 	if(adpt_i2o_query_scalar(pHba, 0 , 0x8000, -1, buf, sizeof(buf))>=0) {
-		pHba->FwDebugBufferSize = buf[1];
-		pHba->FwDebugBuffer_P    = pHba->base_addr_virt + buf[0];
-		pHba->FwDebugFlags_P     = pHba->FwDebugBuffer_P + FW_DEBUG_FLAGS_OFFSET;
-		pHba->FwDebugBLEDvalue_P = pHba->FwDebugBuffer_P + FW_DEBUG_BLED_OFFSET;
-		pHba->FwDebugBLEDflag_P  = pHba->FwDebugBLEDvalue_P + 1;
-		pHba->FwDebugStrLength_P = pHba->FwDebugBuffer_P + FW_DEBUG_STR_LENGTH_OFFSET;
-		pHba->FwDebugBuffer_P += buf[2]; 
-		pHba->FwDebugFlags = 0;
+		pHba->fw_buffer_addr_virt  = pHba->base_addr_virt + buf[0];
+		pHba->bled_value_addr_virt = pHba->fw_buffer_addr_virt + FW_DEBUG_BLED_OFFSET;
+		pHba->bled_flag_addr_virt  = pHba->bled_value_addr_virt + 1; 
+		/* bled fields are both 8 bits, so increment by one is what is desired*/
+#ifdef DEBUG
+		pHba->fw_buffer_size = buf[1];
+		pHba->fw_debug_flags_addr_virt     = pHba->fw_buffer_addr_virt + FW_DEBUG_FLAGS_OFFSET;
+		pHba->fw_string_len_addr_virt = pHba->fw_buffer_addr_virt + FW_DEBUG_STR_LENGTH_OFFSET;
+#endif
+		pHba->fw_buffer_addr_virt += buf[2]; 
 	}
 
 	return 0;
@@ -2887,51 +3576,58 @@
 
 static int adpt_i2o_build_sys_table(void)
 {
-	adpt_hba* pHba = NULL;
+	adpt_hba* pHba = hba_chain;
 	int count = 0;
 
+	if(sys_tbl_va)
+		pci_free_consistent(pHba->pDev, sys_tbl_len, sys_tbl_va, sys_tbl_pa);
 	sys_tbl_len = sizeof(struct i2o_sys_tbl) +	// Header + IOPs
 				(hba_count) * sizeof(struct i2o_sys_tbl_entry);
 
-	if(sys_tbl)
-		kfree(sys_tbl);
-
-	sys_tbl = kmalloc(sys_tbl_len, GFP_KERNEL|ADDR32);
-	if(!sys_tbl) {
+	sys_tbl_va = pci_alloc_consistent(pHba->pDev, sys_tbl_len, &sys_tbl_pa);
+	if(!sys_tbl_va) {
 		printk(KERN_WARNING "SysTab Set failed. Out of memory.\n");	
 		return -ENOMEM;
 	}
-	memset(sys_tbl, 0, sys_tbl_len);
+	if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support) && (((u64)sys_tbl_pa >> 32) != 0) ) {
+		pci_free_consistent(pHba->pDev, sys_tbl_len, sys_tbl_va, sys_tbl_pa);
+		sys_tbl_va = NULL;
+		printk(KERN_WARNING "SysTab Set failed. Out of 32 bit memory.\n");	
+		return -ENOMEM;
+	}
+	memset(sys_tbl_va, 0, sys_tbl_len);
 
-	sys_tbl->num_entries = hba_count;
-	sys_tbl->version = I2OVERSION;
-	sys_tbl->change_ind = sys_tbl_ind++;
+	sys_tbl_va->num_entries = cpu_to_le32(hba_count);
+	sys_tbl_va->version = cpu_to_le32(I2OVERSION);
+	sys_tbl_va->change_ind = cpu_to_le32(sys_tbl_ind++);
 
 	for(pHba = hba_chain; pHba; pHba = pHba->next) {
+		u64 addr;
 		// Get updated Status Block so we have the latest information
 		if (adpt_i2o_status_get(pHba)) {
-			sys_tbl->num_entries--;
+			sys_tbl_va->num_entries = cpu_to_le32(le32_to_cpu(sys_tbl_va->num_entries) - 1);
 			continue; // try next one	
 		}
 
-		sys_tbl->iops[count].org_id = pHba->status_block->org_id;
-		sys_tbl->iops[count].iop_id = pHba->unit + 2;
-		sys_tbl->iops[count].seg_num = 0;
-		sys_tbl->iops[count].i2o_version = pHba->status_block->i2o_version;
-		sys_tbl->iops[count].iop_state = pHba->status_block->iop_state;
-		sys_tbl->iops[count].msg_type = pHba->status_block->msg_type;
-		sys_tbl->iops[count].frame_size = pHba->status_block->inbound_frame_size;
-		sys_tbl->iops[count].last_changed = sys_tbl_ind - 1; // ??
-		sys_tbl->iops[count].iop_capabilities = pHba->status_block->iop_capabilities;
-		sys_tbl->iops[count].inbound_low = (u32)virt_to_bus((void*)pHba->post_port);
-		sys_tbl->iops[count].inbound_high = (u32)((u64)virt_to_bus((void*)pHba->post_port)>>32);
+		sys_tbl_va->iops[count].org_id = pHba->status_block_va->org_id;
+		sys_tbl_va->iops[count].iop_id = cpu_to_le32(pHba->unit + 2);
+		sys_tbl_va->iops[count].seg_num = 0;
+		sys_tbl_va->iops[count].i2o_version = pHba->status_block_va->i2o_version;
+		sys_tbl_va->iops[count].iop_state = pHba->status_block_va->iop_state;
+		sys_tbl_va->iops[count].msg_type = pHba->status_block_va->msg_type;
+		sys_tbl_va->iops[count].frame_size = pHba->status_block_va->inbound_frame_size;
+		sys_tbl_va->iops[count].last_changed = cpu_to_le32(sys_tbl_ind - 1); // ??
+		sys_tbl_va->iops[count].iop_capabilities = pHba->status_block_va->iop_capabilities;
+		addr = cpu_to_le64(pHba->base_addr_phys + 0x40);
+		sys_tbl_va->iops[count].inbound_low = (u32)addr;
+		sys_tbl_va->iops[count].inbound_high = (u32)(addr >> 32);
 
 		count++;
 	}
 
 #ifdef DEBUG
 {
-	u32 *table = (u32*)sys_tbl;
+	u32 *table = (u32*)sys_tbl_va;
 	printk(KERN_DEBUG"sys_tbl_len=%d in 32bit words\n",(sys_tbl_len >>2));
 	for(count = 0; count < (sys_tbl_len >>2); count++) {
 		printk(KERN_INFO "sys_tbl[%d] = %0#10x\n", 
@@ -2951,7 +3647,7 @@
 static void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)
 {
 	char buf[64];
-	int unit = d->lct_data.tid;
+	int unit = le32_to_cpu(d->lct_data.tid);
 
 	printk(KERN_INFO "TID %3.3d ", unit);
 
@@ -2971,17 +3667,17 @@
 		printk(" Rev: %-12.12s\n", buf);
 	}
 #ifdef DEBUG
-	 printk(KERN_INFO "\tClass: %.21s\n", adpt_i2o_get_class_name(d->lct_data.class_id));
-	 printk(KERN_INFO "\tSubclass: 0x%04X\n", d->lct_data.sub_class);
+	 printk(KERN_INFO "\tClass: %.21s\n", adpt_i2o_get_class_name(le32_to_cpu(d->lct_data.class_id)));
+	 printk(KERN_INFO "\tSubclass: 0x%04X\n", le32_to_cpu(d->lct_data.sub_class));
 	 printk(KERN_INFO "\tFlags: ");
 
-	 if(d->lct_data.device_flags&(1<<0))
+	 if(le32_to_cpu(d->lct_data.device_flags)&(1<<0))
 		  printk("C");	     // ConfigDialog requested
-	 if(d->lct_data.device_flags&(1<<1))
+	 if(le32_to_cpu(d->lct_data.device_flags)&(1<<1))
 		  printk("U");	     // Multi-user capable
-	 if(!(d->lct_data.device_flags&(1<<4)))
+	 if(!(le32_to_cpu(d->lct_data.device_flags)&(1<<4)))
 		  printk("P");	     // Peer service enabled!
-	 if(!(d->lct_data.device_flags&(1<<5)))
+	 if(!(le32_to_cpu(d->lct_data.device_flags)&(1<<5)))
 		  printk("M");	     // Mgmt service enabled!
 	 printk("\n");
 #endif
@@ -3056,35 +3752,42 @@
 static s32 adpt_i2o_hrt_get(adpt_hba* pHba)
 {
 	u32 msg[6];
-	int ret, size = sizeof(i2o_hrt);
+	int ret, size = sizeof(i2o_hrt), new_size;
 
 	do {
-		if (pHba->hrt == NULL) {
-			pHba->hrt=kmalloc(size, GFP_KERNEL|ADDR32);
-			if (pHba->hrt == NULL) {
+		if (pHba->hrt_va == NULL) {
+			pHba->hrt_va = pci_alloc_consistent(pHba->pDev, size, &pHba->hrt_pa);
+			if (pHba->hrt_va == NULL) {
 				printk(KERN_CRIT "%s: Hrt Get failed; Out of memory.\n", pHba->name);
 				return -ENOMEM;
 			}
+			if( (sizeof(dma_addr_t) > 4) && (pHba->pae_support) && (((u64)pHba->hrt_pa >> 32) != 0) ) {
+				pci_free_consistent(pHba->pDev, size, pHba->hrt_va, pHba->hrt_pa);
+				pHba->hrt_va = NULL;
+				printk(KERN_CRIT "%s: Hrt Get failed; Out of 32 bit memory.\n", pHba->name);
+				return -ENOMEM;
+			}
 		}
 
-		msg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;
-		msg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;
+		msg[0]= cpu_to_le32(SIX_WORD_MSG_SIZE| SGL_OFFSET_4);
+		msg[1]= cpu_to_le32(I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID);
 		msg[2]= 0;
 		msg[3]= 0;
-		msg[4]= (0xD0000000 | size);    /* Simple transaction */
-		msg[5]= virt_to_bus(pHba->hrt);   /* Dump it here */
+		msg[4]= cpu_to_le32(0xD0000000 | size);    /* Simple transaction */
+		msg[5]= cpu_to_le32(pHba->hrt_pa);   /* Dump it here */
 
 		if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {
 			printk(KERN_ERR "%s: Unable to get HRT (status=%#10x)\n", pHba->name, ret);
 			return ret;
 		}
 
-		if (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {
-			size = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;
-			kfree(pHba->hrt);
-			pHba->hrt = NULL;
+		new_size = le32_to_cpu(pHba->hrt_va->num_entries) * le32_to_cpu(pHba->hrt_va->entry_len) << 2;
+		if (new_size > size) {
+			pci_free_consistent(pHba->pDev, size, pHba->hrt_va, pHba->hrt_pa);
+			size = new_size;
+			pHba->hrt_va = NULL;
 		}
-	} while(pHba->hrt == NULL);
+	} while(pHba->hrt_va == NULL);
 	return 0;
 }                                                                                                                                       
 
@@ -3094,18 +3797,47 @@
 static int adpt_i2o_query_scalar(adpt_hba* pHba, int tid, 
 			int group, int field, void *buf, int buflen)
 {
-	u16 opblk[] = { 1, 0, I2O_PARAMS_FIELD_GET, group, 1, field };
-	u8  resblk[8+buflen]; /* 8 bytes for header */
+	u16 opblk[] = { cpu_to_le16(1), 0, cpu_to_le16(I2O_PARAMS_FIELD_GET), cpu_to_le16(group), cpu_to_le16(1), cpu_to_le16(field) };
+	u8 *opblk_va;
+	dma_addr_t opblk_pa;
+	u8 *resblk_va;
+	dma_addr_t resblk_pa;
 	int size;
 
+	/* 8 bytes for header */
+	resblk_va = pci_alloc_consistent(pHba->pDev, sizeof(u8) * (8 + buflen), &resblk_pa);
+	if (resblk_va == NULL) {
+		printk(KERN_CRIT "%s: query scaler failed; Out of memory.\n", pHba->name);
+		return -ENOMEM;
+	}
+
+	opblk_va = pci_alloc_consistent(pHba->pDev, sizeof(opblk), &opblk_pa);
+	if (opblk_va == NULL) {
+		pci_free_consistent(pHba->pDev, sizeof(u8) * (8+buflen), resblk_va, resblk_pa);
+		printk(KERN_CRIT "%s: query operatio failed; Out of memory.\n", pHba->name);
+		return -ENOMEM;
+	}
+
 	if (field == -1)  		/* whole group */
-			opblk[4] = -1;
+		opblk[4] = -1;
+	memcpy(opblk_va, opblk, sizeof(opblk));
 
 	size = adpt_i2o_issue_params(I2O_CMD_UTIL_PARAMS_GET, pHba, tid, 
-		opblk, sizeof(opblk), resblk, sizeof(resblk));
+		opblk_va, opblk_pa, sizeof(opblk), resblk_va, resblk_pa, sizeof(u8)*(8+buflen));
+	pci_free_consistent(pHba->pDev, sizeof(opblk), opblk_va, opblk_pa);
+	if (size == -ETIME) {
+		pci_free_consistent(pHba->pDev, sizeof(u8) * (8+buflen), resblk_va, resblk_pa);
+		printk(KERN_WARNING "%s: issue params failed; Timed out.\n", pHba->name);
+		return -ETIME;
+	} else if (size == -EINTR) {
+		pci_free_consistent(pHba->pDev, sizeof(u8) * (8+buflen), resblk_va, resblk_pa);
+		printk(KERN_WARNING "%s: issue params failed; Interrupted.\n", pHba->name);
+		return -EINTR;
+	}
 			
-	memcpy(buf, resblk+8, buflen);  /* cut off header */
+	memcpy(buf, resblk_va+8, buflen);  /* cut off header */
 
+	pci_free_consistent(pHba->pDev, sizeof(u8) * (8+buflen), resblk_va, resblk_pa);
 	if (size < 0)
 		return size;	
 
@@ -3122,37 +3854,38 @@
  *	ResultCount, ErrorInfoSize, BlockStatus and BlockSize.
  */
 static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, 
-		  void *opblk, int oplen, void *resblk, int reslen)
+		  void *opblk_va, dma_addr_t opblk_pa, int oplen,
+		  void *resblk_va, dma_addr_t resblk_pa, int reslen)
 {
 	u32 msg[9]; 
-	u32 *res = (u32 *)resblk;
+	u32 *res = (u32 *)resblk_va;
 	int wait_status;
 
-	msg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;
-	msg[1] = cmd << 24 | HOST_TID << 12 | tid; 
+	msg[0] = cpu_to_le32(NINE_WORD_MSG_SIZE | SGL_OFFSET_5);
+	msg[1] = cpu_to_le32(cmd << 24 | HOST_TID << 12 | tid);
 	msg[2] = 0;
 	msg[3] = 0;
 	msg[4] = 0;
-	msg[5] = 0x54000000 | oplen;	/* OperationBlock */
-	msg[6] = virt_to_bus(opblk);
-	msg[7] = 0xD0000000 | reslen;	/* ResultBlock */
-	msg[8] = virt_to_bus(resblk);
+	msg[5] = cpu_to_le32(0x54000000 | oplen);	/* OperationBlock */
+	msg[6] = cpu_to_le32(opblk_pa);
+	msg[7] = cpu_to_le32(0xD0000000 | reslen);	/* ResultBlock */
+	msg[8] = cpu_to_le32(resblk_pa);
 
 	if ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {
    		return wait_status; 	/* -DetailedStatus */
 	}
 
-	if (res[1]&0x00FF0000) { 	/* BlockStatus != SUCCESS */
+	if (res[1]&cpu_to_le32(0x00FF0000)) { 	/* BlockStatus != SUCCESS */
 		printk(KERN_WARNING "%s: %s - Error:\n  ErrorInfoSize = 0x%02x, "
 			"BlockStatus = 0x%02x, BlockSize = 0x%04x\n",
 			pHba->name,
 			(cmd == I2O_CMD_UTIL_PARAMS_SET) ? "PARAMS_SET"
 							 : "PARAMS_GET",   
-			res[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);
-		return -((res[1] >> 16) & 0xFF); /* -BlockStatus */
+			le32_to_cpu(res[1])>>24, (le32_to_cpu(res[1])>>16)&0xFF, le32_to_cpu(res[1])&0xFFFF);
+		return -((le32_to_cpu(res[1]) >> 16) & 0xFF); /* -BlockStatus */
 	}
 
-	 return 4 + ((res[1] & 0x0000FFFF) << 2); /* bytes used in resblk */ 
+	 return 4 + ((le32_to_cpu(res[1]) & 0x0000FFFF) << 2); /* bytes used in resblk */ 
 }
 
 
@@ -3165,13 +3898,13 @@
 
 	/* SysQuiesce discarded if IOP not in READY or OPERATIONAL state */
 
-	if((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&
-   	   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){
+	if((pHba->status_block_va->iop_state != cpu_to_le32(ADAPTER_STATE_READY)) &&
+   	   (pHba->status_block_va->iop_state != cpu_to_le32(ADAPTER_STATE_OPERATIONAL))){
 		return 0;
 	}
 
-	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
-	msg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[0] = cpu_to_le32(FOUR_WORD_MSG_SIZE|SGL_OFFSET_0);
+	msg[1] = cpu_to_le32(I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID);
 	msg[2] = 0;
 	msg[3] = 0;
 
@@ -3196,18 +3929,18 @@
 	int ret;
 	
 	adpt_i2o_status_get(pHba);
-	if(!pHba->status_block){
+	if(!pHba->status_block_va){
 		return -ENOMEM;
 	}
 	/* Enable only allowed on READY state */
-	if(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)
+	if(pHba->status_block_va->iop_state == cpu_to_le32(ADAPTER_STATE_OPERATIONAL))
 		return 0;
 
-	if(pHba->status_block->iop_state != ADAPTER_STATE_READY)
+	if(pHba->status_block_va->iop_state != cpu_to_le32(ADAPTER_STATE_READY))
 		return -EINVAL;
 
-	msg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
-	msg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[0]= cpu_to_le32(FOUR_WORD_MSG_SIZE|SGL_OFFSET_0);
+	msg[1]= cpu_to_le32(I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID);
 	msg[2]= 0;
 	msg[3]= 0;
 
@@ -3228,11 +3961,11 @@
 	 u32 msg[12];
 	 int ret;
 
-	msg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;
-	msg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;
+	msg[0] = cpu_to_le32(I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6);
+	msg[1] = cpu_to_le32(I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID);
 	msg[2] = 0;
 	msg[3] = 0;
-	msg[4] = (0<<16) | ((pHba->unit+2) << 12); /* Host 0 IOP ID (unit + 2) */
+	msg[4] = cpu_to_le32((0<<16) | ((pHba->unit+2) << 12)); /* Host 0 IOP ID (unit + 2) */
 	msg[5] = 0;				   /* Segment 0 */
 
 	/* 
@@ -3240,11 +3973,11 @@
 	 * System table (SysTab), Private memory space declaration and 
 	 * Private i/o space declaration  
 	 */
-	msg[6] = 0x54000000 | sys_tbl_len;
-	msg[7] = virt_to_phys(sys_tbl);
-	msg[8] = 0x54000000 | 0;
+	msg[6] = cpu_to_le32(0x54000000 | sys_tbl_len);
+	msg[7] = cpu_to_le32(sys_tbl_pa);
+	msg[8] = cpu_to_le32(0x54000000 | 0);
 	msg[9] = 0;
-	msg[10] = 0xD4000000 | 0;
+	msg[10] = cpu_to_le32(0xD4000000 | 0);
 	msg[11] = 0;
 
 	if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {
@@ -3279,24 +4012,64 @@
 
 #endif
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+static struct pci_dev *
+adpt_pci_find_device(uint vendor, struct pci_dev *from)
+{
+	if(!from){
+		from = pci_devices;
+	} else {
+		from = from->next;
+	}
+	while (from && from->vendor != vendor) {
+		from = from->next;
+	}
+	return from;
+}
+#endif
+
 static Scsi_Host_Template driver_template = {
-	.name			= "dpt_i2o",
-	.proc_name		= "dpt_i2o",
-	.proc_info		= adpt_proc_info,
-	.detect			= adpt_detect,	
-	.release		= adpt_release,
-	.info			= adpt_info,
-	.queuecommand		= adpt_queue,
-	.eh_abort_handler	= adpt_abort,
-	.eh_device_reset_handler = adpt_device_reset,
-	.eh_bus_reset_handler	= adpt_bus_reset,
-	.eh_host_reset_handler	= adpt_reset,
-	.bios_param		= adpt_bios_param,
-	.slave_configure	= adpt_slave_configure,
-	.can_queue		= MAX_TO_IOP_MESSAGES,
-	.this_id		= 7,
-	.cmd_per_lun		= 1,
-	.use_clustering		= ENABLE_CLUSTERING,
+	.name				= "dpt_i2o",
+	.proc_name			= "dpt_i2o",
+	.proc_info			= adpt_proc_info,
+	.detect				= adpt_detect,
+	.release			= adpt_release,
+	.info				= adpt_info,
+	.queuecommand			= adpt_queue,
+	.eh_abort_handler		= adpt_abort,
+	.eh_device_reset_handler	= adpt_device_reset,
+	.eh_bus_reset_handler		= adpt_bus_reset,
+	.eh_host_reset_handler		= adpt_reset,
+	.bios_param			= adpt_bios_param,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+	.slave_configure		= adpt_slave_configure,
+#else
+	.select_queue_depths		= adpt_select_queue_depths,
+#endif
+	.can_queue			= MAX_TO_IOP_MESSAGES,
+	.this_id			= 7,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,65))
+	.sg_tablesize			= 0, /* max scatter-gather cmds */
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7))
+	.max_sectors			= 4096,
+#endif
+	.cmd_per_lun			= 256,
+	.use_clustering			= ENABLE_CLUSTERING,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,65))
+	.use_new_eh_code		= 1,
+#endif
+	.proc_dir			= &proc_scsi_dptI2O,
 };
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+#include "scsi_module.c"
+#elif (defined(MODULE))
 #include "scsi_module.c"
-MODULE_LICENSE("GPL");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,65))
+EXPORT_NO_SYMBOLS;
+#endif
+
+MODULE_LICENSE("Dual BSD/GPL");
diff -urN linux-2.6.6/drivers/scsi/dpti.h linux-2.6.6-gentoo1/drivers/scsi/dpti.h
--- linux-2.6.6/drivers/scsi/dpti.h	2004-05-09 21:31:56.000000000 -0500
+++ linux-2.6.6-gentoo1/drivers/scsi/dpti.h	2004-05-22 09:13:10.640669279 -0500
@@ -3,10 +3,10 @@
                              -------------------
     begin                : Thu Sep 7 2000
     copyright            : (C) 2001 by Adaptec
-    email                : deanna_bonds@adaptec.com
+    email                : Mark_Salyzyn@adaptec.com
+    original author      : deanna_bonds@adaptec.com
 
-    See Documentation/scsi/dpti.txt for history, notes, license info
-    and credits
+    See README.dpti for history, notes, license info, and credits
  ***************************************************************************/
 
 /***************************************************************************
@@ -37,16 +37,28 @@
  * SCSI interface function Prototypes
  */
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+static int adpt_proc_info(struct Scsi_Host * host, char *buffer, char **start, off_t offset, int length, int inout);
+#else
+static int adpt_proc_info(char *buffer, char **start, off_t offset, int length, int host_no, int inout);
+#endif
 static int adpt_detect(Scsi_Host_Template * sht);
 static int adpt_queue(Scsi_Cmnd * cmd, void (*cmdcomplete) (Scsi_Cmnd *));
 static int adpt_abort(Scsi_Cmnd * cmd);
 static int adpt_reset(Scsi_Cmnd* cmd);
 static int adpt_release(struct Scsi_Host *host);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
 static int adpt_slave_configure(Scsi_Device *);
+#else
+static void adpt_select_queue_depths(struct Scsi_Host *host, Scsi_Device * devicelist);
+#endif
 
 static const char *adpt_info(struct Scsi_Host *pSHost);
-static int adpt_bios_param(struct scsi_device * sdev, struct block_device *dev,
-		sector_t, int geom[]);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,65))
+static int adpt_bios_param(struct scsi_device * sdev, struct block_device * bdev, sector_t, int geom[]);
+#else
+static int adpt_bios_param(Disk * disk, kdev_t dev, int geom[]);
+#endif
 
 static int adpt_bus_reset(Scsi_Cmnd* cmd);
 static int adpt_device_reset(Scsi_Cmnd* cmd);
@@ -62,17 +74,18 @@
 
 #include "dpt/sys_info.h"
 #include <linux/wait.h>
+#include <linux/interrupt.h>
 #include "dpt/dpti_i2o.h"
 #include "dpt/dpti_ioctl.h"
 
-#define DPT_I2O_VERSION "2.4 Build 5"
+#define DPT_I2O_VERSION "2.5.0"
 #define DPT_VERSION     2
-#define DPT_REVISION    '4'
-#define DPT_SUBREVISION '5'
+#define DPT_REVISION    '5'
+#define DPT_SUBREVISION '0'
 #define DPT_BETA	""
-#define DPT_MONTH      8 
-#define DPT_DAY        7
-#define DPT_YEAR        (2001-1980)
+#define DPT_MONTH      8
+#define DPT_DAY        4
+#define DPT_YEAR        (2003-1980)
 
 #define DPT_DRIVER	"dpt_i2o"
 #define DPTI_I2O_MAJOR	(151)
@@ -228,36 +241,42 @@
 	char name[32];
 	char detail[55];
 
-	ulong base_addr_virt;
-	ulong msg_addr_virt;
+	char * base_addr_virt;
+	char * msg_addr_virt;
 	ulong base_addr_phys;
-	ulong  post_port;
-	ulong  reply_port;
-	ulong  irq_mask;
+	u32 *  post_port;
+	u32 *  reply_port;
+	u32 *  irq_mask;
 	u16  post_count;
 	u32  post_fifo_size;
 	u32  reply_fifo_size;
-	u32* reply_pool;
+	u32* reply_pool_va;
+	dma_addr_t reply_pool_pa;
 	u32  sg_tablesize;	// Scatter/Gather List Size.       
 	u8  top_scsi_channel;
 	u8  top_scsi_id;
 	u8  top_scsi_lun;
+	u8  pae_support;
 
-	i2o_status_block* status_block;
-	i2o_hrt* hrt;
-	i2o_lct* lct;
+	i2o_status_block* status_block_va;
+	dma_addr_t status_block_pa;
+	i2o_hrt* hrt_va;
+	dma_addr_t hrt_pa;
+	i2o_lct* lct_va;
+	dma_addr_t lct_pa;
 	uint lct_size;
 	struct i2o_device* devices;
 	struct adpt_channel channel[MAX_CHANNEL];
 	struct proc_dir_entry* proc_entry;	/* /proc dir */
 
-	ulong FwDebugBuffer_P;	// Virtual Address Of FW Debug Buffer
-	u32   FwDebugBufferSize;	// FW Debug Buffer Size In Bytes
-	ulong FwDebugStrLength_P;	// Virtual Addr Of FW Debug String Len
-	ulong FwDebugFlags_P;	// Virtual Address Of FW Debug Flags 
-	ulong FwDebugBLEDflag_P;	// Virtual Addr Of FW Debug BLED
-	ulong FwDebugBLEDvalue_P;	// Virtual Addr Of FW Debug BLED
-	u32 FwDebugFlags;
+	char * fw_buffer_addr_virt;	// Virtual Address Of FW Debug Buffer
+	char * bled_flag_addr_virt;	// Virtual Addr Of FW Debug BLED
+	char * bled_value_addr_virt;	// Virtual Addr Of FW Debug BLED
+
+	u32   fw_buffer_size;	// FW Debug Buffer Size In Bytes
+	char * fw_string_len_addr_virt;	// Virtual Addr Of FW Debug String Len
+	char * fw_debug_flags_addr_virt;	// Virtual Address Of FW Debug Flags 
+	u32 * ioctl_reply_context[4];
 } adpt_hba;
 
 struct sg_simple_element {
@@ -269,10 +288,28 @@
  * Function Prototypes
  */
 
+#ifndef IRQ_HANDLED
+  typedef void irqreturn_t;
+# define IRQ_NONE
+# define IRQ_HANDLED
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+#define iminor(x)	MINOR(x->i_rdev)
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+#define set_current_state(x)	current->state = x
+#endif
+
+#ifndef MODULE_LICENSE
+# define MODULE_LICENSE(x) /* NOTHING */
+#endif
+
 static void adpt_i2o_sys_shutdown(void);
 static int adpt_init(void);
 static int adpt_i2o_build_sys_table(void);
-static void adpt_isr(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t adpt_isr(int irq, void *dev_id, struct pt_regs *regs);
 #ifdef REBOOT_NOTIFIER
 static int adpt_reboot_event(struct notifier_block *n, ulong code, void *p);
 #endif
@@ -284,7 +321,8 @@
 static const char *adpt_i2o_get_class_name(int class);
 #endif
 static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, 
-		  void *opblk, int oplen, void *resblk, int reslen);
+		  void *opblk_va, dma_addr_t opblk_pa, int oplen,
+		  void *resblk_va, dma_addr_t resblk_pa, int reslen);
 static int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout);
 static int adpt_i2o_lct_get(adpt_hba* pHba);
 static int adpt_i2o_parse_lct(adpt_hba* pHba);
@@ -297,7 +335,7 @@
 static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba);
 static s32 adpt_i2o_hrt_get(adpt_hba* pHba);
 static s32 adpt_scsi_to_i2o(adpt_hba* pHba, Scsi_Cmnd* cmd, struct adpt_device* dptdevice);
-static s32 adpt_i2o_to_scsi(ulong reply, Scsi_Cmnd* cmd);
+static s32 adpt_i2o_to_scsi(u8 * reply, Scsi_Cmnd* cmd);
 static s32 adpt_scsi_register(adpt_hba* pHba,Scsi_Host_Template * sht);
 static s32 adpt_hba_reset(adpt_hba* pHba);
 static s32 adpt_i2o_reset_hba(adpt_hba* pHba);
diff -urN linux-2.6.6/drivers/scsi/dpti2oscsi2.c linux-2.6.6-gentoo1/drivers/scsi/dpti2oscsi2.c
--- linux-2.6.6/drivers/scsi/dpti2oscsi2.c	1969-12-31 18:00:00.000000000 -0600
+++ linux-2.6.6-gentoo1/drivers/scsi/dpti2oscsi2.c	2004-05-22 09:13:10.642668980 -0500
@@ -0,0 +1,239 @@
+
+/*
+ * NOTE:  You must include i2obscsi.h before including this file
+ */
+
+/*
+ *      SCSI opcodes
+ */
+/*
+ * i2oscsi2dixkxfer is a table of data transfer direction for SCSI Disk 
+ * device commands.  The table indicates if the command will transfer 
+ * data in (from device to system) or data out (from system to device)
+ * NOSUPPORT indicates the command is not used for a disk device
+ */
+
+/* #define	DATAIN	I2O_SCB_FLAG_XFER_FROM_DEVICE */
+#define	DATAIN	0x01
+/* #define	DATAOUT	I2O_SCB_FLAG_XFER_TO_DEVICE */
+#define	DATAOUT	0x02
+/* #define	NODATA	I2O_SCB_FLAG_NO_DATA_XFER */
+#define	NODATA	0x00
+#define	NOSUPPORT	0xFF
+
+unsigned char i2oscsi2diskxfer[] = {
+
+
+/* TEST_UNIT_READY       0x00 */ NODATA,
+/* REZERO_UNIT           0x01 */ NODATA,
+/*			 0x02 */ NOSUPPORT,
+/* REQUEST_SENSE         0x03 */ DATAIN,
+/* FORMAT_UNIT           0x04 */ DATAOUT,
+/* READ_BLOCK_LIMITS     0x05 */ DATAIN,
+/*			 0x06 */ NOSUPPORT,
+/* REASSIGN_BLOCKS       0x07 */ DATAOUT,
+/* READ_6                0x08 */ DATAIN,
+
+/*			 0x09 */ NOSUPPORT,
+
+/* WRITE_6               0x0a */ DATAOUT,
+/* SEEK_6                0x0b */ NODATA,
+/*			 0x0c */ NOSUPPORT,
+/*			 0x0d */ NOSUPPORT,
+/*			 0x0e */ NOSUPPORT,
+/* READ_REVERSE          0x0f */ NOSUPPORT,
+/* WRITE_FILEMARKS       0x10 */ NODATA,
+/* SPACE                 0x11 */ NOSUPPORT,
+/* INQUIRY               0x12 */ DATAIN,
+/*			 0x13 */ NOSUPPORT,
+/* RECOVER_BUFFERED_DATA 0x14 */ NOSUPPORT,
+/* MODE_SELECT           0x15 */ DATAOUT,
+/* RESERVE               0x16 */ DATAOUT,
+/* RELEASE               0x17 */ NODATA,
+/* COPY                  0x18 */ DATAOUT,
+	/* ERASE                 0x19 */ NOSUPPORT,
+	/* NODATA if supported */
+/* MODE_SENSE            0x1a */ DATAIN,
+/* START_STOP            0x1b */ NODATA,
+/* RECEIVE_DIAGNOSTIC    0x1c */ DATAIN,
+/* SEND_DIAGNOSTIC       0x1d */ DATAOUT,
+/* ALLOW_MEDIUM_REMOVAL  0x1e */ NODATA,
+
+/*			 0x1f */ NOSUPPORT,
+/*			 0x20 */ NOSUPPORT,
+/*			 0x21 */ NOSUPPORT,
+/*			 0x22 */ NOSUPPORT,
+/*			 0x23 */ NOSUPPORT,
+
+/* SET_WINDOW            0x24 */ DATAOUT,
+/* READ_CAPACITY         0x25 */ DATAIN,
+
+/*			 0x26 */ NOSUPPORT,
+/*			 0x27 */ NOSUPPORT,
+
+/* READ_10               0x28 */ DATAIN,
+
+/*			 0x29 */ NOSUPPORT,
+
+/* WRITE_10              0x2a */ DATAOUT,
+/* SEEK_10               0x2b */ NODATA,
+
+/*			 0x2c */ NOSUPPORT,
+/*			 0x2d */ NOSUPPORT,
+
+/* WRITE_VERIFY          0x2e */ DATAOUT,
+/* VERIFY                0x2f */ NODATA,
+/* SEARCH_HIGH           0x30 */ DATAOUT,
+/* SEARCH_EQUAL          0x31 */ DATAOUT,
+/* SEARCH_LOW            0x32 */ DATAOUT,
+/* SET_LIMITS            0x33 */ NODATA,
+/* PRE_FETCH             0x34 */ DATAIN,
+/* SYNCHRONIZE_CACHE     0x35 */ NODATA,
+/* LOCK_UNLOCK_CACHE     0x36 */ NODATA,
+/* READ_DEFECT_DATA      0x37 */ DATAIN,
+/* MEDIUM_SCAN           0x38 */ DATAOUT,
+/* COMPARE               0x39 */ DATAOUT,
+/* COPY_VERIFY           0x3a */ DATAOUT,
+/* WRITE_BUFFER          0x3b */ DATAOUT,
+/* READ_BUFFER           0x3c */ DATAIN,
+/* UPDATE_BLOCK          0x3d */ DATAOUT,
+/* READ_LONG             0x3e */ DATAIN,
+/* WRITE_LONG            0x3f */ DATAOUT,
+/* CHANGE_DEFINITION     0x40 */ DATAOUT,
+/* WRITE_SAME            0x41 */ DATAOUT,
+
+/*			 0x42 */ DATAIN,
+
+/* READ_TOC              0x43 */ DATAIN,
+
+/*			 0x44 */ DATAIN,
+/*			 0x45 */ NOSUPPORT,
+/*			 0x46 */ NOSUPPORT,
+/*			 0x47 */ NOSUPPORT,
+/*			 0x48 */ NOSUPPORT,
+/*			 0x49 */ NOSUPPORT,
+/*			 0x4a */ NOSUPPORT,
+/*			 0x4b */ NOSUPPORT,
+
+/* LOG_SELECT            0x4c */ DATAOUT,
+/* LOG_SENSE             0x4d */ DATAIN,
+
+/*			 0x4e */ NOSUPPORT,
+/*			 0x4f */ NOSUPPORT,
+/*			 0x50 */ NOSUPPORT,
+/*			 0x51 */ DATAIN,
+/*			 0x52 */ DATAIN,
+/*			 0x53 */ DATAOUT,
+/*			 0x54 */ NOSUPPORT,
+
+/* MODE_SELECT_10        0x55 */ DATAOUT,
+
+/*			 0x56 */ NODATA,
+/*			 0x57 */ NODATA,
+/*			 0x58 */ NOSUPPORT,
+/*			 0x59 */ NOSUPPORT,
+
+/* MODE_SENSE_10         0x5a */ DATAIN,
+
+/*			 0x5b */ DATAIN,
+/*			 0x5c */ DATAIN,
+/*			 0x5d */ NOSUPPORT,
+/*			 0x5e */ NOSUPPORT,
+/*			 0x5f */ NOSUPPORT,
+
+/* assign NOSUPPORT for 0x60 - 0x9f */
+	/* 0x60 - 0x6f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0x70 - 0x7f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0x80 - 0x8f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0x90 - 0x9f */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+
+/*			 0xa0 */ NOSUPPORT,
+/*			 0xa1 */ NOSUPPORT,
+/*			 0xa2 */ NOSUPPORT,
+/*			 0xa3 */ NOSUPPORT,
+/*			 0xa4 */ NOSUPPORT,
+
+/* MOVE_MEDIUM           0xa5 */ NODATA,
+
+/*			 0xa6 */ NOSUPPORT,
+/*			 0xa7 */ NOSUPPORT,
+
+/* READ_12               0xa8 */ DATAIN,
+
+/*			 0xa9 */ NOSUPPORT,
+
+/* WRITE_12              0xaa */ DATAOUT,
+
+/*			 0xab */ NOSUPPORT,
+/*			 0xac */ NOSUPPORT,
+/*			 0xad */ NOSUPPORT,
+
+/* WRITE_VERIFY_12       0xae */ DATAOUT,
+
+/*			 0xaf */ NOSUPPORT,
+
+/* SEARCH_HIGH_12        0xb0 */ DATAOUT,
+/* SEARCH_EQUAL_12       0xb1 */ DATAOUT,
+/* SEARCH_LOW_12         0xb2 */ DATAOUT,
+
+/*			 0xb3 */ NOSUPPORT,
+/*			 0xb4 */ NOSUPPORT,
+/*			 0xb5 */ NOSUPPORT,
+
+/* SEND_VOLUME_TAG       0xb6 */ DATAOUT,
+
+/*			 0xb7 */ NOSUPPORT,
+
+/* READ_ELEMENT_STATUS   0xb8 */ DATAIN,
+
+/*			 0xb9 */ NOSUPPORT,
+/*			 0xba */ NOSUPPORT,
+/*			 0xbb */ DATAOUT,
+/*			 0xbc */ NOSUPPORT,
+/*			 0xbd */ DATAIN,
+/*			 0xbe */ NOSUPPORT,
+/*			 0xbf */ NOSUPPORT,
+
+/* assign NOSUPPORT for 0xc0 - 0xdf */
+	/* 0xc0 - 0xcf */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	/* 0xd0 - 0xdf */
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT, NOSUPPORT,
+	NOSUPPORT, NOSUPPORT,
+
+/*			 0xe0 */ NOSUPPORT,
+/*			 0xe1 */ NOSUPPORT,
+/*			 0xe2 */ NOSUPPORT,
+/*			 0xe3 */ NOSUPPORT,
+/*			 0xe4 */ NOSUPPORT,
+/*			 0xe5 */ NOSUPPORT,
+/*			 0xe6 */ NOSUPPORT,
+/*			 0xe7 */ NOSUPPORT,
+/*			 0xe8 */ NOSUPPORT,
+/*			 0xe9 */ NOSUPPORT,
+
+/* WRITE_LONG_2          0xea */ DATAOUT
+};
+
+#define	DISKXFERTBLSIZE sizeof(i2oscsi2diskxfer)
