mason@suse.com

block_write_full_page might see and lock clean metadata buffers, which leads
to vs-12339 messages.  Change the message to ignore bh locked.

Index: linux.mm/fs/reiserfs/do_balan.c
===================================================================
--- linux.mm.orig/fs/reiserfs/do_balan.c	2004-04-23 14:08:22.436537699 -0400
+++ linux.mm/fs/reiserfs/do_balan.c	2004-04-23 14:09:05.089418397 -0400
@@ -1343,7 +1343,8 @@ static void check_internal_node (struct 
 
 static int locked_or_not_in_tree (struct buffer_head * bh, char * which)
 {
-  if ( buffer_locked (bh) || !B_IS_IN_TREE (bh) ) {
+  if ( (!reiserfs_buffer_prepared(bh) && buffer_locked (bh)) || 
+        !B_IS_IN_TREE (bh) ) {
     reiserfs_warning ("vs-12339: locked_or_not_in_tree: %s (%b)\n", which, bh);
     return 1;
   } 
jeffm@suse.com

properly init device inodes in the acl code

Index: linux.mm/fs/reiserfs/namei.c
===================================================================
--- linux.mm.orig/fs/reiserfs/namei.c	2004-04-05 17:29:55.209923503 -0400
+++ linux.mm/fs/reiserfs/namei.c	2004-04-05 17:30:08.727302329 -0400
@@ -630,7 +630,7 @@ static int reiserfs_mknod (struct inode 
         goto out_failed;
     }
 
-    init_special_inode(inode, mode, rdev) ;
+    init_special_inode(inode, inode->i_mode, rdev) ;
 
     //FIXME: needed for block and char devices only
     reiserfs_update_sd (&th, inode);
jeffm@suse.com

reiserfs support for xattrs

Index: linux.mm/fs/Kconfig
===================================================================
--- linux.mm.orig/fs/Kconfig	2004-04-23 14:08:21.287675679 -0400
+++ linux.mm/fs/Kconfig	2004-04-23 14:09:45.730536675 -0400
@@ -244,6 +244,16 @@ config REISERFS_PROC_INFO
 	  Almost everyone but ReiserFS developers and people fine-tuning
 	  reiserfs or tracing problems should say N.
 
+config REISERFS_FS_XATTR
+	bool "ReiserFS extended attributes"
+	depends on REISERFS_FS
+	help
+	  Extended attributes are name:value pairs associated with inodes by
+	  the kernel or by users (see the attr(5) manual page, or visit
+	  <http://acl.bestbits.at/> for details).
+
+	  If unsure, say N.
+
 config JFS_FS
 	tristate "JFS filesystem support"
 	select NLS
Index: linux.mm/fs/reiserfs/Makefile
===================================================================
--- linux.mm.orig/fs/reiserfs/Makefile	2004-01-09 02:00:13.000000000 -0500
+++ linux.mm/fs/reiserfs/Makefile	2004-04-23 14:09:45.731536555 -0400
@@ -9,6 +9,10 @@ reiserfs-objs := bitmap.o do_balan.o nam
 		 hashes.o tail_conversion.o journal.o resize.o \
 		 item_ops.o ioctl.o procfs.o
 
+ifeq ($(CONFIG_REISERFS_FS_XATTR),y)
+reiserfs-objs += xattr.o xattr_user.o
+endif
+
 # gcc -O2 (the kernel default)  is overaggressive on ppc32 when many inline
 # functions are used.  This causes the compiler to advance the stack
 # pointer out of the available stack space, corrupting kernel space,
Index: linux.mm/fs/reiserfs/dir.c
===================================================================
--- linux.mm.orig/fs/reiserfs/dir.c	2004-04-05 10:56:49.000000000 -0400
+++ linux.mm/fs/reiserfs/dir.c	2004-04-23 14:09:45.749534395 -0400
@@ -115,6 +115,17 @@ static int reiserfs_readdir (struct file
 		    /* too big to send back to VFS */
 		    continue ;
 		}
+
+                /* Ignore the .reiserfs_priv entry */
+                if (reiserfs_xattrs (inode->i_sb) &&
+                    !old_format_only(inode->i_sb) &&
+                    filp->f_dentry == inode->i_sb->s_root &&
+                    REISERFS_SB(inode->i_sb)->priv_root &&
+                    REISERFS_SB(inode->i_sb)->priv_root->d_inode &&
+                    deh_objectid(deh) == le32_to_cpu (INODE_PKEY(REISERFS_SB(inode->i_sb)->priv_root->d_inode)->k_objectid)) {
+                  continue;
+                }
+
 		d_off = deh_offset (deh);
 		filp->f_pos = d_off ;
 		d_ino = deh_objectid (deh);
Index: linux.mm/fs/reiserfs/file.c
===================================================================
--- linux.mm.orig/fs/reiserfs/file.c	2004-04-23 14:08:22.459534937 -0400
+++ linux.mm/fs/reiserfs/file.c	2004-04-23 14:09:45.752534035 -0400
@@ -5,6 +5,7 @@
 
 #include <linux/time.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
 #include <linux/pagemap.h>
@@ -97,51 +98,6 @@ static int reiserfs_sync_file(
   return ( n_err < 0 ) ? -EIO : 0;
 }
 
-static int reiserfs_setattr(struct dentry *dentry, struct iattr *attr) {
-    struct inode *inode = dentry->d_inode ;
-    int error ;
-    reiserfs_write_lock(inode->i_sb);
-    if (attr->ia_valid & ATTR_SIZE) {
-	/* version 2 items will be caught by the s_maxbytes check
-	** done for us in vmtruncate
-	*/
-	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&
-	    attr->ia_size > MAX_NON_LFS) {
-	    error = -EFBIG ;
-	    goto out;
-	}
-	/* fill in hole pointers in the expanding truncate case. */
-        if (attr->ia_size > inode->i_size) {
-	    error = generic_cont_expand(inode, attr->ia_size) ;
-	    if (REISERFS_I(inode)->i_prealloc_count > 0) {
-		struct reiserfs_transaction_handle th ;
-		/* we're changing at most 2 bitmaps, inode + super */
-		journal_begin(&th, inode->i_sb, 4) ;
-		reiserfs_discard_prealloc (&th, inode);
-		journal_end(&th, inode->i_sb, 4) ;
-	    }
-	    if (error)
-	        goto out;
-	}
-    }
-
-    if ((((attr->ia_valid & ATTR_UID) && (attr->ia_uid & ~0xffff)) ||
-	 ((attr->ia_valid & ATTR_GID) && (attr->ia_gid & ~0xffff))) &&
-	(get_inode_sd_version (inode) == STAT_DATA_V1)) {
-		/* stat data of format v3.5 has 16 bit uid and gid */
-	    error = -EINVAL;
-	    goto out;	
-	}
-
-    error = inode_change_ok(inode, attr) ;
-    if (!error)
-        inode_setattr(inode, attr) ;
-
-out:
-    reiserfs_write_unlock(inode->i_sb);
-    return error ;
-}
-
 /* I really do not want to play with memory shortage right now, so
    to simplify the code, we are not going to write more than this much pages at
    a time. This still should considerably improve performance compared to 4k
@@ -1321,6 +1277,11 @@ struct file_operations reiserfs_file_ope
 struct  inode_operations reiserfs_file_inode_operations = {
     .truncate	= reiserfs_vfs_truncate_file,
     .setattr    = reiserfs_setattr,
+    .setxattr   = reiserfs_setxattr,
+    .getxattr   = reiserfs_getxattr,
+    .listxattr  = reiserfs_listxattr,
+    .removexattr = reiserfs_removexattr,
+    .permission = reiserfs_permission,
 };
 
 
Index: linux.mm/fs/reiserfs/inode.c
===================================================================
--- linux.mm.orig/fs/reiserfs/inode.c	2004-04-23 14:08:22.546524490 -0400
+++ linux.mm/fs/reiserfs/inode.c	2004-04-23 14:09:45.756533555 -0400
@@ -5,6 +5,7 @@
 #include <linux/config.h>
 #include <linux/time.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <linux/pagemap.h>
 #include <linux/highmem.h>
@@ -13,6 +14,7 @@
 #include <linux/buffer_head.h>
 #include <linux/mpage.h>
 #include <linux/writeback.h>
+#include <linux/quotaops.h>
 
 extern int reiserfs_default_io_size; /* default io size devuned in super.c */
 
@@ -40,6 +42,8 @@ void reiserfs_delete_inode (struct inode
     if (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) { /* also handles bad_inode case */
 	down (&inode->i_sem); 
 
+	reiserfs_delete_xattrs (inode);
+
 	journal_begin(&th, inode->i_sb, jbegin_count) ;
 	reiserfs_update_inode_transaction(inode) ;
 
@@ -1053,10 +1057,11 @@ static void init_inode (struct inode * i
 	inode->i_op = &reiserfs_dir_inode_operations;
 	inode->i_fop = &reiserfs_dir_operations;
     } else if (S_ISLNK (inode->i_mode)) {
-	inode->i_op = &page_symlink_inode_operations;
+	inode->i_op = &reiserfs_symlink_inode_operations;
 	inode->i_mapping->a_ops = &reiserfs_address_space_operations;
     } else {
 	inode->i_blocks = 0;
+	inode->i_op = &reiserfs_special_inode_operations;
 	init_special_inode(inode, inode->i_mode, new_decode_dev(rdev));
     }
 }
@@ -2509,6 +2514,64 @@ static ssize_t reiserfs_direct_IO(int rw
 }
 
 
+int reiserfs_setattr(struct dentry *dentry, struct iattr *attr) {
+    struct inode *inode = dentry->d_inode ;
+    int error ;
+    unsigned int ia_valid = attr->ia_valid;
+    reiserfs_write_lock(inode->i_sb);
+    if (attr->ia_valid & ATTR_SIZE) {
+	/* version 2 items will be caught by the s_maxbytes check
+	** done for us in vmtruncate
+	*/
+	if (get_inode_item_key_version(inode) == KEY_FORMAT_3_5 &&
+	    attr->ia_size > MAX_NON_LFS) {
+	    error = -EFBIG ;
+	    goto out;
+	}
+	/* fill in hole pointers in the expanding truncate case. */
+        if (attr->ia_size > inode->i_size) {
+	    error = generic_cont_expand(inode, attr->ia_size) ;
+	    if (REISERFS_I(inode)->i_prealloc_count > 0) {
+		struct reiserfs_transaction_handle th ;
+		/* we're changing at most 2 bitmaps, inode + super */
+		journal_begin(&th, inode->i_sb, 4) ;
+		reiserfs_discard_prealloc (&th, inode);
+		journal_end(&th, inode->i_sb, 4) ;
+	    }
+	    if (error)
+	        goto out;
+	}
+    }
+
+    if ((((attr->ia_valid & ATTR_UID) && (attr->ia_uid & ~0xffff)) ||
+	 ((attr->ia_valid & ATTR_GID) && (attr->ia_gid & ~0xffff))) &&
+	(get_inode_sd_version (inode) == STAT_DATA_V1)) {
+		/* stat data of format v3.5 has 16 bit uid and gid */
+	    error = -EINVAL;
+	    goto out;
+	}
+
+    error = inode_change_ok(inode, attr) ;
+    if (!error) {
+	if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
+	    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid)) {
+                error = reiserfs_chown_xattrs (inode, attr);
+
+                if (!error)
+                    error = DQUOT_TRANSFER(inode, attr) ? -EDQUOT : 0;
+        }
+        if (!error)
+            inode_setattr(inode, attr) ;
+    }
+
+
+out:
+    reiserfs_write_unlock(inode->i_sb);
+    return error ;
+}
+
+
+
 struct address_space_operations reiserfs_address_space_operations = {
     .writepage = reiserfs_writepage,
     .readpage = reiserfs_readpage, 
Index: linux.mm/fs/reiserfs/namei.c
===================================================================
--- linux.mm.orig/fs/reiserfs/namei.c	2004-04-23 14:09:44.177722996 -0400
+++ linux.mm/fs/reiserfs/namei.c	2004-04-23 14:09:45.759533195 -0400
@@ -15,6 +15,7 @@
 #include <linux/time.h>
 #include <linux/bitops.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 
 #define INC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) { i->i_nlink++; if (i->i_nlink >= REISERFS_LINK_MAX) i->i_nlink=1; }
@@ -331,11 +332,24 @@ static struct dentry * reiserfs_lookup (
     retval = reiserfs_find_entry (dir, dentry->d_name.name, dentry->d_name.len, &path_to_entry, &de);
     pathrelse (&path_to_entry);
     if (retval == NAME_FOUND) {
+        /* Hide the .reiserfs_priv directory */
+	if (reiserfs_xattrs (dir->i_sb) &&
+	    !old_format_only(dir->i_sb) &&
+            REISERFS_SB(dir->i_sb)->priv_root &&
+            REISERFS_SB(dir->i_sb)->priv_root->d_inode &&
+	    de.de_objectid == le32_to_cpu (INODE_PKEY(REISERFS_SB(dir->i_sb)->priv_root->d_inode)->k_objectid)) {
+	  return ERR_PTR (-EACCES);
+	}
+
 	inode = reiserfs_iget (dir->i_sb, (struct cpu_key *)&(de.de_dir_id));
 	if (!inode || IS_ERR(inode)) {
 	    reiserfs_write_unlock(dir->i_sb);
 	    return ERR_PTR(-EACCES);
         }
+
+	/* Propogate the priv_object flag so we know we're in the priv tree */
+	if (is_reiserfs_priv_object (dir))
+	    REISERFS_I(inode)->i_flags |= i_priv_object;
     }
     reiserfs_write_unlock(dir->i_sb);
     if ( retval == IO_ERROR ) {
@@ -630,6 +644,7 @@ static int reiserfs_mknod (struct inode 
         goto out_failed;
     }
 
+    inode->i_op = &reiserfs_special_inode_operations;
     init_special_inode(inode, inode->i_mode, rdev) ;
 
     //FIXME: needed for block and char devices only
@@ -942,7 +957,7 @@ static int reiserfs_symlink (struct inod
     reiserfs_update_inode_transaction(inode) ;
     reiserfs_update_inode_transaction(parent_dir) ;
 
-    inode->i_op = &page_symlink_inode_operations;
+    inode->i_op = &reiserfs_symlink_inode_operations;
     inode->i_mapping->a_ops = &reiserfs_address_space_operations;
 
     // must be sure this inode is written with this transaction
@@ -1318,5 +1333,42 @@ struct inode_operations reiserfs_dir_ino
     .rmdir	= reiserfs_rmdir,
     .mknod	= reiserfs_mknod,
     .rename	= reiserfs_rename,
+    .setattr    = reiserfs_setattr,
+    .setxattr   = reiserfs_setxattr,
+    .getxattr   = reiserfs_getxattr,
+    .listxattr  = reiserfs_listxattr,
+    .removexattr = reiserfs_removexattr,
+    .permission     = reiserfs_permission,
+};
+
+/*
+ * symlink operations.. same as page_symlink_inode_operations, with xattr
+ * stuff added
+ */
+struct inode_operations reiserfs_symlink_inode_operations = {
+    .readlink       = page_readlink,
+    .follow_link    = page_follow_link,
+    .setattr        = reiserfs_setattr,
+    .setxattr       = reiserfs_setxattr,
+    .getxattr       = reiserfs_getxattr,
+    .listxattr      = reiserfs_listxattr,
+    .removexattr    = reiserfs_removexattr,
+    .permission     = reiserfs_permission,
+
 };
 
+
+/*
+ * special file operations.. just xattr/acl stuff
+ */
+struct inode_operations reiserfs_special_inode_operations = {
+    .setattr        = reiserfs_setattr,
+    .setxattr       = reiserfs_setxattr,
+    .getxattr       = reiserfs_getxattr,
+    .listxattr      = reiserfs_listxattr,
+    .removexattr    = reiserfs_removexattr,
+    .permission     = reiserfs_permission,
+
+};
+
+
Index: linux.mm/fs/reiserfs/super.c
===================================================================
--- linux.mm.orig/fs/reiserfs/super.c	2004-04-23 14:08:22.628514643 -0400
+++ linux.mm/fs/reiserfs/super.c	2004-04-23 14:09:45.762532835 -0400
@@ -17,6 +17,7 @@
 #include <linux/time.h>
 #include <asm/uaccess.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
@@ -357,7 +358,17 @@ static void reiserfs_put_super (struct s
 {
   int i;
   struct reiserfs_transaction_handle th ;
+
+  if (REISERFS_SB(s)->xattr_root) {
+    d_invalidate (REISERFS_SB(s)->xattr_root);
+    dput (REISERFS_SB(s)->xattr_root);
+  }
   
+  if (REISERFS_SB(s)->priv_root) {
+    d_invalidate (REISERFS_SB(s)->priv_root);
+    dput (REISERFS_SB(s)->priv_root);
+  }
+
   /* change file system state to current state if it was mounted with read-write permissions */
   if (!(s->s_flags & MS_RDONLY)) {
     journal_begin(&th, s, 10) ;
@@ -669,6 +680,8 @@ static int reiserfs_parse_options (struc
 	{"conv", 0, 0, 1<<REISERFS_CONVERT, 0},
 	{"attrs", 0, 0, 1<<REISERFS_ATTRS, 0},
 	{"noattrs", 0, 0, 0, 1<<REISERFS_ATTRS},
+	{"user_xattr", 0, 0, 1<<REISERFS_XATTRS_USER, 0},
+	{"nouser_xattr", 0, 0, 0, 1<<REISERFS_XATTRS_USER},
 	{"nolog", 0, 0, 0, 0}, /* This is unsupported */
 	{"replayonly", 0, 0, 1<<REPLAYONLY, 0},
 	{"block-allocator", 'a', balloc, 0, 0},
@@ -813,6 +826,7 @@ static int reiserfs_remount (struct supe
   safe_mask |= 1 << REISERFS_HASHED_RELOCATION;
   safe_mask |= 1 << REISERFS_TEST4;
   safe_mask |= 1 << REISERFS_ATTRS;
+  safe_mask |= 1 << REISERFS_XATTRS_USER;
 
   /* Update the bitmask, taking care to keep
    * the bits we're not allowed to change here */
@@ -836,6 +850,7 @@ static int reiserfs_remount (struct supe
   }
 
   if (*mount_flags & MS_RDONLY) {
+    reiserfs_xattr_init (s, *mount_flags);
     /* remount read-only */
     if (s->s_flags & MS_RDONLY)
       /* it is read-only already */
@@ -852,8 +867,10 @@ static int reiserfs_remount (struct supe
     journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
   } else {
     /* remount read-write */
-    if (!(s->s_flags & MS_RDONLY))
+    if (!(s->s_flags & MS_RDONLY)) {
+	reiserfs_xattr_init (s, *mount_flags);
 	return 0; /* We are read-write already */
+    }
 
     handle_data_mode(s, mount_options);
     REISERFS_SB(s)->s_mount_state = sb_umount_state(rs) ;
@@ -874,8 +891,10 @@ static int reiserfs_remount (struct supe
   journal_end(&th, s, 10) ;
   s->s_dirt = 0;
 
-  if (!( *mount_flags & MS_RDONLY ) )
+  if (!( *mount_flags & MS_RDONLY ) ) {
     finish_unfinished( s );
+    reiserfs_xattr_init (s, *mount_flags);
+  }
 
   return 0;
 }
@@ -1305,6 +1324,8 @@ static int reiserfs_fill_super (struct s
     REISERFS_SB(s)->s_alloc_options.preallocmin = 4;
     /* Preallocate by 16 blocks (17-1) at once */
     REISERFS_SB(s)->s_alloc_options.preallocsize = 17;
+    /* Initialize the rwsem for xattr dir */
+    init_rwsem(&REISERFS_SB(s)->xattr_dir_sem);
 
     jdev_name = NULL;
     if (reiserfs_parse_options (s, (char *) data, &(sbi->s_mount_opt), &blocks, &jdev_name, &commit_max_age) == 0) {
@@ -1449,13 +1470,25 @@ static int reiserfs_fill_super (struct s
 
 	journal_mark_dirty(&th, s, SB_BUFFER_WITH_SB (s));
 	journal_end(&th, s, 1) ;
-	
+
+	if (reiserfs_xattr_init (s, s->s_flags)) {
+	    dput (s->s_root);
+	    s->s_root = NULL;
+	    goto error;
+	}
+
 	/* look for files which were to be removed in previous session */
 	finish_unfinished (s);
     } else {
 	if ( old_format_only(s) && !silent) {
 	    reiserfs_warning("reiserfs: using 3.5.x disk format\n") ;
 	}
+
+	if (reiserfs_xattr_init (s, s->s_flags)) {
+	    dput (s->s_root);
+	    s->s_root = NULL;
+	    goto error;
+	}
     }
     // mark hash in super block: it could be unset. overwrite should be ok
     set_sb_hash_function_code( rs, function2code(sbi->s_hash_function ) );
@@ -1523,6 +1556,9 @@ init_reiserfs_fs ( void )
 		return ret;
 	}
 
+        if ((ret = reiserfs_xattr_register_handlers ()))
+            goto failed_reiserfs_xattr_register_handlers;
+
 	reiserfs_proc_info_global_init ();
 	reiserfs_proc_register_global ("version", reiserfs_global_version_in_proc);
 
@@ -1532,6 +1568,9 @@ init_reiserfs_fs ( void )
 		return 0;
 	}
 
+        reiserfs_xattr_unregister_handlers ();
+
+failed_reiserfs_xattr_register_handlers:
 	reiserfs_proc_unregister_global ("version");
 	reiserfs_proc_info_global_done ();
 	destroy_inodecache ();
@@ -1542,6 +1581,7 @@ init_reiserfs_fs ( void )
 static void __exit
 exit_reiserfs_fs ( void )
 {
+        reiserfs_xattr_unregister_handlers ();
 	reiserfs_proc_unregister_global ("version");
 	reiserfs_proc_info_global_done ();
         unregister_filesystem (& reiserfs_fs_type);

Index: linux.mm/fs/reiserfs/xattr.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/fs/reiserfs/xattr.c	2004-04-23 14:09:45.766532356 -0400
@@ -0,0 +1,1348 @@
+/*
+ * linux/fs/reiserfs/xattr.c
+ *
+ * Copyright (c) 2002 by Jeff Mahoney, <jeffm@suse.com>
+ *
+ */
+
+/*
+ * In order to implement EAs in a clean, backwards compatible manner,
+ * they are implemented as files in a "private" directory.
+ * Each EA is in it's own file, with the directory layout like so (/ is assumed
+ * to be relative to fs root). Inside the /.reiserfs_priv/xattrs directory,
+ * directories named using the capital-hex form of the objectid and
+ * generation number are used. Inside each directory are individual files
+ * named with the name of the extended attribute.
+ *
+ * So, for objectid 12648430, we could have:
+ * /.reiserfs_priv/xattrs/C0FFEE.0/user.Content-Type
+ * .. or similar.
+ *
+ * The file contents are the text of the EA. The size is known based on the
+ * stat data describing the file.
+ *
+ */
+
+#include <linux/reiserfs_fs.h>
+#include <linux/dcache.h>
+#include <linux/namei.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <linux/mbcache.h>
+#include <asm/uaccess.h>
+#include <asm/checksum.h>
+#include <linux/smp_lock.h>
+#include <linux/stat.h>
+#include <asm/semaphore.h>
+
+#define FL_READONLY 128
+#define FL_DIR_SEM_HELD 256
+#define PRIVROOT_NAME ".reiserfs_priv"
+#define XAROOT_NAME   "xattrs"
+
+static struct reiserfs_xattr_handler *find_xattr_handler_prefix (const char *prefix);
+
+static struct dentry *
+create_xa_root (struct super_block *sb)
+{
+    struct dentry *privroot = dget (REISERFS_SB(sb)->priv_root);
+    struct dentry *xaroot;
+
+    /* This needs to be created at mount-time */
+    if (!privroot)
+        return ERR_PTR(-EOPNOTSUPP);
+
+    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
+    if (IS_ERR (xaroot)) {
+        goto out;
+    } else if (!xaroot->d_inode) {
+        int err;
+        down (&privroot->d_inode->i_sem);
+        err = privroot->d_inode->i_op->mkdir (privroot->d_inode, xaroot, 0700);
+        up (&privroot->d_inode->i_sem);
+
+        if (err) {
+            dput (xaroot);
+            dput (privroot);
+            return ERR_PTR (err);
+        }
+        REISERFS_SB(sb)->xattr_root = dget (xaroot);
+    }
+
+out:
+    dput (privroot);
+    return xaroot;
+}
+
+/* This will return a dentry, or error, refering to the xa root directory.
+ * If the xa root doesn't exist yet, the dentry will be returned without
+ * an associated inode. This dentry can be used with ->mkdir to create
+ * the xa directory. */
+static struct dentry *
+__get_xa_root (struct super_block *s)
+{
+    struct dentry *privroot = dget (REISERFS_SB(s)->priv_root);
+    struct dentry *xaroot = NULL;
+
+    if (IS_ERR (privroot) || !privroot)
+        return privroot;
+
+    xaroot = lookup_one_len (XAROOT_NAME, privroot, strlen (XAROOT_NAME));
+    if (IS_ERR (xaroot)) {
+        goto out;
+    } else if (!xaroot->d_inode) {
+        dput (xaroot);
+        xaroot = NULL;
+        goto out;
+    }
+
+    REISERFS_SB(s)->xattr_root = dget (xaroot);
+
+out:
+    dput (privroot);
+    return xaroot;
+}
+
+/* Returns the dentry (or NULL) referring to the root of the extended
+ * attribute directory tree. If it has already been retreived, it is used.
+ * Otherwise, we attempt to retreive it from disk. It may also return
+ * a pointer-encoded error.
+ */
+static inline struct dentry *
+get_xa_root (struct super_block *s)
+{
+    struct dentry *dentry = dget (REISERFS_SB(s)->xattr_root);
+
+    if (!dentry)
+        dentry = __get_xa_root (s);
+
+    return dentry;
+}
+
+/* Opens the directory corresponding to the inode's extended attribute store.
+ * If flags allow, the tree to the directory may be created. If creation is
+ * prohibited, -ENODATA is returned. */
+static struct dentry *
+open_xa_dir (const struct inode *inode, int flags)
+{
+    struct dentry *xaroot, *xadir;
+    char namebuf[17];
+
+    xaroot = get_xa_root (inode->i_sb);
+    if (IS_ERR (xaroot)) {
+        return xaroot;
+    } else if (!xaroot) {
+        if (flags == 0 || flags & XATTR_CREATE) {
+            xaroot = create_xa_root (inode->i_sb);
+            if (IS_ERR (xaroot))
+                return xaroot;
+        }
+        if (!xaroot)
+            return ERR_PTR (-ENODATA);
+    }
+
+    /* ok, we have xaroot open */
+
+    snprintf (namebuf, sizeof (namebuf), "%X.%X",
+              le32_to_cpu (INODE_PKEY (inode)->k_objectid),
+              inode->i_generation);
+    xadir = lookup_one_len (namebuf, xaroot, strlen (namebuf));
+    if (IS_ERR (xadir)) {
+        dput (xaroot);
+        return xadir;
+    }
+
+    if (!xadir->d_inode) {
+        int err;
+        if (flags == 0 || flags & XATTR_CREATE) {
+            /* Although there is nothing else trying to create this directory,
+             * another directory with the same hash may be created, so we need
+             * to protect against that */
+            err = xaroot->d_inode->i_op->mkdir (xaroot->d_inode, xadir, 0700);
+            if (err) {
+                dput (xaroot);
+                dput (xadir);
+                return ERR_PTR (err);
+            }
+        }
+        if (!xadir->d_inode) {
+            dput (xaroot);
+            dput (xadir);
+            return ERR_PTR (-ENODATA);
+        }
+        /* Newly created object.. Need to mark it private */
+        REISERFS_I(xadir->d_inode)->i_flags |= i_priv_object;
+    }
+
+    dput (xaroot);
+    return xadir;
+}
+
+/* Returns a dentry corresponding to a specific extended attribute file
+ * for the inode. If flags allow, the file is created. Otherwise, a
+ * valid or negative dentry, or an error is returned. */
+static struct dentry *
+get_xa_file_dentry (const struct inode *inode, const char *name, int flags)
+{
+    struct dentry *xadir, *xafile;
+    int err = 0;
+
+    xadir = open_xa_dir (inode, flags);
+    if (IS_ERR (xadir)) {
+        return ERR_PTR (PTR_ERR (xadir));
+    } else if (xadir && !xadir->d_inode) {
+        dput (xadir);
+        return ERR_PTR (-ENODATA);
+    }
+
+    xafile = lookup_one_len (name, xadir, strlen (name));
+    if (IS_ERR (xafile)) {
+        dput (xadir);
+        return ERR_PTR (PTR_ERR (xafile));
+    }
+
+    if (xafile->d_inode) { /* file exists */
+        if (flags & XATTR_CREATE) {
+            err = -EEXIST;
+            dput (xafile);
+            goto out;
+        }
+    } else if (flags & XATTR_REPLACE || flags & FL_READONLY) {
+        goto out;
+    } else {
+        /* inode->i_sem is down, so nothing else can try to create
+         * the same xattr */
+        err = xadir->d_inode->i_op->create (xadir->d_inode, xafile,
+                                            0700|S_IFREG, NULL);
+
+        if (err) {
+            dput (xafile);
+            goto out;
+        }
+        /* Newly created object.. Need to mark it private */
+        REISERFS_I(xafile->d_inode)->i_flags |= i_priv_object;
+    }
+
+out:
+    dput (xadir);
+    if (err)
+        xafile = ERR_PTR (err);
+    return xafile;
+}
+
+
+/* Opens a file pointer to the attribute associated with inode */
+static struct file *
+open_xa_file (const struct inode *inode, const char *name, int flags)
+{
+    struct dentry *xafile;
+    struct file *fp;
+
+    xafile = get_xa_file_dentry (inode, name, flags);
+    if (IS_ERR (xafile))
+        return ERR_PTR (PTR_ERR (xafile));
+    else if (!xafile->d_inode) {
+        dput (xafile);
+        return ERR_PTR (-ENODATA);
+    }
+
+    fp = dentry_open (xafile, NULL, O_RDWR);
+    /* dentry_open dputs the dentry if it fails */
+
+    return fp;
+}
+
+
+/*
+ * this is very similar to fs/reiserfs/dir.c:reiserfs_readdir, but
+ * we need to drop the path before calling the filldir struct.  That
+ * would be a big performance hit to the non-xattr case, so I've copied
+ * the whole thing for now. --clm
+ *
+ * the big difference is that I go backwards through the directory,
+ * and don't mess with f->f_pos, but the idea is the same.  Do some
+ * action on each and every entry in the directory.
+ *
+ * we're called with i_sem held, so there are no worries about the directory
+ * changing underneath us.
+ */
+static int __xattr_readdir(struct file * filp, void * dirent, filldir_t filldir)
+{
+    struct inode *inode = filp->f_dentry->d_inode;
+    struct cpu_key pos_key;	/* key of current position in the directory (key of directory entry) */
+    INITIALIZE_PATH (path_to_entry);
+    struct buffer_head * bh;
+    int entry_num;
+    struct item_head * ih, tmp_ih;
+    int search_res;
+    char * local_buf;
+    loff_t next_pos;
+    char small_buf[32] ; /* avoid kmalloc if we can */
+    struct reiserfs_de_head *deh;
+    int d_reclen;
+    char * d_name;
+    off_t d_off;
+    ino_t d_ino;
+    struct reiserfs_dir_entry de;
+
+
+    /* form key for search the next directory entry using f_pos field of
+       file structure */
+    next_pos = max_reiserfs_offset(inode);
+
+    while (1) {
+research:
+	if (next_pos <= DOT_DOT_OFFSET)
+	    break;
+	make_cpu_key (&pos_key, inode, next_pos, TYPE_DIRENTRY, 3);
+
+	search_res = search_by_entry_key(inode->i_sb, &pos_key, &path_to_entry, &de);
+	if (search_res == IO_ERROR) {
+	    // FIXME: we could just skip part of directory which could
+	    // not be read
+	    pathrelse(&path_to_entry);
+	    return -EIO;
+	}
+
+	if (search_res == NAME_NOT_FOUND)
+	    de.de_entry_num--;
+
+	set_de_name_and_namelen(&de);
+	entry_num = de.de_entry_num;
+	deh = &(de.de_deh[entry_num]);
+
+	bh = de.de_bh;
+	ih = de.de_ih;
+
+	if (!is_direntry_le_ih(ih)) {
+            reiserfs_warning("not direntry %h\n", ih);
+	    break;
+        }
+	copy_item_head(&tmp_ih, ih);
+
+	/* we must have found item, that is item of this directory, */
+	RFALSE( COMP_SHORT_KEYS (&(ih->ih_key), &pos_key),
+		"vs-9000: found item %h does not match to dir we readdir %K",
+		ih, &pos_key);
+
+	if (deh_offset(deh) <= DOT_DOT_OFFSET) {
+	    break;
+	}
+
+	/* look for the previous entry in the directory */
+	next_pos = deh_offset (deh) - 1;
+
+	if (!de_visible (deh))
+	    /* it is hidden entry */
+	    continue;
+
+	d_reclen = entry_length(bh, ih, entry_num);
+	d_name = B_I_DEH_ENTRY_FILE_NAME (bh, ih, deh);
+	d_off = deh_offset (deh);
+	d_ino = deh_objectid (deh);
+
+	if (!d_name[d_reclen - 1])
+	    d_reclen = strlen (d_name);
+
+	if (d_reclen > REISERFS_MAX_NAME(inode->i_sb->s_blocksize)){
+	    /* too big to send back to VFS */
+	    continue ;
+	}
+
+        /* Ignore the .reiserfs_priv entry */
+        if (reiserfs_xattrs (inode->i_sb) &&
+            !old_format_only(inode->i_sb) &&
+            deh_objectid (deh) == le32_to_cpu (INODE_PKEY(REISERFS_SB(inode->i_sb)->priv_root->d_inode)->k_objectid))
+          continue;
+
+	if (d_reclen <= 32) {
+	  local_buf = small_buf ;
+	} else {
+	    local_buf = reiserfs_kmalloc(d_reclen, GFP_NOFS, inode->i_sb) ;
+	    if (!local_buf) {
+		pathrelse (&path_to_entry);
+		return -ENOMEM ;
+	    }
+	    if (item_moved (&tmp_ih, &path_to_entry)) {
+		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+
+		/* sigh, must retry.  Do this same offset again */
+		next_pos = d_off;
+		goto research;
+	    }
+	}
+
+	// Note, that we copy name to user space via temporary
+	// buffer (local_buf) because filldir will block if
+	// user space buffer is swapped out. At that time
+	// entry can move to somewhere else
+	memcpy (local_buf, d_name, d_reclen);
+
+	/* the filldir function might need to start transactions,
+	 * or do who knows what.  Release the path now that we've
+	 * copied all the important stuff out of the deh
+	 */
+	pathrelse (&path_to_entry);
+
+	if (filldir (dirent, local_buf, d_reclen, d_off, d_ino,
+		     DT_UNKNOWN) < 0) {
+	    if (local_buf != small_buf) {
+		reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+	    }
+	    goto end;
+	}
+	if (local_buf != small_buf) {
+	    reiserfs_kfree(local_buf, d_reclen, inode->i_sb) ;
+	}
+    } /* while */
+
+end:
+    pathrelse (&path_to_entry);
+    return 0;
+}
+
+/*
+ * this could be done with dedicated readdir ops for the xattr files,
+ * but I want to get something working asap
+ * this is stolen from vfs_readdir
+ *
+ */
+static
+int xattr_readdir(struct file *file, filldir_t filler, void *buf)
+{
+        struct inode *inode = file->f_dentry->d_inode;
+        int res = -ENOTDIR;
+        if (!file->f_op || !file->f_op->readdir)
+                goto out;
+        down(&inode->i_sem);
+//        down(&inode->i_zombie);
+        res = -ENOENT;
+        if (!IS_DEADDIR(inode)) {
+                lock_kernel();
+                res = __xattr_readdir(file, buf, filler);
+                unlock_kernel();
+        }
+//        up(&inode->i_zombie);
+        up(&inode->i_sem);
+out:
+        return res;
+}
+
+
+/* Internal operations on file data */
+static inline void
+reiserfs_put_page(struct page *page)
+{
+        kunmap(page);
+        page_cache_release(page);
+}
+
+static struct page *
+reiserfs_get_page(struct inode *dir, unsigned long n)
+{
+        struct address_space *mapping = dir->i_mapping;
+        struct page *page;
+        /* We can deadlock if we try to free dentries,
+           and an unlink/rmdir has just occured - GFP_NOFS avoids this */
+        mapping->flags = (mapping->flags & ~__GFP_BITS_MASK) | GFP_NOFS;
+        page = read_cache_page (mapping, n,
+                                (filler_t*)mapping->a_ops->readpage, NULL);
+        if (!IS_ERR(page)) {
+                wait_on_page_locked(page);
+                kmap(page);
+                if (!PageUptodate(page))
+                        goto fail;
+
+                if (PageError(page))
+                        goto fail;
+        }
+        return page;
+
+fail:
+        reiserfs_put_page(page);
+        return ERR_PTR(-EIO);
+}
+
+static inline __u32
+xattr_hash (const char *msg, int len)
+{
+    return csum_partial (msg, len, 0);
+}
+
+/* Generic extended attribute operations that can be used by xa plugins */
+
+/*
+ * inode->i_sem: down
+ */
+int
+reiserfs_xattr_set (struct inode *inode, const char *name, const void *buffer,
+                    size_t buffer_size, int flags)
+{
+    int err = 0;
+    struct file *fp;
+    struct page *page;
+    char *data;
+    struct address_space *mapping;
+    size_t file_pos = 0;
+    size_t buffer_pos = 0;
+    struct inode *xinode;
+    struct iattr newattrs;
+    __u32 xahash = 0;
+
+    if (IS_RDONLY (inode))
+        return -EROFS;
+
+    if (IS_IMMUTABLE (inode) || IS_APPEND (inode))
+        return -EPERM;
+
+    if (get_inode_sd_version (inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    /* Empty xattrs are ok, they're just empty files, no hash */
+    if (buffer && buffer_size)
+        xahash = xattr_hash (buffer, buffer_size);
+
+open_file:
+    fp = open_xa_file (inode, name, flags);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        goto out;
+    }
+
+    xinode = fp->f_dentry->d_inode;
+
+    /* we need to copy it off.. */
+    if (xinode->i_nlink > 1) {
+	fput(fp);
+        err = reiserfs_xattr_del (inode, name);
+        if (err < 0)
+            goto out;
+        /* We just killed the old one, we're not replacing anymore */
+        if (flags & XATTR_REPLACE)
+            flags &= ~XATTR_REPLACE;
+        goto open_file;
+    }
+
+    /* Resize it so we're ok to write there */
+    newattrs.ia_size = buffer_size;
+    newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
+    down (&xinode->i_sem);
+    err = notify_change(fp->f_dentry, &newattrs);
+    if (err)
+        goto out_filp;
+
+    mapping = xinode->i_mapping;
+    while (buffer_pos < buffer_size || buffer_pos == 0) {
+        size_t chunk;
+        size_t skip = 0;
+        size_t page_offset = (file_pos & (PAGE_CACHE_SIZE - 1));
+        if (buffer_size - buffer_pos > PAGE_CACHE_SIZE)
+            chunk = PAGE_CACHE_SIZE;
+        else
+            chunk = buffer_size - buffer_pos;
+
+        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
+        if (IS_ERR (page)) {
+            err = PTR_ERR (page);
+            goto out_filp;
+        }
+
+        lock_page (page);
+        data = page_address (page);
+
+        if (file_pos == 0) {
+            struct reiserfs_xattr_header *rxh;
+            skip = file_pos = sizeof (struct reiserfs_xattr_header);
+            if (chunk + skip > PAGE_CACHE_SIZE)
+                chunk = PAGE_CACHE_SIZE - skip;
+            rxh = (struct reiserfs_xattr_header *)data;
+            rxh->h_magic = cpu_to_le32 (REISERFS_XATTR_MAGIC);
+            rxh->h_hash = cpu_to_le32 (xahash);
+        }
+
+        err = mapping->a_ops->prepare_write (fp, page, page_offset,
+                                             page_offset + chunk + skip);
+        if (!err) {
+	    if (buffer)
+		memcpy (data + skip, buffer + buffer_pos, chunk);
+            err = mapping->a_ops->commit_write (fp, page, page_offset,
+                                                page_offset + chunk + skip);
+	}
+        unlock_page (page);
+        reiserfs_put_page (page);
+        buffer_pos += chunk;
+        file_pos += chunk;
+        skip = 0;
+        if (err || buffer_size == 0 || !buffer)
+            break;
+    }
+
+    inode->i_ctime = CURRENT_TIME;
+    mark_inode_dirty (inode);
+
+out_filp:
+    up (&xinode->i_sem);
+    fput(fp);
+
+out:
+    return err;
+}
+
+/*
+ * inode->i_sem: down
+ */
+int
+reiserfs_xattr_get (const struct inode *inode, const char *name, void *buffer,
+                    size_t buffer_size)
+{
+    ssize_t err = 0;
+    struct file *fp;
+    size_t isize;
+    size_t file_pos = 0;
+    size_t buffer_pos = 0;
+    struct page *page;
+    struct inode *xinode;
+    __u32 hash = 0;
+
+    if (name == NULL)
+        return -EINVAL;
+
+    /* We can't have xattrs attached to v1 items since they don't have
+     * generation numbers */
+    if (get_inode_sd_version (inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    fp = open_xa_file (inode, name, FL_READONLY);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        goto out;
+    }
+
+    xinode = fp->f_dentry->d_inode;
+    isize = xinode->i_size;
+
+    /* Just return the size needed */
+    if (buffer == NULL) {
+        err = isize - sizeof (struct reiserfs_xattr_header);
+        goto out_dput;
+    }
+
+    if (buffer_size < isize - sizeof (struct reiserfs_xattr_header)) {
+        err = -ERANGE;
+        goto out_dput;
+    }
+
+    while (file_pos < isize) {
+        size_t chunk;
+        char *data;
+        size_t skip = 0;
+        if (isize - file_pos > PAGE_CACHE_SIZE)
+            chunk = PAGE_CACHE_SIZE;
+        else
+            chunk = isize - file_pos;
+
+        page = reiserfs_get_page (xinode, file_pos >> PAGE_CACHE_SHIFT);
+        if (IS_ERR (page)) {
+            err = PTR_ERR (page);
+            goto out_dput;
+        }
+
+        lock_page (page);
+        data = page_address (page);
+        if (file_pos == 0) {
+            struct reiserfs_xattr_header *rxh =
+                                        (struct reiserfs_xattr_header *)data;
+            skip = file_pos = sizeof (struct reiserfs_xattr_header);
+            chunk -= skip;
+            /* Magic doesn't match up.. */
+            if (rxh->h_magic != cpu_to_le32 (REISERFS_XATTR_MAGIC)) {
+                unlock_page (page);
+                reiserfs_put_page (page);
+                reiserfs_warning ("reiserfs: Invalid magic for xattr (%s) "
+                                  "associated with %s %k\n", name,
+                                  reiserfs_bdevname (inode->i_sb),
+                                  INODE_PKEY (inode));
+                err = -EIO;
+                goto out_dput;
+            }
+            hash = le32_to_cpu (rxh->h_hash);
+        }
+        memcpy (buffer + buffer_pos, data + skip, chunk);
+        unlock_page (page);
+        reiserfs_put_page (page);
+        file_pos += chunk;
+        buffer_pos += chunk;
+        skip = 0;
+    }
+    err = isize - sizeof (struct reiserfs_xattr_header);
+
+    if (xattr_hash (buffer, isize - sizeof (struct reiserfs_xattr_header)) != hash) {
+        reiserfs_warning ("reiserfs: Invalid hash for xattr (%s) associated "
+                          "with %s %k\n", name,
+                          reiserfs_bdevname (inode->i_sb), INODE_PKEY (inode));
+        err = -EIO;
+    }
+
+out_dput:
+    fput(fp);
+
+out:
+    return err;
+}
+
+static int
+__reiserfs_xattr_del (struct dentry *xadir, const char *name, int namelen)
+{
+    struct dentry *dentry;
+    struct inode *dir = xadir->d_inode;
+    int err = 0;
+
+    dentry = lookup_one_len (name, xadir, namelen);
+    if (IS_ERR (dentry)) {
+        err = PTR_ERR (dentry);
+        goto out;
+    } else if (!dentry->d_inode) {
+        err = -ENODATA;
+        goto out_file;
+    }
+
+    /* Skip directories.. */
+    if (S_ISDIR (dentry->d_inode->i_mode))
+        goto out_file;
+
+    if (!is_reiserfs_priv_object (dentry->d_inode)) {
+        reiserfs_warning ("OID %08x [%.*s/%.*s] doesn't have priv flag set [parent is %sset].\n",
+                        le32_to_cpu (INODE_PKEY (dentry->d_inode)->k_objectid),
+                        xadir->d_name.len, xadir->d_name.name, namelen, name,
+                        is_reiserfs_priv_object (xadir->d_inode) ? "" : "not ");
+        dput (dentry);
+        return -EIO;
+    }
+
+    err = dir->i_op->unlink (dir, dentry);
+    if (!err)
+        d_delete (dentry);
+
+out_file:
+    dput (dentry);
+
+out:
+    return err;
+}
+
+
+int
+reiserfs_xattr_del (struct inode *inode, const char *name)
+{
+    struct dentry *dir;
+    int err;
+
+    if (IS_RDONLY (inode))
+        return -EROFS;
+
+    dir = open_xa_dir (inode, FL_READONLY);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        goto out;
+    }
+
+    err = __reiserfs_xattr_del (dir, name, strlen (name));
+    dput (dir);
+
+out:
+    return err;
+}
+
+/* The following are side effects of other operations that aren't explicitly
+ * modifying extended attributes. This includes operations such as permissions
+ * or ownership changes, object deletions, etc. */
+
+static int
+reiserfs_delete_xattrs_filler (void *buf, const char *name, int namelen,
+                               loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct dentry *xadir = (struct dentry *)buf;
+
+    return __reiserfs_xattr_del (xadir, name, namelen);
+
+}
+
+/* This is called w/ inode->i_sem downed */
+int
+reiserfs_delete_xattrs (struct inode *inode)
+{
+    struct file *fp;
+    struct dentry *dir, *root;
+    int err = 0;
+
+    /* Skip out, an xattr has no xattrs associated with it */
+    if (is_reiserfs_priv_object (inode) ||
+        get_inode_sd_version (inode) == STAT_DATA_V1 ||
+        !reiserfs_xattrs(inode->i_sb))
+    {
+        return 0;
+    }
+    reiserfs_read_lock_xattrs (inode->i_sb);
+    dir = open_xa_dir (inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (inode->i_sb);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        goto out;
+    } else if (!dir->d_inode) {
+        dput (dir);
+        return 0;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    lock_kernel ();
+    err = xattr_readdir (fp, reiserfs_delete_xattrs_filler, dir);
+    if (err) {
+        unlock_kernel ();
+        goto out_dir;
+    }
+
+    /* Leftovers besides . and .. -- that's not good. */
+    if (dir->d_inode->i_nlink <= 2) {
+        root = get_xa_root (inode->i_sb);
+        reiserfs_write_lock_xattrs (inode->i_sb);
+        err = vfs_rmdir (root->d_inode, dir);
+        reiserfs_write_unlock_xattrs (inode->i_sb);
+        dput (root);
+    } else {
+        reiserfs_warning ("Couldn't remove all entries in directory\n");
+    }
+    unlock_kernel ();
+
+out_dir:
+    fput(fp);
+
+out:
+    return err;
+}
+
+struct reiserfs_chown_buf {
+    struct inode *inode;
+    struct dentry *xadir;
+    struct iattr *attrs;
+};
+
+/* XXX: If there is a better way to do this, I'd love to hear about it */
+static int
+reiserfs_chown_xattrs_filler (void *buf, const char *name, int namelen,
+                               loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct reiserfs_chown_buf *chown_buf = (struct reiserfs_chown_buf *)buf;
+    struct dentry *xafile, *xadir = chown_buf->xadir;
+    struct iattr *attrs = chown_buf->attrs;
+    int err = 0;
+
+    xafile = lookup_one_len (name, xadir, namelen);
+    if (IS_ERR (xafile))
+        return PTR_ERR (xafile);
+    else if (!xafile->d_inode) {
+        dput (xafile);
+        return -ENODATA;
+    }
+
+    if (!S_ISDIR (xafile->d_inode->i_mode))
+        err = notify_change (xafile, attrs);
+    dput (xafile);
+
+    return err;
+}
+
+int
+reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs)
+{
+    struct file *fp;
+    struct dentry *dir;
+    int err = 0;
+    struct reiserfs_chown_buf buf;
+    unsigned int ia_valid = attrs->ia_valid;
+
+    /* Skip out, an xattr has no xattrs associated with it */
+    if (is_reiserfs_priv_object (inode) ||
+        get_inode_sd_version (inode) == STAT_DATA_V1 ||
+        !reiserfs_xattrs(inode->i_sb))
+    {
+        return 0;
+    }
+    reiserfs_read_lock_xattrs (inode->i_sb);
+    dir = open_xa_dir (inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (inode->i_sb);
+    if (IS_ERR (dir)) {
+        if (PTR_ERR (dir) != -ENODATA)
+            err = PTR_ERR (dir);
+        goto out;
+    } else if (!dir->d_inode) {
+        dput (dir);
+        goto out;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    lock_kernel ();
+
+    attrs->ia_valid &= (ATTR_UID | ATTR_GID | ATTR_CTIME);
+    buf.xadir = dir;
+    buf.attrs = attrs;
+    buf.inode = inode;
+
+    err = xattr_readdir (fp, reiserfs_chown_xattrs_filler, &buf);
+    if (err) {
+        unlock_kernel ();
+        goto out_dir;
+    }
+
+    err = notify_change (dir, attrs);
+    unlock_kernel ();
+
+out_dir:
+    fput(fp);
+
+out:
+    attrs->ia_valid = ia_valid;
+    return err;
+}
+
+
+/* Actual operations that are exported to VFS-land */
+
+/*
+ * Inode operation getxattr()
+ * Preliminary locking: we down dentry->d_inode->i_sem
+ */
+ssize_t
+reiserfs_getxattr (struct dentry *dentry, const char *name, void *buffer,
+                   size_t size)
+{
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+    int err;
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    down (&dentry->d_inode->i_sem);
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+    err = xah->get (dentry->d_inode, name, buffer, size);
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    up (&dentry->d_inode->i_sem);
+    return err;
+}
+
+
+/*
+ * Inode operation setxattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+reiserfs_setxattr (struct dentry *dentry, const char *name, const void *value,
+                   size_t size, int flags)
+{
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+    int err;
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    if (IS_RDONLY (dentry->d_inode))
+        return -EROFS;
+
+    if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
+        return -EROFS;
+
+    reiserfs_write_lock_xattrs (dentry->d_sb);
+    err = xah->set (dentry->d_inode, name, value, size, flags);
+    reiserfs_write_unlock_xattrs (dentry->d_sb);
+    return err;
+}
+
+/*
+ * Inode operation removexattr()
+ *
+ * dentry->d_inode->i_sem down
+ */
+int
+reiserfs_removexattr (struct dentry *dentry, const char *name)
+{
+    int err;
+    struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+
+    if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    if (IS_RDONLY (dentry->d_inode))
+        return -EROFS;
+
+    if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
+        return -EPERM;
+
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+
+    /* Deletion pre-operation */
+    if (xah->del) {
+        err = xah->del (dentry->d_inode, name);
+        if (err)
+            goto out;
+    }
+
+    err = reiserfs_xattr_del (dentry->d_inode, name);
+
+    dentry->d_inode->i_ctime = CURRENT_TIME;
+    mark_inode_dirty (dentry->d_inode);
+
+out:
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    return err;
+}
+
+
+/* This is what filldir will use:
+ * r_pos will always contain the amount of space required for the entire
+ * list. If r_pos becomes larger than r_size, we need more space and we
+ * return an error indicating this. If r_pos is less than r_size, then we've
+ * filled the buffer successfully and we return success */
+struct reiserfs_listxattr_buf {
+    int r_pos;
+    int r_size;
+    char *r_buf;
+    struct inode *r_inode;
+};
+
+static int
+reiserfs_listxattr_filler (void *buf, const char *name, int namelen,
+                           loff_t offset, ino_t ino, unsigned int d_type)
+{
+    struct reiserfs_listxattr_buf *b = (struct reiserfs_listxattr_buf *)buf;
+    int len = 0;
+    if (name[0] != '.' || (namelen != 1 && (name[1] != '.' || namelen != 2))) {
+        struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+        if (!xah) return 0; /* Unsupported xattr name, skip it */
+
+        /* We call ->list() twice because the operation isn't required to just
+         * return the name back - we want to make sure we have enough space */
+        len += xah->list (b->r_inode, name, namelen, NULL);
+
+        if (len) {
+            if (b->r_pos + len + 1 <= b->r_size) {
+                char *p = b->r_buf + b->r_pos;
+                p += xah->list (b->r_inode, name, namelen, p);
+                *p++ = '\0';
+            }
+            b->r_pos += len + 1;
+        }
+    }
+
+    return 0;
+}
+/*
+ * Inode operation listxattr()
+ *
+ * Preliminary locking: we down dentry->d_inode->i_sem
+ */
+ssize_t
+reiserfs_listxattr (struct dentry *dentry, char *buffer, size_t size)
+{
+    struct file *fp;
+    struct dentry *dir;
+    int err = 0;
+    struct reiserfs_listxattr_buf buf;
+
+    if (!dentry->d_inode)
+        return -EINVAL;
+
+    if (!reiserfs_xattrs(dentry->d_sb) ||
+        get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
+        return -EOPNOTSUPP;
+
+    down (&dentry->d_inode->i_sem);
+    reiserfs_read_lock_xattrs (dentry->d_sb);
+    dir = open_xa_dir (dentry->d_inode, FL_READONLY);
+    reiserfs_read_unlock_xattrs (dentry->d_sb);
+    if (IS_ERR (dir)) {
+        err = PTR_ERR (dir);
+        if (err == -ENODATA)
+            err = 0; /* Not an error if there aren't any xattrs */
+        goto out;
+    }
+
+    fp = dentry_open (dir, NULL, O_RDWR);
+    if (IS_ERR (fp)) {
+        err = PTR_ERR (fp);
+        /* dentry_open dputs the dentry if it fails */
+        goto out;
+    }
+
+    buf.r_buf = buffer;
+    buf.r_size = buffer ? size : 0;
+    buf.r_pos = 0;
+    buf.r_inode = dentry->d_inode;
+
+    err = xattr_readdir (fp, reiserfs_listxattr_filler, &buf);
+    if (err)
+        goto out_dir;
+
+    if (buf.r_pos > buf.r_size && buffer != NULL)
+        err = -ERANGE;
+    else
+        err = buf.r_pos;
+
+out_dir:
+    fput(fp);
+
+out:
+    up (&dentry->d_inode->i_sem);
+    return err;
+}
+
+/* This is the implementation for the xattr plugin infrastructure */
+static struct list_head xattr_handlers = LIST_HEAD_INIT (xattr_handlers);
+static rwlock_t handler_lock = RW_LOCK_UNLOCKED;
+
+static struct reiserfs_xattr_handler *
+find_xattr_handler_prefix (const char *prefix)
+{
+    struct reiserfs_xattr_handler *xah = NULL;
+    struct list_head *p;
+
+    read_lock (&handler_lock);
+    list_for_each (p, &xattr_handlers) {
+        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
+        if (strncmp (xah->prefix, prefix, strlen (xah->prefix)) == 0)
+            break;
+        xah = NULL;
+    }
+
+    read_unlock (&handler_lock);
+    return xah;
+}
+
+static void
+__unregister_handlers (void)
+{
+    struct reiserfs_xattr_handler *xah;
+    struct list_head *p, *tmp;
+
+    list_for_each_safe (p, tmp, &xattr_handlers) {
+        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
+        if (xah->exit)
+            xah->exit();
+
+        list_del_init (p);
+    }
+    INIT_LIST_HEAD (&xattr_handlers);
+}
+
+int __init
+reiserfs_xattr_register_handlers (void)
+{
+    int err = 0;
+    struct reiserfs_xattr_handler *xah;
+    struct list_head *p;
+
+    write_lock (&handler_lock);
+
+    /* If we're already initialized, nothing to do */
+    if (!list_empty (&xattr_handlers)) {
+        write_unlock (&handler_lock);
+        return 0;
+    }
+
+    /* Add the handlers */
+    list_add_tail (&user_handler.handlers, &xattr_handlers);
+
+    /* Run initializers, if available */
+    list_for_each (p, &xattr_handlers) {
+        xah = list_entry (p, struct reiserfs_xattr_handler, handlers);
+        if (xah->init) {
+            err = xah->init ();
+            if (err) {
+                list_del_init (p);
+                break;
+            }
+        }
+    }
+
+    /* Clean up other handlers, if any failed */
+    if (err)
+        __unregister_handlers ();
+
+    write_unlock (&handler_lock);
+    return err;
+}
+
+void
+reiserfs_xattr_unregister_handlers (void)
+{
+    write_lock (&handler_lock);
+    __unregister_handlers ();
+    write_unlock (&handler_lock);
+}
+
+/* This will catch lookups from the fs root to .reiserfs_priv */
+static int
+xattr_lookup_poison (struct dentry *dentry, struct qstr *q1, struct qstr *name)
+{
+    struct dentry *priv_root = REISERFS_SB(dentry->d_sb)->priv_root;
+    if (name->len == priv_root->d_name.len &&
+        name->hash == priv_root->d_name.hash &&
+        !memcmp (name->name, priv_root->d_name.name, name->len)) {
+            return -ENOENT;
+    }
+    return 0;
+}
+
+static struct dentry_operations xattr_lookup_poison_ops = {
+    .d_compare = xattr_lookup_poison,
+};
+
+
+/* We need to take a copy of the mount flags since things like
+ * MS_RDONLY don't get set until *after* we're called.
+ * mount_flags != mount_options */
+int
+reiserfs_xattr_init (struct super_block *s, int mount_flags)
+{
+  int err = 0;
+
+  /* We need generation numbers to ensure that the oid mapping is correct
+   * v3.5 filesystems don't have them. */
+  if (!old_format_only (s)) {
+    set_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+  } else if (reiserfs_xattrs_optional (s)) {
+    /* Old format filesystem, but optional xattrs have been enabled
+     * at mount time. Error out. */
+    reiserfs_warning ("reiserfs: xattrs not supported on pre v3.6 "
+                      "format filesystem. Failing mount.\n");
+    err = -EOPNOTSUPP;
+    goto error;
+  } else {
+    /* Old format filesystem, but no optional xattrs have been enabled. This
+     * means we silently disable xattrs on the filesystem. */
+    clear_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+  }
+
+  /* If we don't have the privroot located yet - go find it */
+  if (reiserfs_xattrs (s) && !REISERFS_SB(s)->priv_root) {
+      struct dentry *dentry;
+      dentry = lookup_one_len (PRIVROOT_NAME, s->s_root,
+                               strlen (PRIVROOT_NAME));
+      if (!IS_ERR (dentry)) {
+        if (!(mount_flags & MS_RDONLY) && !dentry->d_inode) {
+            struct inode *inode = dentry->d_parent->d_inode;
+            down (&inode->i_sem);
+            err = inode->i_op->mkdir (inode, dentry, 0700);
+            up (&inode->i_sem);
+            if (err) {
+                dput (dentry);
+                dentry = NULL;
+            }
+
+            if (dentry && dentry->d_inode)
+                reiserfs_warning ("reiserfs: Created %s on %s - reserved for "
+                                  "xattr storage.\n", PRIVROOT_NAME,
+                                  reiserfs_bdevname (inode->i_sb));
+        } else if (!dentry->d_inode) {
+            dput (dentry);
+            dentry = NULL;
+        }
+      } else
+        err = PTR_ERR (dentry);
+
+      if (!err && dentry) {
+          s->s_root->d_op = &xattr_lookup_poison_ops;
+          REISERFS_I(dentry->d_inode)->i_flags |= i_priv_object;
+          REISERFS_SB(s)->priv_root = dentry;
+      } else if (!(mount_flags & MS_RDONLY)) { /* xattrs are unavailable */
+          /* If we're read-only it just means that the dir hasn't been
+           * created. Not an error -- just no xattrs on the fs. We'll
+           * check again if we go read-write */
+          reiserfs_warning ("reiserfs: xattrs enabled and couldn't "
+                            "find/create .reiserfs_priv. Failing mount.\n");
+          err = -EOPNOTSUPP;
+      }
+  }
+
+error:
+   /* This is only nonzero if there was an error initializing the xattr
+    * directory or if there is a condition where we don't support them. */
+    if (err) {
+          clear_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
+          clear_bit (REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
+    }
+    return err;
+}
+
+int
+reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd)
+{
+	umode_t			mode = inode->i_mode;
+
+	if (mask & MAY_WRITE) {
+		/*
+		 * Nobody gets write access to a read-only fs.
+		 */
+		if (IS_RDONLY(inode) &&
+		    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+			return -EROFS;
+
+		/*
+		 * Nobody gets write access to an immutable file.
+		 */
+		if (IS_IMMUTABLE(inode))
+			return -EACCES;
+	}
+
+	/* We don't do permission checks on the internal objects.
+	* Permissions are determined by the "owning" object. */
+        if (is_reiserfs_priv_object (inode))
+		return 0;
+
+	if (current->fsuid == inode->i_uid)
+		mode >>= 6;
+	else if (in_group_p(inode->i_gid))
+		mode >>= 3;
+
+	/*
+	 * If the DACs are ok we don't need any capability check.
+	 */
+	if (((mode & mask & (MAY_READ|MAY_WRITE|MAY_EXEC)) == mask))
+		return 0;
+
+	/*
+	 * Read/write DACs are always overridable.
+	 * Executable DACs are overridable if at least one exec bit is set.
+	 */
+	if ((mask & (MAY_READ|MAY_WRITE)) || (inode->i_mode & S_IXUGO))
+		if (capable(CAP_DAC_OVERRIDE))
+			return 0;
+
+	/*
+	 * Searching includes executable on directories, else just read.
+	 */
+	if (mask == MAY_READ || (S_ISDIR(inode->i_mode) && !(mask & MAY_WRITE)))
+		if (capable(CAP_DAC_READ_SEARCH))
+			return 0;
+
+	return -EACCES;
+
+}
Index: linux.mm/fs/reiserfs/xattr_user.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr_user.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/fs/reiserfs/xattr_user.c	2004-04-23 14:09:45.767532236 -0400
@@ -0,0 +1,95 @@
+#include <linux/reiserfs_fs.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <asm/uaccess.h>
+
+#define XATTR_USER_PREFIX "user."
+
+static int
+user_get (struct inode *inode, const char *name, void *buffer, size_t size)
+{
+
+    int error;
+
+    if (strlen(name) < sizeof(XATTR_USER_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    error = permission (inode, MAY_READ, NULL);
+    if (error)
+        return error;
+
+    return reiserfs_xattr_get (inode, name, buffer, size);
+}
+
+static int
+user_set (struct inode *inode, const char *name, const void *buffer,
+          size_t size, int flags)
+{
+
+    int error;
+
+    if (strlen(name) < sizeof(XATTR_USER_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!S_ISREG (inode->i_mode) &&
+        (!S_ISDIR (inode->i_mode) || inode->i_mode & S_ISVTX))
+        return -EPERM;
+
+    error = permission (inode, MAY_WRITE, NULL);
+    if (error)
+        return error;
+
+    return reiserfs_xattr_set (inode, name, buffer, size, flags);
+}
+
+static int
+user_del (struct inode *inode, const char *name)
+{
+    int error;
+
+    if (strlen(name) < sizeof(XATTR_USER_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!S_ISREG (inode->i_mode) &&
+        (!S_ISDIR (inode->i_mode) || inode->i_mode & S_ISVTX))
+        return -EPERM;
+
+    error = permission (inode, MAY_WRITE, NULL);
+    if (error)
+        return error;
+
+    return 0;
+}
+
+static int
+user_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+    if (!reiserfs_xattrs_user (inode->i_sb))
+        return 0;
+
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+struct reiserfs_xattr_handler user_handler = {
+    prefix: XATTR_USER_PREFIX,
+    get: user_get,
+    set: user_set,
+    del: user_del,
+    list: user_list,
+};
Index: linux.mm/include/linux/reiserfs_fs.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs.h	2004-04-23 14:08:24.288315317 -0400
+++ linux.mm/include/linux/reiserfs_fs.h	2004-04-23 14:09:45.771531756 -0400
@@ -287,7 +287,7 @@ struct unfm_nodeinfo {
 #define STAT_DATA_V2 1
 
 
-static inline struct reiserfs_inode_info *REISERFS_I(struct inode *inode)
+static inline struct reiserfs_inode_info *REISERFS_I(const struct inode *inode)
 {
 	return container_of(inode, struct reiserfs_inode_info, vfs_inode);
 }
@@ -1960,6 +1960,7 @@ void reiserfs_update_sd (struct reiserfs
 
 void sd_attrs_to_i_attrs( __u16 sd_attrs, struct inode *inode );
 void i_attrs_to_sd_attrs( struct inode *inode, __u16 *sd_attrs );
+int reiserfs_setattr(struct dentry *dentry, struct iattr *attr);
 
 /* namei.c */
 void set_de_name_and_namelen (struct reiserfs_dir_entry * de);
@@ -2010,6 +2011,8 @@ int reiserfs_global_version_in_proc( cha
 
 /* dir.c */
 extern struct inode_operations reiserfs_dir_inode_operations;
+extern struct inode_operations reiserfs_symlink_inode_operations;
+extern struct inode_operations reiserfs_special_inode_operations;
 extern struct file_operations reiserfs_dir_operations;
 
 /* tail_conversion.c */
@@ -2237,6 +2240,9 @@ int reiserfs_unpack (struct inode * inod
 #define reiserfs_write_lock( sb ) lock_kernel()
 #define reiserfs_write_unlock( sb ) unlock_kernel()
  			         
+/* xattr stuff */
+#define REISERFS_XATTR_DIR_SEM(s) (REISERFS_SB(s)->xattr_dir_sem)
+
 #endif /* _LINUX_REISER_FS_H */
 
 
Index: linux.mm/include/linux/reiserfs_fs_i.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs_i.h	2004-04-23 14:08:24.290315077 -0400
+++ linux.mm/include/linux/reiserfs_fs_i.h	2004-04-23 14:09:45.772531636 -0400
@@ -22,7 +22,8 @@ typedef enum {
       truncate or unlink. Safe link is used to avoid leakage of disk
       space on crash with some files open, but unlinked. */
     i_link_saved_unlink_mask   =  0x0010,
-    i_link_saved_truncate_mask =  0x0020
+    i_link_saved_truncate_mask =  0x0020,
+    i_priv_object              =  0x0080,
 } reiserfs_inode_flags;
 
 
Index: linux.mm/include/linux/reiserfs_fs_sb.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs_sb.h	2004-04-23 14:08:24.304313396 -0400
+++ linux.mm/include/linux/reiserfs_fs_sb.h	2004-04-23 14:09:45.774531396 -0400
@@ -6,6 +6,7 @@
 
 #ifdef __KERNEL__
 #include <linux/workqueue.h>
+#include <linux/rwsem.h>
 #endif
 
 typedef enum {
@@ -251,7 +252,6 @@ struct reiserfs_journal {
 
 #define JOURNAL_DESC_MAGIC "ReIsErLB" /* ick.  magic string to find desc blocks in the journal */
 
-
 typedef __u32 (*hashf_t) (const signed char *, int);
 
 struct reiserfs_bitmap_info
@@ -395,6 +395,10 @@ struct reiserfs_sb_info
     struct proc_dir_entry *procdir;
     int reserved_blocks; /* amount of blocks reserved for further allocations */
     spinlock_t bitmap_lock; /* this lock on now only used to protect reserved_blocks variable */
+    struct dentry *priv_root; /* root of /.reiserfs_priv */
+    struct dentry *xattr_root; /* root of /.reiserfs_priv/.xa */
+    struct rw_semaphore xattr_dir_sem;
+
 };
 
 /* Definitions of reiserfs on-disk properties: */
@@ -437,6 +441,8 @@ enum reiserfs_mount_options {
     REISERFS_NO_UNHASHED_RELOCATION,
     REISERFS_HASHED_RELOCATION,
     REISERFS_ATTRS,
+    REISERFS_XATTRS,
+    REISERFS_XATTRS_USER,
 
     REISERFS_TEST1,
     REISERFS_TEST2,
@@ -462,6 +468,9 @@ enum reiserfs_mount_options {
 #define reiserfs_data_log(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_DATA_LOG))
 #define reiserfs_data_ordered(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_DATA_ORDERED))
 #define reiserfs_data_writeback(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_DATA_WRITEBACK))
+#define reiserfs_xattrs(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_XATTRS))
+#define reiserfs_xattrs_user(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_XATTRS_USER))
+#define reiserfs_xattrs_optional(s) reiserfs_xattrs_user(s)
 
 void reiserfs_file_buffer (struct buffer_head * bh, int list);
 extern struct file_system_type reiserfs_fs_type;
Index: linux.mm/include/linux/reiserfs_xattr.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_xattr.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/include/linux/reiserfs_xattr.h	2004-04-23 14:09:45.776531156 -0400
@@ -0,0 +1,100 @@
+/*
+  File: linux/reiserfs_xattr.h
+*/
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+
+/* Magic value in header */
+#define REISERFS_XATTR_MAGIC 0x52465841 /* "RFXA" */
+
+struct reiserfs_xattr_header {
+    __u32 h_magic;              /* magic number for identification */
+    __u32 h_hash;               /* hash of the value */
+};
+
+#ifdef __KERNEL__
+
+struct reiserfs_xattr_handler {
+	char *prefix;
+        int (*init)(void);
+        void (*exit)(void);
+	int (*get)(struct inode *inode, const char *name, void *buffer,
+		   size_t size);
+	int (*set)(struct inode *inode, const char *name, const void *buffer,
+		   size_t size, int flags);
+	int (*del)(struct inode *inode, const char *name);
+        int (*list)(struct inode *inode, const char *name, int namelen, char *out);
+        struct list_head handlers;
+};
+
+
+#ifdef CONFIG_REISERFS_FS_XATTR
+#define is_reiserfs_priv_object(inode) (REISERFS_I(inode)->i_flags & i_priv_object)
+ssize_t reiserfs_getxattr (struct dentry *dentry, const char *name,
+			   void *buffer, size_t size);
+int reiserfs_setxattr (struct dentry *dentry, const char *name,
+                       const void *value, size_t size, int flags);
+ssize_t reiserfs_listxattr (struct dentry *dentry, char *buffer, size_t size);
+int reiserfs_removexattr (struct dentry *dentry, const char *name);
+int reiserfs_delete_xattrs (struct inode *inode);
+int reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs);
+int reiserfs_xattr_init (struct super_block *sb, int mount_flags);
+int reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd);
+
+int reiserfs_xattr_del (struct inode *, const char *);
+int reiserfs_xattr_get (const struct inode *, const char *, void *, size_t);
+int reiserfs_xattr_set (struct inode *, const char *, const void *,
+                               size_t, int);
+
+extern struct reiserfs_xattr_handler user_handler;
+
+int reiserfs_xattr_register_handlers (void) __init;
+void reiserfs_xattr_unregister_handlers (void);
+
+static inline void
+reiserfs_write_lock_xattrs(struct super_block *sb)
+{
+    down_write (&REISERFS_XATTR_DIR_SEM(sb));
+}
+static inline void
+reiserfs_write_unlock_xattrs(struct super_block *sb)
+{
+    up_write (&REISERFS_XATTR_DIR_SEM(sb));
+}
+static inline void
+reiserfs_read_lock_xattrs(struct super_block *sb)
+{
+    down_read (&REISERFS_XATTR_DIR_SEM(sb));
+}
+
+static inline void
+reiserfs_read_unlock_xattrs(struct super_block *sb)
+{
+    up_read (&REISERFS_XATTR_DIR_SEM(sb));
+}
+
+#else
+
+#define is_reiserfs_priv_object(inode) 0
+#define reiserfs_getxattr NULL
+#define reiserfs_setxattr NULL
+#define reiserfs_listxattr NULL
+#define reiserfs_removexattr NULL
+#define reiserfs_write_lock_xattrs(sb)
+#define reiserfs_write_unlock_xattrs(sb)
+#define reiserfs_read_lock_xattrs(sb)
+#define reiserfs_read_unlock_xattrs(sb)
+
+#define reiserfs_permission NULL
+
+#define reiserfs_xattr_register_handlers() 0
+#define reiserfs_xattr_unregister_handlers()
+
+static inline int reiserfs_delete_xattrs (struct inode *inode) { return 0; };
+static inline int reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs) { return 0; };
+static inline int reiserfs_xattr_init (struct super_block *sb, int mount_flags) { return 0; };
+#endif
+
+#endif  /* __KERNEL__ */
jeffm@suse.com

reiserfs acl support

Index: linux.mm/fs/Kconfig
===================================================================
--- linux.mm.orig/fs/Kconfig	2004-04-23 14:09:45.730536675 -0400
+++ linux.mm/fs/Kconfig	2004-04-23 14:09:54.696461143 -0400
@@ -254,6 +254,18 @@ config REISERFS_FS_XATTR
 
 	  If unsure, say N.
 
+config REISERFS_FS_POSIX_ACL
+	bool "ReiserFS POSIX Access Control Lists"
+	depends on REISERFS_FS_XATTR
+	help
+	  Posix Access Control Lists (ACLs) support permissions for users and
+	  groups beyond the owner/group/world scheme.
+
+	  To learn more about Access Control Lists, visit the Posix ACLs for
+	  Linux website <http://acl.bestbits.at/>.
+
+	  If you don't know what Access Control Lists are, say N
+
 config JFS_FS
 	tristate "JFS filesystem support"
 	select NLS
@@ -292,13 +304,13 @@ config JFS_STATISTICS
 	  to be made available to the user in the /proc/fs/jfs/ directory.
 
 config FS_POSIX_ACL
-# Posix ACL utility routines (for now, only ext2/ext3/jfs)
+# Posix ACL utility routines (for now, only ext2/ext3/jfs/reiserfs)
 #
 # NOTE: you can implement Posix ACLs without these helpers (XFS does).
 # 	Never use this symbol for ifdefs.
 #
 	bool
-	depends on EXT2_FS_POSIX_ACL || EXT3_FS_POSIX_ACL || JFS_POSIX_ACL
+	depends on EXT2_FS_POSIX_ACL || EXT3_FS_POSIX_ACL || JFS_POSIX_ACL || REISERFS_FS_POSIX_ACL
 	default y
 
 config XFS_FS
Index: linux.mm/fs/reiserfs/Makefile
===================================================================
--- linux.mm.orig/fs/reiserfs/Makefile	2004-04-23 14:09:45.731536555 -0400
+++ linux.mm/fs/reiserfs/Makefile	2004-04-23 14:09:54.697461023 -0400
@@ -13,6 +13,10 @@ ifeq ($(CONFIG_REISERFS_FS_XATTR),y)
 reiserfs-objs += xattr.o xattr_user.o
 endif
 
+ifeq ($(CONFIG_REISERFS_FS_POSIX_ACL),y)
+reiserfs-objs += xattr_acl.o
+endif
+
 # gcc -O2 (the kernel default)  is overaggressive on ppc32 when many inline
 # functions are used.  This causes the compiler to advance the stack
 # pointer out of the available stack space, corrupting kernel space,
Index: linux.mm/fs/reiserfs/file.c
===================================================================
--- linux.mm.orig/fs/reiserfs/file.c	2004-04-23 14:09:45.752534035 -0400
+++ linux.mm/fs/reiserfs/file.c	2004-04-23 14:09:54.699460784 -0400
@@ -5,6 +5,7 @@
 
 #include <linux/time.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <asm/uaccess.h>
Index: linux.mm/fs/reiserfs/inode.c
===================================================================
--- linux.mm.orig/fs/reiserfs/inode.c	2004-04-23 14:09:45.756533555 -0400
+++ linux.mm/fs/reiserfs/inode.c	2004-04-23 14:09:54.702460424 -0400
@@ -5,6 +5,7 @@
 #include <linux/config.h>
 #include <linux/time.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <linux/pagemap.h>
@@ -976,6 +977,8 @@ static void init_inode (struct inode * i
     REISERFS_I(inode)->i_prealloc_count = 0;
     REISERFS_I(inode)->i_trans_id = 0;
     REISERFS_I(inode)->i_jl = NULL;
+    REISERFS_I(inode)->i_acl_access = NULL;
+    REISERFS_I(inode)->i_acl_default = NULL;
 
     if (stat_data_v1 (ih)) {
 	struct stat_data_v1 * sd = (struct stat_data_v1 *)B_I_PITEM (bh, ih);
@@ -1637,6 +1640,8 @@ int reiserfs_new_inode (struct reiserfs_
     REISERFS_I(inode)->i_attrs =
 	REISERFS_I(dir)->i_attrs & REISERFS_INHERIT_MASK;
     sd_attrs_to_i_attrs( REISERFS_I(inode) -> i_attrs, inode );
+    REISERFS_I(inode)->i_acl_access = NULL;
+    REISERFS_I(inode)->i_acl_default = NULL;
 
     if (old_format_only (sb))
 	make_le_item_head (&ih, 0, KEY_FORMAT_3_5, SD_OFFSET, TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);
@@ -1721,6 +1726,19 @@ int reiserfs_new_inode (struct reiserfs_
 	goto out_inserted_sd;
     }
 
+    /* XXX CHECK THIS */
+    if (reiserfs_posixacl (inode->i_sb)) {
+        retval = reiserfs_inherit_default_acl (dir, dentry, inode);
+        if (retval) {
+            err = retval;
+            reiserfs_check_path(&path_to_key) ;
+            journal_end(th, th->t_super, th->t_blocks_allocated);
+            goto out_inserted_sd;
+        }
+    } else if (inode->i_sb->s_flags & MS_POSIXACL) {
+        reiserfs_warning ("ACLs aren't enabled in the fs, but vfs thinks they are!\n");
+    }
+
     insert_inode_hash (inode);
     reiserfs_update_sd(th, inode);
     reiserfs_check_path(&path_to_key) ;
@@ -2565,6 +2583,11 @@ int reiserfs_setattr(struct dentry *dent
     }
 
 
+    if (!error && reiserfs_posixacl (inode->i_sb)) {
+        if (attr->ia_valid & ATTR_MODE)
+            error = reiserfs_acl_chmod (inode);
+    }
+
 out:
     reiserfs_write_unlock(inode->i_sb);
     return error ;
Index: linux.mm/fs/reiserfs/namei.c
===================================================================
--- linux.mm.orig/fs/reiserfs/namei.c	2004-04-23 14:09:45.759533195 -0400
+++ linux.mm/fs/reiserfs/namei.c	2004-04-23 14:09:54.705460064 -0400
@@ -15,6 +15,7 @@
 #include <linux/time.h>
 #include <linux/bitops.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 
@@ -579,6 +580,7 @@ static int reiserfs_create (struct inode
     struct inode * inode;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 2 ;
     struct reiserfs_transaction_handle th ;
+    int locked;
 
     if (!(inode = new_inode(dir->i_sb))) {
 	return -ENOMEM ;
@@ -587,9 +589,19 @@ static int reiserfs_create (struct inode
     if (retval)
         return retval;
 
+    locked = reiserfs_cache_default_acl (dir);
+
     reiserfs_write_lock(dir->i_sb);
+
+    if (locked)
+        reiserfs_write_lock_xattrs (dir->i_sb);
+
     journal_begin(&th, dir->i_sb, jbegin_count) ;
     retval = reiserfs_new_inode (&th, dir, mode, 0, 0/*i_size*/, dentry, inode);
+
+    if (locked)
+        reiserfs_write_unlock_xattrs (dir->i_sb);
+
     if (retval) {
         goto out_failed;
     }
@@ -625,6 +637,7 @@ static int reiserfs_mknod (struct inode 
     struct inode * inode;
     struct reiserfs_transaction_handle th ;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+    int locked;
 
     if (!new_valid_dev(rdev))
 	return -EINVAL;
@@ -636,10 +649,20 @@ static int reiserfs_mknod (struct inode 
     if (retval)
         return retval;
 
+    locked = reiserfs_cache_default_acl (dir);
+
     reiserfs_write_lock(dir->i_sb);
+
+    if (locked)
+        reiserfs_write_lock_xattrs (dir->i_sb);
+
     journal_begin(&th, dir->i_sb, jbegin_count) ;
 
     retval = reiserfs_new_inode (&th, dir, mode, 0, 0/*i_size*/, dentry, inode);
+
+    if (locked)
+        reiserfs_write_unlock_xattrs (dir->i_sb);
+
     if (retval) {
         goto out_failed;
     }
@@ -678,6 +701,7 @@ static int reiserfs_mkdir (struct inode 
     struct inode * inode;
     struct reiserfs_transaction_handle th ;
     int jbegin_count = JOURNAL_PER_BALANCE_CNT * 3; 
+    int locked;
 
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
     /* set flag that new packing locality created and new blocks for the content     * of that directory are not displaced yet */
@@ -691,7 +715,11 @@ static int reiserfs_mkdir (struct inode 
     if (retval)
         return retval;
 
+    locked = reiserfs_cache_default_acl (dir);
+
     reiserfs_write_lock(dir->i_sb);
+    if (locked)
+        reiserfs_write_lock_xattrs (dir->i_sb);
     journal_begin(&th, dir->i_sb, jbegin_count) ;
 
     /* inc the link count now, so another writer doesn't overflow it while
@@ -703,6 +731,9 @@ static int reiserfs_mkdir (struct inode 
 				old_format_only (dir->i_sb) ? 
 				EMPTY_DIR_SIZE_V1 : EMPTY_DIR_SIZE,
 				dentry, inode);
+    if (locked)
+        reiserfs_write_unlock_xattrs (dir->i_sb);
+
     if (retval) {
 	dir->i_nlink-- ;
 	goto out_failed;
@@ -945,6 +976,8 @@ static int reiserfs_symlink (struct inod
     memcpy (name, symname, strlen (symname));
     padd_item (name, item_len, strlen (symname));
 
+    /* We would inherit the default ACL here, but symlinks don't get ACLs */
+
     journal_begin(&th, parent_dir->i_sb, jbegin_count) ;
 
     retval = reiserfs_new_inode (&th, parent_dir, mode, name, strlen (symname), 
Index: linux.mm/fs/reiserfs/super.c
===================================================================
--- linux.mm.orig/fs/reiserfs/super.c	2004-04-23 14:09:45.762532835 -0400
+++ linux.mm/fs/reiserfs/super.c	2004-04-23 14:09:54.707459824 -0400
@@ -17,6 +17,7 @@
 #include <linux/time.h>
 #include <asm/uaccess.h>
 #include <linux/reiserfs_fs.h>
+#include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
 #include <linux/init.h>
@@ -433,6 +434,8 @@ static void init_once(void * foo, kmem_c
 	    SLAB_CTOR_CONSTRUCTOR) {
 		INIT_LIST_HEAD(&ei->i_prealloc_list) ;
 		inode_init_once(&ei->vfs_inode);
+		ei->i_acl_access = NULL;
+		ei->i_acl_default = NULL;
 	}
 }
  
@@ -473,6 +476,22 @@ static void reiserfs_dirty_inode (struct
     reiserfs_write_unlock(inode->i_sb);
 }
 
+static void reiserfs_clear_inode (struct inode *inode)
+{
+    struct posix_acl *acl;
+
+    acl = REISERFS_I(inode)->i_acl_access;
+    if (acl && !IS_ERR (acl))
+        posix_acl_release (acl);
+    REISERFS_I(inode)->i_acl_access = NULL;
+
+    acl = REISERFS_I(inode)->i_acl_default;
+    if (acl && !IS_ERR (acl))
+        posix_acl_release (acl);
+    REISERFS_I(inode)->i_acl_default = NULL;
+}
+
+
 struct super_operations reiserfs_sops = 
 {
   .alloc_inode = reiserfs_alloc_inode,
@@ -480,6 +499,7 @@ struct super_operations reiserfs_sops = 
   .write_inode = reiserfs_write_inode,
   .dirty_inode = reiserfs_dirty_inode,
   .delete_inode = reiserfs_delete_inode,
+  .clear_inode  = reiserfs_clear_inode,
   .put_super = reiserfs_put_super,
   .write_super = reiserfs_write_super,
   .write_super_lockfs = reiserfs_write_super_lockfs,
@@ -682,6 +702,10 @@ static int reiserfs_parse_options (struc
 	{"noattrs", 0, 0, 0, 1<<REISERFS_ATTRS},
 	{"user_xattr", 0, 0, 1<<REISERFS_XATTRS_USER, 0},
 	{"nouser_xattr", 0, 0, 0, 1<<REISERFS_XATTRS_USER},
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+	{"acl", 0, 0, 1<<REISERFS_POSIXACL, 0},
+	{"noacl", 0, 0, 0, 1<<REISERFS_POSIXACL},
+#endif
 	{"nolog", 0, 0, 0, 0}, /* This is unsupported */
 	{"replayonly", 0, 0, 1<<REPLAYONLY, 0},
 	{"block-allocator", 'a', balloc, 0, 0},
@@ -827,6 +851,7 @@ static int reiserfs_remount (struct supe
   safe_mask |= 1 << REISERFS_TEST4;
   safe_mask |= 1 << REISERFS_ATTRS;
   safe_mask |= 1 << REISERFS_XATTRS_USER;
+  safe_mask |= 1 << REISERFS_POSIXACL;
 
   /* Update the bitmask, taking care to keep
    * the bits we're not allowed to change here */
Index: linux.mm/fs/reiserfs/xattr.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr.c	2004-04-23 14:09:45.766532356 -0400
+++ linux.mm/fs/reiserfs/xattr.c	2004-04-23 14:09:54.709459584 -0400
@@ -6,7 +6,7 @@
  */
 
 /*
- * In order to implement EAs in a clean, backwards compatible manner,
+ * In order to implement EA/ACLs in a clean, backwards compatible manner,
  * they are implemented as files in a "private" directory.
  * Each EA is in it's own file, with the directory layout like so (/ is assumed
  * to be relative to fs root). Inside the /.reiserfs_priv/xattrs directory,
@@ -15,12 +15,18 @@
  * named with the name of the extended attribute.
  *
  * So, for objectid 12648430, we could have:
+ * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_access
+ * /.reiserfs_priv/xattrs/C0FFEE.0/system.posix_acl_default
  * /.reiserfs_priv/xattrs/C0FFEE.0/user.Content-Type
  * .. or similar.
  *
  * The file contents are the text of the EA. The size is known based on the
  * stat data describing the file.
  *
+ * In the case of system.posix_acl_access and system.posix_acl_default, since
+ * these are special cases for filesystem ACLs, they are interpreted by the
+ * kernel, in addition, they are negatively and positively cached and attached
+ * to the inode so that unnecessary lookups are avoided.
  */
 
 #include <linux/reiserfs_fs.h>
@@ -32,6 +38,7 @@
 #include <linux/pagemap.h>
 #include <linux/xattr.h>
 #include <linux/reiserfs_xattr.h>
+#include <linux/reiserfs_acl.h>
 #include <linux/mbcache.h>
 #include <asm/uaccess.h>
 #include <asm/checksum.h>
@@ -1169,6 +1176,10 @@ reiserfs_xattr_register_handlers (void)
 
     /* Add the handlers */
     list_add_tail (&user_handler.handlers, &xattr_handlers);
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+    list_add_tail (&posix_acl_access_handler.handlers, &xattr_handlers);
+    list_add_tail (&posix_acl_default_handler.handlers, &xattr_handlers);
+#endif
 
     /* Run initializers, if available */
     list_for_each (p, &xattr_handlers) {
@@ -1231,7 +1242,7 @@ reiserfs_xattr_init (struct super_block 
   } else if (reiserfs_xattrs_optional (s)) {
     /* Old format filesystem, but optional xattrs have been enabled
      * at mount time. Error out. */
-    reiserfs_warning ("reiserfs: xattrs not supported on pre v3.6 "
+    reiserfs_warning ("reiserfs: xattrs/ACLs not supported on pre v3.6 "
                       "format filesystem. Failing mount.\n");
     err = -EOPNOTSUPP;
     goto error;
@@ -1276,7 +1287,7 @@ reiserfs_xattr_init (struct super_block 
           /* If we're read-only it just means that the dir hasn't been
            * created. Not an error -- just no xattrs on the fs. We'll
            * check again if we go read-write */
-          reiserfs_warning ("reiserfs: xattrs enabled and couldn't "
+          reiserfs_warning ("reiserfs: xattrs/ACLs enabled and couldn't "
                             "find/create .reiserfs_priv. Failing mount.\n");
           err = -EOPNOTSUPP;
       }
@@ -1288,12 +1299,20 @@ error:
     if (err) {
           clear_bit (REISERFS_XATTRS, &(REISERFS_SB(s)->s_mount_opt));
           clear_bit (REISERFS_XATTRS_USER, &(REISERFS_SB(s)->s_mount_opt));
+          clear_bit (REISERFS_POSIXACL, &(REISERFS_SB(s)->s_mount_opt));
     }
+
+    /* The super_block MS_POSIXACL must mirror the (no)acl mount option. */
+    s->s_flags = s->s_flags & ~MS_POSIXACL;
+    if (reiserfs_posixacl (s))
+	s->s_flags |= MS_POSIXACL;
+
     return err;
 }
 
-int
-reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd)
+static int
+__reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd,
+                       int need_lock)
 {
 	umode_t			mode = inode->i_mode;
 
@@ -1317,10 +1336,45 @@ reiserfs_permission (struct inode *inode
         if (is_reiserfs_priv_object (inode))
 		return 0;
 
-	if (current->fsuid == inode->i_uid)
+	if (current->fsuid == inode->i_uid) {
 		mode >>= 6;
-	else if (in_group_p(inode->i_gid))
-		mode >>= 3;
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+	} else if (reiserfs_posixacl(inode->i_sb) &&
+                   get_inode_sd_version (inode) != STAT_DATA_V1) {
+                struct posix_acl *acl;
+
+		/* ACL can't contain additional permissions if
+		   the ACL_MASK entry is 0 */
+		if (!(mode & S_IRWXG))
+			goto check_groups;
+
+                if (need_lock)
+                    reiserfs_read_lock_xattrs (inode->i_sb);
+                acl = reiserfs_get_acl (inode, ACL_TYPE_ACCESS);
+                if (need_lock)
+                    reiserfs_read_unlock_xattrs (inode->i_sb);
+                if (IS_ERR (acl)) {
+                    if (PTR_ERR (acl) == -ENODATA)
+                        goto check_groups;
+                    return PTR_ERR (acl);
+                }
+
+                if (acl) {
+                    int err = posix_acl_permission (inode, acl, mask);
+                    posix_acl_release (acl);
+                    if (err == -EACCES) {
+                        goto check_capabilities;
+                    }
+                    return err;
+		} else {
+			goto check_groups;
+                }
+#endif
+	} else {
+check_groups:
+		if (in_group_p(inode->i_gid))
+			mode >>= 3;
+	}
 
 	/*
 	 * If the DACs are ok we don't need any capability check.
@@ -1328,6 +1382,7 @@ reiserfs_permission (struct inode *inode
 	if (((mode & mask & (MAY_READ|MAY_WRITE|MAY_EXEC)) == mask))
 		return 0;
 
+check_capabilities:
 	/*
 	 * Read/write DACs are always overridable.
 	 * Executable DACs are overridable if at least one exec bit is set.
@@ -1344,5 +1399,16 @@ reiserfs_permission (struct inode *inode
 			return 0;
 
 	return -EACCES;
+}
 
+int
+reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd)
+{
+    return __reiserfs_permission (inode, mask, nd, 1);
+}
+
+int
+reiserfs_permission_locked (struct inode *inode, int mask, struct nameidata *nd)
+{
+    return __reiserfs_permission (inode, mask, nd, 0);
 }
Index: linux.mm/fs/reiserfs/xattr_acl.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr_acl.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/fs/reiserfs/xattr_acl.c	2004-04-23 14:09:54.711459345 -0400
@@ -0,0 +1,552 @@
+#include <linux/fs.h>
+#include <linux/posix_acl.h>
+#include <linux/reiserfs_fs.h>
+#include <linux/errno.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/xattr_acl.h>
+#include <linux/reiserfs_xattr.h>
+#include <linux/reiserfs_acl.h>
+#include <asm/uaccess.h>
+
+static int
+xattr_set_acl(struct inode *inode, int type, const void *value, size_t size)
+{
+	struct posix_acl *acl;
+	int error;
+
+	if (!reiserfs_posixacl(inode->i_sb))
+		return -EOPNOTSUPP;
+	if ((current->fsuid != inode->i_uid) && !capable(CAP_FOWNER))
+		return -EPERM;
+
+	if (value) {
+		acl = posix_acl_from_xattr(value, size);
+		if (IS_ERR(acl)) {
+			return PTR_ERR(acl);
+		} else if (acl) {
+			error = posix_acl_valid(acl);
+			if (error)
+				goto release_and_out;
+		}
+	} else
+		acl = NULL;
+
+	error = reiserfs_set_acl (inode, type, acl);
+
+release_and_out:
+	posix_acl_release(acl);
+	return error;
+}
+
+
+static int
+xattr_get_acl(struct inode *inode, int type, void *buffer, size_t size)
+{
+	struct posix_acl *acl;
+	int error;
+
+	if (!reiserfs_posixacl(inode->i_sb))
+		return -EOPNOTSUPP;
+
+	acl = reiserfs_get_acl (inode, type);
+	if (IS_ERR(acl))
+		return PTR_ERR(acl);
+	if (acl == NULL)
+		return -ENODATA;
+	error = posix_acl_to_xattr(acl, buffer, size);
+	posix_acl_release(acl);
+
+	return error;
+}
+
+
+/*
+ * Convert from filesystem to in-memory representation.
+ */
+static struct posix_acl *
+posix_acl_from_disk(const void *value, size_t size)
+{
+	const char *end = (char *)value + size;
+	int n, count;
+	struct posix_acl *acl;
+
+	if (!value)
+		return NULL;
+	if (size < sizeof(reiserfs_acl_header))
+		 return ERR_PTR(-EINVAL);
+	if (((reiserfs_acl_header *)value)->a_version !=
+	    cpu_to_le32(REISERFS_ACL_VERSION))
+		return ERR_PTR(-EINVAL);
+	value = (char *)value + sizeof(reiserfs_acl_header);
+	count = reiserfs_acl_count(size);
+	if (count < 0)
+		return ERR_PTR(-EINVAL);
+	if (count == 0)
+		return NULL;
+	acl = posix_acl_alloc(count, GFP_NOFS);
+	if (!acl)
+		return ERR_PTR(-ENOMEM);
+	for (n=0; n < count; n++) {
+		reiserfs_acl_entry *entry =
+			(reiserfs_acl_entry *)value;
+		if ((char *)value + sizeof(reiserfs_acl_entry_short) > end)
+			goto fail;
+		acl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);
+		acl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);
+		switch(acl->a_entries[n].e_tag) {
+			case ACL_USER_OBJ:
+			case ACL_GROUP_OBJ:
+			case ACL_MASK:
+			case ACL_OTHER:
+				value = (char *)value +
+					sizeof(reiserfs_acl_entry_short);
+				acl->a_entries[n].e_id = ACL_UNDEFINED_ID;
+				break;
+
+			case ACL_USER:
+			case ACL_GROUP:
+				value = (char *)value + sizeof(reiserfs_acl_entry);
+				if ((char *)value > end)
+					goto fail;
+				acl->a_entries[n].e_id =
+					le32_to_cpu(entry->e_id);
+				break;
+
+			default:
+				goto fail;
+		}
+	}
+	if (value != end)
+		goto fail;
+	return acl;
+
+fail:
+	posix_acl_release(acl);
+	return ERR_PTR(-EINVAL);
+}
+
+/*
+ * Convert from in-memory to filesystem representation.
+ */
+static void *
+posix_acl_to_disk(const struct posix_acl *acl, size_t *size)
+{
+	reiserfs_acl_header *ext_acl;
+	char *e;
+	int n;
+
+	*size = reiserfs_acl_size(acl->a_count);
+	ext_acl = (reiserfs_acl_header *)kmalloc(sizeof(reiserfs_acl_header) +
+		acl->a_count * sizeof(reiserfs_acl_entry), GFP_NOFS);
+	if (!ext_acl)
+		return ERR_PTR(-ENOMEM);
+	ext_acl->a_version = cpu_to_le32(REISERFS_ACL_VERSION);
+	e = (char *)ext_acl + sizeof(reiserfs_acl_header);
+	for (n=0; n < acl->a_count; n++) {
+		reiserfs_acl_entry *entry = (reiserfs_acl_entry *)e;
+		entry->e_tag  = cpu_to_le16(acl->a_entries[n].e_tag);
+		entry->e_perm = cpu_to_le16(acl->a_entries[n].e_perm);
+		switch(acl->a_entries[n].e_tag) {
+			case ACL_USER:
+			case ACL_GROUP:
+				entry->e_id =
+					cpu_to_le32(acl->a_entries[n].e_id);
+				e += sizeof(reiserfs_acl_entry);
+				break;
+
+			case ACL_USER_OBJ:
+			case ACL_GROUP_OBJ:
+			case ACL_MASK:
+			case ACL_OTHER:
+				e += sizeof(reiserfs_acl_entry_short);
+				break;
+
+			default:
+				goto fail;
+		}
+	}
+	return (char *)ext_acl;
+
+fail:
+	kfree(ext_acl);
+	return ERR_PTR(-EINVAL);
+}
+
+/*
+ * Inode operation get_posix_acl().
+ *
+ * inode->i_sem: down
+ * BKL held [before 2.5.x]
+ */
+struct posix_acl *
+reiserfs_get_acl(struct inode *inode, int type)
+{
+	char *name, *value;
+	struct posix_acl *acl, **p_acl;
+	size_t size;
+	int retval;
+        struct reiserfs_inode_info *reiserfs_i = REISERFS_I(inode);
+
+        switch (type) {
+            case ACL_TYPE_ACCESS:
+                name = XATTR_NAME_ACL_ACCESS;
+                p_acl = &reiserfs_i->i_acl_access;
+                break;
+            case ACL_TYPE_DEFAULT:
+                name = XATTR_NAME_ACL_DEFAULT;
+                p_acl = &reiserfs_i->i_acl_default;
+                break;
+            default:
+                return ERR_PTR (-EINVAL);
+        }
+
+        if (IS_ERR (*p_acl)) {
+            if (PTR_ERR (*p_acl) == -ENODATA)
+                return NULL;
+        } else if (*p_acl != NULL)
+            return posix_acl_dup (*p_acl);
+
+        size = reiserfs_xattr_get (inode, name, NULL, 0);
+        if ((int)size < 0) {
+            if (size == -ENODATA || size == -ENOSYS) {
+		*p_acl = ERR_PTR (-ENODATA);
+		return NULL;
+            }
+            return ERR_PTR (size);
+        }
+
+        value = kmalloc (size, GFP_NOFS);
+        if (!value)
+            return ERR_PTR (-ENOMEM);
+
+	retval = reiserfs_xattr_get(inode, name, value, size);
+	if (retval == -ENODATA || retval == -ENOSYS) {
+		/* This shouldn't actually happen as it should have
+		   been caught above.. but just in case */
+		acl = NULL;
+		*p_acl = ERR_PTR (-ENODATA);
+        } else if (retval < 0) {
+		acl = ERR_PTR(retval);
+	} else {
+		acl = posix_acl_from_disk(value, retval);
+		*p_acl = posix_acl_dup (acl);
+        }
+
+	kfree(value);
+	return acl;
+}
+
+/*
+ * Inode operation set_posix_acl().
+ *
+ * inode->i_sem: down
+ * BKL held [before 2.5.x]
+ */
+int
+reiserfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)
+{
+        char *name;
+	void *value = NULL;
+	struct posix_acl **p_acl;
+	size_t size;
+	int error;
+        struct reiserfs_inode_info *reiserfs_i = REISERFS_I(inode);
+
+	if (S_ISLNK(inode->i_mode))
+		return -EOPNOTSUPP;
+
+        switch (type) {
+            case ACL_TYPE_ACCESS:
+                name = XATTR_NAME_ACL_ACCESS;
+                p_acl = &reiserfs_i->i_acl_access;
+                if (acl) {
+                    mode_t mode = inode->i_mode;
+                    error = posix_acl_equiv_mode (acl, &mode);
+                    if (error < 0)
+                        return error;
+                    else {
+                        inode->i_mode = mode;
+                        if (error == 0)
+                            acl = NULL;
+                    }
+                }
+                break;
+            case ACL_TYPE_DEFAULT:
+                name = XATTR_NAME_ACL_DEFAULT;
+                p_acl = &reiserfs_i->i_acl_default;
+                if (!S_ISDIR (inode->i_mode))
+                    return acl ? -EACCES : 0;
+                break;
+            default:
+                return -EINVAL;
+        }
+
+ 	if (acl) {
+            value = posix_acl_to_disk(acl, &size);
+            if (IS_ERR(value))
+                return (int)PTR_ERR(value);
+            error = reiserfs_xattr_set(inode, name, value, size, 0);
+	} else {
+            error = reiserfs_xattr_del (inode, name);
+            if (error == -ENODATA)
+                error = 0;
+        }
+
+	if (value)
+		kfree(value);
+
+        if (!error) {
+            /* Release the old one */
+            if (!IS_ERR (*p_acl) && *p_acl)
+                posix_acl_release (*p_acl);
+
+            if (acl == NULL)
+                *p_acl = ERR_PTR (-ENODATA);
+            else
+                *p_acl = posix_acl_dup (acl);
+        }
+
+	return error;
+}
+
+/* dir->i_sem: down,
+ * inode is new and not released into the wild yet */
+int
+reiserfs_inherit_default_acl (struct inode *dir, struct dentry *dentry, struct inode *inode)
+{
+    struct posix_acl *acl;
+    int err = 0;
+
+    /* ACLs only get applied to files and directories */
+    if (S_ISLNK (inode->i_mode))
+        return 0;
+
+    /* ACLs can only be used on "new" objects, so if it's an old object
+     * there is nothing to inherit from */
+    if (get_inode_sd_version (dir) == STAT_DATA_V1)
+        goto apply_umask;
+
+    /* Don't apply ACLs to objects in the .reiserfs_priv tree.. This
+     * would be useless since permissions are ignored, and a pain because
+     * it introduces locking cycles */
+    if (is_reiserfs_priv_object (dir)) {
+        REISERFS_I(inode)->i_flags |= i_priv_object;
+        goto apply_umask;
+    }
+
+    acl = reiserfs_get_acl (dir, ACL_TYPE_DEFAULT);
+    if (IS_ERR (acl)) {
+        if (PTR_ERR (acl) == -ENODATA)
+            goto apply_umask;
+        return PTR_ERR (acl);
+    }
+
+    if (acl) {
+        struct posix_acl *acl_copy;
+        mode_t mode = inode->i_mode;
+        int need_acl;
+
+        /* Copy the default ACL to the default ACL of a new directory */
+        if (S_ISDIR (inode->i_mode)) {
+            err = reiserfs_set_acl (inode, ACL_TYPE_DEFAULT, acl);
+            if (err)
+                goto cleanup;
+        }
+
+        /* Now we reconcile the new ACL and the mode,
+           potentially modifying both */
+        acl_copy = posix_acl_clone (acl, GFP_NOFS);
+        if (!acl_copy) {
+            err = -ENOMEM;
+            goto cleanup;
+        }
+
+
+        need_acl = posix_acl_create_masq (acl_copy, &mode);
+        if (need_acl >= 0) {
+            if (mode != inode->i_mode) {
+                inode->i_mode = mode;
+            }
+
+            /* If we need an ACL.. */
+            if (need_acl > 0) {
+                err = reiserfs_set_acl (inode, ACL_TYPE_ACCESS, acl_copy);
+                if (err)
+                    goto cleanup_copy;
+            }
+        }
+cleanup_copy:
+        posix_acl_release (acl_copy);
+cleanup:
+        posix_acl_release (acl);
+    } else {
+apply_umask:
+        /* no ACL, apply umask */
+        inode->i_mode &= ~current->fs->umask;
+    }
+
+    return err;
+}
+
+/* Looks up and caches the result of the default ACL.
+ * We do this so that we don't need to carry the xattr_sem into
+ * reiserfs_new_inode if we don't need to */
+int
+reiserfs_cache_default_acl (struct inode *inode)
+{
+    int ret = 0;
+    if (reiserfs_posixacl (inode->i_sb) &&
+        !is_reiserfs_priv_object (inode)) {
+        struct posix_acl *acl;
+        reiserfs_read_lock_xattrs (inode->i_sb);
+        acl = reiserfs_get_acl (inode, ACL_TYPE_DEFAULT);
+        reiserfs_read_unlock_xattrs (inode->i_sb);
+        ret = acl ? 1 : 0;
+        posix_acl_release (acl);
+    }
+
+    return ret;
+}
+
+int
+reiserfs_acl_chmod (struct inode *inode)
+{
+        struct posix_acl *acl, *clone;
+        int error;
+
+        if (S_ISLNK(inode->i_mode))
+                return -EOPNOTSUPP;
+
+	if (get_inode_sd_version (inode) == STAT_DATA_V1 ||
+	    !reiserfs_posixacl(inode->i_sb))
+        {
+	    return 0;
+	}
+
+        reiserfs_read_lock_xattrs (inode->i_sb);
+        acl = reiserfs_get_acl(inode, ACL_TYPE_ACCESS);
+        reiserfs_read_unlock_xattrs (inode->i_sb);
+        if (!acl)
+                return 0;
+        if (IS_ERR(acl))
+                return PTR_ERR(acl);
+        clone = posix_acl_clone(acl, GFP_NOFS);
+        posix_acl_release(acl);
+        if (!clone)
+                return -ENOMEM;
+        error = posix_acl_chmod_masq(clone, inode->i_mode);
+        if (!error) {
+                reiserfs_write_lock_xattrs (inode->i_sb);
+                error = reiserfs_set_acl(inode, ACL_TYPE_ACCESS, clone);
+                reiserfs_write_unlock_xattrs (inode->i_sb);
+        }
+        posix_acl_release(clone);
+        return error;
+}
+
+static int
+posix_acl_access_get(struct inode *inode, const char *name,
+			  void *buffer, size_t size)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_ACCESS)-1)
+		return -EINVAL;
+	return xattr_get_acl(inode, ACL_TYPE_ACCESS, buffer, size);
+}
+
+static int
+posix_acl_access_set(struct inode *inode, const char *name,
+			  const void *value, size_t size, int flags)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_ACCESS)-1)
+		return -EINVAL;
+	return xattr_set_acl(inode, ACL_TYPE_ACCESS, value, size);
+}
+
+static int
+posix_acl_access_del (struct inode *inode, const char *name)
+{
+    struct reiserfs_inode_info *reiserfs_i = REISERFS_I(inode);
+    struct posix_acl **acl = &reiserfs_i->i_acl_access;
+    if (strlen(name) != sizeof(XATTR_NAME_ACL_ACCESS)-1)
+	return -EINVAL;
+    if (!IS_ERR (*acl) && *acl) {
+        posix_acl_release (*acl);
+        *acl = ERR_PTR (-ENODATA);
+    }
+
+    return 0;
+}
+
+static int
+posix_acl_access_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+    if (!reiserfs_posixacl (inode->i_sb))
+        return 0;
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+struct reiserfs_xattr_handler posix_acl_access_handler = {
+    prefix: XATTR_NAME_ACL_ACCESS,
+    get: posix_acl_access_get,
+    set: posix_acl_access_set,
+    del: posix_acl_access_del,
+    list: posix_acl_access_list,
+};
+
+static int
+posix_acl_default_get (struct inode *inode, const char *name,
+			   void *buffer, size_t size)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_DEFAULT)-1)
+		return -EINVAL;
+	return xattr_get_acl(inode, ACL_TYPE_DEFAULT, buffer, size);
+}
+
+static int
+posix_acl_default_set(struct inode *inode, const char *name,
+			   const void *value, size_t size, int flags)
+{
+	if (strlen(name) != sizeof(XATTR_NAME_ACL_DEFAULT)-1)
+		return -EINVAL;
+	return xattr_set_acl(inode, ACL_TYPE_DEFAULT, value, size);
+}
+
+static int
+posix_acl_default_del (struct inode *inode, const char *name)
+{
+    struct reiserfs_inode_info *reiserfs_i = REISERFS_I(inode);
+    struct posix_acl **acl = &reiserfs_i->i_acl_default;
+    if (strlen(name) != sizeof(XATTR_NAME_ACL_DEFAULT)-1)
+	return -EINVAL;
+    if (!IS_ERR (*acl) && *acl) {
+        posix_acl_release (*acl);
+        *acl = ERR_PTR (-ENODATA);
+    }
+
+    return 0;
+}
+
+static int
+posix_acl_default_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+    if (!reiserfs_posixacl (inode->i_sb))
+        return 0;
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+struct reiserfs_xattr_handler posix_acl_default_handler = {
+    prefix: XATTR_NAME_ACL_DEFAULT,
+    get: posix_acl_default_get,
+    set: posix_acl_default_set,
+    del: posix_acl_default_del,
+    list: posix_acl_default_list,
+};
Index: linux.mm/fs/reiserfs/xattr_user.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr_user.c	2004-04-23 14:09:45.767532236 -0400
+++ linux.mm/fs/reiserfs/xattr_user.c	2004-04-23 14:09:54.712459225 -0400
@@ -6,6 +6,10 @@
 #include <linux/reiserfs_xattr.h>
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+# include <linux/reiserfs_acl.h>
+#endif
+
 #define XATTR_USER_PREFIX "user."
 
 static int
@@ -20,7 +24,7 @@ user_get (struct inode *inode, const cha
     if (!reiserfs_xattrs_user (inode->i_sb))
         return -EOPNOTSUPP;
 
-    error = permission (inode, MAY_READ, NULL);
+    error = reiserfs_permission_locked (inode, MAY_READ, NULL);
     if (error)
         return error;
 
@@ -44,7 +48,7 @@ user_set (struct inode *inode, const cha
         (!S_ISDIR (inode->i_mode) || inode->i_mode & S_ISVTX))
         return -EPERM;
 
-    error = permission (inode, MAY_WRITE, NULL);
+    error = reiserfs_permission_locked (inode, MAY_WRITE, NULL);
     if (error)
         return error;
 
@@ -66,7 +70,7 @@ user_del (struct inode *inode, const cha
         (!S_ISDIR (inode->i_mode) || inode->i_mode & S_ISVTX))
         return -EPERM;
 
-    error = permission (inode, MAY_WRITE, NULL);
+    error = reiserfs_permission_locked (inode, MAY_WRITE, NULL);
     if (error)
         return error;
 
Index: linux.mm/include/linux/reiserfs_acl.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_acl.h	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/include/linux/reiserfs_acl.h	2004-04-23 14:09:54.714458985 -0400
@@ -0,0 +1,91 @@
+#include <linux/init.h>
+#include <linux/posix_acl.h>
+#include <linux/xattr_acl.h>
+
+#define REISERFS_ACL_VERSION	0x0001
+
+typedef struct {
+	__u16		e_tag;
+	__u16		e_perm;
+	__u32		e_id;
+} reiserfs_acl_entry;
+
+typedef struct {
+	__u16		e_tag;
+	__u16		e_perm;
+} reiserfs_acl_entry_short;
+
+typedef struct {
+	__u32		a_version;
+} reiserfs_acl_header;
+
+static inline size_t reiserfs_acl_size(int count)
+{
+	if (count <= 4) {
+		return sizeof(reiserfs_acl_header) +
+		       count * sizeof(reiserfs_acl_entry_short);
+	} else {
+		return sizeof(reiserfs_acl_header) +
+		       4 * sizeof(reiserfs_acl_entry_short) +
+		       (count - 4) * sizeof(reiserfs_acl_entry);
+	}
+}
+
+static inline int reiserfs_acl_count(size_t size)
+{
+	ssize_t s;
+	size -= sizeof(reiserfs_acl_header);
+	s = size - 4 * sizeof(reiserfs_acl_entry_short);
+	if (s < 0) {
+		if (size % sizeof(reiserfs_acl_entry_short))
+			return -1;
+		return size / sizeof(reiserfs_acl_entry_short);
+	} else {
+		if (s % sizeof(reiserfs_acl_entry))
+			return -1;
+		return s / sizeof(reiserfs_acl_entry) + 4;
+	}
+}
+
+
+#ifdef CONFIG_REISERFS_FS_POSIX_ACL
+struct posix_acl * reiserfs_get_acl(struct inode *inode, int type);
+int reiserfs_set_acl(struct inode *inode, int type, struct posix_acl *acl);
+int reiserfs_acl_chmod (struct inode *inode);
+int reiserfs_inherit_default_acl (struct inode *dir, struct dentry *dentry, struct inode *inode);
+int reiserfs_cache_default_acl (struct inode *dir);
+extern int reiserfs_xattr_posix_acl_init (void) __init;
+extern int reiserfs_xattr_posix_acl_exit (void);
+extern struct reiserfs_xattr_handler posix_acl_default_handler;
+extern struct reiserfs_xattr_handler posix_acl_access_handler;
+#else
+
+#define reiserfs_set_acl NULL
+#define reiserfs_get_acl NULL
+#define reiserfs_cache_default_acl(inode) 0
+
+static inline int
+reiserfs_xattr_posix_acl_init (void)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_xattr_posix_acl_exit (void)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_acl_chmod (struct inode *inode)
+{
+    return 0;
+}
+
+static inline int
+reiserfs_inherit_default_acl (const struct inode *dir, struct dentry *dentry, struct inode *inode)
+{
+    return 0;
+}
+
+#endif
Index: linux.mm/include/linux/reiserfs_fs_i.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs_i.h	2004-04-23 14:09:45.772531636 -0400
+++ linux.mm/include/linux/reiserfs_fs_i.h	2004-04-23 14:09:54.714458985 -0400
@@ -52,6 +52,9 @@ struct reiserfs_inode_info {
     ** flushed */
     unsigned long i_trans_id ;
     struct reiserfs_journal_list *i_jl;
+
+    struct posix_acl *i_acl_access;
+    struct posix_acl *i_acl_default;
     struct inode vfs_inode;
 };
 
Index: linux.mm/include/linux/reiserfs_fs_sb.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs_sb.h	2004-04-23 14:09:45.774531396 -0400
+++ linux.mm/include/linux/reiserfs_fs_sb.h	2004-04-23 14:09:54.716458745 -0400
@@ -443,6 +443,7 @@ enum reiserfs_mount_options {
     REISERFS_ATTRS,
     REISERFS_XATTRS,
     REISERFS_XATTRS_USER,
+    REISERFS_POSIXACL,
 
     REISERFS_TEST1,
     REISERFS_TEST2,
@@ -470,7 +471,8 @@ enum reiserfs_mount_options {
 #define reiserfs_data_writeback(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_DATA_WRITEBACK))
 #define reiserfs_xattrs(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_XATTRS))
 #define reiserfs_xattrs_user(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_XATTRS_USER))
-#define reiserfs_xattrs_optional(s) reiserfs_xattrs_user(s)
+#define reiserfs_posixacl(s) (REISERFS_SB(s)->s_mount_opt & (1 << REISERFS_POSIXACL))
+#define reiserfs_xattrs_optional(s) (reiserfs_xattrs_user(s) || reiserfs_posixacl(s))
 
 void reiserfs_file_buffer (struct buffer_head * bh, int list);
 extern struct file_system_type reiserfs_fs_type;
Index: linux.mm/include/linux/reiserfs_xattr.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_xattr.h	2004-04-23 14:09:45.776531156 -0400
+++ linux.mm/include/linux/reiserfs_xattr.h	2004-04-23 14:09:54.717458625 -0400
@@ -42,6 +42,7 @@ int reiserfs_delete_xattrs (struct inode
 int reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs);
 int reiserfs_xattr_init (struct super_block *sb, int mount_flags);
 int reiserfs_permission (struct inode *inode, int mask, struct nameidata *nd);
+int reiserfs_permission_locked (struct inode *inode, int mask, struct nameidata *nd);
 
 int reiserfs_xattr_del (struct inode *, const char *);
 int reiserfs_xattr_get (const struct inode *, const char *, void *, size_t);
@@ -94,7 +95,11 @@ reiserfs_read_unlock_xattrs(struct super
 
 static inline int reiserfs_delete_xattrs (struct inode *inode) { return 0; };
 static inline int reiserfs_chown_xattrs (struct inode *inode, struct iattr *attrs) { return 0; };
-static inline int reiserfs_xattr_init (struct super_block *sb, int mount_flags) { return 0; };
+static inline int reiserfs_xattr_init (struct super_block *sb, int mount_flags)
+{
+    sb->s_flags = (sb->s_flags & ~MS_POSIXACL); /* to be sure */
+    return 0;
+};
 #endif
 
 #endif  /* __KERNEL__ */
jeffm@suse.com

reiserfs support for trusted xattrs

Index: linux.mm/fs/reiserfs/Makefile
===================================================================
--- linux.mm.orig/fs/reiserfs/Makefile	2004-04-05 17:30:11.489969355 -0400
+++ linux.mm/fs/reiserfs/Makefile	2004-04-05 17:30:12.501847426 -0400
@@ -10,7 +10,7 @@ reiserfs-objs := bitmap.o do_balan.o nam
 		 item_ops.o ioctl.o procfs.o
 
 ifeq ($(CONFIG_REISERFS_FS_XATTR),y)
-reiserfs-objs += xattr.o xattr_user.o
+reiserfs-objs += xattr.o xattr_user.o xattr_trusted.o
 endif
 
 ifeq ($(CONFIG_REISERFS_FS_POSIX_ACL),y)
Index: linux.mm/fs/reiserfs/xattr.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr.c	2004-04-05 17:30:11.502967789 -0400
+++ linux.mm/fs/reiserfs/xattr.c	2004-04-05 17:30:12.503847185 -0400
@@ -1176,6 +1176,7 @@ reiserfs_xattr_register_handlers (void)
 
     /* Add the handlers */
     list_add_tail (&user_handler.handlers, &xattr_handlers);
+    list_add_tail (&trusted_handler.handlers, &xattr_handlers);
 #ifdef CONFIG_REISERFS_FS_POSIX_ACL
     list_add_tail (&posix_acl_access_handler.handlers, &xattr_handlers);
     list_add_tail (&posix_acl_default_handler.handlers, &xattr_handlers);
Index: linux.mm/fs/reiserfs/xattr_trusted.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr_trusted.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/fs/reiserfs/xattr_trusted.c	2004-04-05 17:30:12.504847064 -0400
@@ -0,0 +1,81 @@
+#include <linux/reiserfs_fs.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <asm/uaccess.h>
+
+#define XATTR_TRUSTED_PREFIX "trusted."
+
+static int
+trusted_get (struct inode *inode, const char *name, void *buffer, size_t size)
+{
+    if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return -EPERM;
+
+    return reiserfs_xattr_get (inode, name, buffer, size);
+}
+
+static int
+trusted_set (struct inode *inode, const char *name, const void *buffer,
+          size_t size, int flags)
+{
+    if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return -EPERM;
+
+    return reiserfs_xattr_set (inode, name, buffer, size, flags);
+}
+
+static int
+trusted_del (struct inode *inode, const char *name)
+{
+    if (strlen(name) < sizeof(XATTR_TRUSTED_PREFIX))
+        return -EINVAL;
+
+    if (!reiserfs_xattrs (inode->i_sb))
+        return -EOPNOTSUPP;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return -EPERM;
+
+    return 0;
+}
+
+static int
+trusted_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+
+    if (!reiserfs_xattrs (inode->i_sb))
+        return 0;
+
+    if (!(capable(CAP_SYS_ADMIN) || is_reiserfs_priv_object(inode)))
+        return 0;
+
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+
+struct reiserfs_xattr_handler trusted_handler = {
+    prefix: XATTR_TRUSTED_PREFIX,
+    get: trusted_get,
+    set: trusted_set,
+    del: trusted_del,
+    list: trusted_list,
+};
Index: linux.mm/include/linux/reiserfs_xattr.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_xattr.h	2004-04-05 17:30:11.510966825 -0400
+++ linux.mm/include/linux/reiserfs_xattr.h	2004-04-05 17:30:12.505846944 -0400
@@ -50,6 +50,7 @@ int reiserfs_xattr_set (struct inode *, 
                                size_t, int);
 
 extern struct reiserfs_xattr_handler user_handler;
+extern struct reiserfs_xattr_handler trusted_handler;
 
 int reiserfs_xattr_register_handlers (void) __init;
 void reiserfs_xattr_unregister_handlers (void);
jeffm@suse.com

reiserfs support for selinux

Index: linux.mm/fs/Kconfig
===================================================================
--- linux.mm.orig/fs/Kconfig	2004-04-05 17:30:11.488969476 -0400
+++ linux.mm/fs/Kconfig	2004-04-05 17:30:13.527723824 -0400
@@ -266,6 +266,18 @@ config REISERFS_FS_POSIX_ACL
 
 	  If you don't know what Access Control Lists are, say N
 
+config REISERFS_FS_SECURITY
+	bool "ReiserFS Security Labels"
+	depends on REISERFS_FS_XATTR
+	help
+	  Security labels support alternative access control models
+	  implemented by security modules like SELinux.  This option
+	  enables an extended attribute handler for file security
+	  labels in the ReiserFS filesystem.
+
+	  If you are not using a security module that requires using
+	  extended attributes for file security labels, say N.
+
 config JFS_FS
 	tristate "JFS filesystem support"
 	select NLS
Index: linux.mm/fs/reiserfs/Makefile
===================================================================
--- linux.mm.orig/fs/reiserfs/Makefile	2004-04-05 17:30:12.501847426 -0400
+++ linux.mm/fs/reiserfs/Makefile	2004-04-05 17:30:13.528723704 -0400
@@ -13,6 +13,10 @@ ifeq ($(CONFIG_REISERFS_FS_XATTR),y)
 reiserfs-objs += xattr.o xattr_user.o xattr_trusted.o
 endif
 
+ifeq ($(CONFIG_REISERFS_FS_SECURITY),y)
+reiserfs-objs += xattr_security.o
+endif
+
 ifeq ($(CONFIG_REISERFS_FS_POSIX_ACL),y)
 reiserfs-objs += xattr_acl.o
 endif
Index: linux.mm/fs/reiserfs/xattr.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr.c	2004-04-05 17:30:12.503847185 -0400
+++ linux.mm/fs/reiserfs/xattr.c	2004-04-05 17:30:13.529723584 -0400
@@ -1177,6 +1177,9 @@ reiserfs_xattr_register_handlers (void)
     /* Add the handlers */
     list_add_tail (&user_handler.handlers, &xattr_handlers);
     list_add_tail (&trusted_handler.handlers, &xattr_handlers);
+#ifdef CONFIG_REISERFS_FS_SECURITY
+    list_add_tail (&security_handler.handlers, &xattr_handlers);
+#endif
 #ifdef CONFIG_REISERFS_FS_POSIX_ACL
     list_add_tail (&posix_acl_access_handler.handlers, &xattr_handlers);
     list_add_tail (&posix_acl_default_handler.handlers, &xattr_handlers);
Index: linux.mm/fs/reiserfs/xattr_security.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr_security.c	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/fs/reiserfs/xattr_security.c	2004-04-05 17:30:13.530723463 -0400
@@ -0,0 +1,69 @@
+#include <linux/reiserfs_fs.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/pagemap.h>
+#include <linux/xattr.h>
+#include <linux/reiserfs_xattr.h>
+#include <asm/uaccess.h>
+
+#define XATTR_SECURITY_PREFIX "security."
+
+static int
+security_get (struct inode *inode, const char *name, void *buffer, size_t size)
+{
+    if (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))
+        return -EINVAL;
+
+    if (is_reiserfs_priv_object(inode))
+        return -EPERM;
+
+    return reiserfs_xattr_get (inode, name, buffer, size);
+}
+
+static int
+security_set (struct inode *inode, const char *name, const void *buffer,
+          size_t size, int flags)
+{
+    if (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))
+        return -EINVAL;
+
+    if (is_reiserfs_priv_object(inode))
+        return -EPERM;
+
+    return reiserfs_xattr_set (inode, name, buffer, size, flags);
+}
+
+static int
+security_del (struct inode *inode, const char *name)
+{
+    if (strlen(name) < sizeof(XATTR_SECURITY_PREFIX))
+        return -EINVAL;
+
+    if (is_reiserfs_priv_object(inode))
+        return -EPERM;
+
+    return 0;
+}
+
+static int
+security_list (struct inode *inode, const char *name, int namelen, char *out)
+{
+    int len = namelen;
+
+    if (is_reiserfs_priv_object(inode))
+        return 0;
+
+    if (out)
+        memcpy (out, name, len);
+
+    return len;
+}
+
+
+struct reiserfs_xattr_handler security_handler = {
+    prefix: XATTR_SECURITY_PREFIX,
+    get: security_get,
+    set: security_set,
+    del: security_del,
+    list: security_list,
+};
Index: linux.mm/include/linux/reiserfs_xattr.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_xattr.h	2004-04-05 17:30:12.505846944 -0400
+++ linux.mm/include/linux/reiserfs_xattr.h	2004-04-05 17:30:13.531723343 -0400
@@ -51,6 +51,9 @@ int reiserfs_xattr_set (struct inode *, 
 
 extern struct reiserfs_xattr_handler user_handler;
 extern struct reiserfs_xattr_handler trusted_handler;
+#ifdef CONFIG_REISERFS_FS_SECURITY
+extern struct reiserfs_xattr_handler security_handler;
+#endif
 
 int reiserfs_xattr_register_handlers (void) __init;
 void reiserfs_xattr_unregister_handlers (void);
jeffm@suse.com

reiserfs xattr locking fixes

Index: linux.mm/fs/reiserfs/inode.c
===================================================================
--- linux.mm.orig/fs/reiserfs/inode.c	2004-04-05 17:30:11.495968632 -0400
+++ linux.mm/fs/reiserfs/inode.c	2004-04-05 17:30:14.673585785 -0400
@@ -979,6 +979,7 @@ static void init_inode (struct inode * i
     REISERFS_I(inode)->i_jl = NULL;
     REISERFS_I(inode)->i_acl_access = NULL;
     REISERFS_I(inode)->i_acl_default = NULL;
+    init_rwsem (&REISERFS_I(inode)->xattr_sem);
 
     if (stat_data_v1 (ih)) {
 	struct stat_data_v1 * sd = (struct stat_data_v1 *)B_I_PITEM (bh, ih);
@@ -1642,6 +1643,7 @@ int reiserfs_new_inode (struct reiserfs_
     sd_attrs_to_i_attrs( REISERFS_I(inode) -> i_attrs, inode );
     REISERFS_I(inode)->i_acl_access = NULL;
     REISERFS_I(inode)->i_acl_default = NULL;
+    init_rwsem (&REISERFS_I(inode)->xattr_sem);
 
     if (old_format_only (sb))
 	make_le_item_head (&ih, 0, KEY_FORMAT_3_5, SD_OFFSET, TYPE_STAT_DATA, SD_V1_SIZE, MAX_US_INT);
Index: linux.mm/fs/reiserfs/xattr.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr.c	2004-04-05 17:30:13.529723584 -0400
+++ linux.mm/fs/reiserfs/xattr.c	2004-04-05 17:30:14.676585423 -0400
@@ -521,6 +521,7 @@ open_file:
     }
 
     xinode = fp->f_dentry->d_inode;
+    REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
     /* we need to copy it off.. */
     if (xinode->i_nlink > 1) {
@@ -631,6 +632,7 @@ reiserfs_xattr_get (const struct inode *
 
     xinode = fp->f_dentry->d_inode;
     isize = xinode->i_size;
+    REISERFS_I(inode)->i_flags |= i_has_xattr_dir;
 
     /* Just return the size needed */
     if (buffer == NULL) {
@@ -834,6 +836,8 @@ out_dir:
     fput(fp);
 
 out:
+    if (!err)
+        REISERFS_I(inode)->i_flags = REISERFS_I(inode)->i_flags & ~i_has_xattr_dir;
     return err;
 }
 
@@ -945,11 +949,11 @@ reiserfs_getxattr (struct dentry *dentry
         get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
         return -EOPNOTSUPP;
 
-    down (&dentry->d_inode->i_sem);
+    reiserfs_read_lock_xattr_i (dentry->d_inode);
     reiserfs_read_lock_xattrs (dentry->d_sb);
     err = xah->get (dentry->d_inode, name, buffer, size);
     reiserfs_read_unlock_xattrs (dentry->d_sb);
-    up (&dentry->d_inode->i_sem);
+    reiserfs_read_unlock_xattr_i (dentry->d_inode);
     return err;
 }
 
@@ -965,6 +969,7 @@ reiserfs_setxattr (struct dentry *dentry
 {
     struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
     int err;
+    int lock;
 
     if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
         get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
@@ -976,9 +981,18 @@ reiserfs_setxattr (struct dentry *dentry
     if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
         return -EROFS;
 
-    reiserfs_write_lock_xattrs (dentry->d_sb);
+    reiserfs_write_lock_xattr_i (dentry->d_inode);
+    lock = !has_xattr_dir (dentry->d_inode);
+    if (lock)
+        reiserfs_write_lock_xattrs (dentry->d_sb);
+    else
+        reiserfs_read_lock_xattrs (dentry->d_sb);
     err = xah->set (dentry->d_inode, name, value, size, flags);
-    reiserfs_write_unlock_xattrs (dentry->d_sb);
+    if (lock)
+        reiserfs_write_unlock_xattrs (dentry->d_sb);
+    else
+        reiserfs_read_unlock_xattrs (dentry->d_sb);
+    reiserfs_write_unlock_xattr_i (dentry->d_inode);
     return err;
 }
 
@@ -992,6 +1006,7 @@ reiserfs_removexattr (struct dentry *den
 {
     int err;
     struct reiserfs_xattr_handler *xah = find_xattr_handler_prefix (name);
+    int lock;
 
     if (!xah || !reiserfs_xattrs(dentry->d_sb) ||
         get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
@@ -1003,6 +1018,7 @@ reiserfs_removexattr (struct dentry *den
     if (IS_IMMUTABLE (dentry->d_inode) || IS_APPEND (dentry->d_inode))
         return -EPERM;
 
+    reiserfs_write_lock_xattr_i (dentry->d_inode);
     reiserfs_read_lock_xattrs (dentry->d_sb);
 
     /* Deletion pre-operation */
@@ -1019,6 +1035,7 @@ reiserfs_removexattr (struct dentry *den
 
 out:
     reiserfs_read_unlock_xattrs (dentry->d_sb);
+    reiserfs_write_unlock_xattr_i (dentry->d_inode);
     return err;
 }
 
@@ -1081,7 +1098,7 @@ reiserfs_listxattr (struct dentry *dentr
         get_inode_sd_version (dentry->d_inode) == STAT_DATA_V1)
         return -EOPNOTSUPP;
 
-    down (&dentry->d_inode->i_sem);
+    reiserfs_read_lock_xattr_i (dentry->d_inode);
     reiserfs_read_lock_xattrs (dentry->d_sb);
     dir = open_xa_dir (dentry->d_inode, FL_READONLY);
     reiserfs_read_unlock_xattrs (dentry->d_sb);
@@ -1104,6 +1121,8 @@ reiserfs_listxattr (struct dentry *dentr
     buf.r_pos = 0;
     buf.r_inode = dentry->d_inode;
 
+    REISERFS_I(dentry->d_inode)->i_flags |= i_has_xattr_dir;
+
     err = xattr_readdir (fp, reiserfs_listxattr_filler, &buf);
     if (err)
         goto out_dir;
@@ -1117,7 +1136,7 @@ out_dir:
     fput(fp);
 
 out:
-    up (&dentry->d_inode->i_sem);
+    reiserfs_read_unlock_xattr_i (dentry->d_inode);
     return err;
 }
 
@@ -1352,11 +1371,13 @@ __reiserfs_permission (struct inode *ino
 		if (!(mode & S_IRWXG))
 			goto check_groups;
 
+                reiserfs_read_lock_xattr_i (inode);
                 if (need_lock)
                     reiserfs_read_lock_xattrs (inode->i_sb);
                 acl = reiserfs_get_acl (inode, ACL_TYPE_ACCESS);
                 if (need_lock)
                     reiserfs_read_unlock_xattrs (inode->i_sb);
+                reiserfs_read_unlock_xattr_i (inode);
                 if (IS_ERR (acl)) {
                     if (PTR_ERR (acl) == -ENODATA)
                         goto check_groups;
Index: linux.mm/fs/reiserfs/xattr_acl.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr_acl.c	2004-04-05 17:30:11.504967548 -0400
+++ linux.mm/fs/reiserfs/xattr_acl.c	2004-04-05 17:30:14.677585303 -0400
@@ -399,9 +399,11 @@ reiserfs_cache_default_acl (struct inode
     if (reiserfs_posixacl (inode->i_sb) &&
         !is_reiserfs_priv_object (inode)) {
         struct posix_acl *acl;
+        reiserfs_read_lock_xattr_i (inode);
         reiserfs_read_lock_xattrs (inode->i_sb);
         acl = reiserfs_get_acl (inode, ACL_TYPE_DEFAULT);
         reiserfs_read_unlock_xattrs (inode->i_sb);
+        reiserfs_read_unlock_xattr_i (inode);
         ret = acl ? 1 : 0;
         posix_acl_release (acl);
     }
@@ -437,9 +439,18 @@ reiserfs_acl_chmod (struct inode *inode)
                 return -ENOMEM;
         error = posix_acl_chmod_masq(clone, inode->i_mode);
         if (!error) {
-                reiserfs_write_lock_xattrs (inode->i_sb);
+                int lock = !has_xattr_dir (inode);
+                reiserfs_write_lock_xattr_i (inode);
+                if (lock)
+                    reiserfs_write_lock_xattrs (inode->i_sb);
+                else
+                    reiserfs_read_lock_xattrs (inode->i_sb);
                 error = reiserfs_set_acl(inode, ACL_TYPE_ACCESS, clone);
-                reiserfs_write_unlock_xattrs (inode->i_sb);
+                if (lock)
+                    reiserfs_write_unlock_xattrs (inode->i_sb);
+                else
+                    reiserfs_read_unlock_xattrs (inode->i_sb);
+                reiserfs_write_unlock_xattr_i (inode);
         }
         posix_acl_release(clone);
         return error;
Index: linux.mm/include/linux/reiserfs_fs_i.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs_i.h	2004-04-05 17:30:11.507967187 -0400
+++ linux.mm/include/linux/reiserfs_fs_i.h	2004-04-05 17:30:14.678585183 -0400
@@ -24,6 +24,7 @@ typedef enum {
     i_link_saved_unlink_mask   =  0x0010,
     i_link_saved_truncate_mask =  0x0020,
     i_priv_object              =  0x0080,
+    i_has_xattr_dir            =  0x0100,
 } reiserfs_inode_flags;
 
 
@@ -55,6 +56,7 @@ struct reiserfs_inode_info {
 
     struct posix_acl *i_acl_access;
     struct posix_acl *i_acl_default;
+    struct rw_semaphore xattr_sem;
     struct inode vfs_inode;
 };
 
Index: linux.mm/include/linux/reiserfs_xattr.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_xattr.h	2004-04-05 17:30:13.531723343 -0400
+++ linux.mm/include/linux/reiserfs_xattr.h	2004-04-05 17:30:14.679585062 -0400
@@ -32,6 +32,7 @@ struct reiserfs_xattr_handler {
 
 #ifdef CONFIG_REISERFS_FS_XATTR
 #define is_reiserfs_priv_object(inode) (REISERFS_I(inode)->i_flags & i_priv_object)
+#define has_xattr_dir(inode) (REISERFS_I(inode)->i_flags & i_has_xattr_dir)
 ssize_t reiserfs_getxattr (struct dentry *dentry, const char *name,
 			   void *buffer, size_t size);
 int reiserfs_setxattr (struct dentry *dentry, const char *name,
@@ -80,6 +81,28 @@ reiserfs_read_unlock_xattrs(struct super
     up_read (&REISERFS_XATTR_DIR_SEM(sb));
 }
 
+static inline void
+reiserfs_write_lock_xattr_i(struct inode *inode)
+{
+    down_write (&REISERFS_I(inode)->xattr_sem);
+}
+static inline void
+reiserfs_write_unlock_xattr_i(struct inode *inode)
+{
+    up_write (&REISERFS_I(inode)->xattr_sem);
+}
+static inline void
+reiserfs_read_lock_xattr_i(struct inode *inode)
+{
+    down_read (&REISERFS_I(inode)->xattr_sem);
+}
+
+static inline void
+reiserfs_read_unlock_xattr_i(struct inode *inode)
+{
+    up_read (&REISERFS_I(inode)->xattr_sem);
+}
+
 #else
 
 #define is_reiserfs_priv_object(inode) 0
mason@suse.com

ReiserFS support for quotas.  Originally from Jan Kara

Index: linux.mm/fs/reiserfs/bitmap.c
===================================================================
--- linux.mm.orig/fs/reiserfs/bitmap.c	2004-01-09 01:59:45.000000000 -0500
+++ linux.mm/fs/reiserfs/bitmap.c	2004-04-23 10:46:05.310019792 -0400
@@ -12,6 +12,7 @@
 #include <linux/pagemap.h>
 #include <linux/reiserfs_fs_sb.h>
 #include <linux/reiserfs_fs_i.h>
+#include <linux/quotaops.h>
 
 #define PREALLOCATION_SIZE 9
 
@@ -281,7 +282,8 @@ static int scan_bitmap (struct reiserfs_
 }
 
 static void _reiserfs_free_block (struct reiserfs_transaction_handle *th,
-				  b_blocknr_t block)
+				  struct inode *inode, b_blocknr_t block,
+				  int for_unformatted)
 {
     struct super_block * s = th->t_super;
     struct reiserfs_super_block * rs;
@@ -323,11 +325,13 @@ static void _reiserfs_free_block (struct
     set_sb_free_blocks( rs, sb_free_blocks(rs) + 1 );
 
     journal_mark_dirty (th, s, sbh);
-  s->s_dirt = 1;
+    if (for_unformatted)
+        DQUOT_FREE_BLOCK_NODIRTY(inode, 1);
 }
 
 void reiserfs_free_block (struct reiserfs_transaction_handle *th, 
-                          b_blocknr_t block)
+			  struct inode *inode, b_blocknr_t block,
+			  int for_unformatted)
 {
     struct super_block * s = th->t_super;
 
@@ -335,42 +339,46 @@ void reiserfs_free_block (struct reiserf
     RFALSE(is_reusable (s, block, 1) == 0, "vs-4071: can not free such block");
     /* mark it before we clear it, just in case */
     journal_mark_freed(th, s, block) ;
-    _reiserfs_free_block(th, block) ;
+    _reiserfs_free_block(th, inode, block, for_unformatted) ;
 }
 
 /* preallocated blocks don't need to be run through journal_mark_freed */
 void reiserfs_free_prealloc_block (struct reiserfs_transaction_handle *th, 
-                          b_blocknr_t block) {
+			  struct inode *inode, b_blocknr_t block) {
     RFALSE(!th->t_super, "vs-4060: trying to free block on nonexistent device");
     RFALSE(is_reusable (th->t_super, block, 1) == 0, "vs-4070: can not free such block");
-    _reiserfs_free_block(th, block) ;
+    _reiserfs_free_block(th, inode, block, 1) ;
 }
 
 static void __discard_prealloc (struct reiserfs_transaction_handle * th,
 				struct reiserfs_inode_info *ei)
 {
     unsigned long save = ei->i_prealloc_block ;
+    int dirty = 0;
+    struct inode *inode = &ei->vfs_inode;
 #ifdef CONFIG_REISERFS_CHECK
     if (ei->i_prealloc_count < 0)
 	reiserfs_warning("zam-4001:%s: inode has negative prealloc blocks count.\n", __FUNCTION__ );
 #endif
     while (ei->i_prealloc_count > 0) {
-	reiserfs_free_prealloc_block(th,ei->i_prealloc_block);
+	reiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);
 	ei->i_prealloc_block++;
 	ei->i_prealloc_count --;
+	dirty = 1;
     }
+    if (dirty)
+    	reiserfs_update_sd(th, inode);
     ei->i_prealloc_block = save;
     list_del_init(&(ei->i_prealloc_list));
 }
 
 /* FIXME: It should be inline function */
 void reiserfs_discard_prealloc (struct reiserfs_transaction_handle *th, 
-				struct inode * inode)
+				struct inode *inode)
 {
     struct reiserfs_inode_info *ei = REISERFS_I(inode);
-    if (ei->i_prealloc_count) {
+    if (ei->i_prealloc_count)
 	__discard_prealloc(th, ei);
-    }
 }
 
 void reiserfs_discard_all_prealloc (struct reiserfs_transaction_handle *th)
@@ -772,6 +780,24 @@ static inline int blocknrs_and_prealloc_
     int nr_allocated = 0;
 
     determine_prealloc_size(hint);
+    if (!hint->formatted_node) {
+        int quota_ret;
+#ifdef REISERQUOTA_DEBUG
+	printk(KERN_DEBUG "reiserquota: allocating %d blocks id=%u\n", amount_needed, hint->inode->i_uid);
+#endif
+	quota_ret = DQUOT_ALLOC_BLOCK_NODIRTY(hint->inode, amount_needed);
+	if (quota_ret)    /* Quota exceeded? */
+	    return QUOTA_EXCEEDED;
+	if (hint->preallocate && hint->prealloc_size ) {
+#ifdef REISERQUOTA_DEBUG
+	    printk(KERN_DEBUG "reiserquota: allocating (prealloc) %d blocks id=%u\n", hint->prealloc_size, hint->inode->i_uid);
+#endif
+	    quota_ret = DQUOT_PREALLOC_BLOCK_NODIRTY(hint->inode, hint->prealloc_size);
+	    if (quota_ret)
+		hint->preallocate=hint->prealloc_size=0;
+	}
+    }
+
     while((nr_allocated
 	  += allocate_without_wrapping_disk(hint, new_blocknrs + nr_allocated, start, finish,
 					  amount_needed - nr_allocated, hint->prealloc_size))
@@ -779,8 +805,14 @@ static inline int blocknrs_and_prealloc_
 
 	/* not all blocks were successfully allocated yet*/
 	if (second_pass) {	/* it was a second pass; we must free all blocks */
+	    if (!hint->formatted_node) {
+#ifdef REISERQUOTA_DEBUG
+		printk(KERN_DEBUG "reiserquota: freeing (nospace) %d blocks id=%u\n", amount_needed + hint->prealloc_size - nr_allocated, hint->inode->i_uid);
+#endif
+		DQUOT_FREE_BLOCK_NODIRTY(hint->inode, amount_needed + hint->prealloc_size - nr_allocated);     /* Free not allocated blocks */
+	    }
 	    while (nr_allocated --)
-		reiserfs_free_block(hint->th, new_blocknrs[nr_allocated]);
+		reiserfs_free_block(hint->th, hint->inode, new_blocknrs[nr_allocated], !hint->formatted_node);
 
 	    return NO_DISK_SPACE;
 	} else {		/* refine search parameters for next pass */
@@ -789,7 +821,19 @@ static inline int blocknrs_and_prealloc_
 	    start = 0;
 	    continue;
 	}
-      }
+    }
+    if ( !hint->formatted_node &&
+         amount_needed + hint->prealloc_size >
+	 nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {
+    /* Some of preallocation blocks were not allocated */
+#ifdef REISERQUOTA_DEBUG
+	printk(KERN_DEBUG "reiserquota: freeing (failed prealloc) %d blocks id=%u\n", amount_needed + hint->prealloc_size - nr_allocated - INODE_INFO(hint->inode)->i_prealloc_count, hint->inode->i_uid);
+#endif
+	DQUOT_FREE_BLOCK_NODIRTY(hint->inode, amount_needed +
+	                         hint->prealloc_size - nr_allocated -
+				 REISERFS_I(hint->inode)->i_prealloc_count);
+    }
+
     return CARRY_ON;
 }
 
@@ -858,7 +902,7 @@ int reiserfs_allocate_blocknrs(reiserfs_
 
     if (ret != CARRY_ON) {
 	while (amount_needed ++ < initial_amount_needed) {
-	    reiserfs_free_block(hint->th, *(--new_blocknrs));
+	    reiserfs_free_block(hint->th, hint->inode, *(--new_blocknrs), 1);
 	}
     }
     return ret;
Index: linux.mm/fs/reiserfs/do_balan.c
===================================================================
--- linux.mm.orig/fs/reiserfs/do_balan.c	2004-04-23 10:45:29.370327182 -0400
+++ linux.mm/fs/reiserfs/do_balan.c	2004-04-23 10:46:05.313019433 -0400
@@ -1234,7 +1234,7 @@ static void free_thrown(struct tree_bala
 	    if (buffer_dirty (tb->thrown[i]))
 	      printk ("free_thrown deals with dirty buffer %d\n", blocknr);
 	    brelse(tb->thrown[i]) ; /* incremented in store_thrown */
-	    reiserfs_free_block (tb->transaction_handle, blocknr);
+	    reiserfs_free_block (tb->transaction_handle, NULL, blocknr, 0);
 	}
     }
 }
@@ -1247,10 +1247,6 @@ void reiserfs_invalidate_buffer (struct 
     set_blkh_nr_item( blkh, 0 );
     
     clear_buffer_dirty(bh);
-    /* reiserfs_free_block is no longer schedule safe 
-    reiserfs_free_block (tb->transaction_handle, tb->tb_sb, bh->b_blocknr);
-    */
-
     store_thrown (tb, bh);
 }
 
Index: linux.mm/fs/reiserfs/file.c
===================================================================
--- linux.mm.orig/fs/reiserfs/file.c	2004-04-23 10:46:01.457481521 -0400
+++ linux.mm/fs/reiserfs/file.c	2004-04-23 10:46:05.317018953 -0400
@@ -13,6 +13,7 @@
 #include <linux/writeback.h>
 #include <linux/blkdev.h>
 #include <linux/buffer_head.h>
+#include <linux/quotaops.h>
 
 /*
 ** We pack the tails of files on file close, not at the time they are written.
@@ -274,7 +275,7 @@ int reiserfs_allocate_blocks_for_region(
 		    /* Ok, there is existing indirect item already. Need to append it */
 		    /* Calculate position past inserted item */
 		    make_cpu_key( &key, inode, le_key_k_offset( get_inode_item_key_version(inode), &(ih->ih_key)) + op_bytes_number(ih, inode->i_sb->s_blocksize), TYPE_INDIRECT, 3);
-		    res = reiserfs_paste_into_item( th, &path, &key, (char *)zeros, UNFM_P_SIZE*to_paste);
+		    res = reiserfs_paste_into_item( th, &path, &key, inode, (char *)zeros, UNFM_P_SIZE*to_paste);
 		    if ( res ) {
 			kfree(zeros);
 			goto error_exit_free_blocks;
@@ -304,7 +305,7 @@ int reiserfs_allocate_blocks_for_region(
 		        kfree(zeros);
 			goto error_exit_free_blocks;
 		    }
-		    res = reiserfs_insert_item( th, &path, &key, &ins_ih, (char *)zeros);
+		    res = reiserfs_insert_item( th, &path, &key, &ins_ih, inode, (char *)zeros);
 		} else {
 		    reiserfs_panic(inode->i_sb, "green-9011: Unexpected key type %K\n", &key);
 		}
@@ -421,7 +422,7 @@ retry:
 	    // position. We do not need to recalculate path as it should
 	    // already point to correct place.
 	    make_cpu_key( &key, inode, le_key_k_offset( get_inode_item_key_version(inode), &(ih->ih_key)) + op_bytes_number(ih, inode->i_sb->s_blocksize), TYPE_INDIRECT, 3);
-	    res = reiserfs_paste_into_item( th, &path, &key, (char *)(allocated_blocks+curr_block), UNFM_P_SIZE*(blocks_to_allocate-curr_block));
+	    res = reiserfs_paste_into_item( th, &path, &key, inode, (char *)(allocated_blocks+curr_block), UNFM_P_SIZE*(blocks_to_allocate-curr_block));
 	    if ( res ) {
 		goto error_exit_free_blocks;
 	    }
@@ -452,7 +453,7 @@ retry:
 		goto error_exit_free_blocks;
 	    }
 	    /* Insert item into the tree with the data as its body */
-	    res = reiserfs_insert_item( th, &path, &key, &ins_ih, (char *)(allocated_blocks+curr_block));
+	    res = reiserfs_insert_item( th, &path, &key, &ins_ih, inode, (char *)(allocated_blocks+curr_block));
 	} else {
 	    reiserfs_panic(inode->i_sb, "green-9010: unexpected item type for key %K\n",&key);
 	}
@@ -462,7 +463,6 @@ retry:
     // unless we return an error, they are also responsible for logging
     // the inode.
     //
-    inode->i_blocks += blocks_to_allocate << (inode->i_blkbits - 9);
     pathrelse(&path);
     reiserfs_write_unlock(inode->i_sb);
 
@@ -508,7 +508,7 @@ error_exit_free_blocks:
     pathrelse(&path);
     // free blocks
     for( i = 0; i < blocks_to_allocate; i++ )
-	reiserfs_free_block(th, le32_to_cpu(allocated_blocks[i]));
+	reiserfs_free_block(th, inode, le32_to_cpu(allocated_blocks[i]), 1);
 
 error_exit:
     reiserfs_update_sd(th, inode); // update any changes we made to blk count
Index: linux.mm/fs/reiserfs/fix_node.c
===================================================================
--- linux.mm.orig/fs/reiserfs/fix_node.c	2004-04-23 10:45:29.420321190 -0400
+++ linux.mm/fs/reiserfs/fix_node.c	2004-04-23 10:46:05.322018354 -0400
@@ -795,8 +795,9 @@ static int  get_empty_nodes(
   else /* If we have enough already then there is nothing to do. */
     return CARRY_ON;
 
-  if ( reiserfs_new_form_blocknrs (p_s_tb, a_n_blocknrs,
-                                   n_amount_needed) == NO_DISK_SPACE )
+  /* No need to check quota - is not allocated for blocks used for formatted nodes */
+  if (reiserfs_new_form_blocknrs (p_s_tb, a_n_blocknrs,
+                                   n_amount_needed) == NO_DISK_SPACE)
     return NO_DISK_SPACE;
 
   /* for each blocknumber we just got, get a buffer and stick it on FEB */
@@ -2492,7 +2493,7 @@ void unfix_nodes (struct tree_balance * 
 	    /* de-allocated block which was not used by balancing and
                bforget about buffer for it */
 	    brelse (tb->FEB[i]);
-	    reiserfs_free_block (tb->transaction_handle, blocknr);
+	    reiserfs_free_block (tb->transaction_handle, NULL, blocknr, 0);
 	}
 	if (tb->used[i]) {
 	    /* release used as new nodes including a new root */
Index: linux.mm/fs/reiserfs/inode.c
===================================================================
--- linux.mm.orig/fs/reiserfs/inode.c	2004-04-23 10:46:04.129161319 -0400
+++ linux.mm/fs/reiserfs/inode.c	2004-04-23 10:46:05.328017635 -0400
@@ -4,6 +4,7 @@
 
 #include <linux/config.h>
 #include <linux/time.h>
+#include <linux/fs.h>
 #include <linux/reiserfs_fs.h>
 #include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
@@ -39,6 +40,7 @@ void reiserfs_delete_inode (struct inode
   
     reiserfs_write_lock(inode->i_sb);
 
+    DQUOT_FREE_INODE(inode);
     /* The = 0 happens when we abort creating a new inode for some reason like lack of space.. */
     if (!(inode->i_state & I_NEW) && INODE_PKEY(inode)->k_objectid != 0) { /* also handles bad_inode case */
 	down (&inode->i_sem); 
@@ -647,7 +649,7 @@ start_trans:
 
 	repeat = _allocate_block(th, block, inode, &allocated_block_nr, &path, create);
 
-	if (repeat == NO_DISK_SPACE) {
+	if (repeat == NO_DISK_SPACE || repeat == QUOTA_EXCEEDED) {
 	    /* restart the transaction to give the journal a chance to free
 	    ** some blocks.  releases the path, so we have to go back to
 	    ** research if we succeed on the second try
@@ -656,10 +658,13 @@ start_trans:
 	    restart_transaction(th, inode, &path) ;
 	    repeat = _allocate_block(th, block, inode, &allocated_block_nr, NULL, create);
 
-	    if (repeat != NO_DISK_SPACE) {
+	    if (repeat != NO_DISK_SPACE && repeat != QUOTA_EXCEEDED) {
 		goto research ;
 	    }
-	    retval = -ENOSPC;
+	    if (repeat == QUOTA_EXCEEDED)
+		retval = -EDQUOT;
+	    else
+		retval = -ENOSPC;
 	    goto failure;
 	}
 
@@ -687,7 +692,6 @@ start_trans:
 	    put_block_num(item, pos_in_item, allocated_block_nr) ;
             unfm_ptr = allocated_block_nr;
 	    journal_mark_dirty (th, inode->i_sb, bh);
-	    inode->i_blocks += (inode->i_sb->s_blocksize / 512) ;
 	    reiserfs_update_sd(th, inode) ;
 	}
 	set_block_dev_mapped(bh_result, unfm_ptr, inode);
@@ -734,13 +738,11 @@ start_trans:
 	    set_cpu_key_k_offset (&tmp_key, 1);
 	    PATH_LAST_POSITION(&path) ++;
 
-	    retval = reiserfs_insert_item (th, &path, &tmp_key, &tmp_ih, (char *)&unp);
+	    retval = reiserfs_insert_item (th, &path, &tmp_key, &tmp_ih, inode, (char *)&unp);
 	    if (retval) {
-		reiserfs_free_block (th, allocated_block_nr);
-		goto failure; // retval == -ENOSPC or -EIO or -EEXIST
+		reiserfs_free_block (th, inode, allocated_block_nr, 1);
+		goto failure; // retval == -ENOSPC, -EDQUOT or -EIO or -EEXIST
 	    }
-	    if (unp)
-		inode->i_blocks += inode->i_sb->s_blocksize / 512;
 	    //mark_tail_converted (inode);
 	} else if (is_direct_le_ih (ih)) {
 	    /* direct item has to be converted */
@@ -778,7 +780,7 @@ start_trans:
 			if (!th)
 			    th = reiserfs_persistent_transaction(inode->i_sb,3);
 			if (th)
-			    reiserfs_free_block (th, allocated_block_nr);
+			    reiserfs_free_block (th,inode,allocated_block_nr,1);
 		    }
 		    goto failure ;
 		}
@@ -787,7 +789,7 @@ start_trans:
 	    retval = direct2indirect (th, inode, &path, unbh, tail_offset);
 	    if (retval) {
 		reiserfs_unmap_buffer(unbh);
-		reiserfs_free_block (th, allocated_block_nr);
+		reiserfs_free_block (th, inode, allocated_block_nr, 1);
 		goto failure;
 	    }
 	    /* it is important the set_buffer_uptodate is done after
@@ -820,9 +822,6 @@ start_trans:
 		 */
 		mark_buffer_dirty(unbh) ;
 	    }
-
-	    //inode->i_blocks += inode->i_sb->s_blocksize / 512;
-	    //mark_tail_converted (inode);
 	} else {
 	    /* append indirect item with holes if needed, when appending
 	       pointer to 'block'-th block use block, which is already
@@ -870,24 +869,21 @@ start_trans:
 		   only have space for one block */
 		blocks_needed=max_to_insert?max_to_insert:1;
 	    }
-	    retval = reiserfs_paste_into_item (th, &path, &tmp_key, (char *)un, UNFM_P_SIZE * blocks_needed);
+	    retval = reiserfs_paste_into_item (th, &path, &tmp_key, inode, (char *)un, UNFM_P_SIZE * blocks_needed);
 
 	    if (blocks_needed != 1)
 		kfree(un);
 
 	    if (retval) {
-		reiserfs_free_block (th, allocated_block_nr);
+		reiserfs_free_block (th, inode, allocated_block_nr, 1);
 		goto failure;
 	    }
-	    if (done) {
-		inode->i_blocks += inode->i_sb->s_blocksize / 512;
-	    } else {
+	    if (!done) {
 		/* We need to mark new file size in case this function will be
 		   interrupted/aborted later on. And we may do this only for
 		   holes. */
 		inode->i_size += inode->i_sb->s_blocksize * blocks_needed;
 	    }
-	    //mark_tail_converted (inode);
 	}
 
 	if (done == 1)
@@ -919,7 +915,7 @@ start_trans:
 			      "%K should not be found\n", &key);
 	    retval = -EEXIST;
 	    if (allocated_block_nr)
-	        reiserfs_free_block (th, allocated_block_nr);
+	        reiserfs_free_block (th, inode, allocated_block_nr, 1);
 	    pathrelse(&path) ;
 	    goto failure;
 	}
@@ -949,6 +945,58 @@ reiserfs_readpages(struct file *file, st
     return mpage_readpages(mapping, pages, nr_pages, reiserfs_get_block);
 }
 
+/* Compute real number of used bytes by file
+ * Following three functions can go away when we'll have enough space in stat item
+ */
+static int real_space_diff(struct inode *inode, int sd_size)
+{
+    int bytes;
+    loff_t blocksize = inode->i_sb->s_blocksize ;
+
+    if (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode))
+        return sd_size ;
+
+    /* End of file is also in full block with indirect reference, so round
+    ** up to the next block.
+    **
+    ** there is just no way to know if the tail is actually packed
+    ** on the file, so we have to assume it isn't.  When we pack the
+    ** tail, we add 4 bytes to pretend there really is an unformatted
+    ** node pointer
+    */
+    bytes = ((inode->i_size + (blocksize-1)) >> inode->i_sb->s_blocksize_bits) * UNFM_P_SIZE + sd_size;
+    return bytes ;
+}
+
+static inline loff_t to_real_used_space(struct inode *inode, ulong blocks,
+                                        int sd_size)
+{
+    if (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {
+        return inode->i_size + (loff_t)(real_space_diff(inode, sd_size)) ;
+    }
+    return ((loff_t)real_space_diff(inode, sd_size)) + (((loff_t)blocks) << 9);
+}
+
+/* Compute number of blocks used by file in ReiserFS counting */
+static inline ulong to_fake_used_blocks(struct inode *inode, int sd_size)
+{
+    loff_t bytes = inode_get_bytes(inode) ;
+    loff_t real_space = real_space_diff(inode, sd_size) ;
+
+    /* keeps fsck and non-quota versions of reiserfs happy */
+    if (S_ISLNK(inode->i_mode) || S_ISDIR(inode->i_mode)) {
+        bytes += (loff_t)511 ;
+    }
+
+    /* files from before the quota patch might i_blocks such that
+    ** bytes < real_space.  Deal with that here to prevent it from
+    ** going negative.
+    */
+    if (bytes < real_space)
+        return 0 ;
+    return (bytes - real_space) >> 9;
+}
+
 //
 // BAD: new directories have stat data of new type and all other items
 // of old type. Version stored in the inode says about body items, so
@@ -1014,6 +1062,14 @@ static void init_inode (struct inode * i
 
         rdev = sd_v1_rdev(sd);
 	REISERFS_I(inode)->i_first_direct_byte = sd_v1_first_direct_byte(sd);
+	/* an early bug in the quota code can give us an odd number for the
+	** block count.  This is incorrect, fix it here.
+	*/
+	if (inode->i_blocks & 1) {
+	    inode->i_blocks++ ;
+	}
+	inode_set_bytes(inode, to_real_used_space(inode, inode->i_blocks,
+	                                          SD_V1_SIZE));
 	/* nopack is initially zero for v1 objects. For v2 objects,
 	   nopack is initialised from sd_attrs */
 	REISERFS_I(inode)->i_flags &= ~i_nopack_mask;
@@ -1046,6 +1102,8 @@ static void init_inode (struct inode * i
 	    set_inode_item_key_version (inode, KEY_FORMAT_3_6);
 	REISERFS_I(inode)->i_first_direct_byte = 0;
 	set_inode_sd_version (inode, STAT_DATA_V2);
+	inode_set_bytes(inode, to_real_used_space(inode, inode->i_blocks,
+	                                          SD_V2_SIZE));
 	/* read persistent inode attributes from sd and initalise
 	   generic inode flags from them */
 	REISERFS_I(inode)->i_attrs = sd_v2_attrs( sd );
@@ -1072,7 +1130,7 @@ static void init_inode (struct inode * i
 
 
 // update new stat data with inode fields
-static void inode2sd (void * sd, struct inode * inode)
+static void inode2sd (void * sd, struct inode * inode, loff_t size)
 {
     struct stat_data * sd_v2 = (struct stat_data *)sd;
     __u16 flags;
@@ -1080,12 +1138,12 @@ static void inode2sd (void * sd, struct 
     set_sd_v2_mode(sd_v2, inode->i_mode );
     set_sd_v2_nlink(sd_v2, inode->i_nlink );
     set_sd_v2_uid(sd_v2, inode->i_uid );
-    set_sd_v2_size(sd_v2, inode->i_size );
+    set_sd_v2_size(sd_v2, size );
     set_sd_v2_gid(sd_v2, inode->i_gid );
     set_sd_v2_mtime(sd_v2, inode->i_mtime.tv_sec );
     set_sd_v2_atime(sd_v2, inode->i_atime.tv_sec );
     set_sd_v2_ctime(sd_v2, inode->i_ctime.tv_sec );
-    set_sd_v2_blocks(sd_v2, inode->i_blocks );
+    set_sd_v2_blocks(sd_v2, to_fake_used_blocks(inode, SD_V2_SIZE));
     if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
 	set_sd_v2_rdev(sd_v2, new_encode_dev(inode->i_rdev));
     else
@@ -1097,7 +1155,7 @@ static void inode2sd (void * sd, struct 
 
 
 // used to copy inode's fields to old stat data
-static void inode2sd_v1 (void * sd, struct inode * inode)
+static void inode2sd_v1 (void * sd, struct inode * inode, loff_t size)
 {
     struct stat_data_v1 * sd_v1 = (struct stat_data_v1 *)sd;
 
@@ -1105,7 +1163,7 @@ static void inode2sd_v1 (void * sd, stru
     set_sd_v1_uid(sd_v1, inode->i_uid );
     set_sd_v1_gid(sd_v1, inode->i_gid );
     set_sd_v1_nlink(sd_v1, inode->i_nlink );
-    set_sd_v1_size(sd_v1, inode->i_size );
+    set_sd_v1_size(sd_v1, size );
     set_sd_v1_atime(sd_v1, inode->i_atime.tv_sec );
     set_sd_v1_ctime(sd_v1, inode->i_ctime.tv_sec );
     set_sd_v1_mtime(sd_v1, inode->i_mtime.tv_sec );
@@ -1113,7 +1171,7 @@ static void inode2sd_v1 (void * sd, stru
     if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
         set_sd_v1_rdev(sd_v1, new_encode_dev(inode->i_rdev));
     else
-        set_sd_v1_blocks(sd_v1, inode->i_blocks );
+        set_sd_v1_blocks(sd_v1, to_fake_used_blocks(inode, SD_V1_SIZE));
 
     // Sigh. i_first_direct_byte is back
     set_sd_v1_first_direct_byte(sd_v1, REISERFS_I(inode)->i_first_direct_byte);
@@ -1123,7 +1181,8 @@ static void inode2sd_v1 (void * sd, stru
 /* NOTE, you must prepare the buffer head before sending it here,
 ** and then log it after the call
 */
-static void update_stat_data (struct path * path, struct inode * inode)
+static void update_stat_data (struct path * path, struct inode * inode,
+                              loff_t size)
 {
     struct buffer_head * bh;
     struct item_head * ih;
@@ -1137,17 +1196,17 @@ static void update_stat_data (struct pat
   
     if (stat_data_v1 (ih)) {
 	// path points to old stat data
-	inode2sd_v1 (B_I_PITEM (bh, ih), inode);
+	inode2sd_v1 (B_I_PITEM (bh, ih), inode, size);
     } else {
-	inode2sd (B_I_PITEM (bh, ih), inode);
+	inode2sd (B_I_PITEM (bh, ih), inode, size);
     }
 
     return;
 }
 
 
-void reiserfs_update_sd (struct reiserfs_transaction_handle *th, 
-			 struct inode * inode)
+void reiserfs_update_sd_size (struct reiserfs_transaction_handle *th,
+			      struct inode * inode, loff_t size)
 {
     struct cpu_key key;
     INITIALIZE_PATH(path);
@@ -1197,7 +1256,7 @@ void reiserfs_update_sd (struct reiserfs
 	}
 	break;
     }
-    update_stat_data (&path, inode);
+    update_stat_data (&path, inode, size);
     journal_mark_dirty(th, th->t_super, bh) ; 
     pathrelse (&path);
     return;
@@ -1480,6 +1539,7 @@ int reiserfs_sync_inode (struct reiserfs
 /* stat data of new object is inserted already, this inserts the item
    containing "." and ".." entries */
 static int reiserfs_new_directory (struct reiserfs_transaction_handle *th, 
+				   struct inode *inode,
 				   struct item_head * ih, struct path * path,
 				   struct inode * dir)
 {
@@ -1524,13 +1584,14 @@ static int reiserfs_new_directory (struc
     }
 
     /* insert item, that is empty directory item */
-    return reiserfs_insert_item (th, path, &key, ih, body);
+    return reiserfs_insert_item (th, path, &key, ih, inode, body);
 }
 
 
 /* stat data of object has been inserted, this inserts the item
    containing the body of symlink */
 static int reiserfs_new_symlink (struct reiserfs_transaction_handle *th, 
+				 struct inode *inode,	/* Inode of symlink */
 				 struct item_head * ih,
 				 struct path * path, const char * symname, int item_len)
 {
@@ -1560,7 +1621,7 @@ static int reiserfs_new_symlink (struct 
     }
 
     /* insert item, that is body of symlink */
-    return reiserfs_insert_item (th, path, &key, ih, symname);
+    return reiserfs_insert_item (th, path, &key, ih, inode, symname);
 }
 
 
@@ -1628,7 +1689,8 @@ int reiserfs_new_inode (struct reiserfs_
 
     inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;
     inode->i_size = i_size;
-    inode->i_blocks = (inode->i_size + 511) >> 9;
+    inode->i_blocks = 0;
+    inode->i_bytes = 0;
     REISERFS_I(inode)->i_first_direct_byte = S_ISLNK(mode) ? 1 : 
       U32_MAX/*NO_BYTES_IN_DIRECT_ITEM*/;
 
@@ -1673,9 +1735,9 @@ int reiserfs_new_inode (struct reiserfs_
 	    err = -EINVAL;
 	    goto out_bad_inode;
 	}
-	inode2sd_v1 (&sd, inode);
+	inode2sd_v1 (&sd, inode, inode->i_size);
     } else {
-	inode2sd (&sd, inode);
+	inode2sd (&sd, inode, inode->i_size);
     }
     // these do not go to on-disk stat data
     inode->i_ino = le32_to_cpu (ih.ih_key.k_objectid);
@@ -1699,7 +1761,7 @@ int reiserfs_new_inode (struct reiserfs_
     if (REISERFS_I(dir)->new_packing_locality)
 	th->displace_new_blocks = 1;
 #endif
-    retval = reiserfs_insert_item (th, &path_to_key, &key, &ih, (char *)(&sd));
+    retval = reiserfs_insert_item (th, &path_to_key, &key, &ih, inode, (char *)(&sd));
     if (retval) {
 	err = retval;
 	reiserfs_check_path(&path_to_key) ;
@@ -1712,14 +1774,14 @@ int reiserfs_new_inode (struct reiserfs_
 #endif
     if (S_ISDIR(mode)) {
 	/* insert item with "." and ".." */
-	retval = reiserfs_new_directory (th, &ih, &path_to_key, dir);
+	retval = reiserfs_new_directory (th, inode, &ih, &path_to_key, dir);
     }
 
     if (S_ISLNK(mode)) {
 	/* insert body of symlink */
 	if (!old_format_only (sb))
 	    i_size = ROUND_UP(i_size);
-	retval = reiserfs_new_symlink (th, &ih, &path_to_key, symname, i_size);
+	retval = reiserfs_new_symlink (th, inode, &ih, &path_to_key, symname, i_size);
     }
     if (retval) {
 	err = retval;
@@ -1757,6 +1819,9 @@ out_bad_inode:
 
     /* dquot_drop must be done outside a transaction */
     journal_end(th, th->t_super, th->t_blocks_allocated) ;
+    DQUOT_FREE_INODE(inode);
+    DQUOT_DROP(inode);
+    inode->i_flags |= S_NOQUOTA;
     make_bad_inode(inode);
 
 out_inserted_sd:
@@ -2294,6 +2359,7 @@ static int reiserfs_commit_write(struct 
     struct inode *inode = page->mapping->host ;
     loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
     int ret = 0;
+    int update_sd = 0;
     struct reiserfs_transaction_handle *th = NULL;
     
     reiserfs_wait_on_write_block(inode->i_sb) ;
@@ -2320,11 +2386,14 @@ static int reiserfs_commit_write(struct 
 	reiserfs_update_inode_transaction(inode) ;
 	inode->i_size = pos ;
 	reiserfs_update_sd(&myth, inode) ;
+	update_sd = 1;
 	journal_end(&myth, inode->i_sb, 1) ;
 	reiserfs_write_unlock(inode->i_sb);
     }
     if (th) {
 	reiserfs_write_lock(inode->i_sb);
+	if (!update_sd)
+	    reiserfs_update_sd(th, inode) ;
         reiserfs_end_persistent_transaction(th);
 	reiserfs_write_unlock(inode->i_sb);
     }
@@ -2533,7 +2602,6 @@ static ssize_t reiserfs_direct_IO(int rw
 			offset, nr_segs, reiserfs_get_blocks_direct_io, NULL);
 }
 
-
 int reiserfs_setattr(struct dentry *dentry, struct iattr *attr) {
     struct inode *inode = dentry->d_inode ;
     int error ;
Index: linux.mm/fs/reiserfs/namei.c
===================================================================
--- linux.mm.orig/fs/reiserfs/namei.c	2004-04-23 10:46:01.466480443 -0400
+++ linux.mm/fs/reiserfs/namei.c	2004-04-23 10:46:05.332017156 -0400
@@ -18,6 +18,7 @@
 #include <linux/reiserfs_acl.h>
 #include <linux/reiserfs_xattr.h>
 #include <linux/smp_lock.h>
+#include <linux/quotaops.h>
 
 #define INC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) { i->i_nlink++; if (i->i_nlink >= REISERFS_LINK_MAX) i->i_nlink=1; }
 #define DEC_DIR_INODE_NLINK(i) if (i->i_nlink != 1) i->i_nlink--;
@@ -519,7 +520,7 @@ static int reiserfs_add_entry (struct re
     }
   
     /* perform the insertion of the entry that we have prepared */
-    retval = reiserfs_paste_into_item (th, &path, &entry_key, buffer, paste_size);
+    retval = reiserfs_paste_into_item (th, &path, &entry_key, dir, buffer, paste_size);
     if (buffer != small_buf)
 	reiserfs_kfree (buffer, buflen, dir->i_sb);
     if (retval) {
@@ -528,7 +529,6 @@ static int reiserfs_add_entry (struct re
     }
 
     dir->i_size += paste_size;
-    dir->i_blocks = ((dir->i_size + 511) >> 9);
     dir->i_mtime = dir->i_ctime = CURRENT_TIME;
     if (!S_ISDIR (inode->i_mode) && visible)
 	// reiserfs_mkdir or reiserfs_rename will do that by itself
@@ -544,7 +544,9 @@ static int reiserfs_add_entry (struct re
 ** inserted into the tree yet.
 */
 static int drop_new_inode(struct inode *inode) {
+    DQUOT_DROP(inode);
     make_bad_inode(inode) ;
+    inode->i_flags |= S_NOQUOTA;
     iput(inode) ;
     return 0 ;
 }
@@ -570,6 +572,11 @@ static int new_inode_init(struct inode *
     } else {
         inode->i_gid = current->fsgid;
     }
+    DQUOT_INIT(inode);
+    if (DQUOT_ALLOC_INODE(inode)) {
+        drop_new_inode(inode);
+	return -EDQUOT;
+    }
     return 0 ;
 }
 
@@ -836,7 +843,6 @@ static int reiserfs_rmdir (struct inode 
 
     DEC_DIR_INODE_NLINK(dir)
     dir->i_size -= (DEH_SIZE + de.de_entrylen);
-    dir->i_blocks = ((dir->i_size + 511) >> 9);
     reiserfs_update_sd (&th, dir);
 
     /* prevent empty directory from getting lost */
@@ -919,7 +925,6 @@ static int reiserfs_unlink (struct inode
     reiserfs_update_sd (&th, inode);
 
     dir->i_size -= (de.de_entrylen + DEH_SIZE);
-    dir->i_blocks = ((dir->i_size + 511) >> 9);
     dir->i_ctime = dir->i_mtime = CURRENT_TIME;
     reiserfs_update_sd (&th, dir);
 
@@ -1335,7 +1340,6 @@ static int reiserfs_rename (struct inode
 	reiserfs_warning ("vs-7060: reiserfs_rename: couldn't not cut old name. Fsck later?\n");
 
     old_dir->i_size -= DEH_SIZE + old_de.de_entrylen;
-    old_dir->i_blocks = ((old_dir->i_size + 511) >> 9);
 
     reiserfs_update_sd (&th, old_dir);
     reiserfs_update_sd (&th, new_dir);
Index: linux.mm/fs/reiserfs/stree.c
===================================================================
--- linux.mm.orig/fs/reiserfs/stree.c	2004-04-05 10:56:49.000000000 -0400
+++ linux.mm/fs/reiserfs/stree.c	2004-04-23 10:46:05.356014280 -0400
@@ -60,6 +60,7 @@
 #include <linux/reiserfs_fs.h>
 #include <linux/smp_lock.h>
 #include <linux/buffer_head.h>
+#include <linux/quotaops.h>
 
 /* Does the buffer contain a disk block which is in the tree. */
 inline int B_IS_IN_TREE (const struct buffer_head * p_s_bh)
@@ -71,9 +72,6 @@ inline int B_IS_IN_TREE (const struct bu
   return ( B_LEVEL (p_s_bh) != FREE_LEVEL );
 }
 
-
-
-
 inline void copy_short_key (void * to, const void * from)
 {
     memcpy (to, from, SHORT_KEY_SIZE);
@@ -1125,8 +1123,7 @@ static char  prepare_for_delete_or_cut(
 		tmp = get_block_num(p_n_unfm_pointer,0);
 		put_block_num(p_n_unfm_pointer, 0, 0);
 		journal_mark_dirty (th, p_s_sb, p_s_bh);
-		inode->i_blocks -= p_s_sb->s_blocksize / 512;
-		reiserfs_free_block(th, tmp);
+		reiserfs_free_block(th, inode, tmp, 1);
 		if ( item_moved (&s_ih, p_s_path) )  {
 			need_research = 1;
 			break ;
@@ -1155,8 +1152,7 @@ static char  prepare_for_delete_or_cut(
     }
 }
 
-
-/* Calculate bytes number which will be deleted or cutted in the balance. */
+/* Calculate number of bytes which will be deleted or cut during balance */
 int calc_deleted_bytes_number(
     struct  tree_balance  * p_s_tb,
     char                    c_mode
@@ -1167,14 +1163,14 @@ int calc_deleted_bytes_number(
     if ( is_statdata_le_ih (p_le_ih) )
 	return 0;
 
+    n_del_size = ( c_mode == M_DELETE ) ? ih_item_len(p_le_ih) : -p_s_tb->insert_size[0];
     if ( is_direntry_le_ih (p_le_ih) ) {
 	// return EMPTY_DIR_SIZE; /* We delete emty directoris only. */
 	// we can't use EMPTY_DIR_SIZE, as old format dirs have a different
 	// empty size.  ick. FIXME, is this right?
 	//
-	return ih_item_len(p_le_ih);
+	return n_del_size ;
     }
-    n_del_size = ( c_mode == M_DELETE ) ? ih_item_len(p_le_ih) : -p_s_tb->insert_size[0];
 
     if ( is_indirect_le_ih (p_le_ih) )
 	n_del_size = (n_del_size/UNFM_P_SIZE)*
@@ -1208,17 +1204,46 @@ void padd_item (char * item, int total_l
 	item [--i] = 0;
 }
 
+#ifdef REISERQUOTA_DEBUG
+char key2type(struct key *ih)
+{
+  if (is_direntry_le_key(2, ih))
+    return 'd';
+  if (is_direct_le_key(2, ih))
+    return 'D';
+  if (is_indirect_le_key(2, ih))
+    return 'i';
+  if (is_statdata_le_key(2, ih))
+    return 's';
+  return 'u';
+}
+
+char head2type(struct item_head *ih)
+{
+  if (is_direntry_le_ih(ih))
+    return 'd';
+  if (is_direct_le_ih(ih))
+    return 'D';
+  if (is_indirect_le_ih(ih))
+    return 'i';
+  if (is_statdata_le_ih(ih))
+    return 's';
+  return 'u';
+}
+#endif
 
 /* Delete object item. */
 int reiserfs_delete_item (struct reiserfs_transaction_handle *th, 
 			  struct path * p_s_path, /* Path to the deleted item. */
 			  const struct cpu_key * p_s_item_key, /* Key to search for the deleted item.  */
-			  struct inode * p_s_inode,/* inode is here just to update i_blocks */
+			  struct inode * p_s_inode,/* inode is here just to update i_blocks and quotas */
 			  struct buffer_head  * p_s_un_bh)    /* NULL or unformatted node pointer.    */
 {
     struct super_block * p_s_sb = p_s_inode->i_sb;
     struct tree_balance   s_del_balance;
     struct item_head      s_ih;
+    struct item_head      *q_ih;
+    int			  quota_cut_bytes;
     int                   n_ret_value,
 	n_del_size,
 	n_removed;
@@ -1268,6 +1293,22 @@ int reiserfs_delete_item (struct reiserf
 
     // reiserfs_delete_item returns item length when success
     n_ret_value = calc_deleted_bytes_number(&s_del_balance, M_DELETE);
+    q_ih = get_ih(p_s_path) ;
+    quota_cut_bytes = ih_item_len(q_ih) ;
+
+    /* hack so the quota code doesn't have to guess if the file
+    ** has a tail.  On tail insert, we allocate quota for 1 unformatted node.
+    ** We test the offset because the tail might have been
+    ** split into multiple items, and we only want to decrement for
+    ** the unfm node once
+    */
+    if (!S_ISLNK (p_s_inode->i_mode) && is_direct_le_ih(q_ih)) {
+        if ((le_ih_k_offset(q_ih) & (p_s_sb->s_blocksize - 1)) == 1) {
+            quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE;
+        } else {
+	    quota_cut_bytes = 0 ;
+	}
+    }
 
     if ( p_s_un_bh )  {
 	int off;
@@ -1299,10 +1340,14 @@ int reiserfs_delete_item (struct reiserf
 	       B_I_PITEM(PATH_PLAST_BUFFER(p_s_path), &s_ih), n_ret_value);
 	kunmap_atomic(data, KM_USER0);
     }
-
     /* Perform balancing after all resources have been collected at once. */ 
     do_balance(&s_del_balance, NULL, NULL, M_DELETE);
 
+#ifdef REISERQUOTA_DEBUG
+    printk(KERN_DEBUG "reiserquota delete_item(): freeing %u, id=%u type=%c\n", quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
+#endif
+    DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
+
     /* Return deleted body length */
     return n_ret_value;
 }
@@ -1327,14 +1372,16 @@ int reiserfs_delete_item (struct reiserf
 
 /* this deletes item which never gets split */
 void reiserfs_delete_solid_item (struct reiserfs_transaction_handle *th,
+				 struct inode *inode,
 				 struct key * key)
 {
     struct tree_balance tb;
     INITIALIZE_PATH (path);
-    int item_len;
+    int item_len = 0;
     int tb_init = 0 ;
     struct cpu_key cpu_key;
     int retval;
+    int quota_cut_bytes = 0;
     
     le_key2cpu_key (&cpu_key, key);
     
@@ -1358,6 +1405,7 @@ void reiserfs_delete_solid_item (struct 
 	    item_len = ih_item_len( PATH_PITEM_HEAD(&path) );
 	    init_tb_struct (th, &tb, th->t_super, &path, - (IH_SIZE + item_len));
 	}
+	quota_cut_bytes = ih_item_len(PATH_PITEM_HEAD(&path)) ;
 
 	retval = fix_nodes (M_DELETE, &tb, NULL, 0);
 	if (retval == REPEAT_SEARCH) {
@@ -1367,6 +1415,12 @@ void reiserfs_delete_solid_item (struct 
 
 	if (retval == CARRY_ON) {
 	    do_balance (&tb, 0, 0, M_DELETE);
+	    if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
+#ifdef REISERQUOTA_DEBUG
+		printk(KERN_DEBUG "reiserquota delete_solid_item(): freeing %u id=%u type=%c\n", quota_cut_bytes, inode->i_uid, key2type(key));
+#endif
+		DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
+	    }
 	    break;
 	}
 
@@ -1399,7 +1453,7 @@ void reiserfs_delete_object (struct reis
       }
 /* USE_INODE_GENERATION_COUNTER */
 #endif
-    reiserfs_delete_solid_item (th, INODE_PKEY (inode));
+    reiserfs_delete_solid_item (th, inode, INODE_PKEY (inode));
 }
 
 
@@ -1486,12 +1540,14 @@ int reiserfs_cut_from_item (struct reise
        structure by using the init_tb_struct and fix_nodes functions.
        After that we can make tree balancing. */
     struct tree_balance s_cut_balance;
+    struct item_head *p_le_ih;
     int n_cut_size = 0,        /* Amount to be cut. */
 	n_ret_value = CARRY_ON,
 	n_removed = 0,     /* Number of the removed unformatted nodes. */
 	n_is_inode_locked = 0;
     char                c_mode;            /* Mode of the balance. */
     int retval2 = -1;
+    int quota_cut_bytes;
     
     
     init_tb_struct(th, &s_cut_balance, p_s_inode->i_sb, p_s_path, n_cut_size);
@@ -1579,23 +1635,27 @@ int reiserfs_cut_from_item (struct reise
     RFALSE( c_mode == M_PASTE || c_mode == M_INSERT, "invalid mode");
 
     /* Calculate number of bytes that need to be cut from the item. */
+    quota_cut_bytes = ( c_mode == M_DELETE ) ? ih_item_len(get_ih(p_s_path)) : -s_cut_balance.insert_size[0];
     if (retval2 == -1)
 	n_ret_value = calc_deleted_bytes_number(&s_cut_balance, c_mode);
     else
 	n_ret_value = retval2;
-    
-    if ( c_mode == M_DELETE ) {
-	struct item_head * p_le_ih = PATH_PITEM_HEAD (s_cut_balance.tb_path);
-	
-	if ( is_direct_le_ih (p_le_ih) && (le_ih_k_offset (p_le_ih) & (p_s_sb->s_blocksize - 1)) == 1 ) {
-	    /* we delete first part of tail which was stored in direct
-               item(s) */
+
+
+    /* For direct items, we only change the quota when deleting the last
+    ** item.
+    */
+    p_le_ih = PATH_PITEM_HEAD (s_cut_balance.tb_path);
+    if (!S_ISLNK (p_s_inode->i_mode) && is_direct_le_ih(p_le_ih)) {
+        if (c_mode == M_DELETE &&
+	   (le_ih_k_offset (p_le_ih) & (p_s_sb->s_blocksize - 1)) == 1 ) {
 	    // FIXME: this is to keep 3.5 happy
 	    REISERFS_I(p_s_inode)->i_first_direct_byte = U32_MAX;
-	    p_s_inode->i_blocks -= p_s_sb->s_blocksize / 512;
+	    quota_cut_bytes = p_s_sb->s_blocksize + UNFM_P_SIZE ;
+        } else {
+	    quota_cut_bytes = 0 ;
 	}
     }
-
 #ifdef CONFIG_REISERFS_CHECK
     if (n_is_inode_locked) {
 	struct item_head * le_ih = PATH_PITEM_HEAD (s_cut_balance.tb_path);
@@ -1630,10 +1690,13 @@ int reiserfs_cut_from_item (struct reise
 	*/
 	REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask ;
     }
+#ifdef REISERQUOTA_DEBUG
+    printk(KERN_DEBUG "reiserquota cut_from_item(): freeing %u id=%u type=%c\n", quota_cut_bytes, p_s_inode->i_uid, '?');
+#endif
+    DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
     return n_ret_value;
 }
 
-
 static void truncate_directory (struct reiserfs_transaction_handle *th, struct inode * inode)
 {
     if (inode->i_nlink)
@@ -1641,8 +1704,8 @@ static void truncate_directory (struct r
 
     set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), DOT_OFFSET);
     set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_DIRENTRY);
-    reiserfs_delete_solid_item (th, INODE_PKEY (inode));
-
+    reiserfs_delete_solid_item (th, inode, INODE_PKEY (inode));
+    reiserfs_update_sd(th, inode) ;
     set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), SD_OFFSET);
     set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_STAT_DATA);    
 }
@@ -1809,18 +1872,37 @@ static void check_research_for_paste (st
 int reiserfs_paste_into_item (struct reiserfs_transaction_handle *th, 
 			      struct path         * p_s_search_path,	/* Path to the pasted item.          */
 			      const struct cpu_key      * p_s_key,        	/* Key to search for the needed item.*/
+			      struct inode	  * inode,		/* Inode item belongs to */
 			      const char          * p_c_body,       	/* Pointer to the bytes to paste.    */
 			      int                   n_pasted_size)  	/* Size of pasted bytes.             */
 {
     struct tree_balance s_paste_balance;
     int                 retval;
+    int			fs_gen;
+
+    fs_gen = get_generation(inode->i_sb) ;
 
+#ifdef REISERQUOTA_DEBUG
+    printk(KERN_DEBUG "reiserquota paste_into_item(): allocating %u id=%u type=%c\n", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+#endif
+
+    if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
+	pathrelse(p_s_search_path);
+	return -EDQUOT;
+    }
     init_tb_struct(th, &s_paste_balance, th->t_super, p_s_search_path, n_pasted_size);
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
     s_paste_balance.key = p_s_key->on_disk_key;
 #endif
-    
-    while ( (retval = fix_nodes(M_PASTE, &s_paste_balance, NULL, p_c_body)) == REPEAT_SEARCH ) {
+
+    /* DQUOT_* can schedule, must check before the fix_nodes */
+    if (fs_changed(fs_gen, inode->i_sb)) {
+	goto search_again;
+    }
+
+    while ((retval = fix_nodes(M_PASTE, &s_paste_balance, NULL, p_c_body)) ==
+REPEAT_SEARCH ) {
+search_again:
 	/* file system changed while we were in the fix_nodes */
 	PROC_INFO_INC( th -> t_super, paste_into_item_restarted );
 	retval = search_for_position_by_key (th->t_super, p_s_key, p_s_search_path);
@@ -1849,6 +1931,10 @@ int reiserfs_paste_into_item (struct rei
 error_out:
     /* this also releases the path */
     unfix_nodes(&s_paste_balance);
+#ifdef REISERQUOTA_DEBUG
+    printk(KERN_DEBUG "reiserquota paste_into_item(): freeing %u id=%u type=%c\n", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+#endif
+    DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
     return retval ;
 }
 
@@ -1858,23 +1944,45 @@ int reiserfs_insert_item(struct reiserfs
 			 struct path         * 	p_s_path,         /* Path to the inserteded item.         */
 			 const struct cpu_key      * key,
 			 struct item_head    * 	p_s_ih,           /* Pointer to the item header to insert.*/
+			 struct inode        * inode,
 			 const char          * 	p_c_body)         /* Pointer to the bytes to insert.      */
 {
     struct tree_balance s_ins_balance;
     int                 retval;
+    int fs_gen = 0 ;
+    int quota_bytes = 0 ;
 
+    if (inode) {      /* Do we count quotas for item? */
+	fs_gen = get_generation(inode->i_sb);
+	quota_bytes = ih_item_len(p_s_ih);
+
+	/* hack so the quota code doesn't have to guess if the file has
+	 ** a tail, links are always tails, so there's no guessing needed
+	 */
+	if (!S_ISLNK (inode->i_mode) && is_direct_le_ih(p_s_ih)) {
+	    quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE ;
+	}
+#ifdef REISERQUOTA_DEBUG
+	printk(KERN_DEBUG "reiserquota insert_item(): allocating %u id=%u type=%c\n", quota_bytes, inode->i_uid, head2type(p_s_ih));
+#endif
+	/* We can't dirty inode here. It would be immediately written but
+	 * appropriate stat item isn't inserted yet... */
+	if (DQUOT_ALLOC_SPACE_NODIRTY(inode, quota_bytes)) {
+	    pathrelse(p_s_path);
+	    return -EDQUOT;
+	}
+    }
     init_tb_struct(th, &s_ins_balance, th->t_super, p_s_path, IH_SIZE + ih_item_len(p_s_ih));
 #ifdef DISPLACE_NEW_PACKING_LOCALITIES
     s_ins_balance.key = key->on_disk_key;
 #endif
-
-    /*
-    if (p_c_body == 0)
-      n_zeros_num = ih_item_len(p_s_ih);
-    */
-    //    le_key2cpu_key (&key, &(p_s_ih->ih_key));
+    /* DQUOT_* can schedule, must check to be sure calling fix_nodes is safe */
+    if (inode && fs_changed(fs_gen, inode->i_sb)) {
+	goto search_again;
+    }
 
     while ( (retval = fix_nodes(M_INSERT, &s_ins_balance, p_s_ih, p_c_body)) == REPEAT_SEARCH) {
+search_again:
 	/* file system changed while we were in the fix_nodes */
 	PROC_INFO_INC( th -> t_super, insert_item_restarted );
 	retval = search_item (th->t_super, key, p_s_path);
@@ -1900,6 +2008,11 @@ int reiserfs_insert_item(struct reiserfs
 error_out:
     /* also releases the path */
     unfix_nodes(&s_ins_balance);
+#ifdef REISERQUOTA_DEBUG
+    printk(KERN_DEBUG "reiserquota insert_item(): freeing %u id=%u type=%c\n", quota_bytes, inode->i_uid, head2type(p_s_ih));
+#endif
+    if (inode)
+	DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes) ;
     return retval; 
 }
 
Index: linux.mm/fs/reiserfs/super.c
===================================================================
--- linux.mm.orig/fs/reiserfs/super.c	2004-04-23 10:46:01.470479963 -0400
+++ linux.mm/fs/reiserfs/super.c	2004-04-23 10:46:05.360013800 -0400
@@ -115,7 +115,7 @@ static void remove_save_link_only (struc
      /* we are going to do one balancing */
      journal_begin (&th, s, JOURNAL_PER_BALANCE_CNT);
  
-     reiserfs_delete_solid_item (&th, key);
+     reiserfs_delete_solid_item (&th, NULL, key);
      if (oid_free)
         /* removals are protected by direct items */
         reiserfs_release_objectid (&th, le32_to_cpu (key->k_objectid));
@@ -301,8 +301,8 @@ void add_save_link (struct reiserfs_tran
     /* body of "save" link */
     link = INODE_PKEY (inode)->k_dir_id;
 
-    /* put "save" link inot tree */
-    retval = reiserfs_insert_item (th, &path, &key, &ih, (char *)&link);
+    /* put "save" link inot tree, don't charge quota to anyone */
+    retval = reiserfs_insert_item (th, &path, &key, &ih, NULL, (char *)&link);
     if (retval) {
 	if (retval != -ENOSPC)
 	    reiserfs_warning ("vs-2120: add_save_link: insert_item returned %d\n",
@@ -344,7 +344,8 @@ void remove_save_link (struct inode * in
           ( REISERFS_I(inode) -> i_flags & i_link_saved_truncate_mask ) ) ||
         ( !truncate && 
           ( REISERFS_I(inode) -> i_flags & i_link_saved_unlink_mask ) ) )
-	reiserfs_delete_solid_item (&th, &key);
+	/* don't take quota bytes from anywhere */
+	reiserfs_delete_solid_item (&th, NULL, &key);
     if (!truncate) {
 	reiserfs_release_objectid (&th, inode->i_ino);
 	REISERFS_I(inode) -> i_flags &= ~i_link_saved_unlink_mask;
@@ -714,6 +715,8 @@ static int reiserfs_parse_options (struc
 	{"jdev", 'j', 0, 0, 0},
 	{"nolargeio", 'w', 0, 0, 0},
 	{"commit", 'c', 0, 0, 0},
+	{"usrquota", 0, 0, 0, 0},
+	{"grpquota", 0, 0, 0, 0},
 	{NULL, 0, 0, 0, 0}
     };
 	
Index: linux.mm/fs/reiserfs/tail_conversion.c
===================================================================
--- linux.mm.orig/fs/reiserfs/tail_conversion.c	2004-04-23 10:45:29.567303574 -0400
+++ linux.mm/fs/reiserfs/tail_conversion.c	2004-04-23 10:46:05.362013561 -0400
@@ -66,11 +66,11 @@ int direct2indirect (struct reiserfs_tra
 	set_ih_free_space (&ind_ih, 0); /* delete at nearest future */
         put_ih_item_len( &ind_ih, UNFM_P_SIZE );
 	PATH_LAST_POSITION (path)++;
-	n_retval = reiserfs_insert_item (th, path, &end_key, &ind_ih, 
+	n_retval = reiserfs_insert_item (th, path, &end_key, &ind_ih, inode,
 					 (char *)&unfm_ptr);
     } else {
 	/* Paste into last indirect item of an object. */
-	n_retval = reiserfs_paste_into_item(th, path, &end_key,
+	n_retval = reiserfs_paste_into_item(th, path, &end_key, inode,
 					    (char *)&unfm_ptr, UNFM_P_SIZE);
     }
     if ( n_retval ) {
@@ -274,7 +274,7 @@ int indirect2direct (struct reiserfs_tra
     set_cpu_key_k_type (&key, TYPE_DIRECT);
     key.key_length = 4;
     /* Insert tail as new direct item in the tree */
-    if ( reiserfs_insert_item(th, p_s_path, &key, &s_ih,
+    if ( reiserfs_insert_item(th, p_s_path, &key, &s_ih, p_s_inode,
 			      tail ? tail : NULL) < 0 ) {
 	/* No disk memory. So we can not convert last unformatted node
 	   to the direct item.  In this case we used to adjust
@@ -292,13 +292,15 @@ int indirect2direct (struct reiserfs_tra
     */
     unmap_buffers(page, pos1) ;
 
+    /* make sure to get the i_blocks changes from reiserfs_insert_item */
+    reiserfs_update_sd(th, p_s_inode);
+
     // note: we have now the same as in above direct2indirect
     // conversion: there are two keys which have matching first three
     // key components. They only differ by the fouhth one.
 
     /* We have inserted new direct item and must remove last
        unformatted node. */
-    p_s_inode->i_blocks += (p_s_sb->s_blocksize / 512);
     *p_c_mode = M_CUT;
 
     /* we store position of first direct item in the in-core inode */
Index: linux.mm/include/linux/reiserfs_fs.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs.h	2004-04-23 10:46:00.693573076 -0400
+++ linux.mm/include/linux/reiserfs_fs.h	2004-04-23 10:46:05.367012962 -0400
@@ -268,6 +268,7 @@ int is_reiserfs_jr (struct reiserfs_supe
 #define NO_DISK_SPACE -3
 #define NO_BALANCING_NEEDED  (-4)
 #define NO_MORE_UNUSED_CONTIGUOUS_BLOCKS (-5)
+#define QUOTA_EXCEEDED -6
 
 typedef __u32 b_blocknr_t;
 typedef __u32 unp_t;
@@ -1238,7 +1239,6 @@ excessive effort to avoid disturbing the
 gods only know how we are going to SMP the code that uses them.
 znodes are the way! */
 
-
 struct  path {
   int                   path_length;                      	/* Length of the array above.   */
   struct  path_element  path_elements[EXTENDED_MAX_HEIGHT];	/* Array of the path elements.  */
@@ -1889,11 +1889,13 @@ void pathrelse_and_restore (struct super
 int reiserfs_insert_item (struct reiserfs_transaction_handle *th, 
 			  struct path * path, 
 			  const struct cpu_key * key,
-			  struct item_head * ih, const char * body);
+			  struct item_head * ih,
+			  struct inode *inode, const char * body);
 
 int reiserfs_paste_into_item (struct reiserfs_transaction_handle *th,
 			      struct path * path,
 			      const struct cpu_key * key,
+			      struct inode *inode,
 			      const char * body, int paste_size);
 
 int reiserfs_cut_from_item (struct reiserfs_transaction_handle *th,
@@ -1910,7 +1912,7 @@ int reiserfs_delete_item (struct reiserf
 			  struct buffer_head  * p_s_un_bh);
 
 void reiserfs_delete_solid_item (struct reiserfs_transaction_handle *th,
-                                                                struct key * key);
+				 struct inode *inode, struct key * key);
 void reiserfs_delete_object (struct reiserfs_transaction_handle *th, struct inode * p_s_inode);
 void reiserfs_do_truncate (struct reiserfs_transaction_handle *th, 
 			   struct  inode * p_s_inode, struct page *, 
@@ -1955,8 +1957,18 @@ int reiserfs_new_inode (struct reiserfs_
 				   struct inode * dir, int mode, 
 				   const char * symname, loff_t i_size,
 				   struct dentry *dentry, struct inode *inode);
-int reiserfs_sync_inode (struct reiserfs_transaction_handle *th, struct inode * inode);
-void reiserfs_update_sd (struct reiserfs_transaction_handle *th, struct inode * inode);
+
+int reiserfs_sync_inode (struct reiserfs_transaction_handle *th,
+                         struct inode * inode);
+
+void reiserfs_update_sd_size (struct reiserfs_transaction_handle *th,
+                              struct inode * inode, loff_t size);
+
+static inline void reiserfs_update_sd(struct reiserfs_transaction_handle *th,
+                                      struct inode *inode)
+{
+    reiserfs_update_sd_size(th, inode, inode->i_size) ;
+}
 
 void sd_attrs_to_i_attrs( __u16 sd_attrs, struct inode *inode );
 void i_attrs_to_sd_attrs( struct inode *inode, __u16 *sd_attrs );
@@ -2139,7 +2151,7 @@ typedef struct __reiserfs_blocknr_hint r
 
 int reiserfs_parse_alloc_options (struct super_block *, char *);
 int is_reusable (struct super_block * s, b_blocknr_t block, int bit_value);
-void reiserfs_free_block (struct reiserfs_transaction_handle *th, b_blocknr_t);
+void reiserfs_free_block (struct reiserfs_transaction_handle *th, struct inode *, b_blocknr_t, int for_unformatted);
 int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t * , int, int);
 extern inline int reiserfs_new_form_blocknrs (struct tree_balance * tb,
 					      b_blocknr_t *new_blocknrs, int amount_needed)
jeffm@suse.com

reiserfs permission bug fix

Index: linux.mm/fs/reiserfs/xattr.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr.c	2004-04-05 17:30:14.676585423 -0400
+++ linux.mm/fs/reiserfs/xattr.c	2004-04-05 17:30:16.993306390 -0400
@@ -1412,7 +1412,8 @@ check_capabilities:
 	 * Read/write DACs are always overridable.
 	 * Executable DACs are overridable if at least one exec bit is set.
 	 */
-	if ((mask & (MAY_READ|MAY_WRITE)) || (inode->i_mode & S_IXUGO))
+	if (!(mask & MAY_EXEC) ||
+	    (inode->i_mode & S_IXUGO) || S_ISDIR(inode->i_mode))
 		if (capable(CAP_DAC_OVERRIDE))
 			return 0;
 
From Jeff Mahoney <jeffm@suse.com>

Add device info to the various reiserfs warnings and panics so you can tell
which filesystem triggers the message.  Loosely based on code from Oleg
Drokin.

Index: linux.mm/fs/reiserfs/bitmap.c
===================================================================
--- linux.mm.orig/fs/reiserfs/bitmap.c	2004-04-23 14:10:06.369061028 -0400
+++ linux.mm/fs/reiserfs/bitmap.c	2004-04-23 14:10:21.886195019 -0400
@@ -37,7 +37,7 @@
 
 #define SET_OPTION(optname) \
    do { \
-        reiserfs_warning("reiserfs: option \"%s\" is set\n", #optname); \
+        reiserfs_warning(s, "reiserfs: option \"%s\" is set", #optname); \
         set_bit(_ALLOC_ ## optname , &SB_ALLOC_OPTS(s)); \
     } while(0)
 #define TEST_OPTION(optname, s) \
@@ -60,7 +60,7 @@ int is_reusable (struct super_block * s,
     int i, j;
 
     if (block == 0 || block >= SB_BLOCK_COUNT (s)) {
-	reiserfs_warning ("vs-4010: is_reusable: block number is out of range %lu (%u)\n",
+	reiserfs_warning (s, "vs-4010: is_reusable: block number is out of range %lu (%u)",
 			  block, SB_BLOCK_COUNT (s));
 	return 0;
     }
@@ -68,8 +68,8 @@ int is_reusable (struct super_block * s,
     /* it can't be one of the bitmap blocks */
     for (i = 0; i < SB_BMAP_NR (s); i ++)
 	if (block == SB_AP_BITMAP (s)[i].bh->b_blocknr) {
-	    reiserfs_warning ("vs: 4020: is_reusable: "
-			      "bitmap block %lu(%u) can't be freed or reused\n",
+	    reiserfs_warning (s, "vs: 4020: is_reusable: "
+			      "bitmap block %lu(%u) can't be freed or reused",
 			      block, SB_BMAP_NR (s));
 	    return 0;
 	}
@@ -77,8 +77,8 @@ int is_reusable (struct super_block * s,
     get_bit_address (s, block, &i, &j);
 
     if (i >= SB_BMAP_NR (s)) {
-	reiserfs_warning ("vs-4030: is_reusable: there is no so many bitmap blocks: "
-			  "block=%lu, bitmap_nr=%d\n", block, i);
+	reiserfs_warning (s, "vs-4030: is_reusable: there is no so many bitmap blocks: "
+			  "block=%lu, bitmap_nr=%d", block, i);
 	return 0;
     }
 
@@ -86,16 +86,16 @@ int is_reusable (struct super_block * s,
          reiserfs_test_le_bit(j, SB_AP_BITMAP(s)[i].bh->b_data)) ||
 	(bit_value == 1 && 
 	 reiserfs_test_le_bit(j, SB_AP_BITMAP (s)[i].bh->b_data) == 0)) {
-	reiserfs_warning ("vs-4040: is_reusable: corresponding bit of block %lu does not "
-			  "match required value (i==%d, j==%d) test_bit==%d\n",
+	reiserfs_warning (s, "vs-4040: is_reusable: corresponding bit of block %lu does not "
+			  "match required value (i==%d, j==%d) test_bit==%d",
 		block, i, j, reiserfs_test_le_bit (j, SB_AP_BITMAP (s)[i].bh->b_data));
 
 	return 0;
     }
 
     if (bit_value == 0 && block == SB_ROOT_BLOCK (s)) {
-	reiserfs_warning ("vs-4050: is_reusable: this is root block (%u), "
-			  "it must be busy\n", SB_ROOT_BLOCK (s));
+	reiserfs_warning (s, "vs-4050: is_reusable: this is root block (%u), "
+			  "it must be busy", SB_ROOT_BLOCK (s));
 	return 0;
     }
 
@@ -134,7 +134,7 @@ static int scan_bitmap_block (struct rei
     int end, next;
     int org = *beg;
 
-    RFALSE(bmap_n >= SB_BMAP_NR (s), "Bitmap %d is out of range (0..%d)\n",bmap_n, SB_BMAP_NR (s) - 1);
+    RFALSE(bmap_n >= SB_BMAP_NR (s), "Bitmap %d is out of range (0..%d)",bmap_n, SB_BMAP_NR (s) - 1);
     PROC_INFO_INC( s, scan_bitmap.bmap );
 /* this is unclear and lacks comments, explain how journal bitmaps
    work here for the reader.  Convey a sense of the design here. What
@@ -142,7 +142,7 @@ static int scan_bitmap_block (struct rei
 /* - I mean `a window of zero bits' as in description of this function - Zam. */
   
     if ( !bi ) {
-	printk("Hey, bitmap info pointer is zero for bitmap %d!\n",bmap_n);
+	reiserfs_warning (s, "NULL bitmap info pointer for bitmap %d", bmap_n);
 	return 0;
     }
     if (buffer_locked (bi->bh)) {
@@ -300,8 +300,8 @@ static void _reiserfs_free_block (struct
     get_bit_address (s, block, &nr, &offset);
 
     if (nr >= sb_bmap_nr (rs)) {
-	reiserfs_warning ("vs-4075: reiserfs_free_block: "
-			  "block %lu is out of range on %s\n", 
+	reiserfs_warning (s, "vs-4075: reiserfs_free_block: "
+			  "block %lu is out of range on %s",
 			  block, reiserfs_bdevname (s));
 	return;
     }
@@ -310,8 +310,8 @@ static void _reiserfs_free_block (struct
 
     /* clear bit for the given block in bit map */
     if (!reiserfs_test_and_clear_le_bit (offset, apbi[nr].bh->b_data)) {
-	reiserfs_warning ("vs-4080: reiserfs_free_block: "
-			  "free_block (%s:%lu)[dev:blocknr]: bit already cleared\n", 
+	reiserfs_warning (s, "vs-4080: reiserfs_free_block: "
+			  "free_block (%s:%lu)[dev:blocknr]: bit already cleared",
 			  reiserfs_bdevname (s), block);
     }
     if (offset < apbi[nr].first_zero_hint) {
@@ -358,7 +358,7 @@ static void __discard_prealloc (struct r
     struct inode *inode = &ei->vfs_inode;
 #ifdef CONFIG_REISERFS_CHECK
     if (ei->i_prealloc_count < 0)
-	reiserfs_warning("zam-4001:%s: inode has negative prealloc blocks count.\n", __FUNCTION__ );
+	reiserfs_warning (th->t_super, "zam-4001:%s: inode has negative prealloc blocks count.", __FUNCTION__ );
 #endif
     while (ei->i_prealloc_count > 0) {
 	reiserfs_free_prealloc_block(th, inode, ei->i_prealloc_block);
@@ -390,7 +390,7 @@ void reiserfs_discard_all_prealloc (stru
 	ei = list_entry(plist->next, struct reiserfs_inode_info, i_prealloc_list);
 #ifdef CONFIG_REISERFS_CHECK
 	if (!ei->i_prealloc_count) {
-	    reiserfs_warning("zam-4001:%s: inode is in prealloc list but has no preallocated blocks.\n", __FUNCTION__);
+	    reiserfs_warning (th->t_super, "zam-4001:%s: inode is in prealloc list but has no preallocated blocks.", __FUNCTION__);
 	}
 #endif
 	__discard_prealloc(th, ei);
@@ -476,7 +476,8 @@ int reiserfs_parse_alloc_options(struct 
 	    continue;
 	}
 
-	reiserfs_warning("zam-4001: %s : unknown option - %s\n", __FUNCTION__ , this_char);
+	reiserfs_warning (s, "zam-4001: %s : unknown option - %s",
+			  __FUNCTION__ , this_char);
 	return 1;
       }
   
@@ -516,7 +517,7 @@ static inline void get_left_neighbor(rei
 
     path = hint->path;
     bh = get_last_bh(path);
-    RFALSE( !bh, "green-4002: Illegal path specified to get_left_neighbor\n");
+    RFALSE( !bh, "green-4002: Illegal path specified to get_left_neighbor");
     ih = get_ih(path);
     pos_in_item = path->pos_in_item;
     item = get_item (path);
@@ -783,14 +784,14 @@ static inline int blocknrs_and_prealloc_
     if (!hint->formatted_node) {
         int quota_ret;
 #ifdef REISERQUOTA_DEBUG
-	printk(KERN_DEBUG "reiserquota: allocating %d blocks id=%u\n", amount_needed, hint->inode->i_uid);
+	reiserfs_debug (s, "reiserquota: allocating %d blocks id=%u", amount_needed, hint->inode->i_uid);
 #endif
 	quota_ret = DQUOT_ALLOC_BLOCK_NODIRTY(hint->inode, amount_needed);
 	if (quota_ret)    /* Quota exceeded? */
 	    return QUOTA_EXCEEDED;
 	if (hint->preallocate && hint->prealloc_size ) {
 #ifdef REISERQUOTA_DEBUG
-	    printk(KERN_DEBUG "reiserquota: allocating (prealloc) %d blocks id=%u\n", hint->prealloc_size, hint->inode->i_uid);
+	    reiserfs_debug (s, "reiserquota: allocating (prealloc) %d blocks id=%u", hint->prealloc_size, hint->inode->i_uid);
 #endif
 	    quota_ret = DQUOT_PREALLOC_BLOCK_NODIRTY(hint->inode, hint->prealloc_size);
 	    if (quota_ret)
@@ -807,7 +808,7 @@ static inline int blocknrs_and_prealloc_
 	if (second_pass) {	/* it was a second pass; we must free all blocks */
 	    if (!hint->formatted_node) {
 #ifdef REISERQUOTA_DEBUG
-		printk(KERN_DEBUG "reiserquota: freeing (nospace) %d blocks id=%u\n", amount_needed + hint->prealloc_size - nr_allocated, hint->inode->i_uid);
+		reiserfs_debug (s, "reiserquota: freeing (nospace) %d blocks id=%u", amount_needed + hint->prealloc_size - nr_allocated, hint->inode->i_uid);
 #endif
 		DQUOT_FREE_BLOCK_NODIRTY(hint->inode, amount_needed + hint->prealloc_size - nr_allocated);     /* Free not allocated blocks */
 	    }
@@ -827,7 +828,7 @@ static inline int blocknrs_and_prealloc_
 	 nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {
     /* Some of preallocation blocks were not allocated */
 #ifdef REISERQUOTA_DEBUG
-	printk(KERN_DEBUG "reiserquota: freeing (failed prealloc) %d blocks id=%u\n", amount_needed + hint->prealloc_size - nr_allocated - INODE_INFO(hint->inode)->i_prealloc_count, hint->inode->i_uid);
+	reiserfs_debug (s, "reiserquota: freeing (failed prealloc) %d blocks id=%u", amount_needed + hint->prealloc_size - nr_allocated - INODE_INFO(hint->inode)->i_prealloc_count, hint->inode->i_uid);
 #endif
 	DQUOT_FREE_BLOCK_NODIRTY(hint->inode, amount_needed +
 	                         hint->prealloc_size - nr_allocated -
Index: linux.mm/fs/reiserfs/dir.c
===================================================================
--- linux.mm.orig/fs/reiserfs/dir.c	2004-04-23 14:09:45.749534395 -0400
+++ linux.mm/fs/reiserfs/dir.c	2004-04-23 14:10:21.887194898 -0400
@@ -54,7 +54,7 @@ static int reiserfs_readdir (struct file
 
     reiserfs_write_lock(inode->i_sb);
 
-    reiserfs_check_lock_depth("readdir") ;
+    reiserfs_check_lock_depth(inode->i_sb, "readdir") ;
 
     /* form key for search the next directory entry using f_pos field of
        file structure */
@@ -62,7 +62,7 @@ static int reiserfs_readdir (struct file
 		  TYPE_DIRENTRY, 3);
     next_pos = cpu_key_k_offset (&pos_key);
 
-    /*  reiserfs_warning ("reiserfs_readdir 1: f_pos = %Ld\n", filp->f_pos);*/
+    /*  reiserfs_warning (inode->i_sb, "reiserfs_readdir 1: f_pos = %Ld", filp->f_pos);*/
 
     while (1) {
     research:
Index: linux.mm/fs/reiserfs/do_balan.c
===================================================================
--- linux.mm.orig/fs/reiserfs/do_balan.c	2004-04-23 14:10:06.371060788 -0400
+++ linux.mm/fs/reiserfs/do_balan.c	2004-04-23 14:10:23.157042268 -0400
@@ -83,7 +83,7 @@ static int balance_leaf_when_delete (str
     struct item_head * ih;
 
     RFALSE( tb->FR[0] && B_LEVEL (tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
-	    "vs- 12000: level: wrong FR %z\n", tb->FR[0]);
+	    "vs- 12000: level: wrong FR %z", tb->FR[0]);
     RFALSE( tb->blknum[0] > 1,
 	    "PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);
     RFALSE( ! tb->blknum[0] && ! PATH_H_PPARENT(tb->tb_path, 0),
@@ -1056,7 +1056,7 @@ static int balance_leaf (struct tree_bal
 
 	RFALSE (!buffer_journaled (S_new [i]) || buffer_journal_dirty (S_new [i]) ||
 		buffer_dirty (S_new [i]),
-		"PAP-12247: S_new[%d] : (%b)\n", i, S_new[i]);
+		"PAP-12247: S_new[%d] : (%b)", i, S_new[i]);
     }
 
     /* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
@@ -1215,14 +1215,14 @@ static void store_thrown (struct tree_ba
     int i;
 
     if (buffer_dirty (bh))
-      printk ("store_thrown deals with dirty buffer\n");
+      reiserfs_warning (tb->tb_sb, "store_thrown deals with dirty buffer");
     for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i ++)
 	if (!tb->thrown[i]) {
 	    tb->thrown[i] = bh;
 	    get_bh(bh) ; /* free_thrown puts this */
 	    return;
 	}
-    reiserfs_warning ("store_thrown: too many thrown buffers\n");
+    reiserfs_warning (tb->tb_sb, "store_thrown: too many thrown buffers");
 }
 
 static void free_thrown(struct tree_balance *tb) {
@@ -1232,7 +1232,9 @@ static void free_thrown(struct tree_bala
 	if (tb->thrown[i]) {
 	    blocknr = tb->thrown[i]->b_blocknr ;
 	    if (buffer_dirty (tb->thrown[i]))
-	      printk ("free_thrown deals with dirty buffer %d\n", blocknr);
+	      reiserfs_warning (tb->tb_sb,
+				"free_thrown deals with dirty buffer %d",
+				blocknr);
 	    brelse(tb->thrown[i]) ; /* incremented in store_thrown */
 	    reiserfs_free_block (tb->transaction_handle, NULL, blocknr, 0);
 	}
@@ -1341,7 +1343,8 @@ static int locked_or_not_in_tree (struct
 {
   if ( (!reiserfs_buffer_prepared(bh) && buffer_locked (bh)) || 
         !B_IS_IN_TREE (bh) ) {
-    reiserfs_warning ("vs-12339: locked_or_not_in_tree: %s (%b)\n", which, bh);
+    reiserfs_warning (NULL, "vs-12339: locked_or_not_in_tree: %s (%b)",
+                      which, bh);
     return 1;
   } 
   return 0;
@@ -1405,9 +1408,9 @@ void check_after_balance_leaf (struct tr
 		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
 			PATH_H_POSITION (tb->tb_path, 1))));
 	print_cur_tb ("12223");
-	reiserfs_warning(
+	reiserfs_warning (tb->tb_sb,
 	    "B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "
-    	    "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d\n",
+    	    "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",
 	    left,
 	    MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)),
 	    PATH_H_PBUFFER(tb->tb_path,1),
@@ -1564,7 +1567,8 @@ void do_balance (struct tree_balance * t
     }
     /* if we have no real work to do  */
     if ( ! tb->insert_size[0] ) {
-	reiserfs_warning ("PAP-12350: do_balance: insert_size == 0, mode == %c",
+	reiserfs_warning (tb->tb_sb,
+			  "PAP-12350: do_balance: insert_size == 0, mode == %c",
 			  flag);
 	unfix_nodes(tb);
 	return;
Index: linux.mm/fs/reiserfs/file.c
===================================================================
--- linux.mm.orig/fs/reiserfs/file.c	2004-04-23 14:10:06.374060427 -0400
+++ linux.mm/fs/reiserfs/file.c	2004-04-23 14:10:21.892194297 -0400
@@ -298,8 +298,9 @@ int reiserfs_allocate_blocks_for_region(
 		    if ( res != ITEM_NOT_FOUND ) {
 			/* item should not exist, otherwise we have error */
 			if ( res != -ENOSPC ) {
-			    reiserfs_warning ("green-9008: search_by_key (%K) returned %d\n",
-					       &key, res);
+			    reiserfs_warning (inode->i_sb,
+				"green-9008: search_by_key (%K) returned %d",
+					      &key, res);
 			}
 			res = -EIO;
 		        kfree(zeros);
@@ -446,8 +447,9 @@ retry:
 		/* Well, if we have found such item already, or some error
 		   occured, we need to warn user and return error */
 		if ( res != -ENOSPC ) {
-		    reiserfs_warning ("green-9009: search_by_key (%K) returned %d\n",
-			              &key, res);
+		    reiserfs_warning (inode->i_sb,
+				      "green-9009: search_by_key (%K) "
+				      "returned %d", &key, res);
 		}
 		res = -EIO;
 		goto error_exit_free_blocks;
@@ -799,7 +801,9 @@ int reiserfs_prepare_file_region_for_wri
 
 
     if ( num_pages < 1 ) {
-	reiserfs_warning("green-9001: reiserfs_prepare_file_region_for_write called with zero number of pages to process\n");
+	reiserfs_warning (inode->i_sb,
+			  "green-9001: reiserfs_prepare_file_region_for_write "
+			  "called with zero number of pages to process");
 	return -EFAULT;
     }
 
Index: linux.mm/fs/reiserfs/fix_node.c
===================================================================
--- linux.mm.orig/fs/reiserfs/fix_node.c	2004-04-23 14:10:06.378059946 -0400
+++ linux.mm/fs/reiserfs/fix_node.c	2004-04-23 14:10:21.896193817 -0400
@@ -483,7 +483,8 @@ static int get_num_ver (int mode, struct
 	snum012[needed_nodes - 1 + 3] = units;
 
 	if (needed_nodes > 2)
-	    reiserfs_warning ("vs-8111: get_num_ver: split_item_position is out of boundary\n");
+	    reiserfs_warning (tb->tb_sb, "vs-8111: get_num_ver: "
+			      "split_item_position is out of boundary");
 	snum012[needed_nodes - 1] ++;
 	split_item_positions[needed_nodes - 1] = i;
 	needed_nodes ++;
@@ -510,7 +511,8 @@ static int get_num_ver (int mode, struct
 	snum012[4] = op_unit_num (&vn->vn_vi[split_item_num]) - snum012[4] - bytes_to_r - bytes_to_l - bytes_to_S1new;
 
 	if (vn->vn_vi[split_item_num].vi_index != TYPE_DIRENTRY)
-	    reiserfs_warning ("vs-8115: get_num_ver: not directory item\n");
+	    reiserfs_warning (tb->tb_sb, "vs-8115: get_num_ver: not "
+			      "directory item");
     }
 
     /* now we know S2bytes, calculate S1bytes */
@@ -1974,11 +1976,12 @@ void * reiserfs_kmalloc (size_t size, in
     if (vp) {
 	REISERFS_SB(s)->s_kmallocs += size;
 	if (REISERFS_SB(s)->s_kmallocs > malloced + 200000) {
-	    reiserfs_warning ("vs-8301: reiserfs_kmalloc: allocated memory %d\n", REISERFS_SB(s)->s_kmallocs);
+	    reiserfs_warning (s,
+			      "vs-8301: reiserfs_kmalloc: allocated memory %d",
+			      REISERFS_SB(s)->s_kmallocs);
 	    malloced = REISERFS_SB(s)->s_kmallocs;
 	}
     }
-/*printk ("malloc : size %d, allocated %d\n", size, REISERFS_SB(s)->s_kmallocs);*/
     return vp;
 }
 
@@ -1988,7 +1991,8 @@ void reiserfs_kfree (const void * vp, si
   
     REISERFS_SB(s)->s_kmallocs -= size;
     if (REISERFS_SB(s)->s_kmallocs < 0)
-	reiserfs_warning ("vs-8302: reiserfs_kfree: allocated memory %d\n", REISERFS_SB(s)->s_kmallocs);
+	reiserfs_warning (s, "vs-8302: reiserfs_kfree: allocated memory %d",
+			  REISERFS_SB(s)->s_kmallocs);
 
 }
 #endif
@@ -2048,8 +2052,9 @@ static int get_mem_for_virtual_node (str
 	    buf = reiserfs_kmalloc(size, GFP_NOFS, tb->tb_sb);
 	    if ( !buf ) {
 #ifdef CONFIG_REISERFS_CHECK
-		reiserfs_warning ("vs-8345: get_mem_for_virtual_node: "
-				  "kmalloc failed. reiserfs kmalloced %d bytes\n",
+		reiserfs_warning (tb->tb_sb,
+				  "vs-8345: get_mem_for_virtual_node: "
+				  "kmalloc failed. reiserfs kmalloced %d bytes",
 				  REISERFS_SB(tb->tb_sb)->s_kmallocs);
 #endif
 		tb->vn_buf_size = 0;
@@ -2211,7 +2216,10 @@ static int wait_tb_buffers_until_unlocke
 #ifdef CONFIG_REISERFS_CHECK
 	    repeat_counter++;
 	    if ( (repeat_counter % 10000) == 0) {
-		reiserfs_warning ("wait_tb_buffers_until_released(): too many iterations waiting for buffer to unlock (%b)\n", locked);
+		reiserfs_warning (p_s_tb->tb_sb,
+				  "wait_tb_buffers_until_released(): too many "
+				  "iterations waiting for buffer to unlock "
+				  "(%b)", locked);
 
 		/* Don't loop forever.  Try to recover from possible error. */
 
@@ -2324,8 +2332,7 @@ int fix_nodes (int n_op_mode,
     case M_CUT:
 	if ( n_item_num < 0 || n_item_num >= B_NR_ITEMS(p_s_tbS0) ) {
 	    print_block (p_s_tbS0, 0, -1, -1);
-	    printk("mode = %c insert_size = %d\n", n_op_mode, p_s_tb->insert_size[0]);
-	    reiserfs_panic(p_s_tb->tb_sb,"PAP-8335: fix_nodes: Incorrect item number(%d)", n_item_num);
+	    reiserfs_panic(p_s_tb->tb_sb,"PAP-8335: fix_nodes: Incorrect item number(%d); mode = %c insert_size = %d\n", n_item_num, n_op_mode, p_s_tb->insert_size[0]);
 	}
 	break;
     default:
Index: linux.mm/fs/reiserfs/inode.c
===================================================================
--- linux.mm.orig/fs/reiserfs/inode.c	2004-04-23 14:10:06.382059464 -0400
+++ linux.mm/fs/reiserfs/inode.c	2004-04-23 14:10:21.900193336 -0400
@@ -774,7 +774,7 @@ start_trans:
 		retval = convert_tail_for_hole(inode, bh_result, tail_offset) ;
 		if (retval) {
 		    if ( retval != -ENOSPC )
-			printk("clm-6004: convert tail failed inode %lu, error %d\n", inode->i_ino, retval) ;
+			reiserfs_warning (inode->i_sb, "clm-6004: convert tail failed inode %lu, error %d", inode->i_ino, retval) ;
 		    if (allocated_block_nr) {
 			/* the bitmap, the super, and the stat data == 3 */
 			if (!th)
@@ -911,8 +911,8 @@ start_trans:
 	    goto failure;
 	}
 	if (retval == POSITION_FOUND) {
-	    reiserfs_warning ("vs-825: reiserfs_get_block: "
-			      "%K should not be found\n", &key);
+	    reiserfs_warning (inode->i_sb, "vs-825: reiserfs_get_block: "
+			      "%K should not be found", &key);
 	    retval = -EEXIST;
 	    if (allocated_block_nr)
 	        reiserfs_free_block (th, inode, allocated_block_nr, 1);
@@ -1222,7 +1222,7 @@ void reiserfs_update_sd_size (struct rei
 	/* look for the object's stat data */
 	retval = search_item (inode->i_sb, &key, &path);
 	if (retval == IO_ERROR) {
-	    reiserfs_warning ("vs-13050: reiserfs_update_sd: "
+	    reiserfs_warning (inode->i_sb, "vs-13050: reiserfs_update_sd: "
 			      "i/o failure occurred trying to update %K stat data",
 			      &key);
 	    return;
@@ -1231,11 +1231,11 @@ void reiserfs_update_sd_size (struct rei
 	    pos = PATH_LAST_POSITION (&path);
 	    pathrelse(&path) ;
 	    if (inode->i_nlink == 0) {
-		/*printk ("vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found\n");*/
+		/*reiserfs_warning (inode->i_sb, "vs-13050: reiserfs_update_sd: i_nlink == 0, stat data not found");*/
 		return;
 	    }
-	    reiserfs_warning ("vs-13060: reiserfs_update_sd: "
-			      "stat data of object %k (nlink == %d) not found (pos %d)\n", 
+	    reiserfs_warning (inode->i_sb, "vs-13060: reiserfs_update_sd: "
+			      "stat data of object %k (nlink == %d) not found (pos %d)",
 			      INODE_PKEY (inode), inode->i_nlink, pos);
 	    reiserfs_check_path(&path) ;
 	    return;
@@ -1308,9 +1308,9 @@ void reiserfs_read_locked_inode (struct 
     /* look for the object's stat data */
     retval = search_item (inode->i_sb, &key, &path_to_sd);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-13070: reiserfs_read_locked_inode: "
-                    "i/o failure occurred trying to find stat data of %K\n",
-                    &key);
+	reiserfs_warning (inode->i_sb, "vs-13070: reiserfs_read_locked_inode: "
+			  "i/o failure occurred trying to find stat data of %K",
+			  &key);
 	reiserfs_make_bad_inode(inode) ;
 	return;
     }
@@ -1340,9 +1340,10 @@ void reiserfs_read_locked_inode (struct 
        during mount (fs/reiserfs/super.c:finish_unfinished()). */
     if( ( inode -> i_nlink == 0 ) && 
 	! REISERFS_SB(inode -> i_sb) -> s_is_unlinked_ok ) {
-	    reiserfs_warning( "vs-13075: reiserfs_read_locked_inode: "
+	    reiserfs_warning (inode->i_sb,
+			      "vs-13075: reiserfs_read_locked_inode: "
 			      "dead inode read from disk %K. "
-			      "This is likely to be race with knfsd. Ignore\n", 
+			      "This is likely to be race with knfsd. Ignore",
 			      &key );
 	    reiserfs_make_bad_inode( inode );
     }
@@ -1445,7 +1446,7 @@ struct dentry *reiserfs_decode_fh(struct
      */
     if (fhtype > len) {
 	    if (fhtype != 6 || len != 5)
-		    printk(KERN_WARNING "nfsd/reiserfs, fhtype=%d, len=%d - odd\n",
+		    reiserfs_warning (sb, "nfsd/reiserfs, fhtype=%d, len=%d - odd",
 			   fhtype, len);
 	    fhtype = 5;
     }
@@ -1508,8 +1509,9 @@ void reiserfs_write_inode (struct inode 
     int jbegin_count = 1 ;
 
     if (inode->i_sb->s_flags & MS_RDONLY) {
-        reiserfs_warning("clm-6005: writing inode %lu on readonly FS\n", 
-	                  inode->i_ino) ;
+        reiserfs_warning (inode->i_sb,
+			  "clm-6005: writing inode %lu on readonly FS",
+			  inode->i_ino) ;
         return ;
     }
     /* memory pressure can sometimes initiate write_inode calls with sync == 1,
@@ -1572,13 +1574,13 @@ static int reiserfs_new_directory (struc
     /* look for place in the tree for new item */
     retval = search_item (sb, &key, path);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-13080: reiserfs_new_directory: "
-			  "i/o failure occurred creating new directory\n");
+	reiserfs_warning (sb, "vs-13080: reiserfs_new_directory: "
+			  "i/o failure occurred creating new directory");
 	return -EIO;
     }
     if (retval == ITEM_FOUND) {
 	pathrelse (path);
-	reiserfs_warning ("vs-13070: reiserfs_new_directory: "
+	reiserfs_warning (sb, "vs-13070: reiserfs_new_directory: "
 			  "object with this key exists (%k)", &(ih->ih_key));
 	return -EEXIST;
     }
@@ -1609,13 +1611,13 @@ static int reiserfs_new_symlink (struct 
     /* look for place in the tree for new item */
     retval = search_item (sb, &key, path);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-13080: reiserfs_new_symlinik: "
-			  "i/o failure occurred creating new symlink\n");
+	reiserfs_warning (sb, "vs-13080: reiserfs_new_symlinik: "
+			  "i/o failure occurred creating new symlink");
 	return -EIO;
     }
     if (retval == ITEM_FOUND) {
 	pathrelse (path);
-	reiserfs_warning ("vs-13080: reiserfs_new_symlink: "
+	reiserfs_warning (sb, "vs-13080: reiserfs_new_symlink: "
 			  "object with this key exists (%k)", &(ih->ih_key));
 	return -EEXIST;
     }
@@ -1800,7 +1802,8 @@ int reiserfs_new_inode (struct reiserfs_
             goto out_inserted_sd;
         }
     } else if (inode->i_sb->s_flags & MS_POSIXACL) {
-        reiserfs_warning ("ACLs aren't enabled in the fs, but vfs thinks they are!\n");
+	reiserfs_warning (inode->i_sb, "ACLs aren't enabled in the fs, "
+			  "but vfs thinks they are!");
     }
 
     insert_inode_hash (inode);
@@ -1898,9 +1901,10 @@ static int grab_tail_page(struct inode *
 	** I've screwed up the code to find the buffer, or the code to
 	** call prepare_write
 	*/
-	reiserfs_warning("clm-6000: error reading block %lu on dev %s\n",
-			 bh->b_blocknr,
-			 reiserfs_bdevname (p_s_inode->i_sb)) ;
+	reiserfs_warning (p_s_inode->i_sb,
+			  "clm-6000: error reading block %lu on dev %s",
+			  bh->b_blocknr,
+			  reiserfs_bdevname (p_s_inode->i_sb)) ;
 	error = -EIO ;
 	goto unlock ;
     }
@@ -1940,7 +1944,9 @@ void reiserfs_truncate_file(struct inode
 	    // and get_block_create_0 could not find a block to read in,
 	    // which is ok.
 	    if (error != -ENOENT)
-	        reiserfs_warning("clm-6001: grab_tail_page failed %d\n", error);
+	        reiserfs_warning (p_s_inode->i_sb,
+				  "clm-6001: grab_tail_page failed %d",
+				  error);
 	    page = NULL ;
 	    bh = NULL ;
 	}
@@ -2038,7 +2044,8 @@ research:
     /* we've found an unformatted node */
     if (indirect_item_found(retval, ih)) {
 	if (bytes_copied > 0) {
-	    reiserfs_warning("clm-6002: bytes_copied %d\n", bytes_copied) ;
+	    reiserfs_warning (inode->i_sb, "clm-6002: bytes_copied %d",
+			      bytes_copied) ;
 	}
         if (!get_block_num(item, pos_in_item)) {
 	    /* crap, we are writing to a hole */
@@ -2086,7 +2093,9 @@ research:
 	    goto research ;
 	}
     } else {
-        reiserfs_warning("clm-6003: bad item inode %lu, device %s\n", inode->i_ino, reiserfs_bdevname (inode->i_sb)) ;
+        reiserfs_warning (inode->i_sb,
+			  "clm-6003: bad item inode %lu, device %s",
+			  inode->i_ino, reiserfs_bdevname (inode->i_sb)) ;
         retval = -EIO ;
 	goto out ;
     }
Index: linux.mm/fs/reiserfs/item_ops.c
===================================================================
--- linux.mm.orig/fs/reiserfs/item_ops.c	2004-01-09 01:59:46.000000000 -0500
+++ linux.mm/fs/reiserfs/item_ops.c	2004-04-23 14:10:21.902193096 -0400
@@ -106,7 +106,7 @@ static int sd_unit_num (struct virtual_i
 
 static void sd_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("STATDATA, index %d, type 0x%x, %h\n", 
+    reiserfs_warning (NULL, "STATDATA, index %d, type 0x%x, %h",
 		      vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -209,7 +209,7 @@ static int direct_unit_num (struct virtu
 
 static void direct_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("DIRECT, index %d, type 0x%x, %h\n", 
+    reiserfs_warning (NULL, "DIRECT, index %d, type 0x%x, %h",
 		      vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -302,7 +302,7 @@ static void indirect_print_item (struct 
     unp = (__u32 *)item;
 
     if (ih_item_len(ih) % UNFM_P_SIZE)
-	printk ("indirect_print_item: invalid item len");  
+	reiserfs_warning (NULL, "indirect_print_item: invalid item len");
 
     printk ("%d pointers\n[ ", (int)I_UNFM_NUM (ih));
     for (j = 0; j < I_UNFM_NUM (ih); j ++) {
@@ -363,7 +363,7 @@ static int indirect_unit_num (struct vir
 
 static void indirect_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("INDIRECT, index %d, type 0x%x, %h\n", 
+    reiserfs_warning (NULL, "INDIRECT, index %d, type 0x%x, %h",
 		      vi->vi_index, vi->vi_type, vi->vi_ih);
 }
 
@@ -390,7 +390,7 @@ struct item_operations indirect_ops = {
 
 static int direntry_bytes_number (struct item_head * ih, int block_size)
 {
-    reiserfs_warning ("vs-16090: direntry_bytes_number: "
+    reiserfs_warning (NULL, "vs-16090: direntry_bytes_number: "
 		      "bytes number is asked for direntry");
     return 0;
 }
@@ -582,8 +582,7 @@ static int direntry_check_left (struct v
     }
 
     if (entries == dir_u->entry_count) {
-	printk ("free spze %d, entry_count %d\n", free, dir_u->entry_count);
-	BUG ();
+	reiserfs_panic (NULL, "free space %d, entry_count %d\n", free, dir_u->entry_count);
     }
 
     /* "." and ".." can not be separated from each other */
@@ -653,7 +652,7 @@ static void direntry_print_vi (struct vi
     int i;
     struct direntry_uarea * dir_u = vi->vi_uarea;
 
-    reiserfs_warning ("DIRENTRY, index %d, type 0x%x, %h, flags 0x%x\n", 
+    reiserfs_warning (NULL, "DIRENTRY, index %d, type 0x%x, %h, flags 0x%x",
 		      vi->vi_index, vi->vi_type, vi->vi_ih, dir_u->flags);
     printk ("%d entries: ", dir_u->entry_count);
     for (i = 0; i < dir_u->entry_count; i ++)
@@ -682,32 +681,32 @@ struct item_operations direntry_ops = {
 //
 static int errcatch_bytes_number (struct item_head * ih, int block_size)
 {
-    reiserfs_warning ("green-16001: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16001: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 static void errcatch_decrement_key (struct cpu_key * key)
 {
-    reiserfs_warning ("green-16002: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16002: Invalid item type observed, run fsck ASAP");
 }
 
 
 static int errcatch_is_left_mergeable (struct key * key, unsigned long bsize)
 {
-    reiserfs_warning ("green-16003: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16003: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 
 static void errcatch_print_item (struct item_head * ih, char * item)
 {
-    reiserfs_warning ("green-16004: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16004: Invalid item type observed, run fsck ASAP");
 }
 
 
 static void errcatch_check_item (struct item_head * ih, char * item)
 {
-    reiserfs_warning ("green-16005: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16005: Invalid item type observed, run fsck ASAP");
 }
 
 static int errcatch_create_vi (struct virtual_node * vn,
@@ -715,7 +714,7 @@ static int errcatch_create_vi (struct vi
 			       int is_affected, 
 			       int insert_size)
 {
-    reiserfs_warning ("green-16006: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16006: Invalid item type observed, run fsck ASAP");
     return 0;	// We might return -1 here as well, but it won't help as create_virtual_node() from where
 		// this operation is called from is of return type void.
 }
@@ -723,32 +722,32 @@ static int errcatch_create_vi (struct vi
 static int errcatch_check_left (struct virtual_item * vi, int free,
 				int start_skip, int end_skip)
 {
-    reiserfs_warning ("green-16007: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16007: Invalid item type observed, run fsck ASAP");
     return -1;
 }
 
 
 static int errcatch_check_right (struct virtual_item * vi, int free)
 {
-    reiserfs_warning ("green-16008: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16008: Invalid item type observed, run fsck ASAP");
     return -1;
 }
 
 static int errcatch_part_size (struct virtual_item * vi, int first, int count)
 {
-    reiserfs_warning ("green-16009: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16009: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 static int errcatch_unit_num (struct virtual_item * vi)
 {
-    reiserfs_warning ("green-16010: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16010: Invalid item type observed, run fsck ASAP");
     return 0;
 }
 
 static void errcatch_print_vi (struct virtual_item * vi)
 {
-    reiserfs_warning ("green-16011: Invalid item type observed, run fsck ASAP\n");
+    reiserfs_warning (NULL, "green-16011: Invalid item type observed, run fsck ASAP");
 }
 
 struct item_operations errcatch_ops = {
Index: linux.mm/fs/reiserfs/journal.c
===================================================================
--- linux.mm.orig/fs/reiserfs/journal.c	2004-04-23 14:08:22.601517885 -0400
+++ linux.mm/fs/reiserfs/journal.c	2004-04-23 14:10:21.908192374 -0400
@@ -271,7 +271,7 @@ int reiserfs_allocate_list_bitmaps(struc
     jb->journal_list = NULL ;
     jb->bitmaps = vmalloc( mem ) ;
     if (!jb->bitmaps) {
-      reiserfs_warning("clm-2000, unable to allocate bitmaps for journal lists\n") ;
+      reiserfs_warning(p_s_sb, "clm-2000, unable to allocate bitmaps for journal lists") ;
       failed = 1;   
       break ;
     }
@@ -345,7 +345,7 @@ static struct reiserfs_journal_cnode *al
 static struct reiserfs_journal_cnode *get_cnode(struct super_block *p_s_sb) {
   struct reiserfs_journal_cnode *cn ;
 
-  reiserfs_check_lock_depth("get_cnode") ;
+  reiserfs_check_lock_depth(p_s_sb, "get_cnode") ;
 
   if (SB_JOURNAL(p_s_sb)->j_cnode_free <= 0) {
     return NULL ;
@@ -369,7 +369,7 @@ static struct reiserfs_journal_cnode *ge
 */
 static void free_cnode(struct super_block *p_s_sb, struct reiserfs_journal_cnode *cn) {
 
-  reiserfs_check_lock_depth("free_cnode") ;
+  reiserfs_check_lock_depth(p_s_sb, "free_cnode") ;
 
   SB_JOURNAL(p_s_sb)->j_cnode_used-- ;
   SB_JOURNAL(p_s_sb)->j_cnode_free++ ;
@@ -422,11 +422,10 @@ inline int mark_buffer_not_journaled(str
 /* utility function to force a BUG if it is called without the big
 ** kernel lock held.  caller is the string printed just before calling BUG()
 */
-void reiserfs_check_lock_depth(char *caller) {
+void reiserfs_check_lock_depth(struct super_block *sb, char *caller) {
 #ifdef CONFIG_SMP
   if (current->lock_depth < 0) {
-    printk("%s called without kernel lock held\n", caller) ;
-    BUG() ;
+    reiserfs_panic (sb, "%s called without kernel lock held", caller) ;
   }
 #else
   ;
@@ -559,9 +558,8 @@ static inline void put_journal_list(stru
                                    struct reiserfs_journal_list *jl)
 {
     if (jl->j_refcount < 1) {
-        printk("trans id %lu, refcount at %d\n", jl->j_trans_id,
+        reiserfs_panic (s, "trans id %lu, refcount at %d", jl->j_trans_id,
 	                                         jl->j_refcount);
-        BUG();
     }
     if (--jl->j_refcount == 0)
         reiserfs_kfree(jl, sizeof(struct reiserfs_journal_list), s);
@@ -601,7 +599,7 @@ static void reiserfs_end_buffer_io_sync(
     char b[BDEVNAME_SIZE];
 
     if (buffer_journaled(bh)) {
-        reiserfs_warning("clm-2084: pinned buffer %lu:%s sent to disk\n",
+        reiserfs_warning(NULL, "clm-2084: pinned buffer %lu:%s sent to disk",
 	                 bh->b_blocknr, bdevname(bh->b_bdev, b)) ;
     }
     if (uptodate)
@@ -912,7 +910,7 @@ static int flush_commit_list(struct supe
   struct buffer_head *tbh = NULL ;
   unsigned long trans_id = jl->j_trans_id;
 
-  reiserfs_check_lock_depth("flush_commit_list") ;
+  reiserfs_check_lock_depth(s, "flush_commit_list") ;
 
   if (atomic_read(&jl->j_older_commits_done)) {
     return 0 ;
@@ -1007,7 +1005,7 @@ static int flush_commit_list(struct supe
   bforget(jl->j_commit_bh) ;
   if (SB_JOURNAL(s)->j_last_commit_id != 0 &&
      (jl->j_trans_id - SB_JOURNAL(s)->j_last_commit_id) != 1) {
-      reiserfs_warning("clm-2200: last commit %lu, current %lu\n",
+      reiserfs_warning(s, "clm-2200: last commit %lu, current %lu",
                        SB_JOURNAL(s)->j_last_commit_id,
 		       jl->j_trans_id);
   }
@@ -1066,8 +1064,8 @@ static void remove_all_from_journal_list
   while(cn) {
     if (cn->blocknr != 0) {
       if (debug) {
-        printk("block %u, bh is %d, state %ld\n", cn->blocknr, cn->bh ? 1: 0,
-	        cn->state) ;
+       reiserfs_warning (p_s_sb, "block %u, bh is %d, state %ld", cn->blocknr,
+                         cn->bh ? 1: 0, cn->state) ;
       }
       cn->state = 0 ;
       remove_journal_hash(p_s_sb, SB_JOURNAL(p_s_sb)->j_list_hash_table, jl, cn->blocknr, 1) ;
@@ -1104,7 +1102,7 @@ static int _update_journal_header_block(
     set_buffer_dirty(SB_JOURNAL(p_s_sb)->j_header_bh) ;
     sync_dirty_buffer(SB_JOURNAL(p_s_sb)->j_header_bh) ;
     if (!buffer_uptodate(SB_JOURNAL(p_s_sb)->j_header_bh)) {
-      printk( "reiserfs: journal-837: IO error during journal replay\n" );
+      reiserfs_warning (p_s_sb, "journal-837: IO error during journal replay");
       return -EIO ;
     }
   }
@@ -1178,7 +1176,7 @@ static int flush_journal_list(struct sup
   }
 
   if (atomic_read(&SB_JOURNAL(s)->j_wcount) != 0) {
-    reiserfs_warning("clm-2048: flush_journal_list called with wcount %d\n",
+    reiserfs_warning(s, "clm-2048: flush_journal_list called with wcount %d",
                       atomic_read(&SB_JOURNAL(s)->j_wcount)) ;
   }
   if (jl->j_trans_id == 0)
@@ -1277,8 +1275,10 @@ static int flush_journal_list(struct sup
     ** is not marked JDirty_wait
     */
     if ((!was_jwait) && !buffer_locked(saved_bh)) {
-printk("journal-813: BAD! buffer %llu %cdirty %cjwait, not in a newer tranasction\n", (unsigned long long)saved_bh->b_blocknr,
-        was_dirty ? ' ' : '!', was_jwait ? ' ' : '!') ;
+	reiserfs_warning (s, "journal-813: BAD! buffer %llu %cdirty %cjwait, "
+			  "not in a newer tranasction",
+			  (unsigned long long)saved_bh->b_blocknr,
+			  was_dirty ? ' ' : '!', was_jwait ? ' ' : '!') ;
     }
     if (was_dirty) { 
       /* we inc again because saved_bh gets decremented at free_cnode */
@@ -1293,8 +1293,8 @@ printk("journal-813: BAD! buffer %llu %c
         unlock_buffer(saved_bh);
       count++ ;
     } else {
-      printk("clm-2082: Unable to flush buffer %llu in flush_journal_list\n",
-              (unsigned long long)saved_bh->b_blocknr) ;
+      reiserfs_warning (s, "clm-2082: Unable to flush buffer %llu in %s",
+                        (unsigned long long)saved_bh->b_blocknr, __FUNCTION__);
     }
 free_cnode:
     last = cn ;
@@ -1303,7 +1303,7 @@ free_cnode:
       /* we incremented this to keep others from taking the buffer head away */
       put_bh(saved_bh) ;
       if (atomic_read(&(saved_bh->b_count)) < 0) {
-        printk("journal-945: saved_bh->b_count < 0") ;
+        reiserfs_warning (s, "journal-945: saved_bh->b_count < 0");
       }
     }
   }
@@ -1363,7 +1363,7 @@ flush_older_and_return:
 
   if (SB_JOURNAL(s)->j_last_flush_id != 0 &&
      (jl->j_trans_id - SB_JOURNAL(s)->j_last_flush_id) != 1) {
-      reiserfs_warning("clm-2201: last flush %lu, current %lu\n",
+      reiserfs_warning(s, "clm-2201: last flush %lu, current %lu",
                        SB_JOURNAL(s)->j_last_flush_id,
 		       jl->j_trans_id);
   }
@@ -1712,19 +1712,19 @@ static int journal_transaction_is_valid(
     if (oldest_invalid_trans_id && *oldest_invalid_trans_id && get_desc_trans_id(desc) > *oldest_invalid_trans_id) {
       reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-986: transaction "
 	              "is valid returning because trans_id %d is greater than "
-		      "oldest_invalid %lu\n", get_desc_trans_id(desc), 
+		      "oldest_invalid %lu", get_desc_trans_id(desc),
 		       *oldest_invalid_trans_id);
       return 0 ;
     }
     if (newest_mount_id && *newest_mount_id > get_desc_mount_id (desc)) {
       reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1087: transaction "
                      "is valid returning because mount_id %d is less than "
-		     "newest_mount_id %lu\n", get_desc_mount_id (desc), 
+		     "newest_mount_id %lu", get_desc_mount_id (desc),
 		     *newest_mount_id) ;
       return -1 ;
     }
     if ( get_desc_trans_len(desc) > SB_JOURNAL_TRANS_MAX(p_s_sb) ) {
-      reiserfs_warning("journal-2018: Bad transaction length %d encountered, ignoring transaction\n", get_desc_trans_len(desc));
+      reiserfs_warning(p_s_sb, "journal-2018: Bad transaction length %d encountered, ignoring transaction", get_desc_trans_len(desc));
       return -1 ;
     }
     offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) ;
@@ -1738,7 +1738,7 @@ static int journal_transaction_is_valid(
     if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
       reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, 
                      "journal_transaction_is_valid, commit offset %ld had bad "
-		     "time %d or length %d\n", 
+		     "time %d or length %d",
 		     c_bh->b_blocknr -  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb),
 		     get_commit_trans_id (commit), 
 		     get_commit_trans_len(commit));
@@ -1746,14 +1746,14 @@ static int journal_transaction_is_valid(
       if (oldest_invalid_trans_id) {
 	*oldest_invalid_trans_id = get_desc_trans_id(desc) ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1004: "
-	               "transaction_is_valid setting oldest invalid trans_id "
-		       "to %d\n", get_desc_trans_id(desc)) ;
+		       "transaction_is_valid setting oldest invalid trans_id "
+		       "to %d", get_desc_trans_id(desc)) ;
       }
       return -1; 
     }
     brelse(c_bh) ;
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1006: found valid "
-                   "transaction start offset %llu, len %d id %d\n",
+                   "transaction start offset %llu, len %d id %d",
 		   d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		   get_desc_trans_len(desc), get_desc_trans_id(desc)) ;
     return 1 ;
@@ -1793,12 +1793,12 @@ static int journal_read_transaction(stru
   desc = (struct reiserfs_journal_desc *)d_bh->b_data ;
   trans_offset = d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) ;
   reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1037: "
-                 "journal_read_transaction, offset %llu, len %d mount_id %d\n",
+                 "journal_read_transaction, offset %llu, len %d mount_id %d",
 		 d_bh->b_blocknr - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		 get_desc_trans_len(desc), get_desc_mount_id(desc)) ;
   if (get_desc_trans_id(desc) < oldest_trans_id) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1039: "
-                   "journal_read_trans skipping because %lu is too old\n", 
+                   "journal_read_trans skipping because %lu is too old",
 		   cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb)) ;
     brelse(d_bh) ;
     return 1 ;
@@ -1806,7 +1806,7 @@ static int journal_read_transaction(stru
   if (get_desc_mount_id(desc) != newest_mount_id) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1146: "
                    "journal_read_trans skipping because %d is != "
-		   "newest_mount_id %lu\n", get_desc_mount_id(desc), 
+		   "newest_mount_id %lu", get_desc_mount_id(desc),
 		    newest_mount_id) ;
     brelse(d_bh) ;
     return 1 ;
@@ -1821,7 +1821,7 @@ static int journal_read_transaction(stru
   commit = (struct reiserfs_journal_commit *)c_bh->b_data ;
   if (journal_compare_desc_commit(p_s_sb, desc, commit)) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal_read_transaction, "
-                   "commit offset %llu had bad time %d or length %d\n",
+                   "commit offset %llu had bad time %d or length %d",
 		   c_bh->b_blocknr -  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		   get_commit_trans_id(commit), get_commit_trans_len(commit));
     brelse(c_bh) ;
@@ -1837,7 +1837,7 @@ static int journal_read_transaction(stru
     brelse(d_bh) ;
     reiserfs_kfree(log_blocks, get_desc_trans_len(desc) * sizeof(struct buffer_head *), p_s_sb) ;
     reiserfs_kfree(real_blocks, get_desc_trans_len(desc) * sizeof(struct buffer_head *), p_s_sb) ;
-    reiserfs_warning("journal-1169: kmalloc failed, unable to mount FS\n") ;
+    reiserfs_warning(p_s_sb, "journal-1169: kmalloc failed, unable to mount FS") ;
     return -1 ;
   }
   /* get all the buffer heads */
@@ -1850,12 +1850,12 @@ static int journal_read_transaction(stru
       real_blocks[i] = sb_getblk(p_s_sb, le32_to_cpu(commit->j_realblock[i - trans_half])) ;
     }
     if ( real_blocks[i]->b_blocknr > SB_BLOCK_COUNT(p_s_sb) ) {
-      reiserfs_warning("journal-1207: REPLAY FAILURE fsck required! Block to replay is outside of filesystem\n");
+      reiserfs_warning(p_s_sb, "journal-1207: REPLAY FAILURE fsck required! Block to replay is outside of filesystem");
       goto abort_replay;
     }
     /* make sure we don't try to replay onto log or reserved area */
     if (is_block_in_log_or_reserved_area(p_s_sb, real_blocks[i]->b_blocknr)) {
-      reiserfs_warning("journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block\n") ;
+      reiserfs_warning(p_s_sb, "journal-1204: REPLAY FAILURE fsck required! Trying to replay onto a log block") ;
 abort_replay:
       brelse_array(log_blocks, i) ;
       brelse_array(real_blocks, i) ;
@@ -1871,7 +1871,7 @@ abort_replay:
   for (i = 0 ; i < get_desc_trans_len(desc) ; i++) {
     wait_on_buffer(log_blocks[i]) ;
     if (!buffer_uptodate(log_blocks[i])) {
-      reiserfs_warning("journal-1212: REPLAY FAILURE fsck required! buffer write failed\n") ;
+      reiserfs_warning(p_s_sb, "journal-1212: REPLAY FAILURE fsck required! buffer write failed") ;
       brelse_array(log_blocks + i, get_desc_trans_len(desc) - i) ;
       brelse_array(real_blocks, get_desc_trans_len(desc)) ;
       brelse(c_bh) ;
@@ -1892,7 +1892,7 @@ abort_replay:
   for (i = 0 ; i < get_desc_trans_len(desc) ; i++) {
     wait_on_buffer(real_blocks[i]) ; 
     if (!buffer_uptodate(real_blocks[i])) {
-      reiserfs_warning("journal-1226: REPLAY FAILURE, fsck required! buffer write failed\n") ;
+      reiserfs_warning(p_s_sb, "journal-1226: REPLAY FAILURE, fsck required! buffer write failed") ;
       brelse_array(real_blocks + i, get_desc_trans_len(desc) - i) ;
       brelse(c_bh) ;
       brelse(d_bh) ;
@@ -1904,7 +1904,7 @@ abort_replay:
   }
   cur_dblock =  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) + ((trans_offset + get_desc_trans_len(desc) + 2) % SB_ONDISK_JOURNAL_SIZE(p_s_sb)) ;
   reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1095: setting journal "
-                 "start to offset %ld\n", 
+                 "start to offset %ld",
 		 cur_dblock -  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb)) ;
   
   /* init starting values for the first transaction, in case this is the last transaction to be replayed. */
@@ -1986,9 +1986,8 @@ static int journal_read(struct super_blo
   char b[BDEVNAME_SIZE];
 
   cur_dblock = SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) ;
-  printk("reiserfs: checking transaction log (%s) for (%s)\n",
-	 bdevname(SB_JOURNAL(p_s_sb)->j_dev_bd, b),
-	 reiserfs_bdevname(p_s_sb));
+  reiserfs_info (p_s_sb, "checking transaction log (%s)\n",
+	 bdevname(SB_JOURNAL(p_s_sb)->j_dev_bd, b));
   start = get_seconds();
 
   /* step 1, read in the journal header block.  Check the transaction it says 
@@ -2011,7 +2010,7 @@ static int journal_read(struct super_blo
     newest_mount_id = le32_to_cpu(jh->j_mount_id);
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1153: found in "
                    "header: first_unflushed_offset %d, last_flushed_trans_id "
-		   "%lu\n", le32_to_cpu(jh->j_first_unflushed_offset), 
+		   "%lu", le32_to_cpu(jh->j_first_unflushed_offset),
 		   le32_to_cpu(jh->j_last_flush_trans_id)) ;
     valid_journal_header = 1 ;
 
@@ -2029,7 +2028,8 @@ static int journal_read(struct super_blo
   }
 
   if (continue_replay && bdev_read_only(p_s_sb->s_bdev)) {
-    printk("clm-2076: device is readonly, unable to replay log\n") ;
+    reiserfs_warning (p_s_sb,
+		      "clm-2076: device is readonly, unable to replay log") ;
     return -1 ;
   }
 
@@ -2049,7 +2049,7 @@ static int journal_read(struct super_blo
 	oldest_start = d_bh->b_blocknr ;
 	newest_mount_id = get_desc_mount_id(desc) ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1179: Setting "
-	               "oldest_start to offset %llu, trans_id %lu\n",
+	               "oldest_start to offset %llu, trans_id %lu",
 		       oldest_start - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		       oldest_trans_id) ;
       } else if (oldest_trans_id > get_desc_trans_id(desc)) { 
@@ -2057,14 +2057,14 @@ static int journal_read(struct super_blo
         oldest_trans_id = get_desc_trans_id(desc) ;
 	oldest_start = d_bh->b_blocknr ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1180: Resetting "
-	               "oldest_start to offset %lu, trans_id %lu\n", 
+	               "oldest_start to offset %lu, trans_id %lu",
 			oldest_start - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 			oldest_trans_id) ;
       }
       if (newest_mount_id < get_desc_mount_id(desc)) {
         newest_mount_id = get_desc_mount_id(desc) ;
 	reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1299: Setting "
-	              "newest_mount_id to %d\n", get_desc_mount_id(desc));
+	              "newest_mount_id to %d", get_desc_mount_id(desc));
       }
       cur_dblock += get_desc_trans_len(desc) + 2 ;
     } else {
@@ -2077,7 +2077,7 @@ start_log_replay:
   cur_dblock = oldest_start ;
   if (oldest_trans_id)  {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1206: Starting replay "
-                   "from offset %llu, trans_id %lu\n",
+                   "from offset %llu, trans_id %lu",
 		   cur_dblock - SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb), 
 		   oldest_trans_id) ;
 
@@ -2098,7 +2098,7 @@ start_log_replay:
 
   if (oldest_trans_id == 0) {
     reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1225: No valid "
-                   "transactions found\n") ;
+                   "transactions found") ;
   }
   /* j_start does not get set correctly if we don't replay any transactions.
   ** if we had a valid journal_header, set j_start to the first unflushed transaction value,
@@ -2113,11 +2113,11 @@ start_log_replay:
     SB_JOURNAL(p_s_sb)->j_mount_id = newest_mount_id + 1 ;
   }
   reiserfs_debug(p_s_sb, REISERFS_DEBUG_CODE, "journal-1299: Setting "
-                 "newest_mount_id to %lu\n", SB_JOURNAL(p_s_sb)->j_mount_id) ;
+                 "newest_mount_id to %lu", SB_JOURNAL(p_s_sb)->j_mount_id) ;
   SB_JOURNAL(p_s_sb)->j_first_unflushed_offset = SB_JOURNAL(p_s_sb)->j_start ; 
   if (replay_count > 0) {
-    printk("reiserfs: replayed %d transactions in %lu seconds\n", replay_count, 
-	    get_seconds() - start) ;
+    reiserfs_info (p_s_sb, "replayed %d transactions in %lu seconds\n",
+		   replay_count, get_seconds() - start) ;
   }
   if (!bdev_read_only(p_s_sb->s_bdev) && 
        _update_journal_header_block(p_s_sb, SB_JOURNAL(p_s_sb)->j_start, 
@@ -2172,7 +2172,7 @@ static int release_journal_dev( struct s
     }
 
     if( result != 0 ) {
-	reiserfs_warning("sh-457: release_journal_dev: Cannot release journal device: %i\n", result );
+	reiserfs_warning(super, "sh-457: release_journal_dev: Cannot release journal device: %i", result );
     }
     return result;
 }
@@ -2202,8 +2202,9 @@ static int journal_init_dev( struct supe
 		if (IS_ERR(journal->j_dev_bd)) {
 			result = PTR_ERR(journal->j_dev_bd);
 			journal->j_dev_bd = NULL;
-			printk( "sh-458: journal_init_dev: cannot init journal device\n '%s': %i", 
-				__bdevname(jdev, b), result );
+			reiserfs_warning (super, "sh-458: journal_init_dev: "
+					  "cannot init journal device '%s': %i",
+					  __bdevname(jdev, b), result );
 			return result;
 		} else if (jdev != super->s_dev)
 			set_blocksize(journal->j_dev_bd, super->s_blocksize);
@@ -2214,7 +2215,8 @@ static int journal_init_dev( struct supe
 	if( !IS_ERR( journal -> j_dev_file ) ) {
 		struct inode *jdev_inode = journal->j_dev_file->f_mapping->host;
 		if( !S_ISBLK( jdev_inode -> i_mode ) ) {
-			printk( "journal_init_dev: '%s' is not a block device\n", jdev_name );
+			reiserfs_warning  (super, "journal_init_dev: '%s' is "
+					   "not a block device", jdev_name );
 			result = -ENOTBLK;
 		} else  {
 			/* ok */
@@ -2224,12 +2226,14 @@ static int journal_init_dev( struct supe
 	} else {
 		result = PTR_ERR( journal -> j_dev_file );
 		journal -> j_dev_file = NULL;
-		printk( "journal_init_dev: Cannot open '%s': %i\n", jdev_name, result );
+		reiserfs_warning (super,
+				  "journal_init_dev: Cannot open '%s': %i",
+				  jdev_name, result );
 	}
 	if( result != 0 ) {
 		release_journal_dev( super, journal );
 	}
-	printk( "journal_init_dev: journal device: %s\n",
+	reiserfs_info(super, "journal_init_dev: journal device: %s\n",
 		bdevname(journal->j_dev_bd, b));
 	return result;
 }
@@ -2248,7 +2252,7 @@ int journal_init(struct super_block *p_s
 
     journal = SB_JOURNAL(p_s_sb) = vmalloc(sizeof (struct reiserfs_journal)) ;
     if (!journal) {
-	printk("journal-1256: unable to get memory for journal structure\n") ;
+	reiserfs_warning (p_s_sb, "journal-1256: unable to get memory for journal structure") ;
 	return 1 ;
     }
     memset(journal, 0, sizeof(struct reiserfs_journal)) ;
@@ -2270,14 +2274,16 @@ int journal_init(struct super_block *p_s
        (actual for small blocksizes) */
     if ( !SB_ONDISK_JOURNAL_DEVICE( p_s_sb ) &&
          (SB_JOURNAL_1st_RESERVED_BLOCK(p_s_sb) + SB_ONDISK_JOURNAL_SIZE(p_s_sb) > p_s_sb->s_blocksize * 8) ) {
-	printk("journal-1393: journal does not fit for area addressed by first of bitmap blocks. "
-	       "It starts at %u and its size is %u. Block size %ld\n",
-		SB_JOURNAL_1st_RESERVED_BLOCK(p_s_sb), SB_ONDISK_JOURNAL_SIZE(p_s_sb), p_s_sb->s_blocksize) ;
+	reiserfs_warning (p_s_sb, "journal-1393: journal does not fit for area "
+			  "addressed by first of bitmap blocks. It starts at "
+			  "%u and its size is %u. Block size %ld",
+			  SB_JOURNAL_1st_RESERVED_BLOCK(p_s_sb),
+			  SB_ONDISK_JOURNAL_SIZE(p_s_sb), p_s_sb->s_blocksize);
 	goto free_and_return;
     }
 
     if( journal_init_dev( p_s_sb, journal, j_dev_name ) != 0 ) {
-      printk( "sh-462: unable to initialize jornal device\n");
+      reiserfs_warning (p_s_sb, "sh-462: unable to initialize jornal device");
       goto free_and_return;
     }
 
@@ -2287,18 +2293,19 @@ int journal_init(struct super_block *p_s
      bhjh = journal_bread(p_s_sb,
 		   SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) + SB_ONDISK_JOURNAL_SIZE(p_s_sb));
      if (!bhjh) {
-	 printk("sh-459: unable to read  journal header\n") ;
+	 reiserfs_warning (p_s_sb, "sh-459: unable to read journal header");
 	 goto free_and_return;
      }
      jh = (struct reiserfs_journal_header *)(bhjh->b_data);
      
      /* make sure that journal matches to the super block */
      if (is_reiserfs_jr(rs) && (jh->jh_journal.jp_journal_magic != sb_jp_journal_magic(rs))) {
-	 printk("sh-460: journal header magic %x (device %s) does not match "
-		"to magic found in super block %x (device %s)\n",
-		jh->jh_journal.jp_journal_magic,
-		bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
-		sb_jp_journal_magic(rs), reiserfs_bdevname (p_s_sb));
+	 reiserfs_warning (p_s_sb, "sh-460: journal header magic %x "
+			   "(device %s) does not match to magic found in super "
+			   "block %x",
+			   jh->jh_journal.jp_journal_magic,
+			   bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
+			   sb_jp_journal_magic(rs));
 	 brelse (bhjh);
 	 goto free_and_return;
   }
@@ -2324,7 +2331,7 @@ int journal_init(struct super_block *p_s
       SB_JOURNAL_TRANS_MAX(p_s_sb) = JOURNAL_TRANS_MIN_DEFAULT / ratio;
     
     if (SB_JOURNAL_TRANS_MAX(p_s_sb) != initial)
-      printk ("sh-461: journal_init: wrong transaction max size (%u). Changed to %u\n",
+      reiserfs_warning (p_s_sb, "sh-461: journal_init: wrong transaction max size (%u). Changed to %u",
 	      initial, SB_JOURNAL_TRANS_MAX(p_s_sb));
 
     SB_JOURNAL_MAX_BATCH(p_s_sb) = SB_JOURNAL_TRANS_MAX(p_s_sb)*
@@ -2353,16 +2360,16 @@ int journal_init(struct super_block *p_s
       SB_JOURNAL_MAX_TRANS_AGE(p_s_sb) = commit_max_age;
   }
 
-  printk ("Reiserfs journal params: device %s, size %u, "
-	  "journal first block %u, max trans len %u, max batch %u, "
-	  "max commit age %u, max trans age %u\n",
-	  bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
-	  SB_ONDISK_JOURNAL_SIZE(p_s_sb),
-	  SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb),
-	  SB_JOURNAL_TRANS_MAX(p_s_sb),
-	  SB_JOURNAL_MAX_BATCH(p_s_sb),
-	  SB_JOURNAL_MAX_COMMIT_AGE(p_s_sb),
-	  SB_JOURNAL_MAX_TRANS_AGE(p_s_sb));
+  reiserfs_info (p_s_sb, "journal params: device %s, size %u, "
+		 "journal first block %u, max trans len %u, max batch %u, "
+		 "max commit age %u, max trans age %u\n",
+		 bdevname( SB_JOURNAL(p_s_sb)->j_dev_bd, b),
+		 SB_ONDISK_JOURNAL_SIZE(p_s_sb),
+		 SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb),
+		 SB_JOURNAL_TRANS_MAX(p_s_sb),
+		 SB_JOURNAL_MAX_BATCH(p_s_sb),
+		 SB_JOURNAL_MAX_COMMIT_AGE(p_s_sb),
+		 SB_JOURNAL_MAX_TRANS_AGE(p_s_sb));
 
   brelse (bhjh);
      
@@ -2401,11 +2408,11 @@ int journal_init(struct super_block *p_s
   jl = SB_JOURNAL(p_s_sb)->j_current_jl;
   jl->j_list_bitmap = get_list_bitmap(p_s_sb, jl);
   if (!jl->j_list_bitmap) {
-    reiserfs_warning("journal-2005, get_list_bitmap failed for journal list 0\n") ;
+    reiserfs_warning(p_s_sb, "journal-2005, get_list_bitmap failed for journal list 0") ;
     goto free_and_return;
   }
   if (journal_read(p_s_sb) < 0) {
-    reiserfs_warning("Replay Failure, unable to mount\n") ;
+    reiserfs_warning(p_s_sb, "Replay Failure, unable to mount") ;
     goto free_and_return;
   }
 
@@ -2522,7 +2529,7 @@ static int do_journal_begin_r(struct rei
   struct reiserfs_transaction_handle myth;
   int sched_count = 0;
 
-  reiserfs_check_lock_depth("journal_begin") ;
+  reiserfs_check_lock_depth(p_s_sb, "journal_begin") ;
   RFALSE( p_s_sb->s_flags & MS_RDONLY, 
 	  "clm-2078: calling journal_begin on readonly FS") ;
 
@@ -2664,14 +2671,14 @@ int journal_begin(struct reiserfs_transa
 	      cur_th->t_refcount++ ;
 	      memcpy(th, cur_th, sizeof(*th));
 	      if (th->t_refcount <= 1)
-		      printk("BAD: refcount <= 1, but journal_info != 0\n");
+		      reiserfs_warning (p_s_sb, "BAD: refcount <= 1, but journal_info != 0");
 	      return 0;
 	} else {
 	    /* we've ended up with a handle from a different filesystem.
 	    ** save it and restore on journal_end.  This should never
 	    ** really happen...
 	    */
-	    reiserfs_warning("clm-2100: nesting info a different FS\n") ;
+	    reiserfs_warning(p_s_sb, "clm-2100: nesting info a different FS") ;
 	    th->t_handle_save = current->journal_info ;
 	    current->journal_info = th;
 	}
@@ -2718,14 +2725,16 @@ int journal_mark_dirty(struct reiserfs_t
   ** could get to disk too early.  NOT GOOD.
   */
   if (!prepared || buffer_dirty(bh)) {
-    printk("journal-1777: buffer %llu bad state %cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT\n", (unsigned long long)bh->b_blocknr, prepared ? ' ' : '!', 
-                            buffer_locked(bh) ? ' ' : '!',
+    reiserfs_warning (p_s_sb, "journal-1777: buffer %llu bad state "
+		      "%cPREPARED %cLOCKED %cDIRTY %cJDIRTY_WAIT",
+		      (unsigned long long)bh->b_blocknr, prepared ? ' ' : '!',
+			    buffer_locked(bh) ? ' ' : '!',
 			    buffer_dirty(bh) ? ' ' : '!',
 			    buffer_journal_dirty(bh) ? ' ' : '!') ;
   }
 
   if (atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount)) <= 0) {
-    printk("journal-1409: journal_mark_dirty returning because j_wcount was %d\n", atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount))) ;
+    reiserfs_warning (p_s_sb, "journal-1409: journal_mark_dirty returning because j_wcount was %d", atomic_read(&(SB_JOURNAL(p_s_sb)->j_wcount))) ;
     return 1 ;
   }
   /* this error means I've screwed up, and we've overflowed the transaction.  
@@ -2785,7 +2794,8 @@ int journal_mark_dirty(struct reiserfs_t
 
 int journal_end(struct reiserfs_transaction_handle *th, struct super_block *p_s_sb, unsigned long nblocks) {
   if (!current->journal_info && th->t_refcount > 1)
-    printk("REISER-NESTING: th NULL, refcount %d\n", th->t_refcount);
+    reiserfs_warning (p_s_sb, "REISER-NESTING: th NULL, refcount %d",
+                      th->t_refcount);
 
   th->t_refcount--;
   if (th->t_refcount > 0) {
@@ -2844,7 +2854,7 @@ static int remove_from_transaction(struc
     mark_buffer_notjournal_dirty(bh) ; 
     put_bh(bh) ;
     if (atomic_read(&(bh->b_count)) < 0) {
-      printk("journal-1752: remove from trans, b_count < 0\n") ;
+      reiserfs_warning (p_s_sb, "journal-1752: remove from trans, b_count < 0");
     }
     ret = 1 ;
   }
@@ -3142,7 +3152,7 @@ int journal_mark_freed(struct reiserfs_t
 	    cleaned = 1 ;
 	    put_bh(cn->bh) ;
 	    if (atomic_read(&(cn->bh->b_count)) < 0) {
-	      printk("journal-2138: cn->bh->b_count < 0\n") ;
+	      reiserfs_warning (p_s_sb, "journal-2138: cn->bh->b_count < 0");
 	    }
 	  }
 	  if (cn->jlist) { /* since we are clearing the bh, we MUST dec nonzerolen */
@@ -3158,7 +3168,7 @@ int journal_mark_freed(struct reiserfs_t
   if (bh) {
     put_bh(bh) ; /* get_hash grabs the buffer */
     if (atomic_read(&(bh->b_count)) < 0) {
-      printk("journal-2165: bh->b_count < 0\n") ;
+      reiserfs_warning (p_s_sb, "journal-2165: bh->b_count < 0");
     }
   }
   return 0 ;
@@ -3318,7 +3328,7 @@ static int do_journal_end(struct reiserf
     BUG() ;
 
   current->journal_info = th->t_handle_save;
-  reiserfs_check_lock_depth("journal end");
+  reiserfs_check_lock_depth(p_s_sb, "journal end");
   if (SB_JOURNAL(p_s_sb)->j_len == 0) {
       reiserfs_prepare_for_journal(p_s_sb, SB_BUFFER_WITH_SB(p_s_sb), 1) ;
       journal_mark_dirty(th, p_s_sb, SB_BUFFER_WITH_SB(p_s_sb)) ;
@@ -3480,7 +3490,7 @@ static int do_journal_end(struct reiserf
       clear_bit(BH_JDirty, &(cn->bh->b_state)) ;
     } else {
       /* JDirty cleared sometime during transaction.  don't log this one */
-      reiserfs_warning("journal-2048: do_journal_end: BAD, buffer in journal hash, but not JDirty!\n") ;
+      reiserfs_warning(p_s_sb, "journal-2048: do_journal_end: BAD, buffer in journal hash, but not JDirty!") ;
       brelse(cn->bh) ;
     }
     next = cn->next ;
@@ -3612,7 +3622,7 @@ first_jl:
 	  flush_commit_list(p_s_sb, jl, 1) ;
   }
 out:
-  reiserfs_check_lock_depth("journal end2");
+  reiserfs_check_lock_depth(p_s_sb, "journal end2");
   th->t_trans_id = 0;
   return 0 ;
 }
Index: linux.mm/fs/reiserfs/lbalance.c
===================================================================
--- linux.mm.orig/fs/reiserfs/lbalance.c	2004-01-09 02:00:12.000000000 -0500
+++ linux.mm/fs/reiserfs/lbalance.c	2004-04-23 14:10:21.911192014 -0400
@@ -1210,10 +1210,10 @@ void    leaf_paste_entries (
       prev = (i != 0) ? deh_location( &(deh[i - 1]) ) : 0;
       
       if (prev && prev <= deh_location( &(deh[i])))
-	reiserfs_warning ("vs-10240: leaf_paste_entries: directory item (%h) corrupted (prev %a, cur(%d) %a)\n", 
+	reiserfs_warning (NULL, "vs-10240: leaf_paste_entries: directory item (%h) corrupted (prev %a, cur(%d) %a)",
 			  ih, deh + i - 1, i, deh + i);
       if (next && next >= deh_location( &(deh[i])))
-	reiserfs_warning ("vs-10250: leaf_paste_entries: directory item (%h) corrupted (cur(%d) %a, next %a)\n",
+	reiserfs_warning (NULL, "vs-10250: leaf_paste_entries: directory item (%h) corrupted (cur(%d) %a, next %a)",
 			  ih, i, deh + i, deh + i + 1);
     }
   }
Index: linux.mm/fs/reiserfs/namei.c
===================================================================
--- linux.mm.orig/fs/reiserfs/namei.c	2004-04-23 14:10:06.384059224 -0400
+++ linux.mm/fs/reiserfs/namei.c	2004-04-23 14:10:21.913191773 -0400
@@ -126,7 +126,7 @@ int search_by_entry_key (struct super_bl
     switch (retval) {
     case ITEM_NOT_FOUND:
 	if (!PATH_LAST_POSITION (path)) {
-	    reiserfs_warning ("vs-7000: search_by_entry_key: search_by_key returned item position == 0");
+	    reiserfs_warning (sb, "vs-7000: search_by_entry_key: search_by_key returned item position == 0");
 	    pathrelse(path) ;
 	    return IO_ERROR ;
 	}
@@ -140,7 +140,7 @@ int search_by_entry_key (struct super_bl
 
     default:
 	pathrelse (path);
-	reiserfs_warning ("vs-7002: search_by_entry_key: no path to here");
+	reiserfs_warning (sb, "vs-7002: search_by_entry_key: no path to here");
 	return IO_ERROR;
     }
 
@@ -299,7 +299,8 @@ static int reiserfs_find_entry (struct i
     while (1) {
 	retval = search_by_entry_key (dir->i_sb, &key_to_search, path_to_entry, de);
 	if (retval == IO_ERROR) {
-	    reiserfs_warning ("zam-7001: io error in %s\n", __FUNCTION__);
+	    reiserfs_warning (dir->i_sb, "zam-7001: io error in %s",
+			      __FUNCTION__);
 	    return IO_ERROR;
 	}
 
@@ -484,8 +485,9 @@ static int reiserfs_add_entry (struct re
 	}
 
         if (retval != NAME_FOUND) {
-	    reiserfs_warning ("zam-7002:%s: \"reiserfs_find_entry\" has returned"
-                              " unexpected value (%d)\n", __FUNCTION__, retval);
+	    reiserfs_warning (dir->i_sb, "zam-7002:%s: \"reiserfs_find_entry\" "
+			      "has returned unexpected value (%d)",
+			      __FUNCTION__, retval);
        }
 
 	return -EEXIST;
@@ -494,7 +496,7 @@ static int reiserfs_add_entry (struct re
     gen_number = find_first_zero_bit ((unsigned long *)bit_string, MAX_GENERATION_NUMBER + 1);
     if (gen_number > MAX_GENERATION_NUMBER) {
       /* there is no free generation number */
-      reiserfs_warning ("reiserfs_add_entry: Congratulations! we have got hash function screwed up\n");
+      reiserfs_warning (dir->i_sb, "reiserfs_add_entry: Congratulations! we have got hash function screwed up");
       if (buffer != small_buf)
           reiserfs_kfree (buffer, buflen, dir->i_sb);
       pathrelse (&path);
@@ -509,8 +511,9 @@ static int reiserfs_add_entry (struct re
  		  
     if (gen_number != 0) {	/* we need to re-search for the insertion point */
       if (search_by_entry_key (dir->i_sb, &entry_key, &path, &de) != NAME_NOT_FOUND) {
-            reiserfs_warning ("vs-7032: reiserfs_add_entry: "
-                            "entry with this key (%K) already exists\n", &entry_key);
+            reiserfs_warning (dir->i_sb, "vs-7032: reiserfs_add_entry: "
+                              "entry with this key (%K) already exists",
+                              &entry_key);
 
 	    if (buffer != small_buf)
 		reiserfs_kfree (buffer, buflen, dir->i_sb);
@@ -835,7 +838,8 @@ static int reiserfs_rmdir (struct inode 
 	goto end_rmdir;
 
     if ( inode->i_nlink != 2 && inode->i_nlink != 1 )
-	printk ("reiserfs_rmdir: empty directory has nlink != 2 (%d)\n", inode->i_nlink);
+	reiserfs_warning (inode->i_sb, "%s: empty directory has nlink "
+			  "!= 2 (%d)", __FUNCTION__, inode->i_nlink);
 
     inode->i_nlink = 0;
     inode->i_ctime = dir->i_ctime = dir->i_mtime = CURRENT_TIME;
@@ -902,8 +906,10 @@ static int reiserfs_unlink (struct inode
     }
   
     if (!inode->i_nlink) {
-	printk("reiserfs_unlink: deleting nonexistent file (%s:%lu), %d\n",
-	       reiserfs_bdevname (inode->i_sb), inode->i_ino, inode->i_nlink);
+	reiserfs_warning (inode->i_sb, "%s: deleting nonexistent file "
+			  "(%s:%lu), %d", __FUNCTION__,
+			  reiserfs_bdevname (inode->i_sb), inode->i_ino,
+			  inode->i_nlink);
 	inode->i_nlink = 1;
     }
 
@@ -1337,7 +1343,7 @@ static int reiserfs_rename (struct inode
     // anybody, but it will panic if will not be able to find the
     // entry. This needs one more clean up
     if (reiserfs_cut_from_item (&th, &old_entry_path, &(old_de.de_entry_key), old_dir, NULL, 0) < 0)
-	reiserfs_warning ("vs-7060: reiserfs_rename: couldn't not cut old name. Fsck later?\n");
+	reiserfs_warning (old_dir->i_sb, "vs-7060: reiserfs_rename: couldn't not cut old name. Fsck later?");
 
     old_dir->i_size -= DEH_SIZE + old_de.de_entrylen;
 
Index: linux.mm/fs/reiserfs/objectid.c
===================================================================
--- linux.mm.orig/fs/reiserfs/objectid.c	2004-04-23 14:08:22.606517285 -0400
+++ linux.mm/fs/reiserfs/objectid.c	2004-04-23 14:10:21.914191653 -0400
@@ -62,7 +62,7 @@ __u32 reiserfs_get_unused_objectid (stru
                                 /* comment needed -Hans */
     unused_objectid = le32_to_cpu (map[1]);
     if (unused_objectid == U32_MAX) {
-	printk ("REISERFS: get_objectid: no more object ids\n");
+	reiserfs_warning (s, "%s: no more object ids", __FUNCTION__);
 	reiserfs_restore_prepared_buffer(s, SB_BUFFER_WITH_SB(s)) ;
 	return 0;
     }
@@ -159,7 +159,7 @@ void reiserfs_release_objectid (struct r
 	i += 2;
     }
 
-    reiserfs_warning ("vs-15011: reiserfs_release_objectid: tried to free free object id (%lu)\n", 
+    reiserfs_warning (s, "vs-15011: reiserfs_release_objectid: tried to free free object id (%lu)",
 		      ( long unsigned ) objectid_to_release);
 }
 
Index: linux.mm/fs/reiserfs/prints.c
===================================================================
--- linux.mm.orig/fs/reiserfs/prints.c	2004-04-23 14:08:22.608517045 -0400
+++ linux.mm/fs/reiserfs/prints.c	2004-04-23 14:10:21.916191413 -0400
@@ -264,20 +264,43 @@ prepare_error_buf( const char *fmt, va_l
     va_end( args );\
 }
 
-void reiserfs_warning (const char * fmt, ...)
+void reiserfs_warning (struct super_block *sb, const char * fmt, ...)
 {
   do_reiserfs_warning(fmt);
-  /* console_print (error_buf); */
-  printk (KERN_WARNING "%s", error_buf);
+  if (sb)
+      printk (KERN_WARNING "ReiserFS: %s: warning: %s\n",
+             reiserfs_bdevname (sb), error_buf);
+  else
+      printk (KERN_WARNING "ReiserFS: warning: %s\n", error_buf);
+}
+
+/* No newline.. reiserfs_info calls can be followed by printk's */
+void reiserfs_info (struct super_block *sb, const char * fmt, ...)
+{
+  do_reiserfs_warning(fmt);
+  if (sb)
+      printk (KERN_NOTICE "ReiserFS: %s: %s",
+             reiserfs_bdevname (sb), error_buf);
+  else
+      printk (KERN_NOTICE "ReiserFS: %s", error_buf);
+}
+
+/* No newline.. reiserfs_printk calls can be followed by printk's */
+void reiserfs_printk (const char * fmt, ...)
+{
+  do_reiserfs_warning(fmt);
+  printk (error_buf);
 }
 
 void reiserfs_debug (struct super_block *s, int level, const char * fmt, ...)
 {
 #ifdef CONFIG_REISERFS_CHECK
   do_reiserfs_warning(fmt);
-  printk (KERN_DEBUG "%s", error_buf);
-#else
-  ; 
+  if (s)
+      printk (KERN_DEBUG "ReiserFS: %s: %s\n",
+             reiserfs_bdevname (s), error_buf);
+  else
+      printk (KERN_DEBUG "ReiserFS: %s\n", error_buf);
 #endif
 }
 
@@ -334,7 +357,8 @@ extern struct tree_balance * cur_tb;
 void reiserfs_panic (struct super_block * sb, const char * fmt, ...)
 {
   do_reiserfs_warning(fmt);
-  printk ( KERN_EMERG "%s", error_buf);
+  printk (KERN_EMERG "REISERFS: panic (device %s): %s\n",
+          reiserfs_bdevname (sb), error_buf);
   BUG ();
 
   /* this is not actually called, but makes reiserfs_panic() "noreturn" */
@@ -413,13 +437,13 @@ static int print_internal (struct buffer
 	to = last < B_NR_ITEMS (bh) ? last : B_NR_ITEMS (bh);
     }
 
-    reiserfs_warning ("INTERNAL NODE (%ld) contains %z\n",  bh->b_blocknr, bh);
+    reiserfs_printk ("INTERNAL NODE (%ld) contains %z\n",  bh->b_blocknr, bh);
     
     dc = B_N_CHILD (bh, from);
-    reiserfs_warning ("PTR %d: %y ", from, dc);
+    reiserfs_printk ("PTR %d: %y ", from, dc);
     
     for (i = from, key = B_N_PDELIM_KEY (bh, from), dc ++; i < to; i ++, key ++, dc ++) {
-	reiserfs_warning ("KEY %d: %k PTR %d: %y ", i, key, i + 1, dc);
+	reiserfs_printk ("KEY %d: %k PTR %d: %y ", i, key, i + 1, dc);
 	if (i && i % 4 == 0)
 	    printk ("\n");
     }
@@ -448,10 +472,10 @@ static int print_leaf (struct buffer_hea
     nr = blkh_nr_item(blkh);
 
     printk ("\n===================================================================\n");
-    reiserfs_warning ("LEAF NODE (%ld) contains %z\n", bh->b_blocknr, bh);
+    reiserfs_printk ("LEAF NODE (%ld) contains %z\n", bh->b_blocknr, bh);
 
     if (!(print_mode & PRINT_LEAF_ITEMS)) {
-	reiserfs_warning ("FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\n",
+	reiserfs_printk ("FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\n",
 			  &(ih->ih_key), &((ih + nr - 1)->ih_key));
 	return 0;
     }
@@ -471,7 +495,7 @@ static int print_leaf (struct buffer_hea
     printk ("|##|   type    |           key           | ilen | free_space | version | loc  |\n");
     for (i = from; i < to; i++, ih ++) {
 	printk ("-------------------------------------------------------------------------------\n");
-	reiserfs_warning ("|%2d| %h |\n", i, ih);
+	reiserfs_printk ("|%2d| %h |\n", i, ih);
 	if (print_mode & PRINT_LEAF_ITEMS)
 	    op_print_item (ih, B_I_PITEM (bh, ih));
     }
Index: linux.mm/fs/reiserfs/procfs.c
===================================================================
--- linux.mm.orig/fs/reiserfs/procfs.c	2004-04-23 14:08:22.610516805 -0400
+++ linux.mm/fs/reiserfs/procfs.c	2004-04-23 14:10:21.917191293 -0400
@@ -548,8 +548,8 @@ int reiserfs_proc_info_init( struct supe
 		add_file(sb, "journal", show_journal);
 		return 0;
 	}
-	reiserfs_warning( "reiserfs: cannot create /proc/%s/%s\n",
-			  proc_info_root_name, reiserfs_bdevname (sb) );
+	reiserfs_warning(sb, "reiserfs: cannot create /proc/%s/%s",
+			 proc_info_root_name, reiserfs_bdevname (sb) );
 	return 1;
 }
 
@@ -595,7 +595,8 @@ int reiserfs_proc_info_global_init( void
 		if( proc_info_root ) {
 			proc_info_root -> owner = THIS_MODULE;
 		} else {
-			reiserfs_warning( "reiserfs: cannot create /proc/%s\n",
+			reiserfs_warning (NULL,
+					  "reiserfs: cannot create /proc/%s",
 					  proc_info_root_name );
 			return 1;
 		}
Index: linux.mm/fs/reiserfs/stree.c
===================================================================
--- linux.mm.orig/fs/reiserfs/stree.c	2004-04-23 14:10:06.407056457 -0400
+++ linux.mm/fs/reiserfs/stree.c	2004-04-23 14:10:21.921190812 -0400
@@ -164,7 +164,7 @@ inline int comp_cpu_keys (const struct c
     if (cpu_key_k_offset (key1) > cpu_key_k_offset (key2))
 	return 1;
 
-    reiserfs_warning ("comp_cpu_keys: type are compared for %K and %K\n",
+    reiserfs_warning (NULL, "comp_cpu_keys: type are compared for %K and %K",
 		      key1, key2);
 
     if (cpu_key_k_type (key1) < cpu_key_k_type (key2))
@@ -497,21 +497,21 @@ static int is_leaf (char * buf, int bloc
 
     blkh = (struct block_head *)buf;
     if ( blkh_level(blkh) != DISK_LEAF_NODE_LEVEL) {
-	printk ("is_leaf: this should be caught earlier\n");
+	reiserfs_warning (NULL, "is_leaf: this should be caught earlier");
 	return 0;
     }
 
     nr = blkh_nr_item(blkh);
     if (nr < 1 || nr > ((blocksize - BLKH_SIZE) / (IH_SIZE + MIN_ITEM_LEN))) {
 	/* item number is too big or too small */
-	reiserfs_warning ("is_leaf: nr_item seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_leaf: nr_item seems wrong: %z", bh);
 	return 0;
     }
     ih = (struct item_head *)(buf + BLKH_SIZE) + nr - 1;
     used_space = BLKH_SIZE + IH_SIZE * nr + (blocksize - ih_location (ih));
     if (used_space != blocksize - blkh_free_space(blkh)) {
 	/* free space does not match to calculated amount of use space */
-	reiserfs_warning ("is_leaf: free space seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_leaf: free space seems wrong: %z", bh);
 	return 0;
     }
 
@@ -523,19 +523,19 @@ static int is_leaf (char * buf, int bloc
     prev_location = blocksize;
     for (i = 0; i < nr; i ++, ih ++) {
 	if ( le_ih_k_type(ih) == TYPE_ANY) {
-	    reiserfs_warning ("is_leaf: wrong item type for item %h\n",ih);
+	    reiserfs_warning (NULL, "is_leaf: wrong item type for item %h",ih);
 	    return 0;
 	}
 	if (ih_location (ih) >= blocksize || ih_location (ih) < IH_SIZE * nr) {
-	    reiserfs_warning ("is_leaf: item location seems wrong: %h\n", ih);
+	    reiserfs_warning (NULL, "is_leaf: item location seems wrong: %h", ih);
 	    return 0;
 	}
 	if (ih_item_len (ih) < 1 || ih_item_len (ih) > MAX_ITEM_LEN (blocksize)) {
-	    reiserfs_warning ("is_leaf: item length seems wrong: %h\n", ih);
+	    reiserfs_warning (NULL, "is_leaf: item length seems wrong: %h", ih);
 	    return 0;
 	}
 	if (prev_location - ih_location (ih) != ih_item_len (ih)) {
-	    reiserfs_warning ("is_leaf: item location seems wrong (second one): %h\n", ih);
+	    reiserfs_warning (NULL, "is_leaf: item location seems wrong (second one): %h", ih);
 	    return 0;
 	}
 	prev_location = ih_location (ih);
@@ -557,20 +557,20 @@ static int is_internal (char * buf, int 
     nr = blkh_level(blkh);
     if (nr <= DISK_LEAF_NODE_LEVEL || nr > MAX_HEIGHT) {
 	/* this level is not possible for internal nodes */
-	printk ("is_internal: this should be caught earlier\n");
+	reiserfs_warning (NULL, "is_internal: this should be caught earlier");
 	return 0;
     }
     
     nr = blkh_nr_item(blkh);
     if (nr > (blocksize - BLKH_SIZE - DC_SIZE) / (KEY_SIZE + DC_SIZE)) {
 	/* for internal which is not root we might check min number of keys */
-	reiserfs_warning ("is_internal: number of key seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_internal: number of key seems wrong: %z", bh);
 	return 0;
     }
 
     used_space = BLKH_SIZE + KEY_SIZE * nr + DC_SIZE * (nr + 1);
     if (used_space != blocksize - blkh_free_space(blkh)) {
-	reiserfs_warning ("is_internal: free space seems wrong: %z\n", bh);
+	reiserfs_warning (NULL, "is_internal: free space seems wrong: %z", bh);
 	return 0;
     }
 
@@ -584,7 +584,7 @@ static int is_internal (char * buf, int 
 static int is_tree_node (struct buffer_head * bh, int level)
 {
     if (B_LEVEL (bh) != level) {
-	printk ("is_tree_node: node level %d does not match to the expected one %d\n",
+	reiserfs_warning (NULL, "is_tree_node: node level %d does not match to the expected one %d",
 		B_LEVEL (bh), level);
 	return 0;
     }
@@ -681,9 +681,9 @@ int search_by_key (struct super_block * 
 
 #ifdef CONFIG_REISERFS_CHECK
 	if ( !(++n_repeat_counter % 50000) )
-	    reiserfs_warning ("PAP-5100: search_by_key: %s:"
+	    reiserfs_warning (p_s_sb, "PAP-5100: search_by_key: %s:"
 			      "there were %d iterations of while loop "
-			      "looking for key %K\n",
+			      "looking for key %K",
 			      current->comm, n_repeat_counter, p_s_key);
 #endif
 
@@ -746,8 +746,8 @@ int search_by_key (struct super_block * 
 	// make sure, that the node contents look like a node of
 	// certain level
 	if (!is_tree_node (p_s_bh, expected_level)) {
-	    reiserfs_warning ("vs-5150: search_by_key: "
-			      "invalid format found in block %ld. Fsck?\n", 
+	    reiserfs_warning (p_s_sb, "vs-5150: search_by_key: "
+			      "invalid format found in block %ld. Fsck?",
 			      p_s_bh->b_blocknr);
 	    pathrelse (p_s_search_path);
 	    return IO_ERROR;
@@ -1280,8 +1280,8 @@ int reiserfs_delete_item (struct reiserf
 	if (n_ret_value == IO_ERROR)
 	    break;
 	if (n_ret_value == FILE_NOT_FOUND) {
-	    reiserfs_warning ("vs-5340: reiserfs_delete_item: "
-			      "no items of the file %K found\n", p_s_item_key);
+	    reiserfs_warning (p_s_sb, "vs-5340: reiserfs_delete_item: "
+			      "no items of the file %K found", p_s_item_key);
 	    break;
 	}
     } /* while (1) */
@@ -1344,7 +1344,7 @@ int reiserfs_delete_item (struct reiserf
     do_balance(&s_del_balance, NULL, NULL, M_DELETE);
 
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota delete_item(): freeing %u, id=%u type=%c\n", quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
+    reiserfs_debug (p_s_sb, "reiserquota delete_item(): freeing %u, id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, head2type(&s_ih));
 #endif
     DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
 
@@ -1388,8 +1388,10 @@ void reiserfs_delete_solid_item (struct 
     while (1) {
 	retval = search_item (th->t_super, &cpu_key, &path);
 	if (retval == IO_ERROR) {
-	    reiserfs_warning ("vs-5350: reiserfs_delete_solid_item: "
-			      "i/o failure occurred trying to delete %K\n", &cpu_key);
+	    reiserfs_warning (th->t_super,
+			      "vs-5350: reiserfs_delete_solid_item: "
+			      "i/o failure occurred trying to delete %K",
+			      &cpu_key);
 	    break;
 	}
 	if (retval != ITEM_FOUND) {
@@ -1397,7 +1399,7 @@ void reiserfs_delete_solid_item (struct 
 	    // No need for a warning, if there is just no free space to insert '..' item into the newly-created subdir
 	    if ( !( (unsigned long long) GET_HASH_VALUE (le_key_k_offset (le_key_version (key), key)) == 0 && \
 		 (unsigned long long) GET_GENERATION_NUMBER (le_key_k_offset (le_key_version (key), key)) == 1 ) )
-		reiserfs_warning ("vs-5355: reiserfs_delete_solid_item: %k not found", key);
+		reiserfs_warning (th->t_super, "vs-5355: reiserfs_delete_solid_item: %k not found", key);
 	    break;
 	}
 	if (!tb_init) {
@@ -1417,7 +1419,7 @@ void reiserfs_delete_solid_item (struct 
 	    do_balance (&tb, 0, 0, M_DELETE);
 	    if (inode) {	/* Should we count quota for item? (we don't count quotas for save-links) */
 #ifdef REISERQUOTA_DEBUG
-		printk(KERN_DEBUG "reiserquota delete_solid_item(): freeing %u id=%u type=%c\n", quota_cut_bytes, inode->i_uid, key2type(key));
+		reiserfs_debug (th->t_super, "reiserquota delete_solid_item(): freeing %u id=%u type=%c", quota_cut_bytes, inode->i_uid, key2type(key));
 #endif
 		DQUOT_FREE_SPACE_NODIRTY(inode, quota_cut_bytes);
 	    }
@@ -1425,8 +1427,8 @@ void reiserfs_delete_solid_item (struct 
 	}
 
 	// IO_ERROR, NO_DISK_SPACE, etc
-	reiserfs_warning ("vs-5360: reiserfs_delete_solid_item: "
-			  "could not delete %K due to fix_nodes failure\n", &cpu_key);
+	reiserfs_warning (th->t_super, "vs-5360: reiserfs_delete_solid_item: "
+			  "could not delete %K due to fix_nodes failure", &cpu_key);
 	unfix_nodes (&tb);
 	break;
     }
@@ -1520,7 +1522,7 @@ static void indirect_to_direct_roll_back
 	tail_len -= removed;
 	set_cpu_key_k_offset (&tail_key, cpu_key_k_offset (&tail_key) - removed);
     }
-    printk ("indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space\n");
+    reiserfs_warning (inode->i_sb, "indirect_to_direct_roll_back: indirect_to_direct conversion has been rolled back due to lack of disk space");
     //mark_file_without_tail (inode);
     mark_inode_dirty (inode);
 }
@@ -1612,7 +1614,7 @@ int reiserfs_cut_from_item (struct reise
 	if (n_ret_value == POSITION_FOUND)
 	    continue;
 
-	reiserfs_warning ("PAP-5610: reiserfs_cut_from_item: item %K not found\n", p_s_item_key);
+	reiserfs_warning (p_s_sb, "PAP-5610: reiserfs_cut_from_item: item %K not found", p_s_item_key);
 	unfix_nodes (&s_cut_balance);
 	return (n_ret_value == IO_ERROR) ? -EIO : -ENOENT;
     } /* while */
@@ -1625,7 +1627,7 @@ int reiserfs_cut_from_item (struct reise
 	    indirect_to_direct_roll_back (th, p_s_inode, p_s_path);
 	}
 	if (n_ret_value == NO_DISK_SPACE)
-	    reiserfs_warning ("NO_DISK_SPACE");
+	    reiserfs_warning (p_s_sb, "NO_DISK_SPACE");
 	unfix_nodes (&s_cut_balance);
 	return -EIO;
     }
@@ -1691,7 +1693,7 @@ int reiserfs_cut_from_item (struct reise
 	REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask ;
     }
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota cut_from_item(): freeing %u id=%u type=%c\n", quota_cut_bytes, p_s_inode->i_uid, '?');
+    reiserfs_debug (p_s_inode->i_sb, "reiserquota cut_from_item(): freeing %u id=%u type=%c", quota_cut_bytes, p_s_inode->i_uid, '?');
 #endif
     DQUOT_FREE_SPACE_NODIRTY(p_s_inode, quota_cut_bytes);
     return n_ret_value;
@@ -1700,7 +1702,8 @@ int reiserfs_cut_from_item (struct reise
 static void truncate_directory (struct reiserfs_transaction_handle *th, struct inode * inode)
 {
     if (inode->i_nlink)
-	reiserfs_warning ("vs-5655: truncate_directory: link count != 0\n");
+	reiserfs_warning (inode->i_sb,
+			  "vs-5655: truncate_directory: link count != 0");
 
     set_le_key_k_offset (KEY_FORMAT_3_5, INODE_PKEY (inode), DOT_OFFSET);
     set_le_key_k_type (KEY_FORMAT_3_5, INODE_PKEY (inode), TYPE_DIRENTRY);
@@ -1749,14 +1752,14 @@ void reiserfs_do_truncate (struct reiser
 
     retval = search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path);
     if (retval == IO_ERROR) {
-	reiserfs_warning ("vs-5657: reiserfs_do_truncate: "
-			  "i/o failure occurred trying to truncate %K\n", &s_item_key);
+	reiserfs_warning (p_s_inode->i_sb, "vs-5657: reiserfs_do_truncate: "
+			  "i/o failure occurred trying to truncate %K", &s_item_key);
 	return;
     }
     if (retval == POSITION_FOUND || retval == FILE_NOT_FOUND) {
 	pathrelse (&s_search_path);
-	reiserfs_warning ("PAP-5660: reiserfs_do_truncate: "
-			  "wrong result %d of search for %K\n", retval, &s_item_key);
+	reiserfs_warning (p_s_inode->i_sb, "PAP-5660: reiserfs_do_truncate: "
+			  "wrong result %d of search for %K", retval, &s_item_key);
 	return;
     }
 
@@ -1787,7 +1790,7 @@ void reiserfs_do_truncate (struct reiser
 	/* Cut or delete file item. */
 	n_deleted = reiserfs_cut_from_item(th, &s_search_path, &s_item_key, p_s_inode,  page, n_new_file_size);
 	if (n_deleted < 0) {
-	    reiserfs_warning ("vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
+	    reiserfs_warning (p_s_inode->i_sb, "vs-5665: reiserfs_do_truncate: reiserfs_cut_from_item failed");
 	    reiserfs_check_path(&s_search_path) ;
 	    return;
 	}
@@ -1827,7 +1830,7 @@ void reiserfs_do_truncate (struct reiser
 	      search_for_position_by_key(p_s_inode->i_sb, &s_item_key, &s_search_path) == POSITION_FOUND )  ;
 
     RFALSE( n_file_size > ROUND_UP (n_new_file_size),
-	    "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d\n",
+	    "PAP-5680: truncate did not finish: new_file_size %Ld, current %Ld, oid %d",
 	    n_new_file_size, n_file_size, s_item_key.on_disk_key.k_objectid);
 
 update_and_out:
@@ -1883,7 +1886,7 @@ int reiserfs_paste_into_item (struct rei
     fs_gen = get_generation(inode->i_sb) ;
 
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota paste_into_item(): allocating %u id=%u type=%c\n", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+    reiserfs_debug (inode->i_sb, "reiserquota paste_into_item(): allocating %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
 #endif
 
     if (DQUOT_ALLOC_SPACE_NODIRTY(inode, n_pasted_size)) {
@@ -1911,7 +1914,7 @@ search_again:
 	    goto error_out ;
 	}
 	if (retval == POSITION_FOUND) {
-	    reiserfs_warning ("PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists\n", p_s_key);
+	    reiserfs_warning (inode->i_sb, "PAP-5710: reiserfs_paste_into_item: entry or pasted byte (%K) exists", p_s_key);
 	    retval = -EEXIST ;
 	    goto error_out ;
 	}
@@ -1932,7 +1935,7 @@ error_out:
     /* this also releases the path */
     unfix_nodes(&s_paste_balance);
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota paste_into_item(): freeing %u id=%u type=%c\n", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
+    reiserfs_debug (inode->i_sb, "reiserquota paste_into_item(): freeing %u id=%u type=%c", n_pasted_size, inode->i_uid, key2type(&(p_s_key->on_disk_key)));
 #endif
     DQUOT_FREE_SPACE_NODIRTY(inode, n_pasted_size);
     return retval ;
@@ -1963,7 +1966,7 @@ int reiserfs_insert_item(struct reiserfs
 	    quota_bytes = inode->i_sb->s_blocksize + UNFM_P_SIZE ;
 	}
 #ifdef REISERQUOTA_DEBUG
-	printk(KERN_DEBUG "reiserquota insert_item(): allocating %u id=%u type=%c\n", quota_bytes, inode->i_uid, head2type(p_s_ih));
+	reiserfs_debug (inode->i_sb, "reiserquota insert_item(): allocating %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
 #endif
 	/* We can't dirty inode here. It would be immediately written but
 	 * appropriate stat item isn't inserted yet... */
@@ -1991,8 +1994,8 @@ search_again:
 	    goto error_out ;
 	}
 	if (retval == ITEM_FOUND) {
-	    reiserfs_warning ("PAP-5760: reiserfs_insert_item: "
-			      "key %K already exists in the tree\n", key);
+	    reiserfs_warning (th->t_super, "PAP-5760: reiserfs_insert_item: "
+			      "key %K already exists in the tree", key);
 	    retval = -EEXIST ;
 	    goto error_out; 
 	}
@@ -2009,7 +2012,7 @@ error_out:
     /* also releases the path */
     unfix_nodes(&s_ins_balance);
 #ifdef REISERQUOTA_DEBUG
-    printk(KERN_DEBUG "reiserquota insert_item(): freeing %u id=%u type=%c\n", quota_bytes, inode->i_uid, head2type(p_s_ih));
+    reiserfs_debug (th->t_super, "reiserquota insert_item(): freeing %u id=%u type=%c", quota_bytes, inode->i_uid, head2type(p_s_ih));
 #endif
     if (inode)
 	DQUOT_FREE_SPACE_NODIRTY(inode, quota_bytes) ;
Index: linux.mm/fs/reiserfs/super.c
===================================================================
--- linux.mm.orig/fs/reiserfs/super.c	2004-04-23 14:10:06.409056216 -0400
+++ linux.mm/fs/reiserfs/super.c	2004-04-23 14:10:21.925190331 -0400
@@ -150,7 +150,7 @@ static void finish_unfinished (struct su
     while (1) {
         retval = search_item (s, &max_cpu_key, &path);
         if (retval != ITEM_NOT_FOUND) {
-            reiserfs_warning ("vs-2140: finish_unfinished: search_by_key returned %d\n",
+            reiserfs_warning (s, "vs-2140: finish_unfinished: search_by_key returned %d",
                               retval);
             break;
         }
@@ -158,7 +158,7 @@ static void finish_unfinished (struct su
         bh = get_last_bh (&path);
         item_pos = get_item_pos (&path);
         if (item_pos != B_NR_ITEMS (bh)) {
-            reiserfs_warning ("vs-2060: finish_unfinished: wrong position found\n");
+            reiserfs_warning (s, "vs-2060: finish_unfinished: wrong position found");
             break;
         }
         item_pos --;
@@ -187,7 +187,7 @@ static void finish_unfinished (struct su
         if (!inode) {
             /* the unlink almost completed, it just did not manage to remove
 	       "save" link and release objectid */
-            reiserfs_warning ("vs-2180: finish_unfinished: iget failed for %K\n",
+            reiserfs_warning (s, "vs-2180: finish_unfinished: iget failed for %K",
                               &obj_key);
             remove_save_link_only (s, &save_link_key, 1);
             continue;
@@ -195,7 +195,7 @@ static void finish_unfinished (struct su
 
 	if (!truncate && inode->i_nlink) {
 	    /* file is not unlinked */
-            reiserfs_warning ("vs-2185: finish_unfinished: file %K is not unlinked\n",
+            reiserfs_warning (s, "vs-2185: finish_unfinished: file %K is not unlinked",
                               &obj_key);
             remove_save_link_only (s, &save_link_key, 0);
             continue;
@@ -206,7 +206,7 @@ static void finish_unfinished (struct su
 	       The only imaginable way is to execute unfinished truncate request
 	       then boot into old kernel, remove the file and create dir with
 	       the same key. */
-	    reiserfs_warning("green-2101: impossible truncate on a directory %k. Please report\n", INODE_PKEY (inode));
+	    reiserfs_warning(s, "green-2101: impossible truncate on a directory %k. Please report", INODE_PKEY (inode));
 	    remove_save_link_only (s, &save_link_key, 0);
 	    truncate = 0;
 	    iput (inode); 
@@ -217,14 +217,14 @@ static void finish_unfinished (struct su
             REISERFS_I(inode) -> i_flags |= i_link_saved_truncate_mask;
             /* not completed truncate found. New size was committed together
 	       with "save" link */
-            reiserfs_warning ("Truncating %k to %Ld ..",
+            reiserfs_info (s, "Truncating %k to %Ld ..",
                               INODE_PKEY (inode), inode->i_size);
             reiserfs_truncate_file (inode, 0/*don't update modification time*/);
             remove_save_link (inode, truncate);
         } else {
             REISERFS_I(inode) -> i_flags |= i_link_saved_unlink_mask;
             /* not completed unlink (rmdir) found */
-            reiserfs_warning ("Removing %k..", INODE_PKEY (inode));
+            reiserfs_info (s, "Removing %k..", INODE_PKEY (inode));
             /* removal gets completed in iput */
         }
  
@@ -236,7 +236,7 @@ static void finish_unfinished (struct su
      
     pathrelse (&path);
     if (done)
-        reiserfs_warning ("There were %d uncompleted unlinks/truncates. "
+        reiserfs_info (s, "There were %d uncompleted unlinks/truncates. "
                           "Completed\n", done);
 }
  
@@ -278,7 +278,7 @@ void add_save_link (struct reiserfs_tran
     } else {
 	/* truncate */
 	if (S_ISDIR (inode->i_mode))
-	    reiserfs_warning("green-2102: Adding a truncate savelink for a directory %k! Please report\n", INODE_PKEY(inode));
+	    reiserfs_warning(inode->i_sb, "green-2102: Adding a truncate savelink for a directory %k! Please report", INODE_PKEY(inode));
 	set_cpu_key_k_offset (&key, 1);
 	set_cpu_key_k_type (&key, TYPE_INDIRECT);
 
@@ -292,8 +292,8 @@ void add_save_link (struct reiserfs_tran
     retval = search_item (inode->i_sb, &key, &path);
     if (retval != ITEM_NOT_FOUND) {
 	if ( retval != -ENOSPC )
-	    reiserfs_warning ("vs-2100: add_save_link:"
-			  "search_by_key (%K) returned %d\n", &key, retval);
+	    reiserfs_warning (inode->i_sb, "vs-2100: add_save_link:"
+			  "search_by_key (%K) returned %d", &key, retval);
 	pathrelse (&path);
 	return;
     }
@@ -305,7 +305,7 @@ void add_save_link (struct reiserfs_tran
     retval = reiserfs_insert_item (th, &path, &key, &ih, NULL, (char *)&link);
     if (retval) {
 	if (retval != -ENOSPC)
-	    reiserfs_warning ("vs-2120: add_save_link: insert_item returned %d\n",
+	    reiserfs_warning (inode->i_sb, "vs-2120: add_save_link: insert_item returned %d",
 			  retval);
     } else {
 	if( truncate )
@@ -394,12 +394,12 @@ static void reiserfs_put_super (struct s
   print_statistics (s);
 
   if (REISERFS_SB(s)->s_kmallocs != 0) {
-    reiserfs_warning ("vs-2004: reiserfs_put_super: allocated memory left %d\n",
+    reiserfs_warning (s, "vs-2004: reiserfs_put_super: allocated memory left %d",
 		      REISERFS_SB(s)->s_kmallocs);
   }
 
   if (REISERFS_SB(s)->reserved_blocks != 0) {
-    reiserfs_warning ("green-2005: reiserfs_put_super: reserved blocks left %d\n",
+    reiserfs_warning (s, "green-2005: reiserfs_put_super: reserved blocks left %d",
 		      REISERFS_SB(s)->reserved_blocks);
   }
 
@@ -454,7 +454,7 @@ static int init_inodecache(void)
 static void destroy_inodecache(void)
 {
 	if (kmem_cache_destroy(reiserfs_inode_cachep))
-		printk(KERN_INFO "reiserfs_inode_cache: not all structures were freed\n");
+		reiserfs_warning (NULL, "reiserfs_inode_cache: not all structures were freed");
 }
 
 /* we don't mark inodes dirty, we just log them */
@@ -462,7 +462,7 @@ static void reiserfs_dirty_inode (struct
     struct reiserfs_transaction_handle th ;
 
     if (inode->i_sb->s_flags & MS_RDONLY) {
-        reiserfs_warning("clm-6006: writing inode %lu on readonly FS\n", 
+        reiserfs_warning(inode->i_sb, "clm-6006: writing inode %lu on readonly FS",
 	                  inode->i_ino) ;
         return ;
     }
@@ -627,7 +627,7 @@ static int reiserfs_getopt ( struct supe
 	}
     }
     if (!opt->option_name) {
-	printk ("reiserfs_getopt: unknown option \"%s\"\n", p);
+	reiserfs_warning (s, "unknown mount option \"%s\"", p);
 	return -1;
     }
     
@@ -635,7 +635,7 @@ static int reiserfs_getopt ( struct supe
     switch (*p) {
     case '=':
 	if (!opt->arg_required) {
-	    printk ("reiserfs_getopt: the option \"%s\" does not require an argument\n",
+	    reiserfs_warning (s, "the option \"%s\" does not require an argument",
 		    opt->option_name);
 	    return -1;
 	}
@@ -643,12 +643,12 @@ static int reiserfs_getopt ( struct supe
 	
     case 0:
 	if (opt->arg_required) {
-	    printk ("reiserfs_getopt: the option \"%s\" requires an argument\n", opt->option_name);
+	    reiserfs_warning (s, "the option \"%s\" requires an argument", opt->option_name);
 	    return -1;
 	}
 	break;
     default:
-	printk ("reiserfs_getopt: head of option \"%s\" is only correct\n", opt->option_name);
+	reiserfs_warning (s, "head of option \"%s\" is only correct", opt->option_name);
 	return -1;
     }
 	
@@ -657,7 +657,7 @@ static int reiserfs_getopt ( struct supe
     
     if ( opt->arg_required && !strlen (p) ) {
 	/* this catches "option=," */
-	printk ("reiserfs_getopt: empty argument for \"%s\"\n", opt->option_name);
+	reiserfs_warning (s, "empty argument for \"%s\"", opt->option_name);
 	return -1;
     }
     
@@ -678,7 +678,7 @@ static int reiserfs_getopt ( struct supe
 	}
     }
     
-    printk ("reiserfs_getopt: bad value \"%s\" for option \"%s\"\n", p, opt->option_name);
+    reiserfs_warning (s, "bad value \"%s\" for option \"%s\"", p, opt->option_name);
     return -1;
 }
 
@@ -740,7 +740,7 @@ static int reiserfs_parse_options (struc
 	    *blocks = simple_strtoul (arg, &p, 0);
 	    if (*p != '\0') {
 		/* NNN does not look like a number */
-		printk ("reiserfs_parse_options: bad value %s\n", arg);
+		reiserfs_warning (s, "reiserfs_parse_options: bad value %s", arg);
 		return 0;
 	    }
 	}
@@ -750,7 +750,7 @@ static int reiserfs_parse_options (struc
 		int val = simple_strtoul (arg, &p, 0);
 		/* commit=NNN (time in seconds) */
 		if ( *p != '\0' || val < 0) {
-			printk ("reiserfs_parse_options: bad value %s\n", arg);
+			reiserfs_warning (s, "reiserfs_parse_options: bad value %s", arg);
 			return 0;
 		}
 		*commit_max_age = val;
@@ -761,7 +761,7 @@ static int reiserfs_parse_options (struc
 		int val = simple_strtoul (arg, &p, 0);
 
 		if ( *p != '\0') {
-		    printk ("reiserfs_parse_options: non-numeric value %s for nolargeio option\n", arg);
+		    reiserfs_warning (s, "reiserfs_parse_options: non-numeric value %s for nolargeio option", arg);
 		    return 0;
 		}
 		if ( val ) 
@@ -773,7 +773,7 @@ static int reiserfs_parse_options (struc
 	if (c == 'j') {
 	    if (arg && *arg && jdev_name) {
 		if ( *jdev_name ) { //Hm, already assigned?
-		    printk("reiserfs_parse_options: journal device was already  specified to be %s\n", *jdev_name);
+		    reiserfs_warning (s, "reiserfs_parse_options: journal device was already  specified to be %s", *jdev_name);
 		    return 0;
 		}
 		*jdev_name = arg;
@@ -796,17 +796,17 @@ static void handle_data_mode(struct supe
     if (mount_options & (1 << REISERFS_DATA_LOG)) {
         if (!reiserfs_data_log(s)) {
 	    switch_data_mode(s, REISERFS_DATA_LOG);
-	    printk("reiserfs: switching to journaled data mode\n");
+	    reiserfs_info (s, "switching to journaled data mode\n");
 	}
     } else if (mount_options & (1 << REISERFS_DATA_ORDERED)) {
         if (!reiserfs_data_ordered(s)) {
 	    switch_data_mode(s, REISERFS_DATA_ORDERED);
-	    printk("reiserfs: switching to ordered data mode\n");
+	    reiserfs_info (s, "switching to ordered data mode\n");
 	}
     } else if (mount_options & (1 << REISERFS_DATA_WRITEBACK)) {
         if (!reiserfs_data_writeback(s)) {
 	    switch_data_mode(s, REISERFS_DATA_WRITEBACK);
-	    printk("reiserfs: switching to writeback data mode\n");
+	    reiserfs_info (s, "switching to writeback data mode\n");
 	}
     }
 }
@@ -818,12 +818,12 @@ static void handle_attrs( struct super_b
 	if( reiserfs_attrs( s ) ) {
 		rs = SB_DISK_SUPER_BLOCK (s);
 		if( old_format_only(s) ) {
-			reiserfs_warning( "reiserfs: cannot support attributes on 3.5.x disk format\n" );
+			reiserfs_warning(s, "reiserfs: cannot support attributes on 3.5.x disk format" );
 			REISERFS_SB(s) -> s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
 			return;
 		}
 		if( !( le32_to_cpu( rs -> s_flags ) & reiserfs_attrs_cleared ) ) {
-				reiserfs_warning( "reiserfs: cannot support attributes until flag is set in super-block\n" );
+				reiserfs_warning(s, "reiserfs: cannot support attributes until flag is set in super-block" );
 				REISERFS_SB(s) -> s_mount_opt &= ~ ( 1 << REISERFS_ATTRS );
 		}
 	}
@@ -973,7 +973,7 @@ static void load_bitmap_info_data (struc
 
 #ifdef CONFIG_REISERFS_CHECK
 // This outputs a lot of unneded info on big FSes
-//    reiserfs_warning ("bitmap loaded from block %d: %d free blocks\n",
+//    reiserfs_warning ("bitmap loaded from block %d: %d free blocks",
 //		      bi->bh->b_blocknr, bi->free_count);
 #endif
 }
@@ -995,8 +995,8 @@ static int read_bitmaps (struct super_bl
     for (i = 0; i < SB_BMAP_NR(s); i++) {
 	wait_on_buffer(SB_AP_BITMAP (s)[i].bh);
 	if (!buffer_uptodate(SB_AP_BITMAP(s)[i].bh)) {
-	    reiserfs_warning("sh-2029: reiserfs read_bitmaps: "
-			 "bitmap block (#%lu) reading failed\n",
+	    reiserfs_warning(s,"sh-2029: reiserfs read_bitmaps: "
+			 "bitmap block (#%lu) reading failed",
 			 SB_AP_BITMAP(s)[i].bh->b_blocknr);
 	    for (i = 0; i < SB_BMAP_NR(s); i++)
 		brelse(SB_AP_BITMAP(s)[i].bh);
@@ -1046,7 +1046,7 @@ void check_bitmap (struct super_block * 
   }
 
   if (free != SB_FREE_BLOCKS (s))
-    reiserfs_warning ("vs-4000: check_bitmap: %d free blocks, must be %d\n",
+    reiserfs_warning (s,"vs-4000: check_bitmap: %d free blocks, must be %d",
 		      free, SB_FREE_BLOCKS (s));
 }
 
@@ -1059,8 +1059,8 @@ static int read_super_block (struct supe
 
     bh = sb_bread (s, offset / s->s_blocksize);
     if (!bh) {
-      printk ("sh-2006: read_super_block: "
-              "bread failed (dev %s, block %lu, size %lu)\n",
+      reiserfs_warning (s, "sh-2006: read_super_block: "
+              "bread failed (dev %s, block %lu, size %lu)",
               reiserfs_bdevname (s), offset / s->s_blocksize, s->s_blocksize);
       return 1;
     }
@@ -1080,7 +1080,7 @@ static int read_super_block (struct supe
     
     bh = sb_bread (s, offset / s->s_blocksize);
     if (!bh) {
-	printk("sh-2007: read_super_block: "
+	reiserfs_warning (s, "sh-2007: read_super_block: "
                 "bread failed (dev %s, block %lu, size %lu)\n",
                 reiserfs_bdevname (s), offset / s->s_blocksize, s->s_blocksize);
 	return 1;
@@ -1088,7 +1088,7 @@ static int read_super_block (struct supe
     
     rs = (struct reiserfs_super_block *)bh->b_data;
     if (sb_blocksize(rs) != s->s_blocksize) {
-	printk ("sh-2011: read_super_block: "
+	reiserfs_warning (s, "sh-2011: read_super_block: "
 		"can't find a reiserfs filesystem on (dev %s, block %Lu, size %lu)\n",
 		reiserfs_bdevname (s), (unsigned long long)bh->b_blocknr, s->s_blocksize);
 	brelse (bh);
@@ -1097,9 +1097,9 @@ static int read_super_block (struct supe
 
     if ( rs->s_v1.s_root_block == -1 ) {
        brelse(bh) ;
-       printk("dev %s: Unfinished reiserfsck --rebuild-tree run detected. Please run\n"
+       reiserfs_warning (s, "Unfinished reiserfsck --rebuild-tree run detected. Please run\n"
               "reiserfsck --rebuild-tree and wait for a completion. If that fails\n"
-              "get newer reiserfsprogs package\n", reiserfs_bdevname (s));
+              "get newer reiserfsprogs package");
        return 1;
     }
 
@@ -1110,21 +1110,22 @@ static int read_super_block (struct supe
 	/* magic is of non-standard journal filesystem, look at s_version to
 	   find which format is in use */
 	if (sb_version(rs) == REISERFS_VERSION_2)
-	  printk ("read_super_block: found reiserfs format \"3.6\" "
-		  "with non-standard journal\n");
+	  reiserfs_warning (s, "read_super_block: found reiserfs format \"3.6\""
+		  " with non-standard journal");
 	else if (sb_version(rs) == REISERFS_VERSION_1)
-	  printk ("read_super_block: found reiserfs format \"3.5\" "
-		  "with non-standard journal\n");
+	  reiserfs_warning (s, "read_super_block: found reiserfs format \"3.5\""
+		  " with non-standard journal");
 	else {
-	  printk ("sh-2012: read_super_block: found unknown format \"%u\" "
-	            "of reiserfs with non-standard magic\n", sb_version(rs));
+	  reiserfs_warning (s, "sh-2012: read_super_block: found unknown "
+			    "format \"%u\" of reiserfs with non-standard magic",
+			    sb_version(rs));
 	return 1;
 	}
     }
     else
       /* s_version of standard format may contain incorrect information,
 	 so we just look at the magic string */
-      printk ("found reiserfs format \"%s\" with standard journal\n",
+      reiserfs_info (s, "found reiserfs format \"%s\" with standard journal\n",
 	      is_reiserfs_3_5 (rs) ? "3.5" : "3.6");
 
     s->s_op = &reiserfs_sops;
@@ -1145,7 +1146,7 @@ static int reread_meta_blocks(struct sup
   ll_rw_block(READ, 1, &(SB_BUFFER_WITH_SB(s))) ;
   wait_on_buffer(SB_BUFFER_WITH_SB(s)) ;
   if (!buffer_uptodate(SB_BUFFER_WITH_SB(s))) {
-    printk("reread_meta_blocks, error reading the super\n") ;
+    reiserfs_warning (s, "reread_meta_blocks, error reading the super") ;
     return 1 ;
   }
 
@@ -1153,7 +1154,7 @@ static int reread_meta_blocks(struct sup
     ll_rw_block(READ, 1, &(SB_AP_BITMAP(s)[i].bh)) ;
     wait_on_buffer(SB_AP_BITMAP(s)[i].bh) ;
     if (!buffer_uptodate(SB_AP_BITMAP(s)[i].bh)) {
-      printk("reread_meta_blocks, error reading bitmap block number %d at %llu\n", 
+      reiserfs_warning (s, "reread_meta_blocks, error reading bitmap block number %d at %llu",
         i, (unsigned long long)SB_AP_BITMAP(s)[i].bh->b_blocknr) ;
       return 1 ;
     }
@@ -1200,8 +1201,8 @@ __u32 find_hash_out (struct super_block 
 	    if (reiserfs_rupasov_hash(s)) {
 		hash = YURA_HASH ;
 	    }
-	    reiserfs_warning("reiserfs: FS seems to be empty, autodetect "
-	                     "is using the default hash\n");
+	    reiserfs_warning(s,"FS seems to be empty, autodetect "
+	                     "is using the default hash");
 	    break;
 	}
 	r5hash=GET_HASH_VALUE (r5_hash (de.de_name, de.de_namelen));
@@ -1210,9 +1211,9 @@ __u32 find_hash_out (struct super_block 
 	if ( ( (teahash == r5hash) && (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num]))) == r5hash) ) ||
 	     ( (teahash == yurahash) && (yurahash == GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])))) ) ||
 	     ( (r5hash == yurahash) && (yurahash == GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])))) ) ) {
-	    reiserfs_warning("reiserfs: Unable to automatically detect hash"
-		"function for device %s\n"
-		"please mount with -o hash={tea,rupasov,r5}\n", reiserfs_bdevname (s));
+	    reiserfs_warning(s,"Unable to automatically detect hash function. "
+			     "Please mount with -o hash={tea,rupasov,r5}",
+			     reiserfs_bdevname (s));
 	    hash = UNSET_HASH;
 	    break;
 	}
@@ -1223,8 +1224,7 @@ __u32 find_hash_out (struct super_block 
 	else if (GET_HASH_VALUE( deh_offset(&(de.de_deh[de.de_entry_num])) ) == r5hash)
 	    hash = R5_HASH;
 	else {
-	    reiserfs_warning("reiserfs: Unrecognised hash function for "
-			     "device %s\n", reiserfs_bdevname (s));
+	    reiserfs_warning (s,"Unrecognised hash function");
 	    hash = UNSET_HASH;
 	}
     } while (0);
@@ -1252,16 +1252,16 @@ static int what_hash (struct super_block
 	** mount options 
 	*/
 	if (reiserfs_rupasov_hash(s) && code != YURA_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force rupasov hash\n", reiserfs_hashname(code)) ;
+	    reiserfs_warning (s, "Error, %s hash detected, "
+		   "unable to force rupasov hash", reiserfs_hashname(code)) ;
 	    code = UNSET_HASH ;
 	} else if (reiserfs_tea_hash(s) && code != TEA_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force tea hash\n", reiserfs_hashname(code)) ;
+	    reiserfs_warning (s, "Error, %s hash detected, "
+		   "unable to force tea hash", reiserfs_hashname(code)) ;
 	    code = UNSET_HASH ;
 	} else if (reiserfs_r5_hash(s) && code != R5_HASH) {
-	    printk("REISERFS: Error, %s hash detected, "
-		   "unable to force r5 hash\n", reiserfs_hashname(code)) ;
+	    reiserfs_warning (s, "Error, %s hash detected, "
+		   "unable to force r5 hash", reiserfs_hashname(code)) ;
 	    code = UNSET_HASH ;
 	} 
     } else { 
@@ -1291,13 +1291,13 @@ static hashf_t hash_function (struct sup
 {
     switch (what_hash (s)) {
     case TEA_HASH:
-	reiserfs_warning ("Using tea hash to sort names\n");
+	reiserfs_info (s, "Using tea hash to sort names\n");
 	return keyed_hash;
     case YURA_HASH:
-	reiserfs_warning ("Using rupasov hash to sort names\n");
+	reiserfs_info (s, "Using rupasov hash to sort names\n");
 	return yura_hash;
     case R5_HASH:
-	reiserfs_warning ("Using r5 hash to sort names\n");
+	reiserfs_info (s, "Using r5 hash to sort names\n");
 	return r5_hash;
     }
     return NULL;
@@ -1318,9 +1318,9 @@ int function2code (hashf_t func)
     return 0;
 }
 
-#define SPRINTK(silent, ...)			\
+#define SWARN(silent, s, ...)			\
 	if (!(silent))				\
-		printk(__VA_ARGS__)
+		reiserfs_warning (s, __VA_ARGS__)
 
 static int reiserfs_fill_super (struct super_block * s, void * data, int silent)
 {
@@ -1361,7 +1361,8 @@ static int reiserfs_fill_super (struct s
     }
 
     if (blocks) {
-	SPRINTK(silent, "jmacd-7: reiserfs_fill_super: resize option for remount only\n");
+	SWARN (silent, s, "jmacd-7: reiserfs_fill_super: resize option "
+	       "for remount only");
 	goto error;
     }	
 
@@ -1370,7 +1371,7 @@ static int reiserfs_fill_super (struct s
       old_format = 1;
     /* try new format (64-th 1k block), which can contain reiserfs super block */
     else if (read_super_block (s, REISERFS_DISK_OFFSET_IN_BYTES)) {
-      SPRINTK(silent, "sh-2021: reiserfs_fill_super: can not find reiserfs on %s\n", reiserfs_bdevname (s));
+      SWARN(silent, s, "sh-2021: reiserfs_fill_super: can not find reiserfs on %s", reiserfs_bdevname (s));
       goto error;
     }
 
@@ -1379,9 +1380,9 @@ static int reiserfs_fill_super (struct s
        smaller than the filesystem. If the check fails then abort and scream,
        because bad stuff will happen otherwise. */
     if ( s->s_bdev && s->s_bdev->bd_inode && i_size_read(s->s_bdev->bd_inode) < sb_block_count(rs)*sb_blocksize(rs)) {
-	SPRINTK(silent, "Filesystem on %s cannot be mounted because it is bigger than the device\n", reiserfs_bdevname(s));
-	SPRINTK(silent, "You may need to run fsck or increase size of your LVM partition\n");
-	SPRINTK(silent, "Or may be you forgot to reboot after fdisk when it told you to\n");
+	SWARN (silent, s, "Filesystem on %s cannot be mounted because it is bigger than the device", reiserfs_bdevname(s));
+	SWARN(silent, s, "You may need to run fsck or increase size of your LVM partition");
+	SWARN(silent, s, "Or may be you forgot to reboot after fdisk when it told you to");
 	goto error;
     }
 
@@ -1389,12 +1390,12 @@ static int reiserfs_fill_super (struct s
     sbi->s_mount_state = REISERFS_VALID_FS ;
 
     if (old_format ? read_old_bitmaps(s) : read_bitmaps(s)) {
-	SPRINTK(silent, "jmacd-8: reiserfs_fill_super: unable to read bitmap\n");
+	SWARN(silent, s, "jmacd-8: reiserfs_fill_super: unable to read bitmap");
 	goto error;
     }
 #ifdef CONFIG_REISERFS_CHECK
-    SPRINTK(silent, "reiserfs:warning: CONFIG_REISERFS_CHECK is set ON\n");
-    SPRINTK(silent, "reiserfs:warning: - it is slow mode for debugging.\n");
+    SWARN (silent, s, "CONFIG_REISERFS_CHECK is set ON");
+    SWARN (silent, s, "- it is slow mode for debugging.");
 #endif
 
     /* make data=ordered the default */
@@ -1405,16 +1406,16 @@ static int reiserfs_fill_super (struct s
     }
 
     if (reiserfs_data_log(s)) {
-        printk("reiserfs: using journaled data mode\n");
+        reiserfs_info (s, "using journaled data mode\n");
     } else if (reiserfs_data_ordered(s)) {
-        printk("reiserfs: using ordered data mode\n");
+        reiserfs_info (s, "using ordered data mode\n");
     } else {
-        printk("reiserfs: using writeback data mode\n");
+        reiserfs_info (s, "using writeback data mode\n");
     }
 
     // set_device_ro(s->s_dev, 1) ;
     if( journal_init(s, jdev_name, old_format, commit_max_age) ) {
-	SPRINTK(silent, "sh-2022: reiserfs_fill_super: unable to initialize journal space\n") ;
+	SWARN(silent, s, "sh-2022: reiserfs_fill_super: unable to initialize journal space") ;
 	goto error ;
     } else {
 	jinit_done = 1 ; /* once this is set, journal_release must be called
@@ -1422,7 +1423,7 @@ static int reiserfs_fill_super (struct s
 			 */
     }
     if (reread_meta_blocks(s)) {
-	SPRINTK(silent, "jmacd-9: reiserfs_fill_super: unable to reread meta blocks after journal init\n") ;
+	SWARN(silent, s, "jmacd-9: reiserfs_fill_super: unable to reread meta blocks after journal init") ;
 	goto error ;
     }
 
@@ -1430,14 +1431,14 @@ static int reiserfs_fill_super (struct s
 	goto error;
 
     if (bdev_read_only(s->s_bdev) && !(s->s_flags & MS_RDONLY)) {
-        SPRINTK(silent, "clm-7000: Detected readonly device, marking FS readonly\n") ;
+        SWARN(silent, s, "clm-7000: Detected readonly device, marking FS readonly") ;
 	s->s_flags |= MS_RDONLY ;
     }
     args.objectid = REISERFS_ROOT_OBJECTID ;
     args.dirid = REISERFS_ROOT_PARENT_OBJECTID ;
     root_inode = iget5_locked (s, REISERFS_ROOT_OBJECTID, reiserfs_find_actor, reiserfs_init_locked_inode, (void *)(&args));
     if (!root_inode) {
-	SPRINTK(silent, "jmacd-10: reiserfs_fill_super: get root inode failed\n");
+	SWARN(silent, s, "jmacd-10: reiserfs_fill_super: get root inode failed");
 	goto error;
     }
 
@@ -1479,7 +1480,7 @@ static int reiserfs_fill_super (struct s
 	  if (convert_reiserfs (s)) {
 	    /* and -o conv is given */
 	    if(!silent)
-	      reiserfs_warning ("reiserfs: converting 3.5 filesystem to the 3.6 format\n") ;
+	      reiserfs_info (s,"converting 3.5 filesystem to the 3.6 format") ;
 
 	    if (is_reiserfs_3_5 (rs))
 	      /* put magic string of 3.6 format. 2.2 will not be able to
@@ -1492,7 +1493,7 @@ static int reiserfs_fill_super (struct s
 	    set_bit(REISERFS_3_6, &(sbi->s_properties));
 	    clear_bit(REISERFS_3_5, &(sbi->s_properties));
 	  } else if (!silent){
-	    reiserfs_warning("reiserfs: using 3.5.x disk format\n") ;
+	    reiserfs_info (s, "using 3.5.x disk format\n") ;
 	  }
 	}
 
@@ -1509,7 +1510,7 @@ static int reiserfs_fill_super (struct s
 	finish_unfinished (s);
     } else {
 	if ( old_format_only(s) && !silent) {
-	    reiserfs_warning("reiserfs: using 3.5.x disk format\n") ;
+	    reiserfs_info (s, "using 3.5.x disk format\n") ;
 	}
 
 	if (reiserfs_xattr_init (s, s->s_flags)) {
Index: linux.mm/fs/reiserfs/tail_conversion.c
===================================================================
--- linux.mm.orig/fs/reiserfs/tail_conversion.c	2004-04-23 14:10:06.411055976 -0400
+++ linux.mm/fs/reiserfs/tail_conversion.c	2004-04-23 14:10:21.926190211 -0400
@@ -50,9 +50,9 @@ int direct2indirect (struct reiserfs_tra
 
     // FIXME: we could avoid this 
     if ( search_for_position_by_key (sb, &end_key, path) == POSITION_FOUND ) {
-	reiserfs_warning ("PAP-14030: direct2indirect: "
+	reiserfs_warning (sb, "PAP-14030: direct2indirect: "
 			"pasted or inserted byte exists in the tree %K. "
-			"Use fsck to repair.\n", &end_key);
+			"Use fsck to repair.", &end_key);
 	pathrelse(path);
 	return -EIO;
     }
Index: linux.mm/fs/reiserfs/xattr.c
===================================================================
--- linux.mm.orig/fs/reiserfs/xattr.c	2004-04-23 14:10:07.694901522 -0400
+++ linux.mm/fs/reiserfs/xattr.c	2004-04-23 14:10:21.928189971 -0400
@@ -326,7 +326,7 @@ research:
 	ih = de.de_ih;
 
 	if (!is_direntry_le_ih(ih)) {
-            reiserfs_warning("not direntry %h\n", ih);
+            reiserfs_warning(inode->i_sb, "not direntry %h", ih);
 	    break;
         }
 	copy_item_head(&tmp_ih, ih);
@@ -671,9 +671,8 @@ reiserfs_xattr_get (const struct inode *
             if (rxh->h_magic != cpu_to_le32 (REISERFS_XATTR_MAGIC)) {
                 unlock_page (page);
                 reiserfs_put_page (page);
-                reiserfs_warning ("reiserfs: Invalid magic for xattr (%s) "
-                                  "associated with %s %k\n", name,
-                                  reiserfs_bdevname (inode->i_sb),
+                reiserfs_warning (inode->i_sb, "Invalid magic for xattr (%s) "
+                                  "associated with %k", name,
                                   INODE_PKEY (inode));
                 err = -EIO;
                 goto out_dput;
@@ -690,9 +689,8 @@ reiserfs_xattr_get (const struct inode *
     err = isize - sizeof (struct reiserfs_xattr_header);
 
     if (xattr_hash (buffer, isize - sizeof (struct reiserfs_xattr_header)) != hash) {
-        reiserfs_warning ("reiserfs: Invalid hash for xattr (%s) associated "
-                          "with %s %k\n", name,
-                          reiserfs_bdevname (inode->i_sb), INODE_PKEY (inode));
+        reiserfs_warning (inode->i_sb, "Invalid hash for xattr (%s) associated "
+                          "with %k", name, INODE_PKEY (inode));
         err = -EIO;
     }
 
@@ -724,7 +722,8 @@ __reiserfs_xattr_del (struct dentry *xad
         goto out_file;
 
     if (!is_reiserfs_priv_object (dentry->d_inode)) {
-        reiserfs_warning ("OID %08x [%.*s/%.*s] doesn't have priv flag set [parent is %sset].\n",
+        reiserfs_warning (dir->i_sb, "OID %08x [%.*s/%.*s] doesn't have "
+                                     "priv flag set [parent is %sset].",
                         le32_to_cpu (INODE_PKEY (dentry->d_inode)->k_objectid),
                         xadir->d_name.len, xadir->d_name.name, namelen, name,
                         is_reiserfs_priv_object (xadir->d_inode) ? "" : "not ");
@@ -828,7 +827,8 @@ reiserfs_delete_xattrs (struct inode *in
         reiserfs_write_unlock_xattrs (inode->i_sb);
         dput (root);
     } else {
-        reiserfs_warning ("Couldn't remove all entries in directory\n");
+        reiserfs_warning (inode->i_sb,
+                          "Couldn't remove all entries in directory");
     }
     unlock_kernel ();
 
@@ -1265,8 +1265,8 @@ reiserfs_xattr_init (struct super_block 
   } else if (reiserfs_xattrs_optional (s)) {
     /* Old format filesystem, but optional xattrs have been enabled
      * at mount time. Error out. */
-    reiserfs_warning ("reiserfs: xattrs/ACLs not supported on pre v3.6 "
-                      "format filesystem. Failing mount.\n");
+    reiserfs_warning (s, "xattrs/ACLs not supported on pre v3.6 "
+                      "format filesystem. Failing mount.");
     err = -EOPNOTSUPP;
     goto error;
   } else {
@@ -1292,8 +1292,8 @@ reiserfs_xattr_init (struct super_block 
             }
 
             if (dentry && dentry->d_inode)
-                reiserfs_warning ("reiserfs: Created %s on %s - reserved for "
-                                  "xattr storage.\n", PRIVROOT_NAME,
+                reiserfs_warning (s, "Created %s on %s - reserved for "
+                                  "xattr storage.", PRIVROOT_NAME,
                                   reiserfs_bdevname (inode->i_sb));
         } else if (!dentry->d_inode) {
             dput (dentry);
@@ -1310,8 +1310,8 @@ reiserfs_xattr_init (struct super_block 
           /* If we're read-only it just means that the dir hasn't been
            * created. Not an error -- just no xattrs on the fs. We'll
            * check again if we go read-write */
-          reiserfs_warning ("reiserfs: xattrs/ACLs enabled and couldn't "
-                            "find/create .reiserfs_priv. Failing mount.\n");
+          reiserfs_warning (s, "xattrs/ACLs enabled and couldn't "
+                            "find/create .reiserfs_priv. Failing mount.");
           err = -EOPNOTSUPP;
       }
   }
Index: linux.mm/include/linux/reiserfs_fs.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs.h	2004-04-23 14:10:06.414055615 -0400
+++ linux.mm/include/linux/reiserfs_fs.h	2004-04-23 14:10:21.932189490 -0400
@@ -75,6 +75,7 @@
 */
 #define REISERFS_DEBUG_CODE 5 /* extra messages to help find/debug errors */ 
 
+void reiserfs_warning (struct super_block *s, const char * fmt, ...);
 /* assertions handling */
 
 /** always check a condition and panic if it's false. */
@@ -562,9 +563,6 @@ struct item_head
 #define V1_DIRENTRY_UNIQUENESS 500
 #define V1_ANY_UNIQUENESS 555 // FIXME: comment is required
 
-extern void reiserfs_warning (const char * fmt, ...);
-/* __attribute__( ( format ( printf, 1, 2 ) ) ); */
-
 //
 // here are conversion routines
 //
@@ -577,7 +575,8 @@ static inline int uniqueness2type (__u32
     case V1_DIRECT_UNIQUENESS: return TYPE_DIRECT;
     case V1_DIRENTRY_UNIQUENESS: return TYPE_DIRENTRY;
     default:
-	    reiserfs_warning( "vs-500: unknown uniqueness %d\n", uniqueness);
+	    reiserfs_warning (NULL, "vs-500: unknown uniqueness %d",
+			      uniqueness);
 	case V1_ANY_UNIQUENESS:
 	    return TYPE_ANY;
     }
@@ -592,7 +591,7 @@ static inline __u32 type2uniqueness (int
     case TYPE_DIRECT: return V1_DIRECT_UNIQUENESS;
     case TYPE_DIRENTRY: return V1_DIRENTRY_UNIQUENESS;
     default:
-	    reiserfs_warning( "vs-501: unknown type %d\n", type);
+	    reiserfs_warning (NULL, "vs-501: unknown type %d", type);
 	case TYPE_ANY:
 	    return V1_ANY_UNIQUENESS;
     }
@@ -1771,7 +1770,7 @@ void reiserfs_update_inode_transaction(s
 void reiserfs_wait_on_write_block(struct super_block *s) ;
 void reiserfs_block_writes(struct reiserfs_transaction_handle *th) ;
 void reiserfs_allow_writes(struct super_block *s) ;
-void reiserfs_check_lock_depth(char *caller) ;
+void reiserfs_check_lock_depth(struct super_block *s, char *caller) ;
 int reiserfs_prepare_for_journal(struct super_block *, struct buffer_head *bh, int wait) ;
 void reiserfs_restore_prepared_buffer(struct super_block *, struct buffer_head *bh) ;
 int journal_init(struct super_block *, const char * j_dev_name, int old_format, unsigned int) ;
@@ -2063,10 +2062,10 @@ void free_buffers_in_tb (struct tree_bal
 
 
 /* prints.c */
-void reiserfs_panic (struct super_block * s, const char * fmt, ...)
-__attribute__ ( ( noreturn ) );/* __attribute__( ( format ( printf, 2, 3 ) ) ) */
+void reiserfs_panic (struct super_block * s, const char * fmt, ...) __attribute__ ( ( noreturn ) );
+void reiserfs_info (struct super_block *s, const char * fmt, ...);
+void reiserfs_printk (const char * fmt, ...);
 void reiserfs_debug (struct super_block *s, int level, const char * fmt, ...);
-/* __attribute__( ( format ( printf, 3, 4 ) ) ); */
 void print_virtual_node (struct virtual_node * vn);
 void print_indirect_item (struct buffer_head * bh, int item_num);
 void store_print_tb (struct tree_balance * tb);
mason@suse.com
jeffm@suse.com

The current reiserfs allocator pretty much allocates things sequentially
from the start of the disk, it works very nicely for desktop loads but
once you've got more then one proc doing io data files can fragment badly.

One obvious solution is something like ext2's bitmap groups, which puts
file data into different areas of the disk based on which subdirectory
they are in.  The problem with bitmap groups is that if you've got a
group of subdirectories their contents will be spread out all over the
disk, leading to lots of seeks during a sequential read.

This allocator patch uses the packing locality to determine which bitmap
group to allocate from, but when you create a file it looks in the bitmaps
to see how 'full' that packing locality already is.  If it hasn't been
heavily used yet, the packing locality is inherited from the parent
directory putting files in new subdirs close to the parent subdir,
otherwise it is the inode number of the parent directory putting new
files far away from the parent subdir.

The end result is fewer bitmap groups for the same working set.  For
example, one test data set created by 20 procs running in parallel has
6822 subdirs.  And with vanilla reiserfs that would mean 6822
packing localities.  This patch turns that into 26 packing localities.

This makes sequential reads of big directory trees more efficient, but
it also makes the btree more efficient in general.  Things end up sorted
better because groups of subdirs end up with similar keys in the btree,
instead of being spread out all over.

The bitmap grouping code tries to use the start of each bitmap group
for metadata, and offsets the data slightly.  The data and metadata
are still close together, but not completely intermixed like they are
in the default allocator.  The end result is that leaf nodes tend to be
close to each other, making metadata readahead more effective.

The old block allocator had the ability to enforce a minimum
allocation size, but did not use it.  It now tries to do a pass looking
for larger allocation chunks before falling back to the old behaviour
of taking any blocks it can find.

The patch changes the defaults to:

mount -o alloc=skip_busy:dirid_groups:packing_groups

You can get back the old behaviour with mount -o alloc=skip_busy

mount -o alloc=dirid_groups will turn on the bitmap groups
mount -o alloc=packing_groups turns on the packing locality reduction code
mount -o alloc=skip_busy:dirid_groups turns on both dirid_groups and
skip_busy

Finally the patch adds a mount -o alloc=oid_groups, which puts files into
bitmap groups based on a hash of their objectid.  This would be used for
databases or other situations where you have a limited number of very
large files.

This command will tell you how many packing localities are actually in
use:

debugreiserfs -d /dev/xxx | grep '^|.*SD' | sed 's/^.....//' | awk '{print $1}' | sort -u | wc -l

===== fs/reiserfs/bitmap.c 1.19 vs edited =====
Index: linux.mm/fs/reiserfs/bitmap.c
===================================================================
--- linux.mm.orig/fs/reiserfs/bitmap.c	2004-04-16 14:25:16.000000000 -0400
+++ linux.mm/fs/reiserfs/bitmap.c	2004-04-16 14:25:16.000000000 -0400
@@ -30,6 +30,9 @@
 #define  _ALLOC_hashed_formatted_nodes 7
 #define  _ALLOC_old_way 8
 #define  _ALLOC_hundredth_slices 9
+#define  _ALLOC_dirid_groups 10
+#define  _ALLOC_oid_groups 11
+#define  _ALLOC_packing_groups 12
 
 #define  concentrating_formatted_nodes(s)	test_bit(_ALLOC_concentrating_formatted_nodes, &SB_ALLOC_OPTS(s))
 #define  displacing_large_files(s)		test_bit(_ALLOC_displacing_large_files, &SB_ALLOC_OPTS(s))
@@ -150,11 +153,6 @@ static int scan_bitmap_block (struct rei
        __wait_on_buffer (bi->bh);
     }
 
-    /* If we know that first zero bit is only one or first zero bit is
-       closer to the end of bitmap than our start pointer */
-    if (bi->first_zero_hint > *beg || bi->free_count == 1)
-	*beg = bi->first_zero_hint;
-
     while (1) {
 	cont:
 	if (bi->free_count < min)
@@ -204,21 +202,12 @@ static int scan_bitmap_block (struct rei
 		    while (--i >= *beg)
 			reiserfs_test_and_clear_le_bit (i, bi->bh->b_data);
 		    reiserfs_restore_prepared_buffer (s, bi->bh);
-		    *beg = max(org, (int)bi->first_zero_hint);
+		    *beg = org;
 		    /* ... and search again in current block from beginning */
 		    goto cont;	
 		}
 	    }
 	    bi->free_count -= (end - *beg);
-
-	    /* if search started from zero_hint bit, and zero hint have not
-                changed since, then we need to update first_zero_hint */
-	    if ( bi->first_zero_hint >= *beg)
-		/* no point in looking for free bit if there is not any */
-		bi->first_zero_hint = (bi->free_count > 0 ) ?
-			reiserfs_find_next_zero_le_bit
-			((unsigned long*)(bi->bh->b_data), s->s_blocksize << 3, end) : (s->s_blocksize << 3);
-
 	    journal_mark_dirty (th, s, bi->bh);
 
 	    /* free block count calculation */
@@ -231,7 +220,52 @@ static int scan_bitmap_block (struct rei
 	    *beg = next;
 	}
     }
-  }
+}
+
+static int bmap_hash_id(struct super_block *s, u32 id) {
+    char * hash_in = NULL;
+    unsigned long hash;
+    unsigned bm;
+
+    if (id <= 2) {
+	bm = 1;
+    } else {
+        hash_in = (char *)(&id);
+        hash = keyed_hash(hash_in, 4);
+	bm = hash % SB_BMAP_NR(s);
+	if (!bm)
+	    bm = 1;
+    }
+    return bm;
+}
+
+/*
+ * hashes the id and then returns > 0 if the block group for the
+ * corresponding hash is full
+ */
+static inline int block_group_used(struct super_block *s, u32 id) {
+    int bm;
+    bm = bmap_hash_id(s, id);
+    if (SB_AP_BITMAP(s)[bm].free_count > ((s->s_blocksize << 3) * 60 / 100) ) {
+        return 0;
+    }
+    return 1;
+}    
+
+/*
+ * the packing is returned in disk byte order
+ */
+u32 reiserfs_choose_packing(struct inode *dir) {
+    u32 packing;
+    if (TEST_OPTION(packing_groups, dir->i_sb)) {
+	if (block_group_used(dir->i_sb,le32_to_cpu(INODE_PKEY(dir)->k_dir_id)))
+            packing = INODE_PKEY(dir)->k_objectid;
+        else
+            packing = INODE_PKEY(dir)->k_dir_id;
+    } else
+        packing = INODE_PKEY(dir)->k_objectid;
+    return packing;
+}
   
 /* Tries to find contiguous zero bit window (given size) in given region of
  * bitmap and place new blocks there. Returns number of allocated blocks. */
@@ -255,8 +289,18 @@ static int scan_bitmap (struct reiserfs_
     get_bit_address (s, *start, &bm, &off);
     get_bit_address (s, finish, &end_bm, &end_off);
 
-    // With this option set first we try to find a bitmap that is at least 10%
-    // free, and if that fails, then we fall back to old whole bitmap scanning
+    /* When the bitmap is more than 10% free, anyone can allocate.
+     * When it's less than 10% free, only files that already use the
+     * bitmap are allowed. Once we pass 80% full, this restriction
+     * is lifted.
+     *
+     * We do this so that files that grow later still have space close to
+     * their original allocation. This improves locality, and presumably
+     * performance as a result.
+     *
+     * This is only an allocation policy and does not make up for getting a
+     * bad hint. Decent hinting must be implemented for this to work well.
+     */
     if ( TEST_OPTION(skip_busy, s) && SB_FREE_BLOCKS(s) > SB_BLOCK_COUNT(s)/20 ) {
 	for (;bm < end_bm; bm++, off = 0) {
 	    if ( ( off && (!unfm || (file_block != 0))) || SB_AP_BITMAP(s)[bm].free_count > (s->s_blocksize << 3) / 10 )
@@ -314,9 +358,6 @@ static void _reiserfs_free_block (struct
 			  "free_block (%s:%lu)[dev:blocknr]: bit already cleared",
 			  reiserfs_bdevname (s), block);
     }
-    if (offset < apbi[nr].first_zero_hint) {
-      apbi[nr].first_zero_hint = offset;
-    }
     apbi[nr].free_count ++;
     journal_mark_dirty (th, s, apbi[nr].bh);
 
@@ -396,6 +437,15 @@ void reiserfs_discard_all_prealloc (stru
 	__discard_prealloc(th, ei);
     }
 }
+
+void reiserfs_init_alloc_options (struct super_block *s)
+{
+    set_bit (_ALLOC_skip_busy, &SB_ALLOC_OPTS(s));
+    set_bit (_ALLOC_dirid_groups, &SB_ALLOC_OPTS(s));
+    set_bit (_ALLOC_packing_groups, &SB_ALLOC_OPTS(s));
+    reiserfs_warning (s, "allocator defaults = [%08x]\n", SB_ALLOC_OPTS(s));
+}
+
 /* block allocator related options are parsed here */
 int reiserfs_parse_alloc_options(struct super_block * s, char * options)
 {
@@ -439,6 +489,18 @@ int reiserfs_parse_alloc_options(struct 
 	    continue;
 	}
 
+        if (!strcmp(this_char, "dirid_groups")) {
+	    SET_OPTION(dirid_groups);
+	    continue;
+        }
+        if (!strcmp(this_char, "oid_groups")) {
+	    SET_OPTION(oid_groups);
+	    continue;
+        }
+        if (!strcmp(this_char, "packing_groups")) {
+	    SET_OPTION(packing_groups);
+	    continue;
+        }
 	if (!strcmp(this_char, "hashed_formatted_nodes")) {
 	    SET_OPTION(hashed_formatted_nodes);
 	    continue;
@@ -481,6 +543,7 @@ int reiserfs_parse_alloc_options(struct 
 	return 1;
       }
   
+    reiserfs_warning (s, "allocator options = [%08x]\n", SB_ALLOC_OPTS(s));
     return 0;
 }
   
@@ -503,17 +566,76 @@ static inline void new_hashed_relocation
     hint->search_start = hint->beg + keyed_hash(hash_in, 4) % (hint->end - hint->beg);
 }
 
-static inline void get_left_neighbor(reiserfs_blocknr_hint_t *hint)
+/*
+ * Relocation based on dirid, hashing them into a given bitmap block
+ * files. Formatted nodes are unaffected, a seperate policy covers them
+ */
+static void
+dirid_groups (reiserfs_blocknr_hint_t *hint)
+{
+    unsigned long hash;
+    __u32 dirid = 0;
+    int bm = 0;
+    struct super_block *sb = hint->th->t_super;
+    if (hint->inode)
+	dirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);
+    else if (hint->formatted_node)
+        dirid = hint->key.k_dir_id;
+
+    if (dirid) {
+	bm = bmap_hash_id(sb, dirid);
+	hash = bm * (sb->s_blocksize << 3);
+	/* give a portion of the block group to metadata */
+	if (hint->inode)
+	    hash += sb->s_blocksize/2;
+	hint->search_start = hash;
+    }
+}
+
+/*
+ * Relocation based on oid, hashing them into a given bitmap block
+ * files. Formatted nodes are unaffected, a seperate policy covers them
+ */
+static void
+oid_groups (reiserfs_blocknr_hint_t *hint)
+{
+    if (hint->inode) {
+	unsigned long hash;
+	__u32 oid;
+	__u32 dirid;
+	int bm;
+
+	dirid = le32_to_cpu(INODE_PKEY(hint->inode)->k_dir_id);
+
+	/* keep the root dir and it's first set of subdirs close to
+	 * the start of the disk
+	 */
+	if (dirid <= 2)
+	    hash = (hint->inode->i_sb->s_blocksize << 3);
+	else {
+	    oid = le32_to_cpu(INODE_PKEY(hint->inode)->k_objectid);
+	    bm = bmap_hash_id(hint->inode->i_sb, oid);
+	    hash = bm * (hint->inode->i_sb->s_blocksize << 3);
+	}
+	hint->search_start = hash;
+    }
+}
+
+/* returns 1 if it finds an indirect item and gets valid hint info
+ * from it, otherwise 0
+ */
+static int get_left_neighbor(reiserfs_blocknr_hint_t *hint)
 {
     struct path * path;
     struct buffer_head * bh;
     struct item_head * ih;
     int pos_in_item;
     __u32 * item;
+    int ret = 0;
 
     if (!hint->path)		/* reiserfs code can call this function w/o pointer to path
 				 * structure supplied; then we rely on supplied search_start */
-	return;
+	return 0;
 
     path = hint->path;
     bh = get_last_bh(path);
@@ -534,15 +656,15 @@ static inline void get_left_neighbor(rei
 	    int t=get_block_num(item,pos_in_item);
 	    if (t) {
 		hint->search_start = t;
+		ret = 1;
 		break;
 	    }
 	    pos_in_item --;
 	}
-    } else {
-      }
+    }
 
     /* does result value fit into specified region? */
-    return;
+    return ret;
 }
 
 /* should be, if formatted node, then try to put on first part of the device
@@ -639,12 +761,13 @@ static inline void hundredth_slices (rei
     }
 }
   
-static inline void determine_search_start(reiserfs_blocknr_hint_t *hint,
+static void determine_search_start(reiserfs_blocknr_hint_t *hint,
 					  int amount_needed)
 {
     struct super_block *s = hint->th->t_super;
     hint->beg = 0;
     hint->end = SB_BLOCK_COUNT(s) - 1;
+    int unfm_hint;
 
     /* This is former border algorithm. Now with tunable border offset */
     if (concentrating_formatted_nodes(s))
@@ -673,19 +796,14 @@ static inline void determine_search_star
 	return;
     }
 
-    /* attempt to copy a feature from old block allocator code */
-    if (TEST_OPTION(old_hashed_relocation, s) && !hint->formatted_node) {
-	old_hashed_relocation(hint);
-    }
-
     /* if none of our special cases is relevant, use the left neighbor in the
        tree order of the new node we are allocating for */
     if (hint->formatted_node && TEST_OPTION(hashed_formatted_nodes,s)) {
-	hash_formatted_node(hint);
+        hash_formatted_node(hint);
 	return;
-    } 
+    }
 
-    get_left_neighbor(hint);
+    unfm_hint = get_left_neighbor(hint);
 
     /* Mimic old block allocator behaviour, that is if VFS allowed for preallocation,
        new blocks are displaced based on directory ID. Also, if suggested search_start
@@ -710,10 +828,36 @@ static inline void determine_search_star
 	return;
     }
 
-    if (TEST_OPTION(old_hashed_relocation, s))
+    /* old_hashed_relocation only works on unformatted */
+    if (!unfm_hint && !hint->formatted_node &&
+        TEST_OPTION(old_hashed_relocation, s))
+    {
 	old_hashed_relocation(hint);
-    if (TEST_OPTION(new_hashed_relocation, s))
+    }
+    /* new_hashed_relocation works with both formatted/unformatted nodes */
+    if ((!unfm_hint || hint->formatted_node) &&
+        TEST_OPTION(new_hashed_relocation, s))
+    {
 	new_hashed_relocation(hint);
+    }
+    /* dirid grouping works only on unformatted nodes */
+    if (!unfm_hint && !hint->formatted_node && TEST_OPTION(dirid_groups,s))
+    {
+        dirid_groups(hint);
+    }
+
+#ifdef DISPLACE_NEW_PACKING_LOCALITIES
+    if (hint->formatted_node && TEST_OPTION(dirid_groups,s))
+    {
+        dirid_groups(hint);
+    }
+#endif
+
+    /* oid grouping works only on unformatted nodes */
+    if (!unfm_hint && !hint->formatted_node && TEST_OPTION(oid_groups,s))
+    {
+        oid_groups(hint);
+    }
     return;
 }
 
@@ -738,13 +882,14 @@ static int determine_prealloc_size(reise
 static inline int allocate_without_wrapping_disk (reiserfs_blocknr_hint_t * hint,
 					 b_blocknr_t * new_blocknrs,
 					 b_blocknr_t start, b_blocknr_t finish,
+					 int min,
 					 int amount_needed, int prealloc_size)
 {
     int rest = amount_needed;
     int nr_allocated;
   
     while (rest > 0 && start <= finish) {
-	nr_allocated = scan_bitmap (hint->th, &start, finish, 1,
+	nr_allocated = scan_bitmap (hint->th, &start, finish, min,
 				    rest + prealloc_size, !hint->formatted_node,
 				    hint->block);
 
@@ -777,8 +922,9 @@ static inline int blocknrs_and_prealloc_
     struct super_block *s = hint->th->t_super;
     b_blocknr_t start = hint->search_start;
     b_blocknr_t finish = SB_BLOCK_COUNT(s) - 1;
-    int second_pass = 0;
+    int passno = 0;
     int nr_allocated = 0;
+    int bigalloc = 0;
 
     determine_prealloc_size(hint);
     if (!hint->formatted_node) {
@@ -797,32 +943,64 @@ static inline int blocknrs_and_prealloc_
 	    if (quota_ret)
 		hint->preallocate=hint->prealloc_size=0;
 	}
-    }
-
-    while((nr_allocated
-	  += allocate_without_wrapping_disk(hint, new_blocknrs + nr_allocated, start, finish,
-					  amount_needed - nr_allocated, hint->prealloc_size))
-	  < amount_needed) {
-
-	/* not all blocks were successfully allocated yet*/
-	if (second_pass) {	/* it was a second pass; we must free all blocks */
+	/* for unformatted nodes, force large allocations */
+	bigalloc = amount_needed + hint->prealloc_size;
+	/* try to make things even */
+	if (bigalloc & 1 && hint->prealloc_size)
+	    bigalloc--;
+    }
+
+    do {
+	/* in bigalloc mode, nr_allocated should stay zero until
+	 * the entire allocation is filled
+	 */
+	if (unlikely(bigalloc && nr_allocated)) {
+	    reiserfs_warning(s, "bigalloc is %d, nr_allocated %d\n", 
+	    bigalloc, nr_allocated);
+	    /* reset things to a sane value */
+	    bigalloc = amount_needed - nr_allocated;
+	}
+	/*
+	 * try pass 0 and pass 1 looking for a nice big
+	 * contiguous allocation.  Then reset and look
+	 * for anything you can find.
+	 */
+	if (passno == 2 && bigalloc) {
+	    passno = 0;
+	    bigalloc = 0;
+	}
+	switch (passno++) {
+        case 0: /* Search from hint->search_start to end of disk */
+	    start = hint->search_start;
+	    finish = SB_BLOCK_COUNT(s) - 1;
+	    break;
+        case 1: /* Search from hint->beg to hint->search_start */
+	    start = hint->beg;
+	    finish = hint->search_start;
+	    break;
+	case 2: /* Last chance: Search from 0 to hint->beg */
+	    start = 0;
+	    finish = hint->beg;
+	    break;
+	default: /* We've tried searching everywhere, not enough space */
+	    /* Free the blocks */
 	    if (!hint->formatted_node) {
 #ifdef REISERQUOTA_DEBUG
 		reiserfs_debug (s, "reiserquota: freeing (nospace) %d blocks id=%u", amount_needed + hint->prealloc_size - nr_allocated, hint->inode->i_uid);
 #endif
 		DQUOT_FREE_BLOCK_NODIRTY(hint->inode, amount_needed + hint->prealloc_size - nr_allocated);     /* Free not allocated blocks */
 	    }
-	    while (nr_allocated --)
+  	    while (nr_allocated --)
 		reiserfs_free_block(hint->th, hint->inode, new_blocknrs[nr_allocated], !hint->formatted_node);
 
 	    return NO_DISK_SPACE;
-	} else {		/* refine search parameters for next pass */
-	    second_pass = 1;
-	    finish = start;
-	    start = 0;
-	    continue;
 	}
-    }
+    } while ((nr_allocated += allocate_without_wrapping_disk (hint,
+			    new_blocknrs + nr_allocated, start, finish,
+			    bigalloc ? bigalloc : 1,
+			    amount_needed - nr_allocated,
+			    hint->prealloc_size))
+			< amount_needed);
     if ( !hint->formatted_node &&
          amount_needed + hint->prealloc_size >
 	 nr_allocated + REISERFS_I(hint->inode)->i_prealloc_count) {
Index: linux.mm/fs/reiserfs/file.c
===================================================================
--- linux.mm.orig/fs/reiserfs/file.c	2004-04-16 14:25:16.000000000 -0400
+++ linux.mm/fs/reiserfs/file.c	2004-04-16 14:25:16.000000000 -0400
@@ -175,12 +175,13 @@ int reiserfs_allocate_blocks_for_region(
     hint.formatted_node = 0; // We are allocating blocks for unformatted node.
 
     /* only preallocate if this is a small write */
-    if (blocks_to_allocate <
-        REISERFS_SB(inode->i_sb)->s_alloc_options.preallocsize)
+    if (REISERFS_I(inode)->i_prealloc_count ||
+       (!(write_bytes & (inode->i_sb->s_blocksize -1)) &&
+        blocks_to_allocate <
+        REISERFS_SB(inode->i_sb)->s_alloc_options.preallocsize)) 
         hint.preallocate = 1;
     else
         hint.preallocate = 0;
-
     /* Call block allocator to allocate blocks */
     res = reiserfs_allocate_blocknrs(&hint, allocated_blocks, blocks_to_allocate, blocks_to_allocate);
     if ( res != CARRY_ON ) {
@@ -466,6 +467,12 @@ retry:
     // the inode.
     //
     pathrelse(&path);
+    /*
+     * cleanup prellocation from previous writes
+     * if this is a partial block write
+     */
+    if (write_bytes & (inode->i_sb->s_blocksize -1))
+        reiserfs_discard_prealloc(th, inode);
     reiserfs_write_unlock(inode->i_sb);
 
     // go through all the pages/buffers and map the buffers to newly allocated
@@ -1246,6 +1253,7 @@ ssize_t reiserfs_file_write( struct file
 	journal_end(&th, th.t_super, th.t_blocks_allocated);
         reiserfs_write_unlock(inode->i_sb);
     }
+
     if ((file->f_flags & O_SYNC) || IS_SYNC(inode))
 	res = generic_osync_inode(inode, file->f_mapping, OSYNC_METADATA|OSYNC_DATA);
 
Index: linux.mm/fs/reiserfs/inode.c
===================================================================
--- linux.mm.orig/fs/reiserfs/inode.c	2004-04-16 14:25:16.000000000 -0400
+++ linux.mm/fs/reiserfs/inode.c	2004-04-16 14:25:16.000000000 -0400
@@ -1660,7 +1660,7 @@ int reiserfs_new_inode (struct reiserfs_
     sb = dir->i_sb;
 
     /* item head of new item */
-    ih.ih_key.k_dir_id = INODE_PKEY (dir)->k_objectid;
+    ih.ih_key.k_dir_id = reiserfs_choose_packing(dir);
     ih.ih_key.k_objectid = cpu_to_le32 (reiserfs_get_unused_objectid (th));
     if (!ih.ih_key.k_objectid) {
 	err = -ENOMEM;
@@ -1729,7 +1729,6 @@ int reiserfs_new_inode (struct reiserfs_
 	err = -EEXIST;
 	goto out_bad_inode;
     }
-
     if (old_format_only (sb)) {
 	if (inode->i_uid & ~0xffff || inode->i_gid & ~0xffff) {
 	    pathrelse (&path_to_key);
Index: linux.mm/fs/reiserfs/super.c
===================================================================
--- linux.mm.orig/fs/reiserfs/super.c	2004-04-16 14:25:16.000000000 -0400
+++ linux.mm/fs/reiserfs/super.c	2004-04-16 14:25:16.000000000 -0400
@@ -492,7 +492,6 @@ static void reiserfs_clear_inode (struct
     REISERFS_I(inode)->i_acl_default = NULL;
 }
 
-
 struct super_operations reiserfs_sops = 
 {
   .alloc_inode = reiserfs_alloc_inode,
@@ -651,7 +650,7 @@ static int reiserfs_getopt ( struct supe
 	reiserfs_warning (s, "head of option \"%s\" is only correct", opt->option_name);
 	return -1;
     }
-	
+
     /* move to the argument, or to next option if argument is not required */
     p ++;
     
@@ -1346,15 +1345,17 @@ static int reiserfs_fill_super (struct s
     memset (sbi, 0, sizeof (struct reiserfs_sb_info));
     /* Set default values for options: non-aggressive tails */
     REISERFS_SB(s)->s_mount_opt = ( 1 << REISERFS_SMALLTAIL );
-    /* default block allocator option: skip_busy */
-    REISERFS_SB(s)->s_alloc_options.bits = ( 1 << 5);
-    /* If file grew past 4 blocks, start preallocation blocks for it. */
-    REISERFS_SB(s)->s_alloc_options.preallocmin = 4;
+    /* no preallocation minimum, be smart in
+       reiserfs_file_write instead */
+    REISERFS_SB(s)->s_alloc_options.preallocmin = 0;
     /* Preallocate by 16 blocks (17-1) at once */
     REISERFS_SB(s)->s_alloc_options.preallocsize = 17;
     /* Initialize the rwsem for xattr dir */
     init_rwsem(&REISERFS_SB(s)->xattr_dir_sem);
 
+    /* setup default block allocator options */
+    reiserfs_init_alloc_options(s);
+
     jdev_name = NULL;
     if (reiserfs_parse_options (s, (char *) data, &(sbi->s_mount_opt), &blocks, &jdev_name, &commit_max_age) == 0) {
 	goto error;
Index: linux.mm/include/linux/reiserfs_fs.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs.h	2004-04-16 14:25:16.000000000 -0400
+++ linux.mm/include/linux/reiserfs_fs.h	2004-04-19 10:34:53.355562888 -0400
@@ -1247,7 +1247,7 @@ struct  path {
 #define pos_in_item(path) ((path)->pos_in_item)
 
 #define INITIALIZE_PATH(var) \
-struct path var = {ILLEGAL_PATH_ELEMENT_OFFSET, }
+struct path var = {.path_length = ILLEGAL_PATH_ELEMENT_OFFSET,}
 
 /* Get path element by path and path position. */
 #define PATH_OFFSET_PELEMENT(p_s_path,n_offset)  ((p_s_path)->path_elements +(n_offset))
@@ -2149,6 +2149,15 @@ struct buffer_head * get_FEB (struct tre
 typedef struct __reiserfs_blocknr_hint reiserfs_blocknr_hint_t;
 
 int reiserfs_parse_alloc_options (struct super_block *, char *);
+void reiserfs_init_alloc_options (struct super_block *s);
+
+/* 
+ * given a directory, this will tell you what packing locality
+ * to use for a new object underneat it.  The locality is returned
+ * in disk byte order (le).
+ */
+u32 reiserfs_choose_packing(struct inode *dir);
+
 int is_reusable (struct super_block * s, b_blocknr_t block, int bit_value);
 void reiserfs_free_block (struct reiserfs_transaction_handle *th, struct inode *, b_blocknr_t, int for_unformatted);
 int reiserfs_allocate_blocknrs(reiserfs_blocknr_hint_t *, b_blocknr_t * , int, int);
mason@suse.com

Walking the btree can trigger a number of single block synchronous reads.
This patch does btree readahead during operations that are likely to be long
and sequential.  So far, that only includes directory reads and truncates,
but it can make both much faster.

Index: linux.mm/fs/reiserfs/dir.c
===================================================================
--- linux.mm.orig/fs/reiserfs/dir.c	2004-04-14 19:34:37.000000000 -0400
+++ linux.mm/fs/reiserfs/dir.c	2004-04-14 19:41:56.000000000 -0400
@@ -64,6 +64,7 @@ static int reiserfs_readdir (struct file
 
     /*  reiserfs_warning (inode->i_sb, "reiserfs_readdir 1: f_pos = %Ld", filp->f_pos);*/
 
+    path_to_entry.reada = PATH_READA;
     while (1) {
     research:
 	/* search the directory item, containing entry with specified key */
Index: linux.mm/fs/reiserfs/stree.c
===================================================================
--- linux.mm.orig/fs/reiserfs/stree.c	2004-04-14 19:34:37.000000000 -0400
+++ linux.mm/fs/reiserfs/stree.c	2004-04-14 19:47:09.000000000 -0400
@@ -596,26 +596,29 @@ static int is_tree_node (struct buffer_h
 
 
 
-#ifdef SEARCH_BY_KEY_READA
+#define SEARCH_BY_KEY_READA 16
 
 /* The function is NOT SCHEDULE-SAFE! */
-static void search_by_key_reada (struct super_block * s, int blocknr)
+static void search_by_key_reada (struct super_block * s,
+                                 struct buffer_head **bh,
+				 unsigned long *b, int num)
 {
-    struct buffer_head * bh;
+    int i,j;
   
-    if (blocknr == 0)
-	return;
-
-    bh = sb_getblk (s, blocknr);
-  
-    if (!buffer_uptodate (bh)) {
-	ll_rw_block (READA, 1, &bh);
+    for (i = 0 ; i < num ; i++) {
+	bh[i] = sb_getblk (s, b[i]);
+    }
+    for (j = 0 ; j < i ; j++) {
+	/*
+	 * note, this needs attention if we are getting rid of the BKL
+	 * you have to make sure the prepared bit isn't set on this buffer
+	 */
+	if (!buffer_uptodate(bh[j]))
+	    ll_rw_block(READA, 1, bh + j);
+    	brelse(bh[j]);
     }
-    bh->b_count --;
 }
 
-#endif
-
 /**************************************************************************
  * Algorithm   SearchByKey                                                *
  *             look for item in the Disk S+Tree by its key                *
@@ -657,6 +660,9 @@ int search_by_key (struct super_block * 
     int				n_node_level, n_retval;
     int 			right_neighbor_of_leaf_node;
     int				fs_gen;
+    struct buffer_head *reada_bh[SEARCH_BY_KEY_READA];
+    unsigned long      reada_blocks[SEARCH_BY_KEY_READA];
+    int reada_count = 0;
 
 #ifdef CONFIG_REISERFS_CHECK
     int n_repeat_counter = 0;
@@ -691,19 +697,25 @@ int search_by_key (struct super_block * 
 	p_s_last_element = PATH_OFFSET_PELEMENT(p_s_search_path, ++p_s_search_path->path_length);
 	fs_gen = get_generation (p_s_sb);
 
-#ifdef SEARCH_BY_KEY_READA
-	/* schedule read of right neighbor */
-	search_by_key_reada (p_s_sb, right_neighbor_of_leaf_node);
-#endif
-
 	/* Read the next tree node, and set the last element in the path to
            have a pointer to it. */
-	if ( ! (p_s_bh = p_s_last_element->pe_buffer =
-		sb_bread(p_s_sb, n_block_number)) ) {
+	if ((p_s_bh = p_s_last_element->pe_buffer =
+	     sb_getblk(p_s_sb, n_block_number)) ) {
+	    if (!buffer_uptodate(p_s_bh) && reada_count > 1) {
+		search_by_key_reada (p_s_sb, reada_bh,
+		                     reada_blocks, reada_count);
+	    }
+	    ll_rw_block(READ, 1, &p_s_bh);
+	    wait_on_buffer(p_s_bh);
+	    if (!buffer_uptodate(p_s_bh))
+	        goto io_error;
+	} else {
+io_error:
 	    p_s_search_path->path_length --;
 	    pathrelse(p_s_search_path);
 	    return IO_ERROR;
 	}
+	reada_count = 0;
 	if (expected_level == -1)
 		expected_level = SB_TREE_HEIGHT (p_s_sb);
 	expected_level --;
@@ -783,12 +795,37 @@ int search_by_key (struct super_block * 
 	   an internal node.  Now we calculate child block number by
 	   position in the node. */
 	n_block_number = B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position);
-
-#ifdef SEARCH_BY_KEY_READA
-	/* if we are going to read leaf node, then calculate its right neighbor if possible */
-	if (n_node_level == DISK_LEAF_NODE_LEVEL + 1 && p_s_last_element->pe_position < B_NR_ITEMS (p_s_bh))
-	    right_neighbor_of_leaf_node = B_N_CHILD_NUM(p_s_bh, p_s_last_element->pe_position + 1);
-#endif
+
+	/* if we are going to read leaf nodes, try for read ahead as well */
+	if ((p_s_search_path->reada & PATH_READA) &&
+	    n_node_level == DISK_LEAF_NODE_LEVEL + 1)
+	{
+	    int pos = p_s_last_element->pe_position;
+	    int limit = B_NR_ITEMS(p_s_bh);
+	    struct key *le_key;
+
+	    if (p_s_search_path->reada & PATH_READA_BACK)
+		limit = 0;
+	    while(reada_count < SEARCH_BY_KEY_READA) {
+		if (pos == limit)
+		    break;
+	        reada_blocks[reada_count++] = B_N_CHILD_NUM(p_s_bh, pos);
+		if (p_s_search_path->reada & PATH_READA_BACK)
+		    pos--;
+		else
+		    pos++;
+
+		/*
+		 * check to make sure we're in the same object
+		 */
+		le_key = B_N_PDELIM_KEY(p_s_bh, pos);
+		if (le32_to_cpu(le_key->k_objectid) !=
+		    p_s_key->on_disk_key.k_objectid)
+		{
+		    break;
+		}
+	    }
+        }
     }
 }
 
@@ -1778,6 +1815,12 @@ void reiserfs_do_truncate (struct reiser
            space, this file would have this file size */
 	n_file_size = offset + bytes - 1;
     }
+    /*
+     * are we doing a full truncate or delete, if so
+     * kick in the reada code
+     */
+    if (n_new_file_size == 0)
+        s_search_path.reada = PATH_READA | PATH_READA_BACK;
 
     if ( n_file_size == 0 || n_file_size < n_new_file_size ) {
 	goto update_and_out ;
Index: linux.mm/include/linux/reiserfs_fs.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs.h	2004-04-14 19:34:37.000000000 -0400
+++ linux.mm/include/linux/reiserfs_fs.h	2004-04-14 19:41:56.000000000 -0400
@@ -1238,8 +1238,12 @@ excessive effort to avoid disturbing the
 gods only know how we are going to SMP the code that uses them.
 znodes are the way! */
 
+#define PATH_READA	0x1 /* do read ahead */
+#define PATH_READA_BACK 0x2 /* read backwards */
+
 struct  path {
   int                   path_length;                      	/* Length of the array above.   */
+  int			reada;
   struct  path_element  path_elements[EXTENDED_MAX_HEIGHT];	/* Array of the path elements.  */
   int			pos_in_item;
 };
@@ -1247,7 +1251,7 @@ struct  path {
 #define pos_in_item(path) ((path)->pos_in_item)
 
 #define INITIALIZE_PATH(var) \
-struct path var = {.path_length = ILLEGAL_PATH_ELEMENT_OFFSET,}
+struct path var = {.path_length = ILLEGAL_PATH_ELEMENT_OFFSET, .reada = 0,}
 
 /* Get path element by path and path position. */
 #define PATH_OFFSET_PELEMENT(p_s_path,n_offset)  ((p_s_path)->path_elements +(n_offset))
mason@suse.com

Add data=journal support for reiserfs

Index: linux.mm/fs/reiserfs/file.c
===================================================================
--- linux.mm.orig/fs/reiserfs/file.c	2004-04-23 15:20:05.420051144 -0400
+++ linux.mm/fs/reiserfs/file.c	2004-04-23 15:20:05.589025456 -0400
@@ -591,9 +591,18 @@ int reiserfs_commit_page(struct inode *i
     struct buffer_head *bh, *head;
     unsigned long i_size_index = inode->i_size >> PAGE_CACHE_SHIFT;
     int new;
+    int logit = reiserfs_file_data_log(inode);
+    struct super_block *s = inode->i_sb;
+    int bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;
+    struct reiserfs_transaction_handle th;
+    th.t_trans_id = 0;
 
     blocksize = 1 << inode->i_blkbits;
 
+    if (logit) {
+	reiserfs_write_lock(s);
+	journal_begin(&th, s, bh_per_page + 1);
+    }
     for(bh = head = page_buffers(page), block_start = 0;
         bh != head || !block_start;
 	block_start=block_end, bh = bh->b_this_page)
@@ -607,7 +616,10 @@ int reiserfs_commit_page(struct inode *i
 		    partial = 1;
 	} else {
 	    set_buffer_uptodate(bh);
-	    if (!buffer_dirty(bh)) {
+	    if (logit) {
+		reiserfs_prepare_for_journal(s, bh, 1);
+		journal_mark_dirty(&th, s, bh);
+	    } else if (!buffer_dirty(bh)) {
 		mark_buffer_dirty(bh);
 		/* do data=ordered on any page past the end
 		 * of file and any buffer marked BH_New.
@@ -619,7 +631,10 @@ int reiserfs_commit_page(struct inode *i
 	    }
 	}
     }
-
+    if (logit) {
+	journal_end(&th, s, bh_per_page + 1);
+	reiserfs_write_unlock(s);
+    }
     /*
      * If this is a partial write which happened to make all buffers
      * uptodate then we can optimize away a bogus readpage() for
Index: linux.mm/fs/reiserfs/inode.c
===================================================================
--- linux.mm.orig/fs/reiserfs/inode.c	2004-04-23 15:20:05.425050384 -0400
+++ linux.mm/fs/reiserfs/inode.c	2004-04-23 15:20:05.595024544 -0400
@@ -2147,6 +2147,11 @@ static int reiserfs_write_full_page(stru
     struct buffer_head *head, *bh;
     int partial = 0 ;
     int nr = 0;
+    int checked = PageChecked(page);
+    struct reiserfs_transaction_handle th;
+    struct super_block *s = inode->i_sb;
+    int bh_per_page = PAGE_CACHE_SIZE / s->s_blocksize;
+    th.t_trans_id = 0;
 
     /* The page dirty bit is cleared before writepage is called, which
      * means we have to tell create_empty_buffers to make dirty buffers
@@ -2154,7 +2159,7 @@ static int reiserfs_write_full_page(stru
      * in the BH_Uptodate is just a sanity check.
      */
     if (!page_has_buffers(page)) {
-	create_empty_buffers(page, inode->i_sb->s_blocksize, 
+	create_empty_buffers(page, s->s_blocksize,
 	                    (1 << BH_Dirty) | (1 << BH_Uptodate));
     }
     head = page_buffers(page) ;
@@ -2178,10 +2183,10 @@ static int reiserfs_write_full_page(stru
 	kunmap_atomic(kaddr, KM_USER0) ;
     }
     bh = head ;
-    block = page->index << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits) ;
+    block = page->index << (PAGE_CACHE_SHIFT - s->s_blocksize_bits) ;
     /* first map all the buffers, logging any direct items we find */
     do {
-	if (buffer_dirty(bh) && (!buffer_mapped(bh) ||
+	if ((checked || buffer_dirty(bh)) && (!buffer_mapped(bh) ||
 	   (buffer_mapped(bh) && bh->b_blocknr == 0))) {
 	    /* not mapped yet, or it points to a direct item, search
 	     * the btree for the mapping info, and log any direct
@@ -2195,6 +2200,17 @@ static int reiserfs_write_full_page(stru
 	block++;
     } while(bh != head) ;
 
+    /*
+     * we start the transaction after map_block_for_writepage,
+     * because it can create holes in the file (an unbounded operation).
+     * starting it here, we can make a reliable estimate for how many
+     * blocks we're going to log
+     */
+    if (checked) {
+	ClearPageChecked(page);
+	reiserfs_write_lock(s);
+	journal_begin(&th, s, bh_per_page + 1);
+    }
     /* now go through and lock any dirty buffers on the page */
     do {
 	get_bh(bh);
@@ -2203,6 +2219,11 @@ static int reiserfs_write_full_page(stru
 	if (buffer_mapped(bh) && bh->b_blocknr == 0)
 	    continue;
 
+	if (checked) {
+	    reiserfs_prepare_for_journal(s, bh, 1);
+	    journal_mark_dirty(&th, s, bh);
+	    continue;
+	}
 	/* from this point on, we know the buffer is mapped to a
 	 * real block and not a direct item
 	 */
@@ -2221,6 +2242,10 @@ static int reiserfs_write_full_page(stru
 	}
     } while((bh = bh->b_this_page) != head);
 
+    if (checked) {
+	journal_end(&th, s, bh_per_page + 1);
+	reiserfs_write_unlock(s);
+    }
     BUG_ON(PageWriteback(page));
     set_page_writeback(page);
     unlock_page(page);
@@ -2480,17 +2505,15 @@ static int invalidatepage_can_drop(struc
     /* the page is locked, and the only places that log a data buffer
      * also lock the page.
      */
-#if 0
     if (reiserfs_file_data_log(inode)) {
-	/* very conservative, leave the buffer pinned if anyone might need it.
-	** this should be changed to drop the buffer if it is only in the
-	** current transaction
-	*/
+	/*
+	 * very conservative, leave the buffer pinned if
+	 * anyone might need it. 
+	 */
         if (buffer_journaled(bh) || buffer_journal_dirty(bh)) {
 	    ret = 0 ;
 	}
     } else
-#endif
     if (buffer_dirty(bh) || buffer_locked(bh)) {
 	struct reiserfs_journal_list *jl;
 	struct reiserfs_jh *jh = bh->b_private;
@@ -2528,6 +2551,10 @@ static int reiserfs_invalidatepage(struc
     int ret = 1;
 
     BUG_ON(!PageLocked(page));
+
+    if (offset == 0)
+	ClearPageChecked(page);
+
     if (!page_has_buffers(page))
 	goto out;
 
@@ -2561,6 +2588,15 @@ out:
     return ret;
 }
 
+static int reiserfs_set_page_dirty(struct page *page) {
+    struct inode *inode = page->mapping->host;
+    if (reiserfs_file_data_log(inode)) {
+	SetPageChecked(page);
+	return __set_page_dirty_nobuffers(page);
+    }
+    return __set_page_dirty_buffers(page);
+}
+
 /*
  * Returns 1 if the page's buffers were dropped.  The page is locked.
  *
@@ -2578,6 +2614,7 @@ static int reiserfs_releasepage(struct p
     struct buffer_head *bh ;
     int ret = 1 ;
 
+    WARN_ON(PageChecked(page));
     spin_lock(&j->j_dirty_buffers_lock) ;
     head = page_buffers(page) ;
     bh = head ;
@@ -2683,5 +2720,6 @@ struct address_space_operations reiserfs
     .prepare_write = reiserfs_prepare_write,
     .commit_write = reiserfs_commit_write,
     .bmap = reiserfs_aop_bmap,
-    .direct_IO = reiserfs_direct_IO
+    .direct_IO = reiserfs_direct_IO,
+    .set_page_dirty = reiserfs_set_page_dirty,
 } ;
Index: linux.mm/fs/reiserfs/journal.c
===================================================================
--- linux.mm.orig/fs/reiserfs/journal.c	2004-04-23 15:20:05.210083064 -0400
+++ linux.mm/fs/reiserfs/journal.c	2004-04-23 15:20:16.861311808 -0400
@@ -1024,7 +1024,6 @@ static int flush_commit_list(struct supe
   up(&jl->j_commit_lock);
 put_jl:
   put_journal_list(s, jl);
-
   return 0 ;
 }
 
@@ -1544,14 +1543,18 @@ static int flush_used_journal_lists(stru
     unsigned long cur_len;
     int ret;
     int i;
+    int limit = 256;
     struct reiserfs_journal_list *tjl;
     struct reiserfs_journal_list *flush_jl;
     unsigned long trans_id;
 
     flush_jl = tjl = jl;
 
-    /* flush for 256 transactions or 256 blocks, whichever comes first */
-    for(i = 0 ; i < 256 && len < 256 ; i++) {
+    /* in data logging mode, try harder to flush a lot of blocks */
+    if (reiserfs_data_log(s))
+	limit = 1024;
+    /* flush for 256 transactions or limit blocks, whichever comes first */
+    for(i = 0 ; i < 256 && len < limit ; i++) {
 	if (atomic_read(&tjl->j_commit_left) ||
 	    tjl->j_trans_id < jl->j_trans_id) {
 	    break;
@@ -3480,10 +3483,15 @@ static int do_journal_end(struct reiserf
     /* copy all the real blocks into log area.  dirty log blocks */
     if (test_bit(BH_JDirty, &cn->bh->b_state)) {
       struct buffer_head *tmp_bh ;
+      char *addr;
+      struct page *page;
       tmp_bh =  journal_getblk(p_s_sb, SB_ONDISK_JOURNAL_1st_BLOCK(p_s_sb) + 
 		       ((cur_write_start + jindex) % SB_ONDISK_JOURNAL_SIZE(p_s_sb))) ;
       set_buffer_uptodate(tmp_bh);
-      memcpy(tmp_bh->b_data, cn->bh->b_data, cn->bh->b_size) ;  
+      page = cn->bh->b_page;
+      addr = kmap(page);
+      memcpy(tmp_bh->b_data, addr, cn->bh->b_size) ;  
+      kunmap(page);
       mark_buffer_dirty(tmp_bh);
       jindex++ ;
       set_bit(BH_JDirty_wait, &(cn->bh->b_state)) ; 
Index: linux.mm/fs/reiserfs/stree.c
===================================================================
--- linux.mm.orig/fs/reiserfs/stree.c	2004-04-23 15:20:05.537033360 -0400
+++ linux.mm/fs/reiserfs/stree.c	2004-04-23 15:20:05.607022720 -0400
@@ -1495,6 +1495,41 @@ void reiserfs_delete_object (struct reis
     reiserfs_delete_solid_item (th, inode, INODE_PKEY (inode));
 }
 
+static void
+unmap_buffers(struct page *page, loff_t pos) {
+    struct buffer_head *bh ;
+    struct buffer_head *head ;
+    struct buffer_head *next ;
+    unsigned long tail_index ;
+    unsigned long cur_index ;
+
+    if (page) {
+	if (page_has_buffers(page)) {
+	    tail_index = pos & (PAGE_CACHE_SIZE - 1) ;
+	    cur_index = 0 ;
+	    head = page_buffers(page) ;
+	    bh = head ;
+	    do {
+		next = bh->b_this_page ;
+
+		/* we want to unmap the buffers that contain the tail, and
+		** all the buffers after it (since the tail must be at the
+		** end of the file).  We don't want to unmap file data
+		** before the tail, since it might be dirty and waiting to
+		** reach disk
+		*/
+		cur_index += bh->b_size ;
+		if (cur_index > tail_index) {
+		    reiserfs_unmap_buffer(bh) ;
+		}
+		bh = next ;
+	    } while (bh != head) ;
+	    if ( PAGE_SIZE == bh->b_size ) {
+		clear_page_dirty(page);
+	    }
+	}
+    }
+}
 
 static int maybe_indirect_to_direct (struct reiserfs_transaction_handle *th, 
 			      struct inode * p_s_inode,
@@ -1587,7 +1622,7 @@ int reiserfs_cut_from_item (struct reise
     char                c_mode;            /* Mode of the balance. */
     int retval2 = -1;
     int quota_cut_bytes;
-    
+    loff_t tail_pos = 0;
     
     init_tb_struct(th, &s_cut_balance, p_s_inode->i_sb, p_s_path, n_cut_size);
 
@@ -1627,6 +1662,7 @@ int reiserfs_cut_from_item (struct reise
       	    set_cpu_key_k_type (p_s_item_key, TYPE_INDIRECT);
 	    p_s_item_key->key_length = 4;
 	    n_new_file_size -= (n_new_file_size & (p_s_sb->s_blocksize - 1));
+	    tail_pos = n_new_file_size;
 	    set_cpu_key_k_offset (p_s_item_key, n_new_file_size + 1);
 	    if ( search_for_position_by_key(p_s_sb, p_s_item_key, p_s_path) == POSITION_NOT_FOUND ){
 		print_block (PATH_PLAST_BUFFER (p_s_path), 3, PATH_LAST_POSITION (p_s_path) - 1, PATH_LAST_POSITION (p_s_path) + 1);
@@ -1724,9 +1760,10 @@ int reiserfs_cut_from_item (struct reise
     if ( n_is_inode_locked ) {
 	/* we've done an indirect->direct conversion.  when the data block
 	** was freed, it was removed from the list of blocks that must
-	** be flushed before the transaction commits, so we don't need to
-	** deal with it here.
+	** be flushed before the transaction commits, make sure to
+	** unmap and invalidate it
 	*/
+	unmap_buffers(page, tail_pos);
 	REISERFS_I(p_s_inode)->i_flags &= ~i_pack_on_close_mask ;
     }
 #ifdef REISERQUOTA_DEBUG
Index: linux.mm/fs/reiserfs/tail_conversion.c
===================================================================
--- linux.mm.orig/fs/reiserfs/tail_conversion.c	2004-04-23 15:20:05.258075768 -0400
+++ linux.mm/fs/reiserfs/tail_conversion.c	2004-04-23 15:20:05.610022264 -0400
@@ -162,42 +162,6 @@ void reiserfs_unmap_buffer(struct buffer
     unlock_buffer(bh) ;
 }
 
-static void
-unmap_buffers(struct page *page, loff_t pos) {
-  struct buffer_head *bh ;
-  struct buffer_head *head ;
-  struct buffer_head *next ;
-  unsigned long tail_index ;
-  unsigned long cur_index ;
-
-  if (page) {
-    if (page_has_buffers(page)) {
-      tail_index = pos & (PAGE_CACHE_SIZE - 1) ;
-      cur_index = 0 ;
-      head = page_buffers(page) ;
-      bh = head ;
-      do {
-	next = bh->b_this_page ;
-
-        /* we want to unmap the buffers that contain the tail, and
-        ** all the buffers after it (since the tail must be at the
-        ** end of the file).  We don't want to unmap file data 
-        ** before the tail, since it might be dirty and waiting to 
-        ** reach disk
-        */
-        cur_index += bh->b_size ;
-        if (cur_index > tail_index) {
-          reiserfs_unmap_buffer(bh) ;
-        }
-	bh = next ;
-      } while (bh != head) ;
-      if ( PAGE_SIZE == bh->b_size ) {
-	clear_page_dirty(page);
-      }
-    }
-  } 
-}
-
 /* this first locks inode (neither reads nor sync are permitted),
    reads tail through page cache, insert direct item. When direct item
    inserted successfully inode is left locked. Return value is always
@@ -287,11 +251,6 @@ int indirect2direct (struct reiserfs_tra
     }
     kunmap(page) ;
 
-    /* this will invalidate all the buffers in the page after
-    ** pos1
-    */
-    unmap_buffers(page, pos1) ;
-
     /* make sure to get the i_blocks changes from reiserfs_insert_item */
     reiserfs_update_sd(th, p_s_inode);
 
Index: linux.mm/include/linux/reiserfs_fs.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs.h	2004-04-23 15:20:05.544032296 -0400
+++ linux.mm/include/linux/reiserfs_fs.h	2004-04-23 15:20:05.616021352 -0400
@@ -1752,6 +1752,14 @@ int reiserfs_add_tail_list(struct inode 
 int reiserfs_add_ordered_list(struct inode *inode, struct buffer_head *bh);
 int journal_mark_dirty(struct reiserfs_transaction_handle *, struct super_block *, struct buffer_head *bh) ;
 
+static inline int
+reiserfs_file_data_log(struct inode *inode) {
+    if (reiserfs_data_log(inode->i_sb) ||
+       (REISERFS_I(inode)->i_flags & i_data_log))
+        return 1 ;
+    return 0 ;
+}
+
 static inline int reiserfs_transaction_running(struct super_block *s) {
     struct reiserfs_transaction_handle *th = current->journal_info ;
     if (th && th->t_super == s)
Index: linux.mm/include/linux/reiserfs_fs_i.h
===================================================================
--- linux.mm.orig/include/linux/reiserfs_fs_i.h	2004-04-23 15:20:04.493192048 -0400
+++ linux.mm/include/linux/reiserfs_fs_i.h	2004-04-23 15:20:05.617021200 -0400
@@ -25,6 +25,7 @@ typedef enum {
     i_link_saved_truncate_mask =  0x0020,
     i_priv_object              =  0x0080,
     i_has_xattr_dir            =  0x0100,
+    i_data_log	               =  0x0200,
 } reiserfs_inode_flags;
 
 
mason@suse.com

Document some of the reiserfs mount options

Index: linux.mm/Documentation/filesystems/reiserfsv3.txt
===================================================================
--- linux.mm.orig/Documentation/filesystems/reiserfsv3.txt	2003-09-23 13:59:22.000000000 -0400
+++ linux.mm/Documentation/filesystems/reiserfsv3.txt	2004-04-06 20:29:33.066719303 -0400
@@ -0,0 +1,55 @@
+ReiserFSv3
+
+Please visit http://www.namesys.com for reiserfs history and design
+information.
+
+Options
+=======
+
+When mounting a reiserfsv3 filesystem, the following options are
+accepted.  Defaults are marked with (*)
+
+tails=on        Pack partial blocks into the btree when the file is four
+                filesystem block or smaller, saving disk space
+
+tail=off        No tail packing
+
+tails=small*    Same as tails=on, but only do it for files using less
+                then one filesystem block.  Somewhat faster in many workloads
+
+notail          Same as tails=off
+
+conv            Convert a 3.5.x filesystem to a 3.6.x filesystem.  This is
+		a one way conversion, afterward you will not be able to
+		mount your filesystem under 2.2.x kernels any longer
+
+resize=NNN      Online resize the filesystem to NNN blocks.  This can
+                only be used to expand the filesystem
+
+jdev=device     Specify external journal location
+
+nolargeio       Don't export a large default IO size to userspace in the
+                stat call
+commit=NN       Set the commit interval to NN seconds (default=30)
+
+data=ordered*   Never commit new metadata until all data blocks it
+                references have been written.  This prevents stale disk
+                contents from being exposed after a crash
+
+data=writeback  No data ordering at all
+
+usrquota        Turn on user quotas
+
+grpquota        Turn on group quotas
+
+user_xattr      Enable extended attribute support
+
+nouser_xattr*   Disable extended attribute support
+
+acl             Enable access control lists
+
+noacl*          Disable access control lists
+
+Access control lists and extended attributes tools and documentation can
+be found at http://acl.bestbits.at
+
