diff -burpN -X ../KDIFX linux-vanilla/Documentation/nmi_watchdog.txt linux-2.6.3-amd64/Documentation/nmi_watchdog.txt
--- linux-vanilla/Documentation/nmi_watchdog.txt	2003-08-23 01:53:06.000000000 +0200
+++ linux-2.6.3-amd64/Documentation/nmi_watchdog.txt	2004-02-19 23:28:10.000000000 +0100
@@ -22,9 +22,10 @@ CONFIG_X86_UP_IOAPIC is for uniprocessor
 kernel debugging options, such as Kernel Stack Meter or Kernel Tracer,
 may implicitly disable the NMI watchdog.]
 
-For x86-64, the needed APIC is always compiled in, and the NMI watchdog is
-always enabled with I/O-APIC mode (nmi_watchdog=1). Currently, local APIC
-mode (nmi_watchdog=2) does not work on x86-64.
+For x86-64, the needed APIC is always compiled in, and the NMI
+watchdog is always enabled with Local APIC mode (nmi_watchdog=2).
+Currently, I/O APIC mode (nmi_watchdog=1) does not work on x86_64/AMD8111
+(How about other chipsets?)
 
 Using local APIC (nmi_watchdog=2) needs the first performance register, so
 you can't use it for other purposes (such as high precision performance
diff -burpN -X ../KDIFX linux-vanilla/Documentation/x86_64/boot-options.txt linux-2.6.3-amd64/Documentation/x86_64/boot-options.txt
--- linux-vanilla/Documentation/x86_64/boot-options.txt	2003-10-25 22:57:46.000000000 +0200
+++ linux-2.6.3-amd64/Documentation/x86_64/boot-options.txt	2004-02-19 23:28:11.000000000 +0100
@@ -5,19 +5,12 @@ only the AMD64 specific ones are listed 
 
 Machine check
 
-(see the Opteron BIOS&Kernel manual for more details on the banks etc.)
-
    mce=off disable machine check
-   mce=nok8 disable k8 specific features
-   mce=disable<NUMBER> disable bank NUMBER
-   mce=enable<NUMBER> enable bank number
-   mce=device	Enable more machine check options in Northbridge.
-		Can be useful for device driver debugging.
-   mce=NUMBER mcheck timer interval number seconds.
-   Can be also comma separated in a single mce=
 
    nomce (for compatibility with i386): same as mce=off
 
+   Everything else is in sysfs now.
+
 APICs
 
    apic		 Use IO-APIC. Default
diff -burpN -X ../KDIFX linux-vanilla/arch/i386/kernel/microcode.c linux-2.6.3-amd64/arch/i386/kernel/microcode.c
--- linux-vanilla/arch/i386/kernel/microcode.c	2003-10-25 22:58:00.000000000 +0200
+++ linux-2.6.3-amd64/arch/i386/kernel/microcode.c	2004-02-19 23:28:09.000000000 +0100
@@ -371,7 +371,8 @@ static void do_update_one (void * unused
 	spin_lock_irqsave(&microcode_update_lock, flags);          
 
 	/* write microcode via MSR 0x79 */
-	wrmsr(MSR_IA32_UCODE_WRITE, (unsigned int)(uci->mc->bits), 0);
+	wrmsr(MSR_IA32_UCODE_WRITE, (u32)(unsigned long)(uci->mc->bits), 
+	      (u32)(((unsigned long)uci->mc->bits) >> 32));
 	wrmsr(MSR_IA32_UCODE_REV, 0, 0);
 
 	__asm__ __volatile__ ("cpuid" : : : "ax", "bx", "cx", "dx");
diff -burpN -X ../KDIFX linux-vanilla/arch/i386/oprofile/nmi_int.c linux-2.6.3-amd64/arch/i386/oprofile/nmi_int.c
--- linux-vanilla/arch/i386/oprofile/nmi_int.c	2003-09-28 10:54:48.000000000 +0200
+++ linux-2.6.3-amd64/arch/i386/oprofile/nmi_int.c	2004-02-19 23:28:09.000000000 +0100
@@ -295,8 +295,6 @@ struct oprofile_operations nmi_ops = {
 };
  
 
-#if !defined(CONFIG_X86_64)
-
 static int __init p4_init(void)
 {
 	__u8 cpu_model = current_cpu_data.x86_model;
@@ -347,9 +345,6 @@ static int __init ppro_init(void)
 	return 1;
 }
 
-#endif /* !CONFIG_X86_64 */
- 
-
 /* in order to get driverfs right */
 static int using_nmi;
 
@@ -381,7 +376,6 @@ int __init nmi_init(struct oprofile_oper
 			}
 			break;
  
-#if !defined(CONFIG_X86_64)
 		case X86_VENDOR_INTEL:
 			switch (family) {
 				/* Pentium IV */
@@ -400,7 +394,6 @@ int __init nmi_init(struct oprofile_oper
 					return -ENODEV;
 			}
 			break;
-#endif /* !CONFIG_X86_64 */
 
 		default:
 			return -ENODEV;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/Kconfig linux-2.6.3-amd64/arch/x86_64/Kconfig
--- linux-vanilla/arch/x86_64/Kconfig	2004-02-05 08:10:24.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/Kconfig	2004-02-19 23:28:10.000000000 +0100
@@ -14,7 +14,8 @@ config X86_64
 	default y
 	help
 	  Port to the x86-64 architecture. x86-64 is a 64-bit extension to the
-	  classical 32-bit x86 architecture. For details see http://www.x86-64.org
+	  classical 32-bit x86 architecture. For details see
+	  <http://www.x86-64.org/>.
 
 config 64BIT
 	def_bool y
@@ -89,6 +90,9 @@ config MK8
 	help
 	  Optimize for AMD Opteron/Athlon64/Hammer/K8 CPUs. 
 
+config MPSC
+       bool "Prescott/Nocona" 
+       
 config GENERIC_CPU
 	bool "Generic-x86-64"
 	help
@@ -101,11 +105,13 @@ endchoice
 #
 config X86_L1_CACHE_BYTES
 	int
-	default "64"
+	default "128" if GENERIC_CPU || MPSC
+	default "64" if MK8
 
 config X86_L1_CACHE_SHIFT
 	int
-	default "6"
+	default "7" if GENERIC_CPU || MPSC
+	default "6" if MK8
 
 config X86_TSC
 	bool
@@ -115,6 +121,23 @@ config X86_GOOD_APIC
 	bool
 	default y
 
+config MICROCODE
+	tristate "/dev/cpu/microcode - Intel CPU microcode support"
+	---help---
+	  If you say Y here the 'File systems' section, you will be
+	  able to update the microcode on Intel processors. You will 
+	  obviously need the actual microcode binary data itself which is 
+	  not shipped with the Linux kernel.
+
+	  For latest news and information on obtaining all the required
+	  ingredients for this driver, check:
+	  <http://www.urbanmyth.org/microcode/>.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called microcode.
+	  If you use modprobe or kmod you may also want to add the line
+	  'alias char-major-10-184 microcode' to your /etc/modules.conf file.
+
 config X86_MSR
 	tristate "/dev/cpu/*/msr - Model-specific register support"
 	help
@@ -132,6 +155,11 @@ config X86_CPUID
 	  with major 203 and minors 0 to 31 for /dev/cpu/0/cpuid to
 	  /dev/cpu/31/cpuid.
 
+config X86_HT
+	bool
+	depends on SMP
+	default y
+       
 config MATH_EMULATION
 	bool
 
@@ -256,9 +284,13 @@ config GART_IOMMU
 	  Normally the kernel will take the right choice by itself.
 	  If unsure say Y 
 
+config SWIOTLB
+       select GART_IOMMU
+       bool "Software IOTLB support"
+
 config DUMMY_IOMMU
 	bool
-	depends on !GART_IOMMU
+	depends on !GART_IOMMU && !SWIOTLB
 	default y
 	help
 	  Don't use IOMMU code. This will cause problems when you have more than 4GB 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/Makefile linux-2.6.3-amd64/arch/x86_64/Makefile
--- linux-vanilla/arch/x86_64/Makefile	2004-02-05 08:10:24.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/Makefile	2004-02-19 23:28:10.000000000 +0100
@@ -37,7 +37,9 @@ LDFLAGS		:= -m elf_x86_64
 OBJCOPYFLAGS	:= -O binary -R .note -R .comment -S
 LDFLAGS_vmlinux := -e stext
 
-check_gcc = $(shell if $(CC) $(1) -S -o /dev/null -xc /dev/null > /dev/null 2>&1 ; then echo "$(1)"; else echo "$(2)"; fi)
+cflags-$(CONFIG_MK8) += $(call check_gcc,-march=k8,)
+cflags-$(CONFIG_MPSC) += $(call check_gcc,-march=pentium4,)
+CFLAGS += $(cflags-y)
 
 CFLAGS += -mno-red-zone
 CFLAGS += -mcmodel=kernel
@@ -45,14 +47,16 @@ CFLAGS += -pipe
 # this makes reading assembly source easier, but produces worse code
 # actually it makes the kernel smaller too.
 CFLAGS += -fno-reorder-blocks	
-# should lower this a lot and see how much .text is saves	
-# CFLAGS += -finline-limit=2000
 CFLAGS += -Wno-sign-compare
-# don't enable this when you use kgdb:
 ifneq ($(CONFIG_DEBUG_INFO),y)
 CFLAGS += -fno-asynchronous-unwind-tables
+# -fweb shrinks the kernel a bit, but the difference is very small
+# it also messes up debugging, so don't use it for now.
+#CFLAGS += $(call check_gcc,-fweb,)
 endif
-#CFLAGS += $(call check_gcc,-funit-at-a-time,)
+# -funit-at-a-time shrinks the kernel .text considerably
+# unfortunately it makes reading oopses harder.
+CFLAGS += $(call check_gcc,-funit-at-a-time,)
 
 head-y := arch/x86_64/kernel/head.o arch/x86_64/kernel/head64.o arch/x86_64/kernel/init_task.o
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/boot/setup.S linux-2.6.3-amd64/arch/x86_64/boot/setup.S
--- linux-vanilla/arch/x86_64/boot/setup.S	2003-08-23 02:01:38.000000000 +0200
+++ linux-2.6.3-amd64/arch/x86_64/boot/setup.S	2004-02-19 23:28:10.000000000 +0100
@@ -292,8 +292,9 @@ loader_ok:
 	/* minimum CPUID flags for x86-64 */
 	/* see http://www.x86-64.org/lists/discuss/msg02971.html */		
 #define SSE_MASK ((1<<25)|(1<<26))
-#define REQUIRED_MASK1 ((1<<0)|(1<<3)|(1<<4)|(1<<5)|(1<<6)|(1<<8)|(1<<11)| \
-					   (1<<13)|(1<<15)|(1<<24)|(1<<29))
+#define REQUIRED_MASK1 ((1<<0)|(1<<3)|(1<<4)|(1<<5)|(1<<6)|(1<<8)|\
+					   (1<<13)|(1<<15)|(1<<24))
+#define REQUIRED_MASK2 (1<<29)
 
 	pushfl				/* standard way to check for cpuid */
 	popl	%eax
@@ -305,10 +306,10 @@ loader_ok:
 	popl	%eax
 	cmpl	%eax,%ebx
 	jz	no_longmode		/* cpu has no cpuid */
-	movl	$0x80000000,%eax
+	movl	$0x0,%eax
 	cpuid
-	cmpl	$0x80000001,%eax
-	jb	no_longmode		/* no extended cpuid */
+	cmpl	$0x1,%eax
+	jb	no_longmode		/* no cpuid 1 */
 	xor	%di,%di
 	cmpl	$0x68747541,%ebx	/* AuthenticAMD */
 	jnz	noamd
@@ -318,11 +319,20 @@ loader_ok:
 	jnz	noamd
 	mov	$1,%di			/* cpu is from AMD */
 noamd:		
-	movl	$0x80000001,%eax		
+	movl    $0x1,%eax
 	cpuid
 	andl	$REQUIRED_MASK1,%edx
 	xorl	$REQUIRED_MASK1,%edx
 	jnz	no_longmode
+	movl    $0x80000000,%eax
+	cpuid
+	cmpl    $0x80000001,%eax
+	jb      no_longmode             /* no extended cpuid */
+	movl    $0x80000001,%eax
+	cpuid
+	andl    $REQUIRED_MASK2,%edx
+	xorl    $REQUIRED_MASK2,%edx
+	jnz     no_longmode
 sse_test:		
 	movl	$1,%eax
 	cpuid
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/defconfig linux-2.6.3-amd64/arch/x86_64/defconfig
--- linux-vanilla/arch/x86_64/defconfig	2004-02-19 23:57:10.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/defconfig	2004-02-19 23:28:10.000000000 +0100
@@ -51,14 +51,17 @@ CONFIG_OBSOLETE_MODPARM=y
 #
 # Processor type and features
 #
-CONFIG_MK8=y
-# CONFIG_GENERIC_CPU is not set
-CONFIG_X86_L1_CACHE_BYTES=64
-CONFIG_X86_L1_CACHE_SHIFT=6
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_L1_CACHE_BYTES=128
+CONFIG_X86_L1_CACHE_SHIFT=7
 CONFIG_X86_TSC=y
 CONFIG_X86_GOOD_APIC=y
+# CONFIG_MICROCODE is not set
 CONFIG_X86_MSR=y
 CONFIG_X86_CPUID=y
+CONFIG_X86_HT=y
 CONFIG_X86_IO_APIC=y
 CONFIG_X86_LOCAL_APIC=y
 CONFIG_MTRR=y
@@ -70,6 +73,7 @@ CONFIG_NUMA=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_NR_CPUS=8
 CONFIG_GART_IOMMU=y
+CONFIG_SWIOTLB=y
 CONFIG_X86_MCE=y
 
 #
@@ -77,6 +81,7 @@ CONFIG_X86_MCE=y
 #
 CONFIG_PM=y
 CONFIG_SOFTWARE_SUSPEND=y
+# CONFIG_PM_DISK is not set
 
 #
 # ACPI (Advanced Configuration and Power Interface) Support
@@ -112,7 +117,6 @@ CONFIG_ACPI_SYSTEM=y
 #
 CONFIG_PCI=y
 CONFIG_PCI_DIRECT=y
-# CONFIG_PCI_USE_VECTOR is not set
 # CONFIG_PCI_LEGACY_PROC is not set
 # CONFIG_PCI_NAMES is not set
 # CONFIG_HOTPLUG is not set
@@ -128,6 +132,10 @@ CONFIG_COMPAT=y
 CONFIG_UID16=y
 
 #
+# Device Drivers
+#
+
+#
 # Generic Driver Options
 #
 
@@ -142,6 +150,10 @@ CONFIG_UID16=y
 # CONFIG_PARPORT is not set
 
 #
+# Plug and Play support
+#
+
+#
 # Block devices
 #
 CONFIG_BLK_DEV_FD=y
@@ -180,6 +192,7 @@ CONFIG_BLK_DEV_IDECD=y
 #
 # IDE chipset support/bugfixes
 #
+CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_CMD640 is not set
 CONFIG_BLK_DEV_IDEPCI=y
 # CONFIG_IDEPCI_SHARE_IRQ is not set
@@ -203,7 +216,7 @@ CONFIG_BLK_DEV_AMD74XX=y
 # CONFIG_BLK_DEV_HPT34X is not set
 # CONFIG_BLK_DEV_HPT366 is not set
 # CONFIG_BLK_DEV_SC1200 is not set
-# CONFIG_BLK_DEV_PIIX is not set
+CONFIG_BLK_DEV_PIIX=y
 # CONFIG_BLK_DEV_NS87415 is not set
 # CONFIG_BLK_DEV_PDC202XX_OLD is not set
 # CONFIG_BLK_DEV_PDC202XX_NEW is not set
@@ -267,6 +280,13 @@ CONFIG_SCSI_IPS=m
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_QLA6322 is not set
 # CONFIG_SCSI_DC395x is not set
 # CONFIG_SCSI_DC390T is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -277,11 +297,6 @@ CONFIG_SCSI_IPS=m
 # CONFIG_MD is not set
 
 #
-# Telephony Support
-#
-# CONFIG_PHONE is not set
-
-#
 # Fusion MPT device support
 #
 CONFIG_FUSION=y
@@ -296,6 +311,14 @@ CONFIG_FUSION_MAX_SGE=40
 # CONFIG_IEEE1394 is not set
 
 #
+# I2O device support
+#
+
+#
+# Macintosh device drivers
+#
+
+#
 # Networking support
 #
 CONFIG_NET=y
@@ -388,6 +411,7 @@ CONFIG_NET_PCI=y
 CONFIG_AMD8111_ETH=y
 # CONFIG_ADAPTEC_STARFIRE is not set
 # CONFIG_B44 is not set
+CONFIG_FORCEDETH=y
 # CONFIG_DGRS is not set
 # CONFIG_EEPRO100 is not set
 # CONFIG_E100 is not set
@@ -400,6 +424,7 @@ CONFIG_8139TOO=m
 # CONFIG_8139TOO_TUNE_TWISTER is not set
 # CONFIG_8139TOO_8129 is not set
 # CONFIG_8139_OLD_RX_RESET is not set
+CONFIG_8139_RXBUF_IDX=2
 # CONFIG_SIS900 is not set
 # CONFIG_EPIC100 is not set
 # CONFIG_SUNDANCE is not set
@@ -467,6 +492,11 @@ CONFIG_TIGON3=y
 # CONFIG_ISDN_BOOL is not set
 
 #
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
 # Input device support
 #
 CONFIG_INPUT=y
@@ -535,24 +565,6 @@ CONFIG_UNIX98_PTYS=y
 CONFIG_UNIX98_PTY_COUNT=256
 
 #
-# I2C support
-#
-# CONFIG_I2C is not set
-
-#
-# I2C Algorithms
-#
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# I2C Hardware Sensors Chip support
-#
-# CONFIG_I2C_SENSOR is not set
-
-#
 # Mice
 #
 # CONFIG_BUSMOUSE is not set
@@ -579,6 +591,7 @@ CONFIG_RTC=y
 #
 CONFIG_AGP=y
 CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
 # CONFIG_DRM is not set
 # CONFIG_MWAVE is not set
 CONFIG_RAW_DRIVER=y
@@ -586,8 +599,9 @@ CONFIG_MAX_RAW_DEVS=256
 CONFIG_HANGCHECK_TIMER=y
 
 #
-# Misc devices
+# I2C support
 #
+# CONFIG_I2C is not set
 
 #
 # Multimedia devices
@@ -600,6 +614,65 @@ CONFIG_HANGCHECK_TIMER=y
 # CONFIG_DVB is not set
 
 #
+# Graphics support
+#
+# CONFIG_FB is not set
+# CONFIG_VIDEO_SELECT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+CONFIG_SOUND_PRIME=y
+# CONFIG_SOUND_BT878 is not set
+# CONFIG_SOUND_CMPCI is not set
+# CONFIG_SOUND_EMU10K1 is not set
+# CONFIG_SOUND_FUSION is not set
+# CONFIG_SOUND_CS4281 is not set
+# CONFIG_SOUND_ES1370 is not set
+# CONFIG_SOUND_ES1371 is not set
+# CONFIG_SOUND_ESSSOLO1 is not set
+# CONFIG_SOUND_MAESTRO is not set
+# CONFIG_SOUND_MAESTRO3 is not set
+CONFIG_SOUND_ICH=y
+# CONFIG_SOUND_SONICVIBES is not set
+# CONFIG_SOUND_TRIDENT is not set
+# CONFIG_SOUND_MSNDCLAS is not set
+# CONFIG_SOUND_MSNDPIN is not set
+# CONFIG_SOUND_VIA82CXXX is not set
+# CONFIG_SOUND_OSS is not set
+# CONFIG_SOUND_ALI5455 is not set
+# CONFIG_SOUND_FORTE is not set
+# CONFIG_SOUND_RME96XX is not set
+# CONFIG_SOUND_AD1980 is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
 # File systems
 #
 CONFIG_EXT2_FS=y
@@ -648,8 +721,8 @@ CONFIG_PROC_KCORE=y
 CONFIG_DEVPTS_FS=y
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
-# CONFIG_HUGETLBFS is not set
-# CONFIG_HUGETLB_PAGE is not set
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
 CONFIG_RAMFS=y
 
 #
@@ -703,61 +776,6 @@ CONFIG_MSDOS_PARTITION=y
 # CONFIG_NLS is not set
 
 #
-# Graphics support
-#
-# CONFIG_FB is not set
-# CONFIG_VIDEO_SELECT is not set
-
-#
-# Console display driver support
-#
-CONFIG_VGA_CONSOLE=y
-# CONFIG_MDA_CONSOLE is not set
-CONFIG_DUMMY_CONSOLE=y
-
-#
-# Sound
-#
-CONFIG_SOUND=y
-
-#
-# Advanced Linux Sound Architecture
-#
-# CONFIG_SND is not set
-
-#
-# Open Sound System
-#
-CONFIG_SOUND_PRIME=y
-# CONFIG_SOUND_BT878 is not set
-# CONFIG_SOUND_CMPCI is not set
-# CONFIG_SOUND_EMU10K1 is not set
-# CONFIG_SOUND_FUSION is not set
-# CONFIG_SOUND_CS4281 is not set
-# CONFIG_SOUND_ES1370 is not set
-# CONFIG_SOUND_ES1371 is not set
-# CONFIG_SOUND_ESSSOLO1 is not set
-# CONFIG_SOUND_MAESTRO is not set
-# CONFIG_SOUND_MAESTRO3 is not set
-CONFIG_SOUND_ICH=y
-# CONFIG_SOUND_SONICVIBES is not set
-# CONFIG_SOUND_TRIDENT is not set
-# CONFIG_SOUND_MSNDCLAS is not set
-# CONFIG_SOUND_MSNDPIN is not set
-# CONFIG_SOUND_VIA82CXXX is not set
-# CONFIG_SOUND_OSS is not set
-# CONFIG_SOUND_ALI5455 is not set
-# CONFIG_SOUND_FORTE is not set
-# CONFIG_SOUND_RME96XX is not set
-# CONFIG_SOUND_AD1980 is not set
-
-#
-# USB support
-#
-# CONFIG_USB is not set
-# CONFIG_USB_GADGET is not set
-
-#
 # Profiling support
 #
 CONFIG_PROFILING=y
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/ia32/ia32_binfmt.c linux-2.6.3-amd64/arch/x86_64/ia32/ia32_binfmt.c
--- linux-vanilla/arch/x86_64/ia32/ia32_binfmt.c	2004-02-05 08:10:24.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/ia32/ia32_binfmt.c	2004-02-19 23:28:10.000000000 +0100
@@ -408,3 +408,26 @@ elf32_map (struct file *filep, unsigned 
 	return(map_addr);
 }
 
+#ifdef CONFIG_SYSCTL
+/* Register vsyscall32 into the ABI table */
+#include <linux/sysctl.h>
+
+static ctl_table abi_table2[] = {
+	{ 99, "vsyscall32", &sysctl_vsyscall32, sizeof(int), 0644, NULL,
+	  proc_dointvec },
+	{ 0, }
+}; 
+
+static ctl_table abi_root_table2[] = { 
+	{ .ctl_name = CTL_ABI, .procname = "abi", .mode = 0555, 
+	  .child = abi_table2 }, 
+	{ 0 }, 
+}; 
+
+static __init int ia32_binfmt_init(void)
+{ 
+	register_sysctl_table(abi_root_table2, 1);
+	return 0;
+}
+__initcall(ia32_binfmt_init);
+#endif
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/Makefile linux-2.6.3-amd64/arch/x86_64/kernel/Makefile
--- linux-vanilla/arch/x86_64/kernel/Makefile	2004-01-09 09:26:38.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/Makefile	2004-02-19 23:28:10.000000000 +0100
@@ -7,11 +7,13 @@ EXTRA_AFLAGS	:= -traditional
 obj-y	:= process.o semaphore.o signal.o entry.o traps.o irq.o \
 		ptrace.o i8259.o ioport.o ldt.o setup.o time.o sys_x86_64.o \
 		x8664_ksyms.o i387.o syscall.o vsyscall.o \
-		setup64.o bluesmoke.o bootflag.o e820.o reboot.o warmreboot.o
+		setup64.o bootflag.o e820.o reboot.o warmreboot.o
+obj-y += mce.o
 
 obj-$(CONFIG_MTRR)		+= ../../i386/kernel/cpu/mtrr/
 obj-$(CONFIG_ACPI)		+= acpi/
 obj-$(CONFIG_X86_MSR)		+= msr.o
+obj-$(CONFIG_MICROCODE)		+= microcode.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
 obj-$(CONFIG_SMP)		+= smp.o smpboot.o trampoline.o
 obj-$(CONFIG_X86_LOCAL_APIC)	+= apic.o  nmi.o
@@ -22,6 +24,7 @@ obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
 obj-$(CONFIG_GART_IOMMU)	+= pci-gart.o aperture.o
 obj-$(CONFIG_DUMMY_IOMMU)	+= pci-nommu.o pci-dma.o
+obj-$(CONFIG_SWIOTLB)		+= swiotlb.o
 
 obj-$(CONFIG_MODULES)		+= module.o
 
@@ -30,4 +33,5 @@ obj-y				+= topology.o
 bootflag-y			+= ../../i386/kernel/bootflag.o
 cpuid-$(subst m,y,$(CONFIG_X86_CPUID))  += ../../i386/kernel/cpuid.o
 topology-y                     += ../../i386/mach-default/topology.o
-
+swiotlb-$(CONFIG_SWIOTLB)      += ../../ia64/lib/swiotlb.o
+microcode-$(subst m,y,$(CONFIG_X86_CPUID))  += ../../i386/kernel/microcode.o
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/aperture.c linux-2.6.3-amd64/arch/x86_64/kernel/aperture.c
--- linux-vanilla/arch/x86_64/kernel/aperture.c	2004-02-19 23:57:11.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/aperture.c	2004-02-19 23:28:10.000000000 +0100
@@ -24,6 +24,8 @@
 #include <asm/proto.h>
 #include <asm/pci-direct.h>
 
+int iommu_aperture;
+
 int fallback_aper_order __initdata = 1; /* 64MB */
 int fallback_aper_force __initdata = 0; 
 
@@ -206,6 +208,8 @@ void __init iommu_hole_init(void) 
 		if (read_pci_config(0, num, 3, 0x00) != NB_ID_3) 
 			continue;	
 
+		iommu_aperture = 1; 
+
 		aper_order = (read_pci_config(0, num, 3, 0x90) >> 1) & 7; 
 		aper_size = (32 * 1024 * 1024) << aper_order; 
 		aper_base = read_pci_config(0, num, 3, 0x94) & 0x7fff;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/apic.c linux-2.6.3-amd64/arch/x86_64/kernel/apic.c
--- linux-vanilla/arch/x86_64/kernel/apic.c	2004-01-09 09:26:38.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/apic.c	2004-02-19 23:28:10.000000000 +0100
@@ -646,11 +646,13 @@ void __init init_apic_mappings(void)
 
 void __setup_APIC_LVTT(unsigned int clocks)
 {
-	unsigned int lvtt1_value, tmp_value;
+	unsigned int lvtt_value, tmp_value, ver;
 
-	lvtt1_value = SET_APIC_TIMER_BASE(APIC_TIMER_BASE_DIV) |
-			APIC_LVT_TIMER_PERIODIC | LOCAL_TIMER_VECTOR;
-	apic_write_around(APIC_LVTT, lvtt1_value);
+	ver = GET_APIC_VERSION(apic_read(APIC_LVR));
+	lvtt_value = APIC_LVT_TIMER_PERIODIC | LOCAL_TIMER_VECTOR;
+	if (!APIC_INTEGRATED(ver))
+		lvtt_value |= SET_APIC_TIMER_BASE(APIC_TIMER_BASE_DIV);
+	apic_write_around(APIC_LVTT, lvtt_value);
 
 	/*
 	 * Divide PICLK by 16
@@ -994,8 +996,6 @@ int __init APIC_init_uniprocessor (void)
 
 	setup_local_APIC();
 
-	if (nmi_watchdog == NMI_LOCAL_APIC)
-		check_nmi_watchdog();
 #ifdef CONFIG_X86_IO_APIC
 	if (smp_found_config && !skip_ioapic_setup && nr_ioapics)
 			setup_IO_APIC();
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/bluesmoke.c linux-2.6.3-amd64/arch/x86_64/kernel/bluesmoke.c
--- linux-vanilla/arch/x86_64/kernel/bluesmoke.c	2004-01-09 09:26:38.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/bluesmoke.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,473 +0,0 @@
-/*
- * Machine check handler.
- * K8 parts Copyright 2002,2003 Andi Kleen, SuSE Labs.
- * Rest from unknown author(s). 
- */
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/string.h>
-#include <linux/ctype.h>
-#include <asm/processor.h> 
-#include <asm/msr.h>
-#include <asm/kdebug.h>
-#include <linux/pci.h>
-#include <linux/timer.h>
-
-static int mce_disabled __initdata;
-static unsigned long mce_cpus; 
-
-/*
- *	Machine Check Handler For PII/PIII/K7
- */
-
-static int banks;
-static unsigned long ignored_banks, disabled_banks;
-
-static void generic_machine_check(struct pt_regs * regs, long error_code)
-{
-	int recover=1;
-	u32 alow, ahigh, high, low;
-	u32 mcgstl, mcgsth;
-	int i;
-
-	preempt_disable();
-
-	rdmsr(MSR_IA32_MCG_STATUS, mcgstl, mcgsth);
-	if(mcgstl&(1<<0))	/* Recoverable ? */
-		recover=0;
-
-	printk(KERN_EMERG "CPU %d: Machine Check Exception: %08x%08x\n", smp_processor_id(), mcgsth, mcgstl);
-	
-	if (regs && (mcgstl & 2))
-		printk(KERN_EMERG "RIP <%02lx>:%016lx RSP %016lx\n", 
-		       regs->cs, regs->rip, regs->rsp); 
-
-	for(i=0;i<banks;i++)
-	{
-		if ((1UL<<i) & ignored_banks) 
-			continue; 
-
-		rdmsr(MSR_IA32_MC0_STATUS+i*4,low, high);
-		if(high&(1<<31))
-		{
-			if(high&(1<<29))
-				recover|=1;
-			if(high&(1<<25))
-				recover|=2;
-			printk(KERN_EMERG "Bank %d: %08x%08x", i, high, low);
-			high&=~(1<<31);
-			if(high&(1<<27))
-			{
-				rdmsr(MSR_IA32_MC0_MISC+i*4, alow, ahigh);
-				printk("[%08x%08x]", alow, ahigh);
-			}
-			if(high&(1<<26))
-			{
-				rdmsr(MSR_IA32_MC0_ADDR+i*4, alow, ahigh);
-				printk(" at %08x%08x", 
-					ahigh, alow);
-			}
-			printk("\n");
-			/* Clear it */
-			wrmsr(MSR_IA32_MC0_STATUS+i*4, 0UL, 0UL);
-			/* Serialize */
-			wmb();
-		}
-	}
-
-	if(recover&2)
-		panic("CPU context corrupt");
-	if(recover&1)
-		panic("Unable to continue");
-	printk(KERN_EMERG "Attempting to continue.\n");
-	mcgstl&=~(1<<2);
-	wrmsr(MSR_IA32_MCG_STATUS,mcgstl, mcgsth);
-
-	preempt_enable();
-}
-
-static void unexpected_machine_check(struct pt_regs *regs, long error_code)
-{	
-	printk("unexpected machine check %lx\n", error_code); 
-}
-
-/*
- *	Call the installed machine check handler for this CPU setup.
- */
-
-static void (*machine_check_vector)(struct pt_regs *, long error_code) = unexpected_machine_check;
-
-void do_machine_check(struct pt_regs * regs, long error_code)
-{
-	notify_die(DIE_NMI, "machine check", regs, error_code, 255, SIGKILL);
-	machine_check_vector(regs, error_code);
-}
-
-/* 
- *	K8 machine check.
- */
-
-static struct pci_dev *find_k8_nb(void)
-{ 
-	struct pci_dev *dev = NULL;
-	int cpu = smp_processor_id(); 
-	while ((dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, dev)) != NULL) {
-		if (dev->bus->number==0 && PCI_SLOT(dev->devfn) == (24U+cpu))
-			return dev;
-	}
-	return NULL;
-}
-
-/* When we have kallsyms we can afford kmcedecode too. */
-
-static char *transaction[] = { 
-	"instruction", "data", "generic", "reserved"
-}; 
-static char *cachelevel[] = { 
-	"level 0", "level 1", "level 2", "level generic"
-};
-static char *memtrans[] = { 
-	"generic error", "generic read", "generic write", "data read",
-	"data write", "instruction fetch", "prefetch", "snoop",
-	"?", "?", "?", "?", "?", "?", "?"
-};
-static char *partproc[] = { 
-	"local node origin", "local node response", 
-	"local node observed", "generic" 
-};
-static char *timeout[] = { 
-	"request didn't time out",
-	"request timed out"
-};
-static char *memoryio[] = { 
-	"memory access", "res.", "i/o access", "generic"
-}; 
-static char *extendederr[] = { 
-	"ecc error", 
-	"crc error",
-	"sync error",
-	"mst abort",
-	"tgt abort",
-	"gart error",
-	"rmw error",
-	"wdog error",
-	"chipkill ecc error", 
-	"<9>","<10>","<11>","<12>",
-	"<13>","<14>","<15>"
-}; 
-static char *highbits[32] = { 
-	[31] = "previous error lost", 
-	[30] = "error overflow",
-	[29] = "error uncorrected",
-	[28] = "error enable",
-	[27] = "misc error valid",
-	[26] = "error address valid", 
-	[25] = "processor context corrupt", 
-	[24] = "res24",
-	[23] = "res23",
-	/* 22-15 ecc syndrome bits */
-	[14] = "corrected ecc error",
-	[13] = "uncorrected ecc error",
-	[12] = "res12",
-	[11] = "res11",
-	[10] = "res10",
-	[9] = "res9",
-	[8] = "dram scrub error", 
-	[7] = "res7",
-	/* 6-4 ht link number of error */ 
-	[3] = "res3",
-	[2] = "res2",
-	[1] = "err cpu0",
-	[0] = "err cpu1",
-};
-
-static void check_k8_nb(int header)
-{
-	struct pci_dev *nb;
-	u32 statuslow, statushigh;
-	unsigned short errcode;
-	int i;
-
-	nb = find_k8_nb(); 
-	if (nb == NULL)
-		return;
-
-	pci_read_config_dword(nb, 0x48, &statuslow);
-	pci_read_config_dword(nb, 0x4c, &statushigh);
-	if (!(statushigh & (1<<31)))
-		return;
-	if (header)
-		printk(KERN_ERR "CPU %d: Silent Northbridge MCE\n", smp_processor_id());
-
-	printk(KERN_ERR "Northbridge status %08x%08x\n",
-	       statushigh,statuslow); 
-
-	printk(KERN_ERR "    Error %s\n", extendederr[(statuslow >> 16) & 0xf]); 
-
-	errcode = statuslow & 0xffff;	
-	switch ((statuslow >> 16) & 0xF) { 
-	case 5: 					
-		printk(KERN_ERR "    GART TLB error %s %s\n", 
-		       transaction[(errcode >> 2) & 3], 
-		       cachelevel[errcode & 3]);
-		break;
-	case 8:
-		printk(KERN_ERR "    ECC error syndrome %x\n", 
-		       (((statuslow >> 24) & 0xff)  << 8) | ((statushigh >> 15) & 0x7f));		
-		/*FALL THROUGH*/
-	default:
-		printk(KERN_ERR "    bus error %s, %s\n    %s\n    %s, %s\n",
-		       partproc[(errcode >> 9) & 0x3],
-		       timeout[(errcode >> 8) & 1],
-			       memtrans[(errcode >> 4) & 0xf],
-			       memoryio[(errcode >> 2) & 0x3], 
-			       cachelevel[(errcode & 0x3)]); 
-	/* should only print when it was a HyperTransport related error. */
-	printk(KERN_ERR "    link number %x\n", (statushigh >> 4) & 3);
- 		break;
-	} 
-
-	for (i = 0; i < 32; i++) {
-		if (i == 26 || i == 28) 
-			continue;
-		if (highbits[i] && (statushigh & (1<<i)))
-			printk(KERN_ERR "    %s\n", highbits[i]); 
-	}
-	if (statushigh & (1<<26)) { 
-		u32 addrhigh, addrlow; 
-		pci_read_config_dword(nb, 0x54, &addrhigh); 
-		pci_read_config_dword(nb, 0x50, &addrlow); 
-		printk(KERN_ERR "    NB error address %08x%08x\n", addrhigh,addrlow); 
-	}
-	statushigh &= ~(1<<31); 
-	pci_write_config_dword(nb, 0x4c, statushigh); 		
-}
-
-static void k8_machine_check(struct pt_regs * regs, long error_code)
-{ 
-	u64 status, nbstatus;
-
-	preempt_disable();
-
-	rdmsrl(MSR_IA32_MCG_STATUS, status); 
-	if ((status & (1<<2)) == 0) { 
-		if (!regs) 
-			check_k8_nb(1);
-		return; 
-		}
-
-	printk(KERN_EMERG "CPU %d: Machine Check Exception: %016Lx\n", smp_processor_id(), status);
-
-	if (status & 1)
-		printk(KERN_EMERG "MCG_STATUS: unrecoverable\n"); 
-
-	rdmsrl(MSR_IA32_MC0_STATUS+4*4, nbstatus); 
-	if ((nbstatus & (1UL<<63)) == 0)
-		goto others; 
-	
-	printk(KERN_EMERG "Northbridge Machine Check %s %016lx %lx\n", 
-	       regs ? "exception" : "timer",
-	       (unsigned long)nbstatus, error_code); 
-	if (nbstatus & (1UL<<62))
-		printk(KERN_EMERG "Lost at least one NB error condition\n"); 	
-	if (nbstatus & (1UL<<61))
-		printk(KERN_EMERG "Uncorrectable condition\n"); 
-	if (nbstatus & (1UL<57))
-		printk(KERN_EMERG "Unrecoverable condition\n"); 
-		
-	check_k8_nb(0);
-
-	if (nbstatus & (1UL<<58)) { 
-		u64 adr;
-		rdmsrl(MSR_IA32_MC0_ADDR+4*4, adr);
-		printk(KERN_EMERG "Address: %016lx\n", (unsigned long)adr);
-	}
-	
-	wrmsrl(MSR_IA32_MC0_STATUS+4*4, 0); 
-	wrmsrl(MSR_IA32_MCG_STATUS, 0);
-       
- others:
-	generic_machine_check(regs, error_code); 
-
-	preempt_enable();
-} 
-
-static struct timer_list mcheck_timer;
-int mcheck_interval = 30*HZ; 
-
-#ifndef CONFIG_SMP 
-static void mcheck_timer_handler(unsigned long data)
-{
-	k8_machine_check(NULL,0);
-	mcheck_timer.expires = jiffies + mcheck_interval;
-	add_timer(&mcheck_timer);
-}
-#else
-
-/* SMP needs a process context trampoline because smp_call_function cannot be 
-   called from interrupt context. */
-
-static void mcheck_timer_other(void *data)
-{ 
-	k8_machine_check(NULL, 0); 
-} 
-
-static void mcheck_timer_dist(void *data)
-{
-	smp_call_function(mcheck_timer_other,0,0,0);
-	k8_machine_check(NULL, 0); 
-	mcheck_timer.expires = jiffies + mcheck_interval;
-	add_timer(&mcheck_timer);
-} 
-
-static void mcheck_timer_handler(unsigned long data)
-{ 
-	static DECLARE_WORK(mcheck_work, mcheck_timer_dist, NULL);
-	schedule_work(&mcheck_work); 
-}
-#endif
-
-static int nok8 __initdata; 
-
-static void __init k8_mcheck_init(struct cpuinfo_x86 *c)
-{
-	u64 cap;
-	int i;
-
-	if (!test_bit(X86_FEATURE_MCE, &c->x86_capability) || 
-	    !test_bit(X86_FEATURE_MCA, &c->x86_capability))
-		return; 
-
-	rdmsrl(MSR_IA32_MCG_CAP, cap); 
-	banks = cap&0xff; 
-	machine_check_vector = k8_machine_check; 
-	for (i = 0; i < banks; i++) { 
-		u64 val = ((1UL<<i) & disabled_banks) ? 0 : ~0UL; 
-		wrmsrl(MSR_IA32_MC0_CTL+4*i, val);
-		wrmsrl(MSR_IA32_MC0_STATUS+4*i,0); 
-	}
-
-	if (cap & (1<<8))
-		wrmsrl(MSR_IA32_MCG_CTL, 0xffffffffffffffffULL);
-
-	set_in_cr4(X86_CR4_MCE);	   	
-
-	if (mcheck_interval && (smp_processor_id() == 0)) { 
-		init_timer(&mcheck_timer); 
-		mcheck_timer.function = (void (*)(unsigned long))mcheck_timer_handler; 
-		mcheck_timer.expires = jiffies + mcheck_interval; 
-		add_timer(&mcheck_timer); 
-	} 
-	
-	printk(KERN_INFO "Machine Check Reporting enabled for CPU#%d\n", smp_processor_id()); 
-} 
-
-/*
- *	Set up machine check reporting for Intel processors
- */
-
-static void __init generic_mcheck_init(struct cpuinfo_x86 *c)
-{
-	u32 l, h;
-	int i;
-	static int done;
-	
-	/*
-	 *	Check for MCE support
-	 */
-
-	if( !test_bit(X86_FEATURE_MCE, &c->x86_capability) )
-		return;	
-
-	/*
-	 *	Check for PPro style MCA
-	 */
-	 		
-	if( !test_bit(X86_FEATURE_MCA, &c->x86_capability) )
-		return;
-
-	/* Ok machine check is available */
-	
-	machine_check_vector = generic_machine_check;
-	wmb();
-
-	if(done==0)
-		printk(KERN_INFO "Intel machine check architecture supported.\n");
-	rdmsr(MSR_IA32_MCG_CAP, l, h);
-	if(l&(1<<8))
-		wrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
-	banks = l&0xff;
-
-	for(i=0;i<banks;i++)
-	{
-		u32 val = ((1UL<<i) & disabled_banks) ? 0 : ~0;
-		wrmsr(MSR_IA32_MC0_CTL+4*i, val, val);
-		wrmsr(MSR_IA32_MC0_STATUS+4*i, 0x0, 0x0);
-	}
-	set_in_cr4(X86_CR4_MCE);
-	printk(KERN_INFO "Intel machine check reporting enabled on CPU#%d.\n", smp_processor_id());
-	done=1;
-}
-
-/*
- *	This has to be run for each processor
- */
-
-void __init mcheck_init(struct cpuinfo_x86 *c)
-{
-	if (test_and_set_bit(smp_processor_id(), &mce_cpus))
-		return; 
-
-	if(mce_disabled==1)
-		return;
-
-	switch(c->x86_vendor) {
-		case X86_VENDOR_AMD:
-		if (c->x86 == 15 && !nok8) {
-			k8_mcheck_init(c); 
-			break;
-		}
-		/* FALL THROUGH */
-		default:
-	case X86_VENDOR_INTEL:
-		generic_mcheck_init(c);
-			break;
-	}
-}
-
-static int __init mcheck_disable(char *str)
-{
-	mce_disabled = 1;
-	return 0;
-}
-
-
-/* mce=off disable machine check
-   mce=nok8 disable k8 specific features
-   mce=disable<NUMBER> disable bank NUMBER
-   mce=enable<NUMBER> enable bank number
-   mce=NUMBER mcheck timer interval number seconds. 
-   Can be also comma separated in a single mce= */
-static int __init mcheck_enable(char *str)
-{
-	char *p;
-	while ((p = strsep(&str,",")) != NULL) { 
-		if (isdigit(*p))
-			mcheck_interval = simple_strtol(p,NULL,0) * HZ; 
-		else if (!strcmp(p,"off"))
-			mce_disabled = 1; 
-		else if (!strncmp(p,"enable",6))
-			disabled_banks &= ~(1<<simple_strtol(p+6,NULL,0));
-		else if (!strncmp(p,"disable",7))
-			disabled_banks |= ~(1<<simple_strtol(p+7,NULL,0));
-		else if (!strcmp(p,"nok8"))
-			nok8 = 1;
-	}
-	return 0;
-}
-
-__setup("nomce", mcheck_disable);
-__setup("mce", mcheck_enable);
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/cpufreq/Kconfig linux-2.6.3-amd64/arch/x86_64/kernel/cpufreq/Kconfig
--- linux-vanilla/arch/x86_64/kernel/cpufreq/Kconfig	2003-10-25 22:57:30.000000000 +0200
+++ linux-2.6.3-amd64/arch/x86_64/kernel/cpufreq/Kconfig	2004-02-19 23:28:10.000000000 +0100
@@ -11,8 +11,8 @@ config CPU_FREQ
 	  fly. This is a nice method to save battery power on notebooks,
 	  because the lower the clock speed, the less power the CPU consumes.
 
-	  For more information, take a look at linux/Documentation/cpu-freq or
-	  at <http://www.brodo.de/cpufreq/>
+	  For more information, take a look at <file:Documentation/cpu-freq/>
+	  or at <http://www.codemonkey.org.uk/projects/cpufreq/>
 
 	  If in doubt, say N.
 
@@ -37,7 +37,7 @@ config X86_POWERNOW_K8
 	help
 	  This adds the CPUFreq driver for mobile AMD Opteron/Athlon64 processors.
 
-	  For details, take a look at linux/Documentation/cpu-freq. 
+	  For details, take a look at <file:Documentation/cpu-freq/>. 
 
 	  If in doubt, say N.
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/head.S linux-2.6.3-amd64/arch/x86_64/kernel/head.S
--- linux-vanilla/arch/x86_64/kernel/head.S	2004-01-09 09:26:38.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/head.S	2004-02-19 23:28:10.000000000 +0100
@@ -16,6 +16,7 @@
 #include <asm/segment.h>
 #include <asm/page.h>
 #include <asm/msr.h>
+#include <asm/cache.h>
 	
 /* we are not able to switch in one step to the final KERNEL ADRESS SPACE
  * because we need identity-mapped pages on setup so define __START_KERNEL to
@@ -322,7 +323,6 @@ gdt:
 	.endr
 #endif
 
-.align 64 /* cacheline aligned */
 ENTRY(gdt_table32)
 	.quad	0x0000000000000000	/* This one is magic */
 	.quad	0x0000000000000000	/* unused */
@@ -334,14 +334,14 @@ gdt32_end:	
  * Also sysret mandates a special GDT layout 
  */
 		 		
-.align 64 /* cacheline aligned, keep this synchronized with asm/desc.h */
+.align L1_CACHE_BYTES
 
 /* The TLS descriptors are currently at a different place compared to i386.
    Hopefully nobody expects them at a fixed place (Wine?) */
 	
 ENTRY(cpu_gdt_table)
 	.quad	0x0000000000000000	/* NULL descriptor */
-	.quad	0x00af9a000000ffff ^ (1<<21)	/* __KERNEL_COMPAT32_CS */	
+	.quad	0x008f9a000000ffff	/* __KERNEL_COMPAT32_CS */	
 	.quad	0x00af9a000000ffff	/* __KERNEL_CS */
 	.quad	0x00cf92000000ffff	/* __KERNEL_DS */
 	.quad	0x00cffe000000ffff	/* __USER32_CS */
@@ -354,18 +354,13 @@ ENTRY(cpu_gdt_table)
 	.quad	0			/* unused now */
 	.quad	0x00009a000000ffff	/* __KERNEL16_CS - 16bit PM for S3 wakeup. */
 					/* base must be patched for real base address. */
-	/* This should be a multiple of the cache line size */
 gdt_end:	
-	.globl gdt_end
-
-	/* GDTs of other CPUs */	
-#ifdef CONFIG_SMP
-	.rept NR_CPUS-1
-	.quad 0,0,0,0,0,0,0,0,0,0,0
-	.endr	
-#endif
+	/* asm/segment.h:GDT_ENTRIES must match this */	
+	/* This should be a multiple of the cache line size */
+	/* GDTs of other CPUs: */	
+	.fill (GDT_SIZE * NR_CPUS) - (gdt_end - cpu_gdt_table) 
 
-	.align  64
+	.align  L1_CACHE_BYTES
 ENTRY(idt_table)	
 	.rept   256
 	.quad   0
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/io_apic.c linux-2.6.3-amd64/arch/x86_64/kernel/io_apic.c
--- linux-vanilla/arch/x86_64/kernel/io_apic.c	2004-02-05 08:10:24.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/io_apic.c	2004-02-19 23:28:10.000000000 +0100
@@ -245,7 +245,7 @@ void __init check_ioapic(void) 
 							 PCI_VENDOR_ID);
 				vendor &= 0xffff;
 				switch (vendor) { 
-				case PCI_VENDOR_ID_NVIDIA: 
+//				case PCI_VENDOR_ID_NVIDIA: 
 				case PCI_VENDOR_ID_VIA:
 					printk(KERN_INFO 
      "PCI bridge %02x:%02x from %x found. Setting \"noapic\". Overwrite with \"apic\"\n",
@@ -1759,23 +1759,6 @@ void __init setup_IO_APIC(void)
 		print_IO_APIC();
 }
 
-/* Ensure the ACPI SCI interrupt level is active low, edge-triggered */
-
-void __init mp_config_ioapic_for_sci(int irq)
-{
-#if 0 /* fixme */
-       int ioapic;
-       int ioapic_pin;
-
-       ioapic = mp_find_ioapic(irq);
-
-       ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
-
-       io_apic_set_pci_routing(ioapic, ioapic_pin, irq);
-#endif
-}
-
-
 /* --------------------------------------------------------------------------
                           ACPI-based IOAPIC Configuration
    -------------------------------------------------------------------------- */
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/mce.c linux-2.6.3-amd64/arch/x86_64/kernel/mce.c
--- linux-vanilla/arch/x86_64/kernel/mce.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/mce.c	2004-02-19 23:28:10.000000000 +0100
@@ -0,0 +1,463 @@
+/*
+ * Machine check handler.
+ * K8 parts Copyright 2002,2003 Andi Kleen, SuSE Labs.
+ * Rest from unknown author(s). 
+ * 2004 Andi Kleen. Rewrote most of it. 
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/rcupdate.h>
+#include <linux/kallsyms.h>
+#include <linux/sysdev.h>
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <asm/processor.h> 
+#include <asm/msr.h>
+#include <asm/mce.h>
+#include <asm/kdebug.h>
+#include <asm/uaccess.h>
+
+#define MISC_MCELOG_MINOR 227
+
+static int mce_disabled __initdata;
+/* 0: always panic, 1: panic if deadlock possible, 2: try to avoid panic */ 
+static int tolerant = 2;
+static int banks;
+static unsigned long disabled_banks;
+
+/*
+ * Lockless MCE logging infrastructure.
+ * This avoids deadlocks on printk locks without having to break locks. Also
+ * separate MCEs from kernel messages to avoid bogus bug reports.
+ */
+
+struct mce_log mcelog = { 
+	MCE_LOG_SIGNATURE,
+	MCE_LOG_LEN,
+}; 
+
+static void mce_log(struct mce *mce)
+{
+	unsigned next, entry;
+	mce->finished = 0;
+	smp_wmb();
+	for (;;) {
+		entry = mcelog.next;
+		read_barrier_depends();
+		/* When the buffer fills up discard new entries. Assume 
+		   that the earlier errors are the more interesting. */
+		if (entry >= MCE_LOG_LEN) {
+			set_bit(MCE_OVERFLOW, &mcelog.flags);
+			return;
+		}
+		/* Old left over entry. Skip. */
+		if (mcelog.entry[entry].finished)
+			continue;
+		smp_rmb();
+		next = entry + 1;
+		if (cmpxchg(&mcelog.next, entry, next) == entry)
+			break;
+	}
+	memcpy(mcelog.entry + entry, mce, sizeof(struct mce));
+	smp_wmb();
+	mcelog.entry[entry].finished = 1;
+	smp_wmb();
+}
+
+static void print_mce(struct mce *m)
+{
+	printk("CPU %d: Machine Check Exception: %16Lx Bank %d: %016Lx\n",
+	       m->cpu, m->mcgstatus, m->bank, m->status);
+	if (m->rip) {
+		printk("RIP %02x:<%016Lx> ", m->cs, m->rip);
+		if (m->cs == __KERNEL_CS)
+			print_symbol("{%s}", m->rip);
+		printk("\n");
+	}
+	printk("TSC %Lx ", m->tsc); 
+	if (m->addr)
+		printk("ADDR %Lx ", m->addr);
+	if (m->misc)
+		printk("MISC %Lx ", m->addr); 	
+	printk("\n");
+}
+
+static void mce_panic(char *msg, struct mce *backup, unsigned long start)
+{ 
+	int i;
+	oops_begin();
+	for (i = 0; i < MCE_LOG_LEN; i++) {
+		if (mcelog.entry[i].tsc < start)
+			continue;
+		print_mce(&mcelog.entry[i]); 
+		if (mcelog.entry[i].tsc == backup->tsc)
+			backup = NULL;
+	}
+	if (backup)
+		print_mce(backup);
+	panic(msg);
+} 
+
+static int mce_available(struct cpuinfo_x86 *c)
+{
+	return !mce_disabled && 
+		test_bit(X86_FEATURE_MCE, &c->x86_capability) &&
+		test_bit(X86_FEATURE_MCA, &c->x86_capability);
+}
+
+/* 
+ * The actual machine check handler
+ */
+
+void do_machine_check(struct pt_regs * regs, long error_code)
+{
+	struct mce m;
+	int nowayout = 0;
+	int kill_it = 0;
+	u64 mcestart;
+	int i;
+
+	if (regs)
+		notify_die(DIE_NMI, "machine check", regs, error_code, 255, SIGKILL);
+	if (!banks)
+		return;
+
+	memset(&m, 0, sizeof(struct mce));
+	m.cpu = hard_smp_processor_id();
+	rdmsrl(MSR_IA32_MCG_STATUS, m.mcgstatus);
+	if (!regs && (m.mcgstatus & MCG_STATUS_MCIP))
+		return;
+	if (!(m.mcgstatus & MCG_STATUS_RIPV))
+		kill_it = 1;
+	if (regs && (m.mcgstatus & MCG_STATUS_EIPV)) {
+		m.rip = regs->rip;
+		m.cs = regs->cs;
+	}
+	
+	rdtscll(mcestart);
+	mb();
+
+	for (i = 0; i < banks; i++) {
+		if (test_bit(i, &disabled_banks))
+			continue;
+
+		rdmsrl(MSR_IA32_MC0_STATUS + i*4, m.status);
+		if ((m.status & MCI_STATUS_VAL) == 0)
+			continue;
+
+		nowayout |= (tolerant < 1); 
+		nowayout |= !!(m.status & (MCI_STATUS_OVER|MCI_STATUS_PCC));
+		kill_it |= !!(m.status & MCI_STATUS_UC);
+		m.bank = i;
+
+		if (m.status & MCI_STATUS_MISCV)
+			rdmsrl(MSR_IA32_MC0_MISC + i*4, m.misc);
+		if (m.status & MCI_STATUS_ADDRV)
+			rdmsrl(MSR_IA32_MC0_MISC + i*4, m.addr);
+
+		rdtscll(m.tsc);
+		wrmsrl(MSR_IA32_MC0_STATUS + i*4, 0);
+		mce_log(&m);
+	}
+	wrmsrl(MSR_IA32_MCG_STATUS, 0);
+
+	/* Never do anything final in the polling timer */
+	if (!regs)
+		return;
+	if (nowayout)
+		mce_panic("Machine check", &m, mcestart);
+	if (kill_it) {
+		int user_space = (m.rip && (m.cs & 3));
+		
+		/* When the machine was in user space and the CPU didn't get
+		   confused it's normally not necessary to panic, unless you are 
+		   paranoid (tolerant == 0) */ 
+		if (!user_space && (panic_on_oops || tolerant < 2))
+			mce_panic("Uncorrected machine check in kernel", &m, mcestart);
+
+		/* do_exit takes an awful lot of locks and has as slight risk 
+		   of deadlocking. If you don't want that don't set tolerant >= 2 */
+		do_exit(SIGBUS);
+	}
+}
+
+static void mce_clear_all(void)
+{
+	int i;
+	for (i = 0; i < banks; i++)
+		wrmsrl(MSR_IA32_MC0_STATUS + i*4, 0);
+	wrmsrl(MSR_IA32_MCG_STATUS, 0);
+}
+
+/*
+ * Periodic polling timer for "silent" machine check errors.
+ */
+
+static int check_interval = 3600; /* one hour */
+static void mcheck_timer(void *data);
+static DECLARE_WORK(mcheck_work, mcheck_timer, NULL);
+
+static void mcheck_check_cpu(void *info)
+{
+	if (mce_available(&current_cpu_data))
+		do_machine_check(NULL, 0);
+}
+
+static void mcheck_timer(void *data)
+{
+	on_each_cpu(mcheck_check_cpu, NULL, 1, 1);
+	schedule_delayed_work(&mcheck_work, check_interval * HZ);
+}
+
+
+static __init int periodic_mcheck_init(void)
+{ 
+	if (check_interval)
+		schedule_delayed_work(&mcheck_work, check_interval*HZ);
+	return 0;
+} 
+__initcall(periodic_mcheck_init);
+
+
+/* 
+ * Initialize Machine Checks for a CPU.
+ */
+static void mce_init(void *dummy)
+{
+	u64 cap;
+	int i;
+
+	rdmsrl(MSR_IA32_MCG_CAP, cap);
+	if (cap & MCG_CTL_P)
+		wrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
+
+	banks = cap & 0xff;
+
+	mce_clear_all(); 
+	for (i = 0; i < banks; i++) {
+		u64 val = test_bit(i, &disabled_banks) ? 0 : ~0UL;
+		wrmsrl(MSR_IA32_MC0_CTL+4*i, val);
+		wrmsrl(MSR_IA32_MC0_STATUS+4*i, 0);
+	}	
+
+	set_in_cr4(X86_CR4_MCE);
+}
+
+/* 
+ * Called for each booted CPU to set up machine checks.
+ * Must be called with preempt off. 
+ */
+void __init mcheck_init(struct cpuinfo_x86 *c)
+{
+	static unsigned long mce_cpus __initdata = 0;
+
+	if (test_and_set_bit(smp_processor_id(), &mce_cpus) || !mce_available(c))
+		return;
+
+	mce_init(NULL);
+}
+
+/*
+ * Character device to read and clear the MCE log.
+ */
+
+static void collect_tscs(void *data) 
+{ 
+	unsigned long *cpu_tsc = (unsigned long *)data;
+	rdtscll(cpu_tsc[smp_processor_id()]);
+} 
+
+static ssize_t mce_read(struct file *filp, char *ubuf, size_t usize, loff_t *off)
+{
+	unsigned long cpu_tsc[NR_CPUS];
+	static DECLARE_MUTEX(mce_read_sem);
+	unsigned next;
+	char *buf = ubuf;
+	int i, err;
+
+	down(&mce_read_sem); 
+	next = mcelog.next;
+	read_barrier_depends();
+		
+	/* Only supports full reads right now */
+	if (*off != 0 || usize < MCE_LOG_LEN*sizeof(struct mce)) { 
+		up(&mce_read_sem);
+		return -EINVAL;
+	}
+
+	err = 0;
+	for (i = 0; i < next; i++) {
+		if (!mcelog.entry[i].finished)
+			continue;
+		smp_rmb();
+		err |= copy_to_user(buf, mcelog.entry + i, sizeof(struct mce));
+		buf += sizeof(struct mce); 
+	} 
+
+	memset(mcelog.entry, 0, next * sizeof(struct mce));
+	mcelog.next = 0;
+	smp_wmb(); 
+	
+	synchronize_kernel();	
+
+	/* Collect entries that were still getting written before the synchronize. */
+
+	on_each_cpu(collect_tscs, cpu_tsc, 1, 1);
+	for (i = next; i < MCE_LOG_LEN; i++) { 
+		if (mcelog.entry[i].finished && 
+		    mcelog.entry[i].tsc < cpu_tsc[mcelog.entry[i].cpu]) {  
+			err |= copy_to_user(buf, mcelog.entry+i, sizeof(struct mce));
+			smp_rmb();
+			buf += sizeof(struct mce);
+			memset(&mcelog.entry[i], 0, sizeof(struct mce));
+		}
+	} 	
+	up(&mce_read_sem);
+	return err ? -EFAULT : buf - ubuf; 
+}
+
+static int mce_ioctl(struct inode *i, struct file *f,unsigned int cmd, unsigned long arg)
+{
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM; 
+	switch (cmd) {
+	case MCE_GET_RECORD_LEN: 
+		return put_user(sizeof(struct mce), (int *)arg);
+	case MCE_GET_LOG_LEN:
+		return put_user(MCE_LOG_LEN, (int *)arg);		
+	case MCE_GETCLEAR_FLAGS: {
+		unsigned flags;
+		do { 
+			flags = mcelog.flags;
+		} while (cmpxchg(&mcelog.flags, flags, 0) != flags); 
+		return put_user(flags, (int *)arg); 
+	}
+	default:
+		return -ENOTTY; 
+	} 
+}
+
+#if 1 /* for testing */
+static ssize_t mce_write(struct file *f, const char __user *buf, size_t sz, loff_t *off)
+{
+	struct mce m;
+	if (sz != sizeof(struct mce))
+		return -EINVAL;
+	copy_from_user(&m, buf, sizeof(struct mce));
+	m.finished = 0;
+	mce_log(&m);
+	return sizeof(struct mce);
+}
+#endif
+
+static struct file_operations mce_chrdev_ops = {
+	.read = mce_read,
+	.ioctl = mce_ioctl,
+	.write = mce_write
+};
+
+static struct miscdevice mce_log_device = {
+	MISC_MCELOG_MINOR,
+	"mcelog",
+	&mce_chrdev_ops,
+};
+
+/* 
+ * Old style boot options parsing. Only for compatibility. 
+ */
+
+static int __init mcheck_disable(char *str)
+{
+	mce_disabled = 1;
+	return 0;
+}
+
+/* mce=off disable machine check */
+static int __init mcheck_enable(char *str)
+{
+	if (!strcmp(str, "off"))
+		mce_disabled = 1;
+	else
+		printk("mce= argument %s ignored. Please use /sys", str); 
+	return 0;
+}
+
+__setup("nomce", mcheck_disable);
+__setup("mce", mcheck_enable);
+
+/* 
+ * Sysfs support
+ */ 
+
+/* On resume clear all MCE state. Don't want to see leftovers from the BIOS. */
+static int mce_resume(struct sys_device *dev)
+{
+	mce_clear_all();
+	on_each_cpu(mce_init, NULL, 1, 1);
+	return 0;
+}
+
+/* Reinit MCEs after user configuration changes */
+static void mce_restart(void) 
+{ 
+	if (check_interval)
+		cancel_delayed_work(&mcheck_work);
+	/* Timer race is harmless here */
+	on_each_cpu(mce_init, NULL, 1, 1);       
+	if (check_interval)
+		schedule_delayed_work(&mcheck_work, check_interval*HZ);
+}
+
+static struct sysdev_class mce_sysclass = {
+	.resume = mce_resume,
+	set_kset_name("machinecheck"),
+};
+
+static struct sys_device device_mce = {
+	.id	= 0,
+	.cls	= &mce_sysclass,
+};
+
+/* Why are there no generic functions for this? */
+#define ACCESSOR(name, start) \
+	static ssize_t show_ ## name(struct sys_device *s, char *buf) { 	   	   \
+		return sprintf(buf, "%lu\n", (unsigned long)name);		   \
+	} 									   \
+	static ssize_t set_ ## name(struct sys_device *s,const char *buf,size_t siz) { \
+		char *end; 							   \
+		unsigned long new = simple_strtoul(buf, &end, 0); 		   \
+		if (end == buf) return -EINVAL;					   \
+		name = new;							   \
+		start; 								   \
+		return end-buf;		     					   \
+	}									   \
+	static SYSDEV_ATTR(name, 0644, show_ ## name, set_ ## name);
+
+ACCESSOR(disabled_banks,mce_restart())
+ACCESSOR(tolerant,)
+ACCESSOR(check_interval,mce_restart())
+
+static __init int mce_init_device(void)
+{
+	int err;
+	if (!mce_available(&boot_cpu_data))
+		return -EIO;
+	err = sysdev_class_register(&mce_sysclass);
+	if (!err)
+		err = sys_device_register(&device_mce);
+	if (!err) { 
+		/* could create per CPU objects, but is not worth it. */
+		sysdev_create_file(&device_mce, &attr_disabled_banks); 
+		sysdev_create_file(&device_mce, &attr_tolerant); 
+		sysdev_create_file(&device_mce, &attr_check_interval);
+	} 
+	
+	misc_register(&mce_log_device);
+	return err;
+
+}
+device_initcall(mce_init_device);
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/mpparse.c linux-2.6.3-amd64/arch/x86_64/kernel/mpparse.c
--- linux-vanilla/arch/x86_64/kernel/mpparse.c	2004-02-19 23:57:11.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/mpparse.c	2004-02-20 00:16:01.000000000 +0100
@@ -876,6 +876,72 @@ void __init mp_config_acpi_legacy_irqs (
 	return;
 }
 
+
+extern FADT_DESCRIPTOR acpi_fadt;
+
+void __init mp_config_ioapic_for_sci(int irq)
+{
+	int ioapic;
+	int ioapic_pin;
+	struct acpi_table_madt *madt;
+	struct acpi_table_int_src_ovr *entry = NULL;
+	acpi_interrupt_flags flags;
+	void *madt_end;
+	acpi_status status;
+
+	/*
+	 * Ensure that if there is an interrupt source override entry
+	 * for the ACPI SCI, we leave it as is. Unfortunately this involves
+	 * walking the MADT again.
+	 */
+	status = acpi_get_firmware_table("APIC", 1, ACPI_LOGICAL_ADDRESSING,
+		(struct acpi_table_header **) &madt);
+	if (ACPI_SUCCESS(status)) {
+		madt_end = (void *) (unsigned long)madt + madt->header.length;
+
+		entry = (struct acpi_table_int_src_ovr *)
+                ((unsigned long) madt + sizeof(struct acpi_table_madt));
+
+		while ((void *) entry < madt_end) {
+                	if (entry->header.type == ACPI_MADT_INT_SRC_OVR &&
+			    acpi_fadt.sci_int == entry->bus_irq)
+				goto found;
+			
+                	entry = (struct acpi_table_int_src_ovr *)
+                	        ((unsigned long) entry + entry->header.length);
+        	}
+	}
+	/*
+	 * Although the ACPI spec says that the SCI should be level/low
+	 * don't reprogram it unless there is an explicit MADT OVR entry
+	 * instructing us to do so -- otherwise we break Tyan boards which
+	 * have the SCI wired edge/high but no MADT OVR.
+	 */
+	return;
+
+found:
+	/*
+	 * See the note at the end of ACPI 2.0b section
+	 * 5.2.10.8 for what this is about.
+	 */
+	flags = entry->flags;
+	acpi_fadt.sci_int = entry->global_irq;
+	irq = entry->global_irq;
+
+	ioapic = mp_find_ioapic(irq);
+
+	ioapic_pin = irq - mp_ioapic_routing[ioapic].irq_start;
+
+	/*
+	 * MPS INTI flags:
+	 *  trigger: 0=default, 1=edge, 3=level
+	 *  polarity: 0=default, 1=high, 3=low
+	 * Per ACPI spec, default for SCI means level/low.
+	 */
+	io_apic_set_pci_routing(ioapic, ioapic_pin, irq, 
+		(flags.trigger == 1 ? 0 : 1), (flags.polarity == 1 ? 0 : 1));
+}
+
 #ifdef CONFIG_ACPI_PCI
 
 void __init mp_parse_prt (void)
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/nmi.c linux-2.6.3-amd64/arch/x86_64/kernel/nmi.c
--- linux-vanilla/arch/x86_64/kernel/nmi.c	2004-02-19 23:57:11.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/nmi.c	2004-02-19 23:28:10.000000000 +0100
@@ -47,6 +47,9 @@ static unsigned int nmi_hz = HZ;
 unsigned int nmi_perfctr_msr;	/* the MSR to reset in NMI handler */
 int nmi_watchdog_disabled;
 
+/* Note that these events don't tick when the CPU idles. This means
+   the frequency varies with CPU load. */
+
 #define K7_EVNTSEL_ENABLE	(1 << 22)
 #define K7_EVNTSEL_INT		(1 << 20)
 #define K7_EVNTSEL_OS		(1 << 17)
@@ -236,6 +239,9 @@ static void setup_k7_watchdog(void)
 	int i;
 	unsigned int evntsel;
 
+	/* No check, so can start with slow frequency */
+	nmi_hz = 1; 
+
 	/* XXX should check these in EFER */
 
 	nmi_perfctr_msr = MSR_K7_PERFCTR0;
@@ -253,14 +259,13 @@ static void setup_k7_watchdog(void)
 		| K7_NMI_EVENT;
 
 	wrmsr(MSR_K7_EVNTSEL0, evntsel, 0);
-	printk(KERN_INFO "watchdog: setting K7_PERFCTR0 to %08x\n", -(cpu_khz/nmi_hz*1000));
-	wrmsr(MSR_K7_PERFCTR0, -(cpu_khz/nmi_hz*1000), -1);
+	wrmsrl(MSR_K7_PERFCTR0, -((u64)cpu_khz*1000) / nmi_hz);
 	apic_write(APIC_LVTPC, APIC_DM_NMI);
 	evntsel |= K7_EVNTSEL_ENABLE;
 	wrmsr(MSR_K7_EVNTSEL0, evntsel, 0);
 }
 
-void setup_apic_nmi_watchdog (void)
+void setup_apic_nmi_watchdog(void)
 {
 	switch (boot_cpu_data.x86_vendor) {
 	case X86_VENDOR_AMD:
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/pci-gart.c linux-2.6.3-amd64/arch/x86_64/kernel/pci-gart.c
--- linux-vanilla/arch/x86_64/kernel/pci-gart.c	2004-02-19 23:57:11.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/pci-gart.c	2004-02-19 23:28:10.000000000 +0100
@@ -354,6 +354,11 @@ dma_addr_t pci_map_single(struct pci_dev
 
 	BUG_ON(dir == PCI_DMA_NONE);
 
+#ifdef CONFIG_SWIOTLB
+	if (swiotlb)
+		return swiotlb_map_single(&dev->dev,addr,size,dir);
+#endif
+
 	phys_mem = virt_to_phys(addr); 
 	if (!need_iommu(dev, phys_mem, size))
 		return phys_mem; 
@@ -460,6 +465,12 @@ int pci_map_sg(struct pci_dev *dev, stru
 	BUG_ON(dir == PCI_DMA_NONE);
 	if (nents == 0) 
 		return 0;
+
+#ifdef CONFIG_SWIOTLB
+	if (swiotlb)
+		return swiotlb_map_sg(&dev->dev,sg,nents,dir);
+#endif
+
 	out = 0;
 	start = 0;
 	for (i = 0; i < nents; i++) {
@@ -520,6 +531,13 @@ void pci_unmap_single(struct pci_dev *hw
 	unsigned long iommu_page; 
 	int npages;
 	int i;
+
+#ifdef CONFIG_SWIOTLB
+ 	if (swiotlb) {
+ 		swiotlb_unmap_single(&hwdev->dev,dma_addr,size,direction);
+ 		return;
+ 	}
+#endif
 	if (dma_addr < iommu_bus_base + EMERGENCY_PAGES*PAGE_SIZE || 
 	    dma_addr >= iommu_bus_base + iommu_size)
 		return;
@@ -570,7 +588,7 @@ int pci_dma_supported(struct pci_dev *de
 		return 0; 
 	}
 
-	if (no_iommu && (mask < (end_pfn << PAGE_SHIFT)))
+	if (no_iommu && (mask < (end_pfn << PAGE_SHIFT)) && !swiotlb)
 		return 0;
 
 	return 1;
@@ -680,6 +698,7 @@ static __init int init_k8_gatt(struct ag
 	return 0;
 
  nommu:
+ 	/* Should not happen anymore */
 	printk(KERN_ERR "PCI-DMA: More than 4GB of RAM and no IOMMU\n"
 	       KERN_ERR "PCI-DMA: 32bit PCI IO may malfunction."); 
 	return -1; 
@@ -694,6 +713,7 @@ static int __init pci_iommu_init(void)
 	unsigned long iommu_start;
 	struct pci_dev *dev;
 		
+
 #ifndef CONFIG_AGP_AMD64
 	no_agp = 1; 
 #else
@@ -704,7 +724,14 @@ static int __init pci_iommu_init(void)
 		(agp_copy_info(&info) < 0); 
 #endif	
 
-	if (no_iommu || (!force_iommu && end_pfn < 0xffffffff>>PAGE_SHIFT)) { 
+	if (swiotlb) { 
+		no_iommu = 1;
+		printk(KERN_INFO "PCI-DMA: Using SWIOTLB :-(\n"); 
+		return -1; 
+	} 
+	
+	if (no_iommu || (!force_iommu && end_pfn < 0xffffffff>>PAGE_SHIFT) || 
+	    !iommu_aperture) {
 		printk(KERN_INFO "PCI-DMA: Disabling IOMMU.\n"); 
 		no_iommu = 1;
 		return -1;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/process.c linux-2.6.3-amd64/arch/x86_64/kernel/process.c
--- linux-vanilla/arch/x86_64/kernel/process.c	2004-02-05 08:10:24.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/process.c	2004-02-19 23:28:10.000000000 +0100
@@ -140,6 +140,52 @@ void cpu_idle (void)
 	}
 }
 
+/*
+ * This uses new MONITOR/MWAIT instructions on P4 processors with PNI,
+ * which can obviate IPI to trigger checking of need_resched.
+ * We execute MONITOR against need_resched and enter optimized wait state
+ * through MWAIT. Whenever someone changes need_resched, we would be woken
+ * up from MWAIT (without an IPI).
+ */
+static void mwait_idle(void)
+{
+	local_irq_enable();
+
+	if (!need_resched()) {
+		set_thread_flag(TIF_POLLING_NRFLAG);
+		do {
+			__monitor((void *)&current_thread_info()->flags, 0, 0);
+			if (need_resched())
+				break;
+			__mwait(0, 0);
+		} while (!need_resched());
+		clear_thread_flag(TIF_POLLING_NRFLAG);
+	}
+}
+
+void __init select_idle_routine(const struct cpuinfo_x86 *c)
+{
+	static int printed;
+	if (cpu_has(c, X86_FEATURE_MWAIT)) {
+		/*
+		 * Skip, if setup has overridden idle.
+		 * Also, take care of system with asymmetric CPUs.
+		 * Use, mwait_idle only if all cpus support it.
+		 * If not, we fallback to default_idle()
+		 */
+		if (!pm_idle) {
+			if (!printed) {
+				printk("using mwait in idle threads.\n");
+				printed = 1;
+			}
+			pm_idle = mwait_idle;
+		}
+		return;
+	}
+	pm_idle = default_idle;
+	return;
+}
+
 static int __init idle_setup (char *str)
 {
 	if (!strncmp(str, "poll", 4)) {
@@ -537,16 +583,18 @@ extern void scheduling_functions_end_her
 
 unsigned long get_wchan(struct task_struct *p)
 {
+	unsigned long stack;
 	u64 fp,rip;
 	int count = 0;
 
 	if (!p || p == current || p->state==TASK_RUNNING)
 		return 0; 
-	if (p->thread.rsp < (u64)p || p->thread.rsp > (u64)p + THREAD_SIZE)
+	stack = (unsigned long)p->thread_info; 
+	if (p->thread.rsp < stack || p->thread.rsp > stack+THREAD_SIZE)
 		return 0;
 	fp = *(u64 *)(p->thread.rsp);
 	do { 
-		if (fp < (unsigned long)p || fp > (unsigned long)p+THREAD_SIZE)
+		if (fp < (unsigned long)stack || fp > (unsigned long)stack+THREAD_SIZE)
 			return 0; 
 		rip = *(u64 *)(fp+8); 
 		if (rip < first_sched || rip >= last_sched)
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/setup.c linux-2.6.3-amd64/arch/x86_64/kernel/setup.c
--- linux-vanilla/arch/x86_64/kernel/setup.c	2004-02-05 08:10:25.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/setup.c	2004-02-19 23:28:10.000000000 +0100
@@ -76,6 +76,9 @@ unsigned long pci_mem_start = 0x10000000
 
 unsigned long saved_video_mode;
 
+int swiotlb;
+EXPORT_SYMBOL(swiotlb);
+
 /*
  * Setup options
  */
@@ -440,7 +443,6 @@ void __init setup_arch(char **cmdline_p)
 		}
 	}
 #endif
-
 	paging_init();
 
 #ifndef CONFIG_SMP
@@ -584,6 +586,193 @@ static int __init init_amd(struct cpuinf
 	return r;
 }
 
+static void __init detect_ht(void)
+{
+#ifdef CONFIG_SMP
+	extern	int phys_proc_id[NR_CPUS];
+	
+	u32 	eax, ebx, ecx, edx;
+	int 	index_lsb, index_msb, tmp;
+	int	initial_apic_id;
+	int 	cpu = smp_processor_id();
+	
+	cpuid(1, &eax, &ebx, &ecx, &edx);
+	smp_num_siblings = (ebx & 0xff0000) >> 16;
+	
+	if (smp_num_siblings == 1) {
+		printk(KERN_INFO  "CPU: Hyper-Threading is disabled\n");
+	} else if (smp_num_siblings > 1) {
+		index_lsb = 0;
+		index_msb = 31;
+		/*
+		 * At this point we only support two siblings per
+		 * processor package.
+		 */
+#define NR_SIBLINGS	2
+		if (smp_num_siblings != NR_SIBLINGS) {
+			printk(KERN_WARNING "CPU: Unsupported number of the siblings %d", smp_num_siblings);
+			smp_num_siblings = 1;
+			return;
+		}
+		tmp = smp_num_siblings;
+		while ((tmp & 1) == 0) {
+			tmp >>=1 ;
+			index_lsb++;
+		}
+		tmp = smp_num_siblings;
+		while ((tmp & 0x80000000 ) == 0) {
+			tmp <<=1 ;
+			index_msb--;
+		}
+		if (index_lsb != index_msb )
+			index_msb++;
+		initial_apic_id = ebx >> 24 & 0xff;
+		phys_proc_id[cpu] = initial_apic_id >> index_msb;
+		
+		printk(KERN_INFO  "CPU: Physical Processor ID: %d\n",
+		       phys_proc_id[cpu]);
+	}
+#endif
+}
+	
+#define LVL_1_INST	1
+#define LVL_1_DATA	2
+#define LVL_2		3
+#define LVL_3		4
+#define LVL_TRACE	5
+
+struct _cache_table
+{
+	unsigned char descriptor;
+	char cache_type;
+	short size;
+};
+
+/* all the cache descriptor types we care about (no TLB or trace cache entries) */
+static struct _cache_table cache_table[] __initdata =
+{
+	{ 0x06, LVL_1_INST, 8 },
+	{ 0x08, LVL_1_INST, 16 },
+	{ 0x0a, LVL_1_DATA, 8 },
+	{ 0x0c, LVL_1_DATA, 16 },
+	{ 0x22, LVL_3,      512 },
+	{ 0x23, LVL_3,      1024 },
+	{ 0x25, LVL_3,      2048 },
+	{ 0x29, LVL_3,      4096 },
+	{ 0x2c, LVL_1_DATA, 32 },
+	{ 0x30, LVL_1_INST, 32 },
+	{ 0x39, LVL_2,      128 },
+	{ 0x3b, LVL_2,      128 },
+	{ 0x3c, LVL_2,      256 },
+	{ 0x41, LVL_2,      128 },
+	{ 0x42, LVL_2,      256 },
+	{ 0x43, LVL_2,      512 },
+	{ 0x44, LVL_2,      1024 },
+	{ 0x45, LVL_2,      2048 },
+	{ 0x66, LVL_1_DATA, 8 },
+	{ 0x67, LVL_1_DATA, 16 },
+	{ 0x68, LVL_1_DATA, 32 },
+	{ 0x70, LVL_TRACE,  12 },
+	{ 0x71, LVL_TRACE,  16 },
+	{ 0x72, LVL_TRACE,  32 },
+	{ 0x79, LVL_2,      128 },
+	{ 0x7a, LVL_2,      256 },
+	{ 0x7b, LVL_2,      512 },
+	{ 0x7c, LVL_2,      1024 },
+	{ 0x82, LVL_2,      256 },
+	{ 0x83, LVL_2,      512 },
+	{ 0x84, LVL_2,      1024 },
+	{ 0x85, LVL_2,      2048 },
+	{ 0x86, LVL_2,      512 },
+	{ 0x87, LVL_2,      1024 },
+	{ 0x00, 0, 0}
+};
+
+static void __init init_intel(struct cpuinfo_x86 *c)
+{
+	/* Cache sizes */
+	unsigned int trace = 0, l1i = 0, l1d = 0, l2 = 0, l3 = 0; 
+	unsigned n;
+
+	select_idle_routine(c);
+	if (c->cpuid_level > 1) {
+		/* supports eax=2  call */
+		int i, j, n;
+		int regs[4];
+		unsigned char *dp = (unsigned char *)regs;
+
+		/* Number of times to iterate */
+		n = cpuid_eax(2) & 0xFF;
+
+		for ( i = 0 ; i < n ; i++ ) {
+			cpuid(2, &regs[0], &regs[1], &regs[2], &regs[3]);
+			
+			/* If bit 31 is set, this is an unknown format */
+			for ( j = 0 ; j < 3 ; j++ ) {
+				if ( regs[j] < 0 ) regs[j] = 0;
+			}
+
+			/* Byte 0 is level count, not a descriptor */
+			for ( j = 1 ; j < 16 ; j++ ) {
+				unsigned char des = dp[j];
+				unsigned char k = 0;
+
+				/* look up this descriptor in the table */
+				while (cache_table[k].descriptor != 0)
+				{
+					if (cache_table[k].descriptor == des) {
+						switch (cache_table[k].cache_type) {
+						case LVL_1_INST:
+							l1i += cache_table[k].size;
+							break;
+						case LVL_1_DATA:
+							l1d += cache_table[k].size;
+							break;
+						case LVL_2:
+							l2 += cache_table[k].size;
+							break;
+						case LVL_3:
+							l3 += cache_table[k].size;
+							break;
+						case LVL_TRACE:
+							trace += cache_table[k].size;
+							break;
+						}
+
+						break;
+					}
+
+					k++;
+				}
+			}
+		}
+
+		if (trace)
+			printk (KERN_INFO "CPU: Trace cache: %dK uops", trace);
+		else if (l1i)
+			printk (KERN_INFO "CPU: L1 I cache: %dK", l1i);
+		if (l1d)
+			printk(", L1 D cache: %dK\n", l1d);
+		else
+			printk("\n"); 
+		if (l2)
+			printk(KERN_INFO "CPU: L2 cache: %dK\n", l2);
+		if (l3)
+			printk(KERN_INFO "CPU: L3 cache: %dK\n", l3);
+
+		c->x86_cache_size = l2 ? l2 : (l1i+l1d);
+	}
+
+	if (cpu_has(c, X86_FEATURE_HT))
+		detect_ht(); 
+
+	n = cpuid_eax(0x80000000);
+	if (n >= 0x80000008) {
+		unsigned eax = cpuid_eax(0x80000008);
+		c->x86_virt_bits = (eax >> 8) & 0xff;
+		c->x86_phys_bits = eax & 0xff;
+	}
+}
 
 void __init get_cpu_vendor(struct cpuinfo_x86 *c)
 {
@@ -591,6 +780,8 @@ void __init get_cpu_vendor(struct cpuinf
 
 	if (!strcmp(v, "AuthenticAMD"))
 		c->x86_vendor = X86_VENDOR_AMD;
+	else if (!strcmp(v, "GenuineIntel"))
+		c->x86_vendor = X86_VENDOR_INTEL;
 	else
 		c->x86_vendor = X86_VENDOR_UNKNOWN;
 }
@@ -606,7 +797,7 @@ struct cpu_model_info {
  */
 void __init identify_cpu(struct cpuinfo_x86 *c)
 {
-	int junk, i;
+	int i;
 	u32 xlvl, tfms;
 
 	c->loops_per_jiffy = loops_per_jiffy;
@@ -630,7 +821,7 @@ void __init identify_cpu(struct cpuinfo_
 	/* Intel-defined flags: level 0x00000001 */
 	if (c->cpuid_level >= 0x00000001) {
 		__u32 misc;
-		cpuid(0x00000001, &tfms, &misc, &junk,
+		cpuid(0x00000001, &tfms, &misc, &c->x86_capability[4],
 		      &c->x86_capability[0]);
 		c->x86 = (tfms >> 8) & 0xf;
 		c->x86_model = (tfms >> 4) & 0xf;
@@ -679,9 +870,13 @@ void __init identify_cpu(struct cpuinfo_
 			init_amd(c);
 			break;
 
+		case X86_VENDOR_INTEL:
+			init_intel(c); 
+			break; 
+
 		case X86_VENDOR_UNKNOWN:
 		default:
-			/* Not much we can do here... */
+			display_cacheinfo(c);
 			break;
 	}
 	
@@ -697,6 +892,7 @@ void __init identify_cpu(struct cpuinfo_
 			boot_cpu_data.x86_capability[i] &= c->x86_capability[i];
 	}
 
+	mcheck_init(c);
 }
  
 
@@ -732,7 +928,7 @@ static int show_cpuinfo(struct seq_file 
 	        "fpu", "vme", "de", "pse", "tsc", "msr", "pae", "mce",
 	        "cx8", "apic", NULL, "sep", "mtrr", "pge", "mca", "cmov",
 	        "pat", "pse36", "pn", "clflush", NULL, "dts", "acpi", "mmx",
-	        "fxsr", "sse", "sse2", "ss", NULL, "tm", "ia64", NULL,
+	        "fxsr", "sse", "sse2", "ss", "ht", "tm", "ia64", NULL,
 
 		/* AMD-defined */
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
@@ -751,6 +947,12 @@ static int show_cpuinfo(struct seq_file 
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+
+		/* Intel-defined (#2) */
+		"pni", NULL, NULL, "monitor", "ds_cpl", NULL, NULL, "tm2",
+		"est", NULL, "cid", NULL, NULL, "cmpxchg16b", NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+		NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 	};
 	static char *x86_power_flags[] = { 
 		"ts",	/* temperature sensor */
@@ -790,6 +992,14 @@ static int show_cpuinfo(struct seq_file 
 	if (c->x86_cache_size >= 0) 
 		seq_printf(m, "cache size\t: %d KB\n", c->x86_cache_size);
 	
+#ifdef CONFIG_X86_HT
+	if (cpu_has_ht) {
+		extern int phys_proc_id[NR_CPUS];
+		seq_printf(m, "physical id\t: %d\n", phys_proc_id[c - cpu_data]);
+		seq_printf(m, "siblings\t: %d\n", smp_num_siblings);
+	}
+#endif	
+
 	seq_printf(m,
 	        "fpu\t\t: yes\n"
 	        "fpu_exception\t: yes\n"
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/smpboot.c linux-2.6.3-amd64/arch/x86_64/kernel/smpboot.c
--- linux-vanilla/arch/x86_64/kernel/smpboot.c	2003-09-23 08:03:38.000000000 +0200
+++ linux-2.6.3-amd64/arch/x86_64/kernel/smpboot.c	2004-02-19 23:28:10.000000000 +0100
@@ -53,6 +53,10 @@
 #include <asm/tlbflush.h>
 #include <asm/proto.h>
 
+/* Number of siblings per CPU package */
+int smp_num_siblings = 1;
+int phys_proc_id[NR_CPUS]; /* Package ID of each logical CPU */
+
 /* Bitmask of currently online CPUs */
 cpumask_t cpu_online_map;
 
@@ -66,6 +70,8 @@ struct cpuinfo_x86 cpu_data[NR_CPUS] __c
 /* Set when the idlers are all forked */
 int smp_threads_ready;
 
+int cpu_sibling_map[NR_CPUS] __cacheline_aligned;
+
 /*
  * Trampoline 80x86 program as an array.
  */
@@ -645,7 +651,6 @@ static void __init do_boot_cpu (int apic
 		if (cpu_isset(cpu, cpu_callin_map)) {
 			/* number CPUs logically, starting from 1 (BSP is 0) */
 			Dprintk("OK.\n");
-			printk(KERN_INFO "CPU%d: ", cpu);
 			print_cpu_info(&cpu_data[cpu]);
 			Dprintk("CPU has booted.\n");
 		} else {
@@ -857,6 +862,34 @@ static void __init smp_boot_cpus(unsigne
 		Dprintk("Before bogocount - setting activated=1.\n");
 	}
 
+	/*
+	 * If Hyper-Threading is avaialble, construct cpu_sibling_map[], so
+	 * that we can tell the sibling CPU efficiently.
+	 */
+	if (cpu_has_ht && smp_num_siblings > 1) {
+		for (cpu = 0; cpu < NR_CPUS; cpu++)
+			cpu_sibling_map[cpu] = NO_PROC_ID;
+		
+		for (cpu = 0; cpu < NR_CPUS; cpu++) {
+			int 	i;
+			if (!cpu_isset(cpu, cpu_callout_map))
+				continue;
+
+			for (i = 0; i < NR_CPUS; i++) {
+				if (i == cpu || !cpu_isset(i, cpu_callout_map))
+					continue;
+				if (phys_proc_id[cpu] == phys_proc_id[i]) {
+					cpu_sibling_map[cpu] = i;
+					break;
+				}
+			}
+			if (cpu_sibling_map[cpu] == NO_PROC_ID) {
+				smp_num_siblings = 1;
+				printk(KERN_WARNING "WARNING: No sibling found for CPU %d.\n", cpu);
+			}
+		}
+	}
+
 	Dprintk("Boot done.\n");
 
 	/*
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/time.c linux-2.6.3-amd64/arch/x86_64/kernel/time.c
--- linux-vanilla/arch/x86_64/kernel/time.c	2004-02-05 08:10:25.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/time.c	2004-02-19 23:28:10.000000000 +0100
@@ -24,6 +24,7 @@
 #include <linux/ioport.h>
 #include <linux/module.h>
 #include <linux/device.h>
+#include <linux/sysdev.h>
 #include <linux/bcd.h>
 #include <asm/pgtable.h>
 #include <asm/vsyscall.h>
@@ -217,14 +218,22 @@ static void set_rtc_mmss(unsigned long n
 		real_minutes += 30;		/* correct for half hour time zone */
 	real_minutes %= 60;
 
-	if (abs(real_minutes - cmos_minutes) < 30) {
+#if 0
+	/* AMD 8111 is a really bad time keeper and hits this regularly. 
+	   It probably was an attempt to avoid screwing up DST, but ignore
+	   that for now. */	   
+	if (abs(real_minutes - cmos_minutes) >= 30) {
+		printk(KERN_WARNING "time.c: can't update CMOS clock "
+		       "from %d to %d\n", cmos_minutes, real_minutes);
+	} else
+#endif
+
+	{
 			BIN_TO_BCD(real_seconds);
 			BIN_TO_BCD(real_minutes);
 		CMOS_WRITE(real_seconds, RTC_SECONDS);
 		CMOS_WRITE(real_minutes, RTC_MINUTES);
-	} else
-		printk(KERN_WARNING "time.c: can't update CMOS clock "
-		       "from %d to %d\n", cmos_minutes, real_minutes);
+	}
 
 /*
  * The following flags have to be released exactly in this order, otherwise the
@@ -736,6 +745,51 @@ void __init time_init_smp(void)
 
 __setup("report_lost_ticks", time_setup);
 
+static long clock_cmos_diff;
+
+static int time_suspend(struct sys_device *dev, u32 state)
+{
+	/*
+	 * Estimate time zone so that set_time can update the clock
+	 */
+	clock_cmos_diff = -get_cmos_time();
+	clock_cmos_diff += get_seconds();
+	return 0;
+}
+
+static int time_resume(struct sys_device *dev)
+{
+	unsigned long sec = get_cmos_time() + clock_cmos_diff;
+	write_seqlock_irq(&xtime_lock);
+	xtime.tv_sec = sec;
+	xtime.tv_nsec = 0;
+	write_sequnlock_irq(&xtime_lock);
+	return 0;
+}
+
+static struct sysdev_class pit_sysclass = {
+	.resume = time_resume,
+	.suspend = time_suspend,
+	set_kset_name("pit"),
+};
+
+
+/* XXX this driverfs stuff should probably go elsewhere later -john */
+static struct sys_device device_i8253 = {
+	.id	= 0,
+	.cls	= &pit_sysclass,
+};
+
+static int time_init_device(void)
+{
+	int error = sysdev_class_register(&pit_sysclass);
+	if (!error)
+		error = sys_device_register(&device_i8253);
+	return error;
+}
+
+device_initcall(time_init_device);
+
 #ifdef CONFIG_HPET_EMULATE_RTC
 /* HPET in LegacyReplacement Mode eats up RTC interrupt line. When, HPET
  * is enabled, we support RTC interrupt functionality in software.
@@ -961,3 +1015,4 @@ irqreturn_t hpet_rtc_interrupt(int irq, 
 	return IRQ_HANDLED;
 }
 #endif
+
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/kernel/x8664_ksyms.c linux-2.6.3-amd64/arch/x86_64/kernel/x8664_ksyms.c
--- linux-vanilla/arch/x86_64/kernel/x8664_ksyms.c	2004-02-05 08:10:25.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/kernel/x8664_ksyms.c	2004-02-19 23:28:10.000000000 +0100
@@ -194,6 +194,10 @@ EXPORT_SYMBOL(atomic_dec_and_lock);
 
 EXPORT_SYMBOL(die_chain);
 
+#ifdef CONFIG_SMP
+EXPORT_SYMBOL(cpu_sibling_map);
+#endif
+
 extern void do_softirq_thunk(void);
 EXPORT_SYMBOL_NOVERS(do_softirq_thunk);
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/lib/copy_page.S linux-2.6.3-amd64/arch/x86_64/lib/copy_page.S
--- linux-vanilla/arch/x86_64/lib/copy_page.S	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.3-amd64/arch/x86_64/lib/copy_page.S	2004-02-19 23:28:10.000000000 +0100
@@ -8,11 +8,6 @@
 	.globl copy_page
 	.p2align 4
 copy_page:
-	prefetch (%rsi) 
-	prefetch 1*64(%rsi)
-	prefetchw (%rdi) 
-	prefetchw 1*64(%rdi) 
-
 	subq	$3*8,%rsp
 	movq	%rbx,(%rsp)
 	movq	%r12,1*8(%rsp)
@@ -32,7 +27,7 @@ copy_page:
 	movq     48 (%rsi), %r11
 	movq     56 (%rsi), %r12
 
-	prefetch 5*64(%rsi)
+	prefetcht0 5*64(%rsi)
 
 	movq     %rax,    (%rdi)
 	movq     %rbx,  8 (%rdi)
@@ -43,8 +38,6 @@ copy_page:
 	movq     %r11, 48 (%rdi)
 	movq     %r12, 56 (%rdi)
 
-	prefetchw 5*64(%rdi)
-
 	leaq    64 (%rsi), %rsi
 	leaq    64 (%rdi), %rdi
 
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/lib/csum-copy.S linux-2.6.3-amd64/arch/x86_64/lib/csum-copy.S
--- linux-vanilla/arch/x86_64/lib/csum-copy.S	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.3-amd64/arch/x86_64/lib/csum-copy.S	2004-02-19 23:28:10.000000000 +0100
@@ -59,15 +59,6 @@ csum_partial_copy_generic:
 	cmpl	 $3*64,%edx
 	jle	 .Lignore
 
-	ignore
-	prefetch (%rdi)
-	ignore
-	prefetch 1*64(%rdi)
-	ignore
-	prefetchw (%rsi)
-	ignore
-	prefetchw 1*64(%rsi)
-
 .Lignore:		
 	subq  $7*8,%rsp
 	movq  %rbx,2*8(%rsp)
@@ -115,7 +106,7 @@ csum_partial_copy_generic:
 	movq  56(%rdi),%r13
 		
 	ignore 2f
-	prefetch 5*64(%rdi)
+	prefetcht0 5*64(%rdi)
 2:							
 	adcq  %rbx,%rax
 	adcq  %r8,%rax
@@ -146,8 +137,6 @@ csum_partial_copy_generic:
 	dest
 	movq %r13,56(%rsi)
 	
-	ignore 3f
-	prefetchw 5*64(%rsi)
 3:
 	
 	leaq 64(%rdi),%rdi
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/init.c linux-2.6.3-amd64/arch/x86_64/mm/init.c
--- linux-vanilla/arch/x86_64/mm/init.c	2004-02-19 23:57:11.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/mm/init.c	2004-02-19 23:28:10.000000000 +0100
@@ -402,6 +402,13 @@ void __init mem_init(void)
 	int codesize, reservedpages, datasize, initsize;
 	int tmp;
 
+#ifdef CONFIG_SWIOTLB
+       if (!iommu_aperture && end_pfn >= 0xffffffff>>PAGE_SHIFT) { 
+	       swiotlb_init();
+	       swiotlb = 1;
+       }
+#endif
+
 	/* How many end-of-memory variables you have, grandma! */
 	max_low_pfn = end_pfn;
 	max_pfn = end_pfn;
@@ -541,3 +548,32 @@ int kern_addr_valid(unsigned long addr) 
 		return 0;
 	return pfn_valid(pte_pfn(*pte));
 }
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+
+extern int exception_trace, page_fault_trace;
+
+static ctl_table debug_table2[] = {
+	{ 99, "exception-trace", &exception_trace, sizeof(int), 0644, NULL,
+	  proc_dointvec },
+#ifdef CONFIG_CHECKING
+	{ 100, "page-fault-trace", &page_fault_trace, sizeof(int), 0644, NULL,
+	  proc_dointvec },
+#endif
+	{ 0, }
+}; 
+
+static ctl_table debug_root_table2[] = { 
+	{ .ctl_name = CTL_DEBUG, .procname = "debug", .mode = 0555, 
+	   .child = debug_table2 }, 
+	{ 0 }, 
+}; 
+
+static __init int x8664_sysctl_init(void)
+{ 
+	register_sysctl_table(debug_root_table2, 1);
+	return 0;
+}
+__initcall(x8664_sysctl_init);
+#endif
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/mm/k8topology.c linux-2.6.3-amd64/arch/x86_64/mm/k8topology.c
--- linux-vanilla/arch/x86_64/mm/k8topology.c	2004-02-05 08:10:25.000000000 +0100
+++ linux-2.6.3-amd64/arch/x86_64/mm/k8topology.c	2004-02-19 23:28:10.000000000 +0100
@@ -48,6 +48,7 @@ int __init k8_scan_nodes(unsigned long s
 	int nodeid, i, nb; 
 	int found = 0;
 	u32 reg;
+	int rr;
 
 	nb = find_northbridge(); 
 	if (nb < 0) 
@@ -160,7 +161,7 @@ int __init k8_scan_nodes(unsigned long s
 	   mapping. To avoid this fill in the mapping for all possible
 	   CPUs, as the number of CPUs is not known yet. 
 	   We round robin the existing nodes. */
-	int rr = 0;
+	rr = 0;
 	for (i = 0; i < MAXNODE; i++) {
 		if (nodes_present & (1UL<<i))
 			continue;
diff -burpN -X ../KDIFX linux-vanilla/arch/x86_64/oprofile/Makefile linux-2.6.3-amd64/arch/x86_64/oprofile/Makefile
--- linux-vanilla/arch/x86_64/oprofile/Makefile	2003-09-28 10:54:54.000000000 +0200
+++ linux-2.6.3-amd64/arch/x86_64/oprofile/Makefile	2004-02-19 23:28:10.000000000 +0100
@@ -1,7 +1,6 @@
 #
 # oprofile for x86-64.
-# Just reuse the one from i386. The Hammer performance counters 
-# are similar to Athlon.
+# Just reuse the one from i386. 
 #
 
 obj-$(CONFIG_OPROFILE) += oprofile.o
@@ -13,7 +12,8 @@ DRIVER_OBJS = $(addprefix ../../../drive
 	timer_int.o )
 
 OPROFILE-y := init.o
-OPROFILE-$(CONFIG_X86_LOCAL_APIC) += nmi_int.o op_model_athlon.o
+OPROFILE-$(CONFIG_X86_LOCAL_APIC) += nmi_int.o op_model_athlon.o op_model_p4.o \
+				     op_model_ppro.o
 OPROFILE-$(CONFIG_X86_IO_APIC)    += nmi_timer_int.o 
 
 oprofile-y = $(DRIVER_OBJS) $(addprefix ../../i386/oprofile/, $(OPROFILE-y))
diff -burpN -X ../KDIFX linux-vanilla/drivers/char/agp/Kconfig linux-2.6.3-amd64/drivers/char/agp/Kconfig
--- linux-vanilla/drivers/char/agp/Kconfig	2004-02-19 23:57:13.000000000 +0100
+++ linux-2.6.3-amd64/drivers/char/agp/Kconfig	2004-02-19 23:28:07.000000000 +0100
@@ -77,7 +77,7 @@ config AGP_AMD64
 
 config AGP_INTEL
 	tristate "Intel 440LX/BX/GX, I8xx and E7x05 chipset support"
-	depends on AGP && X86 && !X86_64
+	depends on AGP && X86
 	help
 	  This option gives you AGP support for the GLX component of XFree86 4.x
 	  on Intel 440LX/BX/GX, 815, 820, 830, 840, 845, 850, 860, 875,
diff -burpN -X ../KDIFX linux-vanilla/drivers/char/agp/amd64-agp.c linux-2.6.3-amd64/drivers/char/agp/amd64-agp.c
--- linux-vanilla/drivers/char/agp/amd64-agp.c	2004-01-09 09:26:39.000000000 +0100
+++ linux-2.6.3-amd64/drivers/char/agp/amd64-agp.c	2004-02-19 23:28:07.000000000 +0100
@@ -16,11 +16,7 @@
 #include "agp.h"
 
 /* Will need to be increased if AMD64 ever goes >8-way. */
-#ifdef CONFIG_SMP
 #define MAX_HAMMER_GARTS   8
-#else
-#define MAX_HAMMER_GARTS   1
-#endif
 
 /* PTE bits. */
 #define GPTE_VALID	1
@@ -35,6 +31,14 @@
 #define INVGART		(1<<0)
 #define GARTPTEERR	(1<<1)
 
+/* NVIDIA K8 registers */
+#define NVIDIA_X86_64_0_APBASE		0x10
+#define NVIDIA_X86_64_1_APBASE1		0x50
+#define NVIDIA_X86_64_1_APLIMIT1	0x54
+#define NVIDIA_X86_64_1_APSIZE		0xa8
+#define NVIDIA_X86_64_1_APBASE2		0xd8
+#define NVIDIA_X86_64_1_APLIMIT2	0xdc
+
 static int nr_garts;
 static struct pci_dev * hammers[MAX_HAMMER_GARTS];
 
@@ -346,6 +350,10 @@ static __devinit int cache_nbs (struct p
 	/* cache pci_devs of northbridges. */
 	while ((loop_dev = pci_find_device(PCI_VENDOR_ID_AMD, 0x1103, loop_dev)) 
 			!= NULL) {
+		if (i == MAX_HAMMER_GARTS) { 
+			printk(KERN_ERR PFX "Too many northbridges for AGP\n");
+			return -1;
+		}
 		if (fix_northbridge(loop_dev, pdev, cap_ptr) < 0) { 
 			printk(KERN_ERR PFX "No usable aperture found.\n");
 #ifdef __x86_64__ 
@@ -355,29 +363,111 @@ static __devinit int cache_nbs (struct p
 			return -1;  
 		}
 		hammers[i++] = loop_dev;
+	}
 		nr_garts = i;
-#ifdef CONFIG_SMP
-		if (i > MAX_HAMMER_GARTS) { 
-			printk(KERN_ERR PFX "Too many northbridges for AGP\n");
-			return -1;
+	return i == 0 ? -1 : 0;
+}
+
+/* Handle AMD 8151 quirks */
+static void __devinit amd8151_init(struct pci_dev *pdev, struct agp_bridge_data *bridge)
+
+{		
+	char *revstring;
+	u8 rev_id;
+
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
+	switch (rev_id) {
+	case 0x01: revstring="A0"; break;
+	case 0x02: revstring="A1"; break;
+	case 0x11: revstring="B0"; break;
+	case 0x12: revstring="B1"; break;
+	case 0x13: revstring="B2"; break;
+	default:   revstring="??"; break;
 		}
-#else
-		/* Uniprocessor case, return after finding first bridge.
-		   (There may be more, but in UP, we don't care). */
-		return 0;
-#endif
+
+	printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
+
+	/*
+	 * Work around errata.
+	 * Chips before B2 stepping incorrectly reporting v3.5
+	 */
+	if (rev_id < 0x13) {
+		printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
+		bridge->major_version = 3;
+		bridge->minor_version = 0;
 	}
+}
 
-	return i == 0 ? -1 : 0;
+static struct aper_size_info_32 nforce3_sizes[5] =
+{
+	{512,  131072, 7, 0x00000000 },
+	{256,  65536,  6, 0x00000008 },
+	{128,  32768,  5, 0x0000000C },
+	{64,   16384,  4, 0x0000000E },
+	{32,   8192,   3, 0x0000000F }
+};
+
+/* Handle shadow device of the Nvidia NForce3 */
+/* CHECK-ME original 2.4 version set up some IORRs. Check if that is needed. */
+static int __devinit nforce3_agp_init(struct pci_dev *pdev) 
+{ 
+	u32 tmp, apbase, apbar, aplimit;
+	struct pci_dev *dev1; 
+	int i;
+	unsigned size = amd64_fetch_size(); 
+
+	printk(KERN_INFO PFX "Setting up Nforce3 AGP.\n");
+
+	dev1 = pci_find_slot((unsigned int)pdev->bus->number, PCI_DEVFN(11, 0));
+	if (dev1 == NULL) {
+		printk(KERN_INFO PFX "agpgart: Detected an NVIDIA "
+			"nForce3 chipset, but could not find "
+			"the secondary device.\n");
+		return -ENODEV;
+	}	
+
+	for (i = 0; i < ARRAY_SIZE(nforce3_sizes); i++) 
+		if (nforce3_sizes[i].size == size)
+			break; 
+
+	if (i == ARRAY_SIZE(nforce3_sizes)) {
+		printk(KERN_INFO PFX "No NForce3 size found for %d\n", size); 
+		return -ENODEV; 
+	}
+	
+	pci_read_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, &tmp);
+	tmp &= ~(0xf);
+	tmp |= nforce3_sizes[i].size_value;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APSIZE, tmp);
+
+	/* shadow x86-64 registers into NVIDIA registers */
+	pci_read_config_dword (hammers[0], AMD64_GARTAPERTUREBASE, &apbase);
+
+	/* if x86-64 aperture base is beyond 4G, exit here */
+	if ( (apbase & 0x7fff) >> (32 - 25) )
+		 return -ENODEV;
+
+	apbase = (apbase & 0x7fff) << 25;
+
+	pci_read_config_dword(pdev, NVIDIA_X86_64_0_APBASE, &apbar);
+	apbar &= ~PCI_BASE_ADDRESS_MEM_MASK;
+	apbar |= apbase;
+	pci_write_config_dword(pdev, NVIDIA_X86_64_0_APBASE, apbar);
+
+	aplimit = apbase + (size * 1024 * 1024) - 1;
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE1, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT1, aplimit);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APBASE2, apbase);
+	pci_write_config_dword(dev1, NVIDIA_X86_64_1_APLIMIT2, aplimit);
+
+	return 0;
 }
 
 static int __devinit agp_amd64_probe(struct pci_dev *pdev,
 				     const struct pci_device_id *ent)
 {
 	struct agp_bridge_data *bridge;
-	u8 rev_id;
 	u8 cap_ptr;
-	char *revstring=NULL;
 
 	cap_ptr = pci_find_capability(pdev, PCI_CAP_ID_AGP);
 	if (!cap_ptr)
@@ -391,32 +481,7 @@ static int __devinit agp_amd64_probe(str
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
 	    pdev->device == PCI_DEVICE_ID_AMD_8151_0) {
-
-		pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-		switch (rev_id) {
-		case 0x01:	revstring="A0";
-				break;
-		case 0x02:	revstring="A1";
-				break;
-		case 0x11:	revstring="B0";
-				break;
-		case 0x12:	revstring="B1";
-				break;
-		case 0x13:	revstring="B2";
-				break;
-		default:	revstring="??";
-				break;
-		}
-		printk (KERN_INFO PFX "Detected AMD 8151 AGP Bridge rev %s\n", revstring);
-		/*
-		 * Work around errata.
-		 * Chips before B2 stepping incorrectly reporting v3.5
-		 */
-		if (rev_id < 0x13) {
-			printk (KERN_INFO PFX "Correcting AGP revision (reports 3.5, is really 3.0)\n");
-			bridge->major_version = 3;
-			bridge->minor_version = 0;
-		}
+		amd8151_init(pdev, bridge);
 	} else {
 		printk(KERN_INFO PFX "Detected AGP bridge %x\n",
 			pdev->devfn);
@@ -434,6 +499,14 @@ static int __devinit agp_amd64_probe(str
 		return -ENODEV;
 	}
 
+	if (pdev->vendor == PCI_VENDOR_ID_NVIDIA) { 
+		int ret = nforce3_agp_init(pdev);
+		if (ret) { 
+			agp_put_bridge(bridge); 
+			return ret;
+		}
+	}
+
 	pci_set_drvdata(pdev, bridge);
 	return agp_add_bridge(bridge);
 }
@@ -478,8 +551,25 @@ static struct pci_device_id agp_amd64_pc
 	{
 	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
 	.class_mask	= ~0,
-	.vendor		= PCI_VENDOR_ID_SI,
-	.device		= PCI_DEVICE_ID_SI_755,
+	.vendor		= PCI_VENDOR_ID_VIA,
+	.device		= PCI_DEVICE_ID_VIA_8380_0,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	/* NForce3 */
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3,
+	.subvendor	= PCI_ANY_ID,
+	.subdevice	= PCI_ANY_ID,
+	},
+	{
+	.class		= (PCI_CLASS_BRIDGE_HOST << 8),
+	.class_mask	= ~0,
+	.vendor		= PCI_VENDOR_ID_NVIDIA,
+	.device		= PCI_DEVICE_ID_NVIDIA_NFORCE3S,
 	.subvendor	= PCI_ANY_ID,
 	.subdevice	= PCI_ANY_ID,
 	},
diff -burpN -X ../KDIFX linux-vanilla/fs/binfmt_elf.c linux-2.6.3-amd64/fs/binfmt_elf.c
--- linux-vanilla/fs/binfmt_elf.c	2004-02-19 23:57:37.000000000 +0100
+++ linux-2.6.3-amd64/fs/binfmt_elf.c	2004-02-19 23:28:09.000000000 +0100
@@ -198,6 +198,7 @@ create_elf_tables(struct linux_binprm *b
 	NEW_AUX_ENT(AT_GID, (elf_addr_t) tsk->gid);
 	NEW_AUX_ENT(AT_EGID, (elf_addr_t) tsk->egid);
  	NEW_AUX_ENT(AT_SECURE, (elf_addr_t) security_bprm_secureexec(bprm));
+	NEW_AUX_ENT(AT_NUMCPUS, num_online_cpus());
 	if (k_platform) {
 		NEW_AUX_ENT(AT_PLATFORM, (elf_addr_t)(long)u_platform);
 	}
diff -burpN -X ../KDIFX linux-vanilla/fs/compat.c linux-2.6.3-amd64/fs/compat.c
--- linux-vanilla/fs/compat.c	2004-01-09 09:26:47.000000000 +0100
+++ linux-2.6.3-amd64/fs/compat.c	2004-02-19 23:28:09.000000000 +0100
@@ -405,9 +405,11 @@ asmlinkage long compat_sys_ioctl(unsigne
 	while (t && t->cmd != cmd)
 		t = (struct ioctl_trans *)t->next;
 	if (t) {
-		if (t->handler)
+		if (t->handler) { 
+			lock_kernel();
 			error = t->handler(fd, cmd, arg, filp);
-		else
+			unlock_kernel();
+		} else
 			error = sys_ioctl(fd, cmd, arg);
 	} else if (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15)) {
 		error = siocdevprivate_ioctl(fd, cmd, arg);
diff -burpN -X ../KDIFX linux-vanilla/fs/exec.c linux-2.6.3-amd64/fs/exec.c
--- linux-vanilla/fs/exec.c	2004-02-05 08:10:37.000000000 +0100
+++ linux-2.6.3-amd64/fs/exec.c	2004-02-19 23:28:09.000000000 +0100
@@ -1386,7 +1386,7 @@ int do_coredump(long signr, int exit_cod
 		goto fail_unlock;
 
  	format_corename(corename, core_pattern, signr);
-	file = filp_open(corename, O_CREAT | 2 | O_NOFOLLOW, 0600);
+	file = filp_open(corename, O_CREAT | 2 | O_NOFOLLOW | O_LARGEFILE, 0600);
 	if (IS_ERR(file))
 		goto fail_unlock;
 	inode = file->f_dentry->d_inode;
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/a.out.h linux-2.6.3-amd64/include/asm-x86_64/a.out.h
--- linux-vanilla/include/asm-x86_64/a.out.h	2004-01-09 09:26:50.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/a.out.h	2004-02-19 23:28:07.000000000 +0100
@@ -20,9 +20,8 @@ struct exec
 #define N_SYMSIZE(a)	((a).a_syms)
 
 #ifdef __KERNEL__
-
-#define STACK_TOP	0xc0000000
-
+#include <linux/thread_info.h>
+#define STACK_TOP (test_thread_flag(TIF_IA32) ? IA32_PAGE_OFFSET : TASK_SIZE)
 #endif
 
 #endif /* __A_OUT_GNU_H__ */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/apic.h linux-2.6.3-amd64/include/asm-x86_64/apic.h
--- linux-vanilla/include/asm-x86_64/apic.h	2004-02-19 23:57:46.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/apic.h	2004-02-19 23:28:07.000000000 +0100
@@ -87,6 +87,7 @@ extern void enable_APIC_timer(void);
 extern int check_nmi_watchdog (void);
 
 extern unsigned int nmi_watchdog;
+#define NMI_DEFAULT	-1
 #define NMI_NONE	0
 #define NMI_IO_APIC	1
 #define NMI_LOCAL_APIC	2
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/cpufeature.h linux-2.6.3-amd64/include/asm-x86_64/cpufeature.h
--- linux-vanilla/include/asm-x86_64/cpufeature.h	2003-09-23 08:03:57.000000000 +0200
+++ linux-2.6.3-amd64/include/asm-x86_64/cpufeature.h	2004-02-19 23:28:07.000000000 +0100
@@ -7,7 +7,7 @@
 #ifndef __ASM_X8664_CPUFEATURE_H
 #define __ASM_X8664_CPUFEATURE_H
 
-#define NCAPINTS	4	/* Currently we have 4 32-bit words worth of info */
+#define NCAPINTS	5	/* Currently we have 4 32-bit words worth of info */
 
 /* Intel-defined CPU features, CPUID level 0x00000001, word 0 */
 #define X86_FEATURE_FPU		(0*32+ 0) /* Onboard FPU */
@@ -37,6 +37,7 @@
 #define X86_FEATURE_XMM		(0*32+25) /* Streaming SIMD Extensions */
 #define X86_FEATURE_XMM2	(0*32+26) /* Streaming SIMD Extensions-2 */
 #define X86_FEATURE_SELFSNOOP	(0*32+27) /* CPU self snoop */
+#define X86_FEATURE_HT		(0*32+28) /* Hyper-Threading */
 #define X86_FEATURE_ACC		(0*32+29) /* Automatic clock control */
 #define X86_FEATURE_IA64	(0*32+30) /* IA-64 processor */
 
@@ -61,6 +62,10 @@
 #define X86_FEATURE_CENTAUR_MCR	(3*32+ 3) /* Centaur MCRs (= MTRRs) */
 #define X86_FEATURE_K8_C	(3*32+ 4) /* C stepping K8 */
 
+/* Intel-defined CPU features, CPUID level 0x00000001 (ecx), word 4 */
+#define X86_FEATURE_EST		(4*32+ 7) /* Enhanced SpeedStep */
+#define X86_FEATURE_MWAIT	(4*32+ 3) /* Monitor/Mwait support */
+
 #define cpu_has(c, bit)                test_bit(bit, (c)->x86_capability)
 #define boot_cpu_has(bit)      test_bit(bit, boot_cpu_data.x86_capability)
 
@@ -76,7 +81,7 @@
 #define cpu_has_mmx            1
 #define cpu_has_fxsr           1
 #define cpu_has_xmm            1
-#define cpu_has_ht             0 /* you need to report the support from i386. sorry */
+#define cpu_has_ht             boot_cpu_has(X86_FEATURE_HT)
 #define cpu_has_mp             1 /* XXX */
 #define cpu_has_k6_mtrr        0
 #define cpu_has_cyrix_arr      0
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/hw_irq.h linux-2.6.3-amd64/include/asm-x86_64/hw_irq.h
--- linux-vanilla/include/asm-x86_64/hw_irq.h	2004-02-19 23:57:46.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/hw_irq.h	2004-02-19 23:28:07.000000000 +0100
@@ -132,7 +132,7 @@ static inline void x86_do_profile (struc
 {
 	unsigned long rip;
 	extern unsigned long prof_cpu_mask;
-	extern char _stext[];
+	extern char _stext;
  
 	profile_hook(regs);
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/mce.h linux-2.6.3-amd64/include/asm-x86_64/mce.h
--- linux-vanilla/include/asm-x86_64/mce.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/mce.h	2004-02-19 23:28:07.000000000 +0100
@@ -0,0 +1,67 @@
+#ifndef _ASM_MCE_H
+#define _ASM_MCE_H 1
+
+#include <asm/ioctls.h>
+#include <asm/types.h>
+
+/* 
+ * Machine Check support for x86
+ */
+
+#define MCG_CTL_P        (1UL<<8)   /* MCG_CAP register available */
+
+#define MCG_STATUS_RIPV  (1UL<<0)   /* restart ip valid */
+#define MCG_STATUS_EIPV  (1UL<<1)   /* eip points to correct instruction */
+#define MCG_STATUS_MCIP  (1UL<<2)   /* machine check in progress */
+
+#define MCI_STATUS_VAL   (1UL<<63)  /* valid error */
+#define MCI_STATUS_OVER  (1UL<<62)  /* previous errors lost */
+#define MCI_STATUS_UC    (1UL<<61)  /* uncorrected error */
+#define MCI_STATUS_EN    (1UL<<60)  /* error enabled */
+#define MCI_STATUS_MISCV (1UL<<59)  /* misc error reg. valid */
+#define MCI_STATUS_ADDRV (1UL<<58)  /* addr reg. valid */
+#define MCI_STATUS_PCC   (1UL<<57)  /* processor context corrupt */
+
+/* Fields are zero when not available */
+struct mce {
+	__u64 status;
+	__u64 misc;
+	__u64 addr;
+	__u64 mcgstatus;
+	__u64 rip;	
+	__u64 tsc;	/* cpu time stamp counter */
+	__u64 res1;	/* for future extension */	
+	__u64 res2;	/* dito. */
+	__u8  cs;		/* code segment */
+	__u8  bank;	/* machine check bank */
+	__u8  cpu;	/* cpu that raised the error */
+	__u8  finished;   /* entry is valid */
+	__u32 pad;   
+};
+
+/* 
+ * This structure contains all data related to the MCE log.
+ * Also carries a signature to make it easier to find from external debugging tools.
+ * Each entry is only valid when its finished flag is set.
+ */
+
+#define MCE_LOG_LEN 32
+
+struct mce_log { 
+	char signature[12]; /* "MACHINECHECK" */ 
+	unsigned len;  	    /* = MCE_LOG_LEN */ 
+	unsigned next;
+	unsigned flags;
+	unsigned pad0; 
+	struct mce entry[MCE_LOG_LEN];
+};
+
+#define MCE_OVERFLOW 0		/* bit 0 in flags means overflow */
+
+#define MCE_LOG_SIGNATURE 	"MACHINECHECK"
+
+#define MCE_GET_RECORD_LEN   _IOR('M', 1, int)
+#define MCE_GET_LOG_LEN      _IOR('M', 2, int)
+#define MCE_GETCLEAR_FLAGS   _IOR('M', 3, int)
+
+#endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/msr.h linux-2.6.3-amd64/include/asm-x86_64/msr.h
--- linux-vanilla/include/asm-x86_64/msr.h	2003-12-18 13:50:25.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/msr.h	2004-02-19 23:28:07.000000000 +0100
@@ -121,6 +121,9 @@ extern inline unsigned int cpuid_edx(uns
 	return edx;
 }
 
+#define MSR_IA32_UCODE_WRITE		0x79
+#define MSR_IA32_UCODE_REV		0x8b
+
 
 #endif
 
@@ -243,4 +246,123 @@ extern inline unsigned int cpuid_edx(uns
 #define MSR_IA32_APICBASE_ENABLE        (1<<11)
 #define MSR_IA32_APICBASE_BASE          (0xfffff<<12)
 
+/* P4/Xeon+ specific */
+#define MSR_IA32_MCG_EAX		0x180
+#define MSR_IA32_MCG_EBX		0x181
+#define MSR_IA32_MCG_ECX		0x182
+#define MSR_IA32_MCG_EDX		0x183
+#define MSR_IA32_MCG_ESI		0x184
+#define MSR_IA32_MCG_EDI		0x185
+#define MSR_IA32_MCG_EBP		0x186
+#define MSR_IA32_MCG_ESP		0x187
+#define MSR_IA32_MCG_EFLAGS		0x188
+#define MSR_IA32_MCG_EIP		0x189
+#define MSR_IA32_MCG_RESERVED		0x18A
+
+#define MSR_P6_EVNTSEL0			0x186
+#define MSR_P6_EVNTSEL1			0x187
+
+#define MSR_IA32_PERF_STATUS		0x198
+#define MSR_IA32_PERF_CTL		0x199
+
+#define MSR_IA32_THERM_CONTROL		0x19a
+#define MSR_IA32_THERM_INTERRUPT	0x19b
+#define MSR_IA32_THERM_STATUS		0x19c
+#define MSR_IA32_MISC_ENABLE		0x1a0
+
+#define MSR_IA32_DEBUGCTLMSR		0x1d9
+#define MSR_IA32_LASTBRANCHFROMIP	0x1db
+#define MSR_IA32_LASTBRANCHTOIP		0x1dc
+#define MSR_IA32_LASTINTFROMIP		0x1dd
+#define MSR_IA32_LASTINTTOIP		0x1de
+
+#define MSR_IA32_MC0_CTL		0x400
+#define MSR_IA32_MC0_STATUS		0x401
+#define MSR_IA32_MC0_ADDR		0x402
+#define MSR_IA32_MC0_MISC		0x403
+
+/* Pentium IV performance counter MSRs */
+#define MSR_P4_BPU_PERFCTR0 		0x300
+#define MSR_P4_BPU_PERFCTR1 		0x301
+#define MSR_P4_BPU_PERFCTR2 		0x302
+#define MSR_P4_BPU_PERFCTR3 		0x303
+#define MSR_P4_MS_PERFCTR0 		0x304
+#define MSR_P4_MS_PERFCTR1 		0x305
+#define MSR_P4_MS_PERFCTR2 		0x306
+#define MSR_P4_MS_PERFCTR3 		0x307
+#define MSR_P4_FLAME_PERFCTR0 		0x308
+#define MSR_P4_FLAME_PERFCTR1 		0x309
+#define MSR_P4_FLAME_PERFCTR2 		0x30a
+#define MSR_P4_FLAME_PERFCTR3 		0x30b
+#define MSR_P4_IQ_PERFCTR0 		0x30c
+#define MSR_P4_IQ_PERFCTR1 		0x30d
+#define MSR_P4_IQ_PERFCTR2 		0x30e
+#define MSR_P4_IQ_PERFCTR3 		0x30f
+#define MSR_P4_IQ_PERFCTR4 		0x310
+#define MSR_P4_IQ_PERFCTR5 		0x311
+#define MSR_P4_BPU_CCCR0 		0x360
+#define MSR_P4_BPU_CCCR1 		0x361
+#define MSR_P4_BPU_CCCR2 		0x362
+#define MSR_P4_BPU_CCCR3 		0x363
+#define MSR_P4_MS_CCCR0 		0x364
+#define MSR_P4_MS_CCCR1 		0x365
+#define MSR_P4_MS_CCCR2 		0x366
+#define MSR_P4_MS_CCCR3 		0x367
+#define MSR_P4_FLAME_CCCR0 		0x368
+#define MSR_P4_FLAME_CCCR1 		0x369
+#define MSR_P4_FLAME_CCCR2 		0x36a
+#define MSR_P4_FLAME_CCCR3 		0x36b
+#define MSR_P4_IQ_CCCR0 		0x36c
+#define MSR_P4_IQ_CCCR1 		0x36d
+#define MSR_P4_IQ_CCCR2 		0x36e
+#define MSR_P4_IQ_CCCR3 		0x36f
+#define MSR_P4_IQ_CCCR4 		0x370
+#define MSR_P4_IQ_CCCR5 		0x371
+#define MSR_P4_ALF_ESCR0 		0x3ca
+#define MSR_P4_ALF_ESCR1 		0x3cb
+#define MSR_P4_BPU_ESCR0 		0x3b2
+#define MSR_P4_BPU_ESCR1 		0x3b3
+#define MSR_P4_BSU_ESCR0 		0x3a0
+#define MSR_P4_BSU_ESCR1 		0x3a1
+#define MSR_P4_CRU_ESCR0 		0x3b8
+#define MSR_P4_CRU_ESCR1 		0x3b9
+#define MSR_P4_CRU_ESCR2 		0x3cc
+#define MSR_P4_CRU_ESCR3 		0x3cd
+#define MSR_P4_CRU_ESCR4 		0x3e0
+#define MSR_P4_CRU_ESCR5 		0x3e1
+#define MSR_P4_DAC_ESCR0 		0x3a8
+#define MSR_P4_DAC_ESCR1 		0x3a9
+#define MSR_P4_FIRM_ESCR0 		0x3a4
+#define MSR_P4_FIRM_ESCR1 		0x3a5
+#define MSR_P4_FLAME_ESCR0 		0x3a6
+#define MSR_P4_FLAME_ESCR1 		0x3a7
+#define MSR_P4_FSB_ESCR0 		0x3a2
+#define MSR_P4_FSB_ESCR1 		0x3a3
+#define MSR_P4_IQ_ESCR0 		0x3ba
+#define MSR_P4_IQ_ESCR1 		0x3bb
+#define MSR_P4_IS_ESCR0 		0x3b4
+#define MSR_P4_IS_ESCR1 		0x3b5
+#define MSR_P4_ITLB_ESCR0 		0x3b6
+#define MSR_P4_ITLB_ESCR1 		0x3b7
+#define MSR_P4_IX_ESCR0 		0x3c8
+#define MSR_P4_IX_ESCR1 		0x3c9
+#define MSR_P4_MOB_ESCR0 		0x3aa
+#define MSR_P4_MOB_ESCR1 		0x3ab
+#define MSR_P4_MS_ESCR0 		0x3c0
+#define MSR_P4_MS_ESCR1 		0x3c1
+#define MSR_P4_PMH_ESCR0 		0x3ac
+#define MSR_P4_PMH_ESCR1 		0x3ad
+#define MSR_P4_RAT_ESCR0 		0x3bc
+#define MSR_P4_RAT_ESCR1 		0x3bd
+#define MSR_P4_SAAT_ESCR0 		0x3ae
+#define MSR_P4_SAAT_ESCR1 		0x3af
+#define MSR_P4_SSU_ESCR0 		0x3be
+#define MSR_P4_SSU_ESCR1 		0x3bf    /* guess: not defined in manual */
+#define MSR_P4_TBPU_ESCR0 		0x3c2
+#define MSR_P4_TBPU_ESCR1 		0x3c3
+#define MSR_P4_TC_ESCR0 		0x3c4
+#define MSR_P4_TC_ESCR1 		0x3c5
+#define MSR_P4_U2L_ESCR0 		0x3b0
+#define MSR_P4_U2L_ESCR1 		0x3b1
+
 #endif
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pci-direct.h linux-2.6.3-amd64/include/asm-x86_64/pci-direct.h
--- linux-vanilla/include/asm-x86_64/pci-direct.h	2003-08-23 01:53:08.000000000 +0200
+++ linux-2.6.3-amd64/include/asm-x86_64/pci-direct.h	2004-02-19 23:28:07.000000000 +0100
@@ -28,7 +28,7 @@ static inline u8 read_pci_config_byte(u8
 	return v;
 }
 
-static inline u8 read_pci_config_16(u8 bus, u8 slot, u8 func, u8 offset)
+static inline u16 read_pci_config_16(u8 bus, u8 slot, u8 func, u8 offset)
 {
 	u16 v; 
 	outl(0x80000000 | (bus<<16) | (slot<<11) | (func<<8) | offset, 0xcf8);
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pci.h linux-2.6.3-amd64/include/asm-x86_64/pci.h
--- linux-vanilla/include/asm-x86_64/pci.h	2004-02-19 23:57:46.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/pci.h	2004-02-19 23:28:07.000000000 +0100
@@ -72,6 +72,23 @@ extern void *pci_alloc_consistent(struct
 extern void pci_free_consistent(struct pci_dev *hwdev, size_t size,
 				void *vaddr, dma_addr_t dma_handle);
 
+#ifdef CONFIG_SWIOTLB
+extern int swiotlb; 
+extern dma_addr_t swiotlb_map_single (struct device *hwdev, void *ptr, size_t size, 
+				      int dir);
+extern void swiotlb_unmap_single (struct device *hwdev, dma_addr_t dev_addr,
+				  size_t size, int dir);
+extern void swiotlb_sync_single (struct device *hwdev, dma_addr_t dev_addr, 
+				 size_t size, int dir);
+extern void swiotlb_sync_sg (struct device *hwdev, struct scatterlist *sg, int nelems, 
+			     int dir);
+extern int swiotlb_map_sg(struct device *hwdev, struct scatterlist *sg,
+		      int nents, int direction);
+extern void swiotlb_unmap_sg(struct device *hwdev, struct scatterlist *sg,
+			 int nents, int direction);
+
+#endif
+
 #ifdef CONFIG_GART_IOMMU
 
 /* Map a single buffer of the indicated size for DMA in streaming mode.
@@ -113,6 +130,13 @@ static inline void pci_dma_sync_single(s
 				       size_t size, int direction)
 {
 	BUG_ON(direction == PCI_DMA_NONE); 
+
+#ifdef CONFIG_SWIOTLB
+	if (swiotlb)
+		return swiotlb_sync_single(&hwdev->dev,dma_handle,size,direction);
+#endif
+
+	flush_write_buffers();
 } 
 
 static inline void pci_dma_sync_sg(struct pci_dev *hwdev, 
@@ -120,6 +144,12 @@ static inline void pci_dma_sync_sg(struc
 				   int nelems, int direction)
 { 
 	BUG_ON(direction == PCI_DMA_NONE); 
+
+#ifdef CONFIG_SWIOTLB
+	if (swiotlb)
+		return swiotlb_sync_sg(&hwdev->dev,sg,nelems,direction);
+#endif
+	flush_write_buffers();
 } 
 
 /* The PCI address space does equal the physical memory
@@ -272,4 +302,6 @@ static inline void pcibios_add_platform_
 /* generic pci stuff */
 #include <asm-generic/pci.h>
 
+#include <linux/dma-mapping.h>
+
 #endif /* __x8664_PCI_H */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/pgtable.h linux-2.6.3-amd64/include/asm-x86_64/pgtable.h
--- linux-vanilla/include/asm-x86_64/pgtable.h	2004-02-05 08:10:43.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/pgtable.h	2004-02-19 23:28:07.000000000 +0100
@@ -36,7 +36,7 @@ extern unsigned long pgkern_mask;
  * ZERO_PAGE is a global shared page that is always zero: used
  * for zero-mapped memory areas etc..
  */
-extern unsigned long empty_zero_page[1024];
+extern unsigned long empty_zero_page[PAGE_SIZE/sizeof(unsigned long)];
 #define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
 
 #define PML4_SHIFT	39
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/processor.h linux-2.6.3-amd64/include/asm-x86_64/processor.h
--- linux-vanilla/include/asm-x86_64/processor.h	2004-02-05 08:10:43.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/processor.h	2004-02-19 23:28:07.000000000 +0100
@@ -303,6 +303,67 @@ extern unsigned long get_wchan(struct ta
 	(((struct pt_regs *)(tsk->thread.rsp0 - sizeof(struct pt_regs)))->rip)
 #define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
 
+
+struct microcode_header {
+	unsigned int hdrver;
+	unsigned int rev;
+	unsigned int date;
+	unsigned int sig;
+	unsigned int cksum;
+	unsigned int ldrver;
+	unsigned int pf;
+	unsigned int datasize;
+	unsigned int totalsize;
+	unsigned int reserved[3];
+};
+
+struct microcode {
+	struct microcode_header hdr;
+	unsigned int bits[0];
+};
+
+typedef struct microcode microcode_t;
+typedef struct microcode_header microcode_header_t;
+
+/* microcode format is extended from prescott processors */
+struct extended_signature {
+	unsigned int sig;
+	unsigned int pf;
+	unsigned int cksum;
+};
+
+struct extended_sigtable {
+	unsigned int count;
+	unsigned int cksum;
+	unsigned int reserved[3];
+	struct extended_signature sigs[0];
+};
+
+/* '6' because it used to be for P6 only (but now covers Pentium 4 as well) */
+#define MICROCODE_IOCFREE	_IO('6',0)
+
+
+#define ASM_NOP1 K8_NOP1
+#define ASM_NOP2 K8_NOP2
+#define ASM_NOP3 K8_NOP3
+#define ASM_NOP4 K8_NOP4
+#define ASM_NOP5 K8_NOP5
+#define ASM_NOP6 K8_NOP6
+#define ASM_NOP7 K8_NOP7
+#define ASM_NOP8 K8_NOP8
+
+/* Opteron nops */
+#define K8_NOP1 ".byte 0x90\n"
+#define K8_NOP2	".byte 0x66,0x90\n" 
+#define K8_NOP3	".byte 0x66,0x66,0x90\n" 
+#define K8_NOP4	".byte 0x66,0x66,0x66,0x90\n" 
+#define K8_NOP5	K8_NOP3 K8_NOP2 
+#define K8_NOP6	K8_NOP3 K8_NOP3
+#define K8_NOP7	K8_NOP4 K8_NOP3
+#define K8_NOP8	K8_NOP4 K8_NOP4
+
+#define ASM_NOP_MAX 8
+
 /* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
 extern inline void rep_nop(void)
 {
@@ -318,31 +379,25 @@ extern inline void sync_core(void)
 
 #define cpu_has_fpu 1
 
-/* Some early Opteron versions incorrectly fault on prefetch (errata #91). 
-   If this happens just jump back. */
 #define ARCH_HAS_PREFETCH
 static inline void prefetch(void *x) 
 { 
-	asm volatile("2: prefetcht0 %0\n1:\t" 
-		    ".section __ex_table,\"a\"\n\t"
-		    "  .align 8\n\t"
-		    "  .quad  2b,1b\n\t"
-		    ".previous" :: "m" (*(unsigned long *)x));
+	asm volatile("prefetcht0 %0" :: "m" (*(unsigned long *)x));
 } 
 
-#define ARCH_HAS_PREFETCHW
+#define ARCH_HAS_PREFETCHW 1
 static inline void prefetchw(void *x) 
 { 
-	asm volatile("2: prefetchw %0\n1:\t" 
-		    ".section __ex_table,\"a\"\n\t"
-		    "  .align 8\n\t"
-		    "  .quad  2b,1b\n\t"
-		    ".previous" :: "m" (*(unsigned long *)x));
+	alternative_input(ASM_NOP4,
+			  "prefetchw (%1)",
+			  X86_FEATURE_3DNOW,
+			  "r" (x));
 } 
 
-#define ARCH_HAS_SPINLOCK_PREFETCH
+#define ARCH_HAS_SPINLOCK_PREFETCH 1
 
 #define spin_lock_prefetch(x)  prefetchw(x)
+
 #define cpu_relax()   rep_nop()
 
 /*
@@ -372,6 +427,23 @@ static inline void prefetchw(void *x) 
 	outb((data), 0x23); \
 } while (0)
 
+static inline void __monitor(const void *eax, unsigned long ecx,
+		unsigned long edx)
+{
+	/* "monitor %eax,%ecx,%edx;" */
+	asm volatile(
+		".byte 0x0f,0x01,0xc8;"
+		: :"a" (eax), "c" (ecx), "d"(edx));
+}
+
+static inline void __mwait(unsigned long eax, unsigned long ecx)
+{
+	/* "mwait %eax,%ecx;" */
+	asm volatile(
+		".byte 0x0f,0x01,0xc9;"
+		: :"a" (eax), "c" (ecx));
+}
+
 #define stack_current() \
 ({								\
 	struct thread_info *ti;					\
@@ -379,25 +451,4 @@ static inline void prefetchw(void *x) 
 	ti->task;					\
 })
 
-#define ASM_NOP1 K8_NOP1
-#define ASM_NOP2 K8_NOP2
-#define ASM_NOP3 K8_NOP3
-#define ASM_NOP4 K8_NOP4
-#define ASM_NOP5 K8_NOP5
-#define ASM_NOP6 K8_NOP6
-#define ASM_NOP7 K8_NOP7
-#define ASM_NOP8 K8_NOP8
-
-/* Opteron nops */
-#define K8_NOP1 ".byte 0x90\n"
-#define K8_NOP2	".byte 0x66,0x90\n" 
-#define K8_NOP3	".byte 0x66,0x66,0x90\n" 
-#define K8_NOP4	".byte 0x66,0x66,0x66,0x90\n" 
-#define K8_NOP5	K8_NOP3 K8_NOP2 
-#define K8_NOP6	K8_NOP3 K8_NOP3
-#define K8_NOP7	K8_NOP4 K8_NOP3
-#define K8_NOP8	K8_NOP4 K8_NOP4
-
-#define ASM_NOP_MAX 8
-
 #endif /* __ASM_X86_64_PROCESSOR_H */
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/proto.h linux-2.6.3-amd64/include/asm-x86_64/proto.h
--- linux-vanilla/include/asm-x86_64/proto.h	2004-02-05 08:10:43.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/proto.h	2004-02-19 23:28:07.000000000 +0100
@@ -76,6 +76,10 @@ extern void check_ioapic(void);
 
 extern int unhandled_signal(struct task_struct *tsk, int sig);
 
+extern void select_idle_routine(const struct cpuinfo_x86 *c);
+extern void swiotlb_init(void);
+extern int swiotlb;
+
 extern unsigned long max_mapnr;
 extern unsigned long end_pfn; 
 extern unsigned long table_start, table_end;
@@ -92,6 +96,7 @@ extern int acpi_disabled;
 
 extern int fallback_aper_order;
 extern int fallback_aper_force;
+extern int iommu_aperture;
 
 extern void smp_local_timer_interrupt(struct pt_regs * regs);
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/segment.h linux-2.6.3-amd64/include/asm-x86_64/segment.h
--- linux-vanilla/include/asm-x86_64/segment.h	2003-08-23 02:00:32.000000000 +0200
+++ linux-2.6.3-amd64/include/asm-x86_64/segment.h	2004-02-19 23:28:07.000000000 +0100
@@ -1,6 +1,8 @@
 #ifndef _ASM_SEGMENT_H
 #define _ASM_SEGMENT_H
 
+#include <asm/cache.h>
+
 #define __KERNEL_CS	0x10
 #define __KERNEL_DS	0x18
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/smp.h linux-2.6.3-amd64/include/asm-x86_64/smp.h
--- linux-vanilla/include/asm-x86_64/smp.h	2004-02-05 08:10:43.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/smp.h	2004-02-19 23:28:07.000000000 +0100
@@ -39,6 +39,7 @@ extern void smp_alloc_memory(void);
 extern cpumask_t cpu_online_map;
 extern volatile unsigned long smp_invalidate_needed;
 extern int pic_mode;
+extern int smp_num_siblings;
 extern void smp_flush_tlb(void);
 extern void smp_message_irq(int cpl, void *dev_id, struct pt_regs *regs);
 extern void smp_send_reschedule(int cpu);
@@ -46,7 +47,7 @@ extern void smp_invalidate_rcv(void);		/
 extern void (*mtrr_hook) (void);
 extern void zap_low_mappings(void);
 void smp_stop_cpu(void);
-
+extern int cpu_sibling_map[];
 
 #define SMP_TRAMPOLINE_BASE 0x6000
 
diff -burpN -X ../KDIFX linux-vanilla/include/asm-x86_64/system.h linux-2.6.3-amd64/include/asm-x86_64/system.h
--- linux-vanilla/include/asm-x86_64/system.h	2004-02-05 08:10:43.000000000 +0100
+++ linux-2.6.3-amd64/include/asm-x86_64/system.h	2004-02-19 23:28:07.000000000 +0100
@@ -88,6 +88,56 @@ struct alt_instr { 
 #endif
 
 /*
+ * Alternative instructions for different CPU types or capabilities.
+ * 
+ * This allows to use optimized instructions even on generic binary
+ * kernels.
+ * 
+ * length of oldinstr must be longer or equal the length of newinstr
+ * It can be padded with nops as needed.
+ * 
+ * For non barrier like inlines please define new variants
+ * without volatile and memory clobber.
+ */
+#define alternative(oldinstr, newinstr, feature) 	\
+	asm volatile ("661:\n\t" oldinstr "\n662:\n" 		     \
+		      ".section .altinstructions,\"a\"\n"     	     \
+		      "  .align 8\n"				       \
+		      "  .quad 661b\n"            /* label */          \
+		      "  .quad 663f\n"		  /* new instruction */ \
+		      "  .byte %c0\n"             /* feature bit */    \
+		      "  .byte 662b-661b\n"       /* sourcelen */      \
+		      "  .byte 664f-663f\n"       /* replacementlen */ \
+		      ".previous\n"					\
+		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ \
+		      ".previous" :: "i" (feature) : "memory")  
+
+/*
+ * Alternative inline assembly with input.
+ * 
+ * Pecularities:
+ * No memory clobber here. 
+ * Argument numbers start with 1.
+ * Best is to use constraints that are fixed size (like (%1) ... "r")
+ * If you use variable sized constraints like "m" or "g" in the 
+ * replacement maake sure to pad to the worst case length.
+ */
+#define alternative_input(oldinstr, newinstr, feature, input)		\
+	asm volatile ("661:\n\t" oldinstr "\n662:\n"			\
+		      ".section .altinstructions,\"a\"\n"		\
+		      "  .align 8\n"					\
+		      "  .quad 661b\n"            /* label */		\
+		      "  .quad 663f\n"		  /* new instruction */	\
+		      "  .byte %c0\n"             /* feature bit */	\
+		      "  .byte 662b-661b\n"       /* sourcelen */	\
+		      "  .byte 664f-663f\n"       /* replacementlen */	\
+		      ".previous\n"					\
+		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ \
+		      ".previous" :: "i" (feature), input)
+
+/*
  * Clear and set 'TS' bit respectively
  */
 #define clts() __asm__ __volatile__ ("clts")
diff -burpN -X ../KDIFX linux-vanilla/include/linux/elf.h linux-2.6.3-amd64/include/linux/elf.h
--- linux-vanilla/include/linux/elf.h	2003-10-25 22:57:42.000000000 +0200
+++ linux-2.6.3-amd64/include/linux/elf.h	2004-02-19 23:28:07.000000000 +0100
@@ -164,6 +164,7 @@ typedef __s64	Elf64_Sxword;
 #define AT_CLKTCK 17	/* frequency at which times() increments */
 
 #define AT_SECURE 23   /* secure mode boolean */
+#define AT_NUMCPUS 24  /* number of running cpus */
 
 typedef struct dynamic{
   Elf32_Sword d_tag;
diff -burpN -X ../KDIFX linux-vanilla/include/linux/pci_ids.h linux-2.6.3-amd64/include/linux/pci_ids.h
--- linux-vanilla/include/linux/pci_ids.h	2004-02-19 23:57:48.000000000 +0100
+++ linux-2.6.3-amd64/include/linux/pci_ids.h	2004-02-19 23:28:07.000000000 +0100
@@ -1050,6 +1050,8 @@
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_IDE	0x0085
 #define PCI_DEVICE_ID_NVIDIA_NFORCE2S_SATA	0x008e
 #define PCI_DEVICE_ID_NVIDIA_ITNT2		0x00A0
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3		0x00d1
+#define PCI_DEVICE_ID_NVIDIA_NFORCE3S  		0x00e1
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3_IDE	0x00d5
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_SATA	0x00e3
 #define PCI_DEVICE_ID_NVIDIA_NFORCE3S_IDE	0x00e5
diff -burpN -X ../KDIFX linux-vanilla/scripts/kconfig/Makefile linux-2.6.3-amd64/scripts/kconfig/Makefile
--- linux-vanilla/scripts/kconfig/Makefile	2003-09-28 10:55:19.000000000 +0200
+++ linux-2.6.3-amd64/scripts/kconfig/Makefile	2004-02-19 23:28:10.000000000 +0100
@@ -95,7 +95,7 @@ clean-files	:= libkconfig.so lkc_defs.h 
 HOSTCFLAGS_lex.zconf.o	:= -I$(src)
 HOSTCFLAGS_zconf.tab.o	:= -I$(src)
 
-HOSTLOADLIBES_qconf	= -L$(QTDIR)/lib -Wl,-rpath,$(QTDIR)/lib -l$(QTLIB) -ldl
+HOSTLOADLIBES_qconf	= -L$(QTDIR)/lib -L$(QTDIR)/lib64 -Wl,-rpath,$(QTDIR)/lib -l$(QTLIB) -ldl
 HOSTCXXFLAGS_qconf.o	= -I$(QTDIR)/include 
 
 HOSTLOADLIBES_gconf	= `pkg-config gtk+-2.0 gmodule-2.0 libglade-2.0 --libs`
